From dehnert at sgi.com  Thu Aug  5 02:47:20 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 04 Aug 1999 19:47:20 -0700
Subject: C++ ABI Summary
Message-ID: <37A8FB38.44BCF214@sgi.com>

Sorry this is late.  Things have been distracting :-).

Here are the current versions of the issue pages.  Also, please look
again at the list of actions from the last meeting following.
I've included in the open issues document the priority initialization
writeup I promised (issue C-2), and the data layout document has been
adjusted as discussed for issue A-9 (empty base placement).  I have
not finished the Vtable layout work -- I apologize.


Date: Thu, 29 Jul 1999 20:55:46 -0700 (PDT)
From: dehnert (Jim Dehnert)
To: cxx-abi at corp.sgi.com
Subject: Action items from today's meeting
Reply-To: dehnert (Jim Dehnert)
Sender: owner-cxx-abi-sgi at cthulhu
Precedence: bulk

The following are the actions people agreed to (or were volunteered
for) at today's meeting.  AI-nn refers to an action item in the
summary, X-nn refers to the issue with that number.

Christophe
----------

AI-7, B-1:  We'd like to proceed with the virtual function call protocol,
      but need a write-up of what Christophe discussed last month.

Daveed
------

AI-13:  Describe RTTI representation.

Jim
---

A-9:  Reflect empty base class allocation decision in layout document.

B-6:  Rewrite Christophe's Vtable layout description as an exercise
      to identify any holes.

AI-15, C-2:  Do careful writeup of object file init priority representation.

Jason
-----

B-4/7:  Think carefully about the issues involved in putting Vtables
        (and therefore potentially objects that reference them) in
        shared memory.

Matt
----

C-7:  Write careful description of when parameter copy constructors
      may be elided.

Mike Ball
---------

B-3:  You apparently have a good characterization of when Vtable
      caching is safe/legal.  Can you please describe it for us?

Priti
-----

AI-12:  Describe the Intel C++ exception handling model.
AI-5:   Set up N-way NDA if necessary to discuss it.

All
---

A-11:  Describe your representation for pointers to member functions.

B-6:  Describe your RTTI representation.

F-x:  In anticipation of mangling discussions, please help by (a)
      identifying what needs to be mangled, and (b) describing any
      mangling/compression scheme(s) you think we should consider.



-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990804/d07ca496/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990804/d07ca496/attachment-0001.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990804/d07ca496/attachment-0002.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990804/d07ca496/attachment-0003.html>

From dehnert at baalbek.engr.sgi.com  Sat Aug  7 02:30:25 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 6 Aug 1999 19:30:25 -0700 (PDT)
Subject: C++ ABI Summary -- 5 August meeting
Message-ID: <199908070230.TAA39780@baalbek.engr.sgi.com>

Note that we've added two people with heavy g++ involvement
to the mail alias:  Mark Mitchell from CodeSourcery and Martin
von Loewis from Humboldt-Universitaet Berlin.  Could the two
of you please provide me with phone/FAX numbers?  (Actually,
I don't seem to have Daveed's, either, nor the HP FAX info...)

Attached are versions of the status pages updated based on
yesterday's meeting.  Please check the descriptions of recently
closed items for correctness and clarity.  Also, take a look at
issue A-11.  Although we agreed to close it, a minor improvement
occurred to me -- let me know if it has problems.

Following are the items still open from last week's list, plus
a couple new ones:

Daveed
------

AI-13, A-6, B-8:  Describe RTTI representation, dynamic cast.

Jim
---

AI-17, B-6:  Rewrite Christophe's Vtable layout description as an
	exercise to identify any holes.

AI-19, C-3:  Write up precise destructor proposal.

Priti
-----

AI-12:  Describe the Intel C++ exception handling model.
AI-5:   Set up N-way NDA if necessary to discuss it.

All
---

B-6:  Describe your RTTI representation.

F-x:  In anticipation of mangling discussions, please help by (a)
      identifying what needs to be mangled, and (b) describing any
      mangling/compression scheme(s) you think we should consider.
      (I have started a list in F-1.)


-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990806/f711cea6/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990806/f711cea6/attachment-0001.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990806/f711cea6/attachment-0002.html>

From ddd at cup.hp.com  Mon Aug  9 22:10:09 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 9 Aug 1999 15:10:09 -0700
Subject: Var-args
Message-ID: <199908092210.PAA18782@cllmail.cup.hp.com>

Folks,


Another issue for our list: varargs. In particular, how do we deal  
with non-C types, such as references, class objects and other "outer  
space" varargs. Should we agree on the varargs macros?


Christophe



From dehnert at baalbek.engr.sgi.com  Mon Aug  9 22:50:48 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 9 Aug 1999 15:50:48 -0700 (PDT)
Subject: C++ ABI Summary -- 5 August meeting
References: <199908070230.TAA39780@baalbek.engr.sgi.com>
Message-ID: <199908092250.PAA44899@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Mon Aug  9 10:38:34 1999
> 
> Jim,
> 
> Thanks for sending the documents. While studying them, I found some
> issues that are not listed. Being new to the group, I'd like to ask:
> How do you operate? Should I write some kind of proposal, or just
> ask stupid questions to the list?

Thanks for the feedback.  In general, an issue should be raised with at
least enough information to provide a clear, concise description of
what it really involves.  In particular...

> Specifically, I'm concerned with two issues:
> 
> A) vararg lists: I'd like to see an indirection in vararg lists, so
>    they can be passed through thunks. This is necessary at least for
>    the covariant returns, but might have other applications as well.

I've opened a new issue for this.  You should provide a proposal if you
don't think the underlying C ABI convention is adequate.  Note that we
don't require thunks for covariant returns, and are attempting to avoid
them in general because the performance impact is significant.  A
similar concern might apply to checks in varargs lists.

> B) Global Destructor ordering: They must not only interleave with
>    static locals, but also with atexit. This gives two problems:
>    atexit is only guaranteed to support 32 functions; and dynamic
>    unloading of DSOs break when functions are atexit registered.

I added this comment to issue C-2.  What is the nature of the atexit
interaction requirement?  Does it appear in the Standard?  (We do
not intend to use atexit directly for global object destruction, your
reasons being at least part of the problem.)

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at isolde.engr.sgi.com  Mon Aug  9 22:58:42 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Mon, 9 Aug 1999 15:58:42 -0700
Subject: C++ ABI Summary -- 5 August meeting
In-Reply-To: dehnert@baalbek (Jim Dehnert)
        "Re: C++ ABI Summary -- 5 August meeting" (Aug  9,  3:50pm)
References: <199908070230.TAA39780@baalbek.engr.sgi.com> 
	<199908092250.PAA44899@baalbek.engr.sgi.com>
Message-ID: <9908091558.ZM353615@isolde.engr.sgi.com>

Yes, the interleaving is required by the C++ standard.  (We don't
currently get this right.)  It's a nuisance, and I don't think there's
any good reason for it, but the requirement is quite explicit.

The relevant part of the C++ standard is section 3.6.3, paragraph 3:

"If a function is registered with atexit (see <cstdlib>, 18.3) then
following the call to exit, any objects with static storage duration
initialized prior to the registration of that function shall not be
destroyed until the registered function is called from the termination
process and has completed. For an object with static storage duration
constructed after a function is registered with atexit, then following
the call to exit, the registered function is not called until the
execution of the object's destructor has completed. If atexit is called
during the construction of an object, the complete object to which it
belongs shall be destroyed before the registered function is called."

What this implies to me is that atexit, and the part of the runtime
library that handles destructors for static objects, must know about
each other.

			--Matt



From jason at cygnus.com  Mon Aug  9 23:58:26 1999
From: jason at cygnus.com (Jason Merrill)
Date: 09 Aug 1999 16:58:26 -0700
Subject: C++ ABI Summary -- 5 August meeting
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Mon, 9 Aug 1999 15:50:48 -0700 (PDT)"
References: <199908070230.TAA39780@baalbek.engr.sgi.com> <199908092250.PAA44899@baalbek.engr.sgi.com>
Message-ID: <u9lnbkwlp9.fsf@yorick.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 >> A) vararg lists: I'd like to see an indirection in vararg lists, so
 >>    they can be passed through thunks. This is necessary at least for
 >>    the covariant returns, but might have other applications as well.

 > I've opened a new issue for this.  You should provide a proposal if you
 > don't think the underlying C ABI convention is adequate.  Note that we
 > don't require thunks for covariant returns, and are attempting to avoid
 > them in general because the performance impact is significant.

Only for traditional vcall thunks.  Thunks for covariant returns can always
use a PC-relative branch, because all interesting offsets are known at the
time of the function's definition, so all the thunks can be emitted just
before it.

Daveed had talked about being able to use simple fixup thunks for covariant
returns, just overriding the incoming return address; but now that I think
about it, I don't know where we would store the real return address so that
the thunk could find it again.

Jason



From loewis at informatik.hu-berlin.de  Tue Aug 10 11:07:51 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 10 Aug 1999 13:07:51 +0200
Subject: varargs and covariant returns
In-Reply-To: <u9lnbkwlp9.fsf@yorick.cygnus.com> (message from Jason Merrill on
	09 Aug 1999 16:58:26 -0700)
References: <199908070230.TAA39780@baalbek.engr.sgi.com> <199908092250.PAA44899@baalbek.engr.sgi.com> <u9lnbkwlp9.fsf@yorick.cygnus.com>
Message-ID: <199908101107.NAA27659@pandora>

> Daveed had talked about being able to use simple fixup thunks for covariant
> returns, just overriding the incoming return address; but now that I think
> about it, I don't know where we would store the real return address so that
> the thunk could find it again.

Exactly. Since there already was the decision not to return a list of
pointers from a covariant method, the only alternative to real thunks
is code duplication (as done in Sun Workshop 5).

With real thunks, you have to copy the argument list. That is not
possible for a varargs list, so here is my proposal for varargs in
C++:

In the place of the ellipsis, a pointer to the first argument is
passed. In case of a thunk for covariant returns, this pointer can be
copied to the destination function. The variable arguments are put on
the stack as they normally would.

With that, the issue is in which cases to use such a calling
convention:
1) only for vararg calls to virtual methods, or
2) only for vararg calls to functions with C++ linkage, or
3) for all vararg calls. That would probably require a change to the C
  ABI
Option 1) could be further restricted to methods returning a pointer
or reference to class type. 

Regards,
Martin



From loewis at informatik.hu-berlin.de  Tue Aug 10 11:18:17 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 10 Aug 1999 13:18:17 +0200
Subject: C++ ABI Summary -- 5 August meeting
In-Reply-To: <9908091558.ZM353615@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <199908070230.TAA39780@baalbek.engr.sgi.com> 
	<199908092250.PAA44899@baalbek.engr.sgi.com> <9908091558.ZM353615@isolde.engr.sgi.com>
Message-ID: <199908101118.NAA27719@pandora>

> What this implies to me is that atexit, and the part of the runtime
> library that handles destructors for static objects, must know about
> each other.

Of the compilers I'm using, only MSVC gets this right - they use
atexit to register the destructor function.

I think there should be a way to implement the standard requirement no
matter how stupid the requirement is; I personally think it is good
that it is specified. 

Using atexit is straight-forward, but breaks for DSOs that are
unloaded early (dlopen/dlclose): atexit will call a function that is
not there, anymore. To support this case as well, atexit would need an
unregistration mechanism, e.g.

- atexit_cookie (void (*func)(void), void* cookie)
  registers a function for atexit, associating it with the cookie
- unregister_atexit (void *cookie)
  removes the function associated with cookie from the list of
  functions to call

That, of course, is an extension to the base API.

Regards,
Martin



From jls at sco.com  Wed Aug 11 10:07:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Wed, 11 Aug 1999 06:07 EDT
Subject: atexit/static dtor interleaving
Message-ID: <199908111029.GAA09570@kauai.newjersey.sco.com>

> Date: Tue, 10 Aug 1999 13:18:17 +0200
> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> > What this implies to me is that atexit, and the part of the runtime
> > library that handles destructors for static objects, must know about
> > each other.
> 
> Of the compilers I'm using, only MSVC gets this right - they use
> atexit to register the destructor function.
> 
> I think there should be a way to implement the standard requirement no
> matter how stupid the requirement is; I personally think it is good
> that it is specified. 

The SCO compiler gets the atexit()/static destructor ordering right,
by having both atexit functions and needed destructor calls placed
on a per-DSO/a.out list that is walked upon DSO unload/a.out termination.

But we do this only for atexit functions registered from the std::atexit() 
defined in <cstdlib>, for which we have a completely different implementation
than the C standard library ::atexit() defined in <stdlib.h>.

This is because the C standard library atexit() is used to register functions
for sensitive, system-level tasks (triggering DSO _fini processing, stdio
cleanup, profiling shutdown, etc.) and trying to add C++ semantics to it
proved very troublesome.

Based on a close (perhaps dubious) reading of 18.3, we decided that 
the <cstdlib> std::atexit() may exist in a different world from
the <stdlib.h> ::atexit(); it does not have "additional behavior"
relative to the C standard library but instead has its own specification.

Jonathan Schilling		SCO, Inc.		jls at sco.com



From thomson at ca.ibm.com  Wed Aug 11 12:51:48 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Wed, 11 Aug 1999 08:51:48 -0400
Subject: atexit/static dtor interleaving
Message-ID: <852567CA.0046ABCE.00@D51MTA05.pok.ibm.com>


>Based on a close (perhaps dubious) reading of 18.3, we decided that
>the <cstdlib> std::atexit() may exist in a different world from
>the <stdlib.h> ::atexit(); it does not have "additional behavior"
>relative to the C standard library but instead has its own specification.
>
>Jonathan Schilling      SCO, Inc.       jls at sco.com

Jonathan, the way you have described this it sounds like an exercise in fine
lawyering.
But I'm sure you agree that the final criterion in these cases isn't whether you
can squeak
something by the standard, but whether the result is reasonable and useful to
your customers.
Is it SCO's position that ordering between C and C++ atexit() isn't useful?

Brian Thomson
VisualAge C/C++ Chief Architect






From jls at sco.com  Wed Aug 11 13:17:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Wed, 11 Aug 1999 09:17 EDT
Subject: atexit/static dtor interleaving
Message-ID: <199908111330.JAA10242@kauai.newjersey.sco.com>

> From owner-cxx-abi at corp.sgi.com Wed Aug 11 08:40:00 1999
> 
> >Based on a close (perhaps dubious) reading of 18.3, we decided that
> >the <cstdlib> std::atexit() may exist in a different world from
> >the <stdlib.h> ::atexit(); it does not have "additional behavior"
> >relative to the C standard library but instead has its own specification.
> >
> >Jonathan Schilling      SCO, Inc.       jls at sco.com
> 
> Jonathan, the way you have described this it sounds like an exercise in fine
> lawyering.
> But I'm sure you agree that the final criterion in these cases isn't whether you
> can squeak
> something by the standard, but whether the result is reasonable and useful to
> your customers.
> Is it SCO's position that ordering between C and C++ atexit() isn't useful?

I think it's our position that C++ atexit() isn't very useful, for all the
reasons that have been mentioned (interleaving with static destructions,
interdeterminate static construction/destruction order, and everything
falls apart when DSOs are explicitly unloaded).  

All other things being equal, yes, it's best if C and C++ atexit() 
interoperate together with the static destructions.  But we weren't willing 
to rework our C library atexit() mechanism to make this happen.

For what it's worth, my support mail files contain only one instance of 
anyone using C++ atexit() in an application, and no one has complained
about our partitioning of C and C++ atexit().

Jonathan Schilling		SCO, Inc.		jls at sco.com



From dehnert at sgi.com  Wed Aug 11 23:00:00 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 11 Aug 1999 16:00:00 -0700
Subject: C++ ABI for IA-64: Data Layout
Message-ID: <37B20070.2715BFFE@sgi.com>

I've attached an update of the data layout document.  It contains
minor additions for member pointer representation, along with a
rework of Christophe's virtual table layout description.  The latter
contains a bunch of questions I had (in red, if you read it with a
browser).  Take a look, and we can discuss it tomorrow.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990811/b4f5bcf4/attachment.html>

From dehnert at sgi.com  Thu Aug 12 01:05:15 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 11 Aug 1999 18:05:15 -0700
Subject: C++ ABI Summary
Message-ID: <37B21DCB.256A69BA@sgi.com>

Here are the updated documents.  (I sent the layout document a couple
of hours ago, and the closed issues list hasn't changed since the
mailing last Friday.)

I've added a concrete proposal for C-3.  The biggest issues for
discussion are probably B-6, C-2, and C-3.  Once again, here's the
list of most important actions we're waiting for:

Daveed
------

AI-13, A-6, B-8:  Describe RTTI representation, dynamic cast.

Priti
-----

AI-12:  Describe the Intel C++ exception handling model.
AI-5:   Set up N-way NDA if necessary to discuss it.

All
---

B-6:  Describe your RTTI representation.

F-x:  In anticipation of mangling discussions, please help by (a)
      identifying what needs to be mangled, and (b) describing any
      mangling/compression scheme(s) you think we should consider.
      (I have started a list in F-1.)

-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990811/7a861379/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990811/7a861379/attachment-0001.html>

From jason at cygnus.com  Thu Aug 12 05:29:44 1999
From: jason at cygnus.com (Jason Merrill)
Date: 11 Aug 1999 22:29:44 -0700
Subject: C++ ABI for IA-64: Data Layout
In-Reply-To: dehnert@sgi.com's message of "11 Aug 1999 16:04:31 -0700"
References: <37B20070.2715BFFE.cygnus.g++.abi@sgi.com>
Message-ID: <u9yafhsh13.fsf@yorick.cygnus.com>

The offset to top field is required for dynamic_cast<void*>, which is
supported for all polymorphic classes.  So yes, it's always needed.

The only replicated entries which would be useful are ones from virtual
bases; we can get to entries from secondary vtables in non-virtual base
subobjects directly, since we're concatenating them.

In Category 3, why do you say "base classes are not empty or nearly empty"?
We still need offsets for empty virtual bases, since they might be at a
different location in the complete object.  Why does it matter if the base
classes have bases themselves?

It seems to me that we don't have to duplicate base offset info that's
already in one of our secondary vtables.

----------------
Further analysis:

This description is pretty good, but it doesn't describe how it's used.
I don't see how it can work without relying on concatenation.  Consider:

  struct A {
    virtual void f () = 0;
  };

  struct B {
    virtual void g () = 0;
  }

  struct C: public A, public B {
    void f () { ... }
    void g () { ... }
  };

  int main () 
  {
    C c;
    B* bp = &c;
    bp->g();
  }

Here, in the call to g, we must adjust 'this' to point to the C object.
But C is not a base of B, so B's vtable doesn't have the offset we want.
The vtable that has the interesting offset is C's.  Fortunately, since
we're concatenating, and in the callee we know what our dynamic type is
(because the dynamic type determines the entry point), we can look down
into C's vtable to find the offset.  So far, so good.

Is this how Taligent does/did it?  If not, how?

The situation gets more complicated with virtual inheritance.  Consider:

  struct A {
    virtual void* f () = 0;
    virtual void* g () = 0;
  };

  struct B: virtual public A {
    void* f () { return this; }
    int i;
  };

  struct C: virtual public A {
    void* g () { return this; }
    int j;
  };

  struct D: public B, public C { };

  int main ()
  {
    D d;
    A* ap = &d;
    B* bp = &d;
    C* cp = &d;

    return (ap->f() != bp || ap->g() != cp);
  }

The offset from A to B is different depending on whether the complete
object is a B or a D.  Furthermore, the offset from the A vptr to the B
vtable is different, so we can't just reuse the f entry in A's vtbl that we
inherit from B; it would look for the offset in the wrong place.  So what
do we do?  The only option I can see is to generate an adjustment thunk
that looks in the right place, but that would have the same problems as the
traditional thunking approach; namely, indirect jumps.

Does anyone see a way to avoid the 3rd-party thunk in this case?

One possibility would be to put derived, rather than base, class offsets in
the vtable; perhaps that's what Taligent really does.  This would have the
effect that A's vtable would be larger in a B than in an A.  Further
derivation could cause it to grow still further.  As a result, we wouldn't
be able to take advantage of concatenation to access secondary vtables
through the primary vptr for a class, since we wouldn't know the size of
the base vtables.

Another possibility would be to fall back on ARM-style vtables, with the
offset in the entry.  This option produces larger vtables, but does not
impede optimization.

Jason



From Michael.Lam at eng.sun.com  Thu Aug 12 16:33:29 1999
From: Michael.Lam at eng.sun.com (Michael Lam)
Date: Thu, 12 Aug 1999 09:33:29 -0700 (PDT)
Subject: Sun's ABI on RTTI and dynamic casting algorithm
Message-ID: <199908121634.JAA00155@ha2mpk.eng.sun.com>

I have attached the abi description of Sun's RTTI and dynamic
casting algorithm.  Please note that Sun is filing a pattern
on the described algorithms.

-Michael Lam
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990812/29b5d803/attachment.html>

From dehnert at sgi.com  Wed Aug 18 07:05:48 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 18 Aug 1999 00:05:48 -0700
Subject: C++ ABI Summary
Message-ID: <37BA5B4C.F4B6A41A@sgi.com>

Attached are updates to the issue pages, along with a new one
provided by Sun describing their RTTI/dynamic cast algorithm.
(I haven't just incorporated the latter because of Sun's patent
filing.  Sun should indicate whether they will allow use of their
patent in this ABI -- if not, I presume we'll avoid it.)

Issues B-1 and B-6 remain very much open, and I expect the main
topic of discussion.  Please think over last week's discussion
(which I mentioned only sketchily) and be prepared to talk about
this this week.  If Daveed can get something out on A-6/B-8,
that would be the next priority.  If either Priti or Christophe
can provide an exception model description (PLEASE...), we can
move into those issues.

I am on a jury, and won't be there Thursday (barring a plea
bargain or some such), but Shin will host the meeting.  (I'm
hoping to be done by the next meeting.)

Also, remember that the phone number will change, not this week,
but the next one.  See the summary page.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/4ea4ba31/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/4ea4ba31/attachment-0001.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/4ea4ba31/attachment-0002.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/4ea4ba31/attachment-0003.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/4ea4ba31/attachment-0004.html>

From ddd at cup.hp.com  Wed Aug 18 23:41:24 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 18 Aug 1999 16:41:24 -0700
Subject: Exception Handling specification
Message-ID: <199908182341.QAA09469@cllmail.cup.hp.com>

Folks,


I have the exception handling specification ready to send. However,  
the file is a Postscript file which, compressed, is about 1.1MB. Is  
it OK to send it to the list? Or can you think of an alternate way to  
submit a large document like this?


Regards
Christophe



From priti.shrivastav at intel.com  Thu Aug 19 00:06:30 1999
From: priti.shrivastav at intel.com (Shrivastav, Priti)
Date: Wed, 18 Aug 1999 17:06:30 -0700
Subject: Intel's  Exception Handling Model
Message-ID: <99BAA0EF4B10D211AC4000A0C95BF94002AF9059@fmsmsx45.fm.intel.com>



Hello,
	Here is Intel's Unix IA-64 EH model. These are power point slide and
are Intel confidential.
 Please review before tomorrow's meeting. Please do not re-distribute these
slides. Thanks,

Priti Shrivastav

-------------- next part --------------
A non-text attachment was scrubbed...
Name: cppeh.ppt
Type: application/vnd.ms-powerpoint
Size: 89600 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/27db7ba6/attachment.ppt>

From ddd at cup.hp.com  Thu Aug 19 03:19:20 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 18 Aug 1999 20:19:20 -0700
Subject: Exception Handling specification
Message-ID: <199908190319.UAA14404@cllmail.cup.hp.com>

A non-text attachment was scrubbed...
Name: not available
Type: text/enriched
Size: 602 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/3fbff647/attachment.bin>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: exception.pdf
Type: application/octet-stream
Size: 261114 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990818/3fbff647/attachment.obj>

From jason at cygnus.com  Thu Aug 19 11:28:46 1999
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 19 Aug 1999 04:28:46 -0700
Subject: calling destructors
Message-ID: <199908191128.EAA08748@yorick.cygnus.com>

The summary for C-5 questions the usefulness of calling op delete from the
destructor.  But it's required by the language, in case the derived class
defines its own op delete.  This only applies to virtual dtors, of course.

One option would be to have two dtor slots, one which performs deletion and
one which doesn't.  The advantage of this sort of approach would be
avoiding pulling in all the memory management code if you never actually
touch the heap.

Microsoft has a patent on this device, but the old Sun ABI also talks about
it, which seems to qualify as prior art.

Jason



From daveed at edg.com  Thu Aug 19 15:43:53 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 19 Aug 1999 08:43:53 -0700
Subject: RTTI draft proposal
Message-ID: <37BC2639.D8CEC18F@edg.com>

Hi everyone,

Please find hereunder a draft of an RTTI proposal.
(Note: NTBS == Null-terminated byte string.)

	Daveed



Run-time type information
=========================

The C++ programming language definition implies that information about types
be available at run time for three distinct purposes:
   (a) to support the typeid operator,
   (b) to match an exception handler with a thrown object, and
   (c) to implement the dynamic_cast operator.
(c) only requires type information about polymorphic class types, but (a) and
(b) may apply to other types as well; for example, when a pointer to an int is
thrown, it can be caught by a handler that catches "int const*".


Open questions
--------------
. What is the type of base class offsets?
. What is the limit on the number of classes?
. Should the common dynamic_cast case be optimized by adding an entry to the
  vtable (to indicate a polymorphic base subobject appears on more than one
  derivation path to the complete object type)?


Place of emission
-----------------
It is probably desirable to minimize the number of places where a particular
bit of RTTI is emitted.  For polymorphic types, a similar problem occurs for
virtual function tables, and hence the information can be appended at the end
of the primary vtable for that type.  For other types, they must presumably be
emitted at the location where their use is implied: the object file containing
the typeid, throw or catch.  Basic type information (such as for "int",
"bool", etc.) could be kept in the run-time support library but the benefits
of that may be limited.


The typeid operator
-------------------
The typeid operator produces a reference to a std::type_info structure with
the following public interface:

	struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };

Assuming that after linking and loading only one type_info structure is active
for any particular type symbol, the equality and inequality operators can be
written as address comparisons: to type_info structures describe the same type
if and only if they are the same structure (at the same address).  In a flat
address space (such as that of the IA-64 architecture), the before() member is
also easily written in terms of an address comparison.  The only additional
piece of information that is required is the NTBS that encodes the name.  The
type_info structure itself can hold a pointer into a read-only segment that
contains the text bytes.


Matching throw expressions with handlers
----------------------------------------
When an object is thrown a copy is made of it and the type of that copy is TT.
A handler that catches type HT will match that throw if:
  . HT is equal to TT except that HT may be a reference and that HT may have
    top-level cv qualifiers (i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  . HT is a reference to a public and unambiguous base type of TT; or
  . HT has a pointer type to which TT can be converted by a standard pointer
    conversion (though only public, unambiguous derived-to-base conversions
    are permitted) and/or a qualification conversion.
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const and
volatile qualifications applied to types.


The dynamic_cast operator
-------------------------
Although dynamic_cast can work on pointers and references, from the point of
view of representation we need only to worry about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time and do
not need any RTTI.  There are then three kinds of truly dynamic cast
operations:
  . dynamic_cast<void cv*>, which returns a pointer to the complete lvalue,
  . dynamic_cast operation from a base class to a derived class, and
  . dynamic_cast across the hierarchy which can be seen as a cast to the
    complete lvalue and back to a sibling base.


RTTI layout
-----------

0. The RTTI layout for a given type depends on whether a 32-bit or 64-bit
mode is in effect.

1. Every vtable shall contain one entry describing the offset from a vptr
for that vtable to the origin of the object containing that vptr (or
equivalently: to the vptr for the primary vtable).  This entry is directly
useful to implement dynamic_cast<void cv*>, but is also needed for the other
truly dynamic casts.

2. Every vtable shall contain one entry pointing to an object derived from
std::extended_type_info; the possible types are:
  . std::__fundamental_type_info
  . std::__pointer_type_info
  . std::__reference_type_info
  . std::__array_type_info
  . std::__function_type_info
  . std::__enum_type_info
  . std::__class_type_info
  . std::__qualifier_type_info
std::extended_type_info derives from std::type_info but adds no fields to the
latter; it is introduced solely to follow the suggestion of the C++ standard.

3. std::type_info contains just two pointers:
  . its vptr
  . a pointer to a NTBS representing the name of the type

4. std::__pointer_type_info adds two fields:
  . a word describing the cv-qualification of what is pointed to
    (e.g., "int volatile*" should have the "volatile" bit set in that word)
  . a pointer to the std::type_info derivation for the unqualified type
    being pointed to
Note that the first bits should not be folded into the pointer because we may
eventually need more qualifier bits (e.g. for "restrict").

5. std::__reference_type_info is similar to std::__pointer_type_info but
describes references.

6. std::__qualifier_type_info is similar to std::__pointer_type_info but
describes top level qualifiers as in "int const" and "char *const".

7. std::__class_type_info introduces a variable length structure.
The variable part that follows consists of a sequence of base class
descriptions having the following structure:
    struct std::__base_class_info {
       std::type_info *type; /* Null if unused. */
       std::ptrdiff_t offset;
       std::__base_class_index next; /* Hash table link. */
       int is_direct: 1;
       int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
       int is_virtual: 1; /* Implies is_floating. */
       int is_shared: 1; /* Implies is_floating and the virtual subobject
                            appears on multiple derivation paths. */
       int is_accessible: 1;
       int is_ambiguous: 1;

    };

 The fixed length introduction adds the following fields to std::type_info:
  . a word with flags describing details about the class such as whether
    it is a class/struct/union and whether it is polymorphic.
  . a hashvalue that can be used for quick lookups in a variable length
    structure describing base classes.
  . the number of base class descriptions that follow it (a power of two).



std::type_info::name()
----------------------
The NTBS returned by this routine is the mangled name of the type.


The dynamic_cast algorithm
--------------------------
Dynamic casts to "void cv*" are inserted inline at compile time.  So are
dynamic casts of null pointers and dynamic casts that are really static.

This leaves the following test to be implemented in the run-time library for
truly dynamic casts of the form "dynamic_cast<T>(v)":
  (see [expr.dynamic_cast] 5.2.7/8)
  . If, in the most derived object pointed (referred) to by v, v points
    (refers) to a public base class sub-object of a T object [note: this can
    be checked at compile time], and if only one object of type T is derived
    from the sub-object pointed (referred) to by v, the result is a pointer
    (an lvalue referring) to that T object.
  . Otherwise, if v points (refers) to a public base class sub-object of the
    most derived object, and the type of the most derived object has an
    unambiguous public base class of type T, the result is a pointer (an
    lvalue referring) to the T sub-object of the most derived object. 
  . Otherwise, the run-time check fails.

The first check corresponds to a "base-to-derived cast" and the second to a
"cross cast".  These tests are implemented by std::__dynamic_cast.

   void* std::__dynamic_cast(void *sub, std::__class_type_info *src,
                                        std::__class_type_info *dst,
                                        std::ptrdiff_t src2dst_offset) {
     // Pick up vtable pointer from given object:
     void *vptr = *(void**)sub;
     if (src2dst_offset>=0 && NO_VBASE(sub, vptr)) {
       // If the type of "v" was not an accessible nonvirtual base type of
       // "T", src2dst_offset should have been set to -1 if it was an
       // accessible but floating base of "T" and to -2 if it was not at all
       // an accessible base of "T".
       // In addition, the vtable should contain an entry to indicate that
       // the complete object has no virtual bases (e.g., a count of the
       // vbase locator entries).
       return (char*)sub+src2dst_offset;
     } else {
       // Slower case
       void *result = 0;
       if (src2dst_offset==-1) {
         // Possibly a "floating" base-to-derived cast:
         result = floating_base2derived(sub, src, dst);
       }
       if (result==0) {
         // The base-to-derived case did not succeed, so we should attempt
         // the cross-cast (which is really a derived-to-base cast from the
         // complete object):
         result = derived2base(complete, dst);
       }
     }
     return result;
   }


The exception handler matching algorithm
----------------------------------------

   bool __eh_match(std::type_info *thrown_type,
                   std::type_info *handled_type) {
     if (thrown_type == handled_type) {
       return true;
     } else if (IS_REFTYPE(handled_type)) {
       std::type_info *caught_type = REMOVE_REFTYPE(handled_type);
       if (IS_CVQUAL(caught_type)) {
         caught_type = REMOVE_CVQUAL(caught_type);
       }
       return thrown_type==caught_type;
     } else if (IS_PTRTYPE(handled_type)) {
       cvqual_match(&thrown_type, &handled_type);
       if (thrown_type==handled_type) {
         return true;
       } else if (IS_CLASSTYPE(thrown_type) && IS_CLASSTYPE(handled_type)) {
         return derived2base_check(thrown_type, handled_type);
       } else {
         return false;
       }
     } else {
       return false;
     }
   }



From jason at cygnus.com  Thu Aug 19 22:31:49 1999
From: jason at cygnus.com (Jason Merrill)
Date: 19 Aug 1999 15:31:49 -0700
Subject: RTTI draft proposal
In-Reply-To: Daveed Vandevoorde's message of "Thu, 19 Aug 1999 08:43:53 -0700"
References: <37BC2639.D8CEC18F@edg.com>
Message-ID: <u93dxfieqy.fsf@yorick.cygnus.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 > the typeid, throw or catch.  Basic type information (such as for "int",
 > "bool", etc.) could be kept in the run-time support library but the benefits
 > of that may be limited.

g++ currently does this.

 > Assuming that after linking and loading only one type_info structure is
 > active for any particular type symbol

We've found that we can't always rely on that, when people build shared
libraries with -B symbolic.  So we fall back on strcmp of the mangled name.

 > std::extended_type_info derives from std::type_info but adds no fields
 > to the latter; it is introduced solely to follow the suggestion of the
 > C++ standard.

That seems wrong; the idea of extended_type_info was supposed to extend the
type_info API so that the user could access more information about
classes.  Stuff like member lists and whatnot.  If we aren't doing anything
like that, we shouldn't introduce extended_type_info.

 > 6. std::__qualifier_type_info is similar to std::__pointer_type_info but
 > describes top level qualifiers as in "int const" and "char *const".

Where would this be used?  I included it in the G++ implementation, but
have since come to the conclusion that it was a mistake.

 > 7. std::__class_type_info introduces a variable length structure.
 > The variable part that follows consists of a sequence of base class
 > descriptions having the following structure:
 >     struct std::__base_class_info {
 >        std::type_info *type; /* Null if unused. */
 >        std::ptrdiff_t offset;
 >        std::__base_class_index next; /* Hash table link. */
 >        int is_direct: 1;
 >        int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
 >        int is_virtual: 1; /* Implies is_floating. */
 >        int is_shared: 1; /* Implies is_floating and the virtual subobject
 >                             appears on multiple derivation paths. */
 >        int is_accessible: 1;
 >        int is_ambiguous: 1;
 >     };

So you're proposing that we store the info about all bases in the type_info
for a class, not just the info for direct bases?  That would certainly make
upcasts (i.e. EH matching and cross dynamic_casts) faster, at the price of
larger RTTI info.

 >  The fixed length introduction adds the following fields to std::type_info:
 >   . a word with flags describing details about the class such as whether
 >     it is a class/struct/union and whether it is polymorphic.

Why?

 >   . a hashvalue that can be used for quick lookups in a variable length
 >     structure describing base classes.

How is this calculated/used?

 >   . the number of base class descriptions that follow it (a power of two).

Why a power of two?

 > The dynamic_cast algorithm
 > --------------------------
 >   . If, in the most derived object pointed (referred) to by v, v points
 >     (refers) to a public base class sub-object of a T object [note: this can
 >     be checked at compile time], and if only one object of type T is derived
 >     from the sub-object pointed (referred) to by v, the result is a pointer
 >     (an lvalue referring) to that T object.

More precisely, we can check at compile time whether T has a unique base
subobject of type typeof(*v).  We don't know anything about the true
referent of v.

 >   . Otherwise, if v points (refers) to a public base class sub-object of the
 >     most derived object, and the type of the most derived object has an
 >     unambiguous public base class of type T, the result is a pointer (an
 >     lvalue referring) to the T sub-object of the most derived object. 
 >   . Otherwise, the run-time check fails.

 > The first check corresponds to a "base-to-derived cast" and the second to a
 > "cross cast".  These tests are implemented by std::__dynamic_cast.

 >    void* std::__dynamic_cast(void *sub, std::__class_type_info *src,
 >                                         std::__class_type_info *dst,
 >                                         std::ptrdiff_t src2dst_offset) {
 >      // Pick up vtable pointer from given object:
 >      void *vptr = *(void**)sub;
 >      if (src2dst_offset>=0 && NO_VBASE(sub, vptr)) {
 >        // If the type of "v" was not an accessible nonvirtual base type of
 >        // "T", src2dst_offset should have been set to -1 if it was an
 >        // accessible but floating base of "T" and to -2 if it was not at all
 >        // an accessible base of "T".
 >        // In addition, the vtable should contain an entry to indicate that
 >        // the complete object has no virtual bases (e.g., a count of the
 >        // vbase locator entries).
 >        return (char*)sub+src2dst_offset;

What about the case where v doesn't point to a base subobject of T at all,
even though the compile time check says it could?  Consider

  struct V;
  struct T: public V;
  struct A: public V;
  struct B: public A, public T;

  B b;
  V* v = (V*)(A*)&b;
  dynamic_cast<T*>(v);

The static check says this could be a downcast, but it's really a cross-cast.

Who passes in src2dst_offset?
In a typical downcast, the offset from src to dst will be negative.

 >      } else {
 >        // Slower case
 >        void *result = 0;
 >        if (src2dst_offset==-1) {
 >          // Possibly a "floating" base-to-derived cast:
 >          result = floating_base2derived(sub, src, dst);
 >        }
 >        if (result==0) {
 >          // The base-to-derived case did not succeed, so we should attempt
 >          // the cross-cast (which is really a derived-to-base cast from the
 >          // complete object):
 >          result = derived2base(complete, dst);
 >        }
 >      }
 >      return result;
 >    }

Where are the defns of floating_base2derived and derived2base?

 > The exception handler matching algorithm
 > ----------------------------------------

 >    bool __eh_match(std::type_info *thrown_type,
 >                    std::type_info *handled_type) {
 >      if (thrown_type == handled_type) {
 >        return true;
 >      } else if (IS_REFTYPE(handled_type)) {
 >        std::type_info *caught_type = REMOVE_REFTYPE(handled_type);
 >        if (IS_CVQUAL(caught_type)) {
 >          caught_type = REMOVE_CVQUAL(caught_type);
 >        }
 >        return thrown_type==caught_type;

We do derived-to-base conversions for non-pointers, too.

3 A  handler  is a match for a throw-expression with an object of type E
  if

  --The handler is of type cv T or cv T& and E and T are the  same  type
    (ignoring the top-level cv-qualifiers), or

  --the  handler is of type cv T or cv T& and T is an unambiguous public
    base class of E, or

  --the handler is of type cv1 T* cv2 and E is a pointer type  that  can
    be converted to the type of the handler by either or both of

    --a  standard  pointer conversion (_conv.ptr_) not involving conver-
      sions to pointers to private or protected or ambiguous classes

    --a qualification conversion

FWIW, g++ turns all dynamic_casts into upcasts, using the original pointer
for disambiguation.  I'm not yet convinced that there's a good way to
accelerate downcasts.

Jason



From daveed at edg.com  Fri Aug 20 00:05:27 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 19 Aug 1999 17:05:27 -0700
Subject: RTTI draft proposal
References: <37BC2639.D8CEC18F@edg.com> <u93dxfieqy.fsf@yorick.cygnus.com>
Message-ID: <37BC9BC7.21C71226@edg.com>

Jason Merrill wrote:
> 
> >>>>> Daveed Vandevoorde <daveed at edg.com> writes:
[...]
>  > Assuming that after linking and loading only one type_info structure is
>  > active for any particular type symbol
> 
> We've found that we can't always rely on that, when people build shared
> libraries with -B symbolic.  So we fall back on strcmp of the mangled name.

Is there a -B symbolic option on IA-64? (Is it a base ABI issue, or can
every vendor do what they please?) If so, that is quite unfortunate I 
suppose. (Unless we cab "escape" from the -B somehow.)

We then have the option that you suggest, or we can follow Sun's idea
of using a strong hash (which is not 100% tight, but "close enough").

>  > std::extended_type_info derives from std::type_info but adds no fields
>  > to the latter; it is introduced solely to follow the suggestion of the
>  > C++ standard.
> 
> That seems wrong; the idea of extended_type_info was supposed to extend the
> type_info API so that the user could access more information about
> classes.  Stuff like member lists and whatnot.  If we aren't doing anything
> like that, we shouldn't introduce extended_type_info.

This was suggested by the J16 core discussion list some time ago.
I don't see it wrong either way; I cannot see it hurting either.

>  > 6. std::__qualifier_type_info is similar to std::__pointer_type_info but
>  > describes top level qualifiers as in "int const" and "char *const".
> 
> Where would this be used?  I included it in the G++ implementation, but
> have since come to the conclusion that it was a mistake.

How do you check qualification conversions when catching exceptions?

>  > 7. std::__class_type_info introduces a variable length structure.
>  > The variable part that follows consists of a sequence of base class
>  > descriptions having the following structure:
>  >     struct std::__base_class_info {
>  >        std::type_info *type; /* Null if unused. */
>  >        std::ptrdiff_t offset;
>  >        std::__base_class_index next; /* Hash table link. */
>  >        int is_direct: 1;
>  >        int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
>  >        int is_virtual: 1; /* Implies is_floating. */
>  >        int is_shared: 1; /* Implies is_floating and the virtual subobject
>  >                             appears on multiple derivation paths. */
>  >        int is_accessible: 1;
>  >        int is_ambiguous: 1;
>  >     };
> 
> So you're proposing that we store the info about all bases in the type_info
> for a class, not just the info for direct bases? 

Yes. (The HP and EDG implementation chose that avenue.  I'm not sure what
Sun does from reading Michael's mail, but my inference is that they do the
same.)

> That would certainly make
> upcasts (i.e. EH matching and cross dynamic_casts) faster, at the price of
> larger RTTI info.

Indeed.

>  >  The fixed length introduction adds the following fields to std::type_info:
>  >   . a word with flags describing details about the class such as whether
>  >     it is a class/struct/union and whether it is polymorphic.
> 
> Why?

Just my inclination of the moment.  I probably thought at some point that the
"polymorphic" bit might be useful in the run-time support library, but that
is not the case.

>  >   . a hashvalue that can be used for quick lookups in a variable length
>  >     structure describing base classes.
> 
> How is this calculated/used?

I haven't made up my mind about its calculation.  I don't recall the HP's
strategy, but it does have a slight historical burden as I recall.  You
could hash the mangled name in some way.

For its use: whenever you try to find a base of type "T" in a complete
type "C", you just search the list rooted at the entry whose subscript
is INFO(T).hashvalue%INFO(T).base_table_size.  That speeds things up a
bit.

>  >   . the number of base class descriptions that follow it (a power of two).
> 
> Why a power of two?

To make the modulo operation above faster.

>  > The dynamic_cast algorithm
>  > --------------------------
>  >   . If, in the most derived object pointed (referred) to by v, v points
>  >     (refers) to a public base class sub-object of a T object [note: this can
>  >     be checked at compile time], and if only one object of type T is derived
>  >     from the sub-object pointed (referred) to by v, the result is a pointer
>  >     (an lvalue referring) to that T object.
> 
> More precisely, we can check at compile time whether T has a unique base
> subobject of type typeof(*v).  We don't know anything about the true
> referent of v.

Darn.

>  >   . Otherwise, if v points (refers) to a public base class sub-object of the
>  >     most derived object, and the type of the most derived object has an
>  >     unambiguous public base class of type T, the result is a pointer (an
>  >     lvalue referring) to the T sub-object of the most derived object.
>  >   . Otherwise, the run-time check fails.
> 
>  > The first check corresponds to a "base-to-derived cast" and the second to a
>  > "cross cast".  These tests are implemented by std::__dynamic_cast.
> 
>  >    void* std::__dynamic_cast(void *sub, std::__class_type_info *src,
>  >                                         std::__class_type_info *dst,
>  >                                         std::ptrdiff_t src2dst_offset) {
>  >      // Pick up vtable pointer from given object:
>  >      void *vptr = *(void**)sub;
>  >      if (src2dst_offset>=0 && NO_VBASE(sub, vptr)) {
>  >        // If the type of "v" was not an accessible nonvirtual base type of
>  >        // "T", src2dst_offset should have been set to -1 if it was an
>  >        // accessible but floating base of "T" and to -2 if it was not at all
>  >        // an accessible base of "T".
>  >        // In addition, the vtable should contain an entry to indicate that
>  >        // the complete object has no virtual bases (e.g., a count of the
>  >        // vbase locator entries).
>  >        return (char*)sub+src2dst_offset;
> 
> What about the case where v doesn't point to a base subobject of T at all,
> even though the compile time check says it could?  Consider
> 
>   struct V;
>   struct T: public V;
>   struct A: public V;
>   struct B: public A, public T;
> 
>   B b;
>   V* v = (V*)(A*)&b;
>   dynamic_cast<T*>(v);
> 
> The static check says this could be a downcast, but it's really a cross-cast.

Ah yes, you mentioned it last time but I hadn't grasped it at the time.
So the algorithm needs to be modified.

> Who passes in src2dst_offset?

The compiler.

> In a typical downcast, the offset from src to dst will be negative.

Is the architecture biased? I.e., do we care about the sign convention for this value?

>  >      } else {
>  >        // Slower case
>  >        void *result = 0;
>  >        if (src2dst_offset==-1) {
>  >          // Possibly a "floating" base-to-derived cast:
>  >          result = floating_base2derived(sub, src, dst);
>  >        }
>  >        if (result==0) {
>  >          // The base-to-derived case did not succeed, so we should attempt
>  >          // the cross-cast (which is really a derived-to-base cast from the
>  >          // complete object):
>  >          result = derived2base(complete, dst);
>  >        }
>  >      }
>  >      return result;
>  >    }
> 
> Where are the defns of floating_base2derived and derived2base?

Handwaving <g>.

>  > The exception handler matching algorithm
>  > ----------------------------------------
> 
>  >    bool __eh_match(std::type_info *thrown_type,
>  >                    std::type_info *handled_type) {
>  >      if (thrown_type == handled_type) {
>  >        return true;
>  >      } else if (IS_REFTYPE(handled_type)) {
>  >        std::type_info *caught_type = REMOVE_REFTYPE(handled_type);
>  >        if (IS_CVQUAL(caught_type)) {
>  >          caught_type = REMOVE_CVQUAL(caught_type);
>  >        }
>  >        return thrown_type==caught_type;
> 
> We do derived-to-base conversions for non-pointers, too.

YAB (yet another bug).

[...]
> FWIW, g++ turns all dynamic_casts into upcasts, using the original pointer
> for disambiguation.  I'm not yet convinced that there's a good way to
> accelerate downcasts.

I'm afraid you may be right.  Except perhaps that checking if a base
of type T is at the offset guessed by the base-to-derived cast may
be more efficient than a full-fledged complete-to-base conversion.

	Daveed



From thomson at ca.ibm.com  Fri Aug 20 22:49:24 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Fri, 20 Aug 1999 18:49:24 -0400
Subject: Misc. from this weeks call
Message-ID: <852567D3.007D74E2.00@D51MTA06.pok.ibm.com>


Re Taligent patents:
These are controlled by Object Technology
Licensing Corp., which is jointly owned by IBM
and Apple.  Although IBM is licenced for them,
our local IP experts don't believe we are able to
sublicence.  We'll look into what that would involve
in case it becomes an issue.


Re: vtable layout, sharing vtable offsets
I'm going to write the exam on this to see how well I
am understanding the issue.

If I understand it correctly, the proposal under consideration
is tied to the decision to replicate virtual function
entries in vtables.  It requires
replicating in the vtable for base class B all virtual functions
that are overridden in B; more replication that this implies will
be wasted since a function is always called through a vtable
of an introducing or overriding class.

When a non-pure virtual function X::f() is compiled it is possible to determine
whether it requires a secondary entry point.  It will require one
if that function may be virtually called (i.e., is the final overrider)
in any class in which f() appears in more than one vtable; this
needs to be decidable knowing only X.
A rule that works is: X::f() overrides one or more f()'s from base classes
of X, and either one or more of those base classes are
virtual or X fails to share its vptr with all instances of them.

[Though a virtual base may happen to share its vptr with X
in an object of complete type X, that relationship may fail to
hold in further derived classes, so we need to generate the
secondary entry point just in case.]
["Sharing a vptr" is the condition under which no adjustment
is necessary; if the bases involved are all nonvirtual then
subsequent class derivation won't change this.]

Each vtable that requires a nonzero adjustment will have a
"convert to X" offset mixed in with its virtual base offsets.  It is
necessary that a "convert to X" appears in the same position in
each vtable that references X::f()'s secondary entry; it is desirable that
the "convert to X" also be unique in each vtable.

Assume that X has nonvirtual nonprimary bases Nx (x=1,2,...), and virtual
bases Vx, all of which have a virtual f().   Then vtables for Nx in X, or in any
class
derived from X that does not further override f(), will reference X::f()'s
secondary entry.   Vtables for Vx in X or any derived class where Vx does
not share a vptr with X, will also reference X::f()'s secondary entry; note
this will occur in a construction vtable even if the derived class does
further override f().

The question, then, is whether a position for the "convert to X" offset can be
chosen, knowing only X and its parentage, that can be used consistently
in all those vtables and that won't collide with a "convert to Y" position
chosen on account of some other hierarchy where Y::g() overrides an
Nx::g() or Vx::g().

If Y derives from X, we will be able to select a "convert to Y" position
that doesn't conflict, so we can restrict our attention to cases where X
and Y are unrelated.
Also, if the base involved is nonvirtual (Nx) then we are safe,
because no instance of Nx will be a subobject of both X and Y, so no
Nx vtable will require both "convert to X" and "convert to Y" offsets.

The remaining case is where X and Y are unrelated but both have
a virtual base Vx:

struct V1 { virtual void f();  virtual void g(); };
struct Other1 { virtual void ignore1(); }
struct X : Other1, virtual V1 { virtual void f(); }

struct Y : Other1, virtual V1 { virtual void g(); }

struct ZZ: X, Y {}

The vtable for N1 in ZZ does require both offsets.
The only way I see to accomplish this is to preallocate
an adjustment slot for each virtual function in V1.  That
is, X::f() uses the first slot position, and Y::g() the second,
based on the order that f() and g() are declared in V1.
This only needs to be done in hierarchies where V1 is virtual,
but the same offset has to be used for any Nx tables in X too.

Is this close?


Re: Concatenating vtables
I don't understand the comment that varying numbers of virtual
base offsets make it impossible to concatenate vtables and refer
to them via a single symbol.
The only code that refers by name to X's vtable and the vtables
of N1 in X etc. is X's constructor and destructor, and maybe some
derived classes that find they are able to reuse some pieces.
All that code is aware of X's declaration and can map out its tables.
What am I missing?




Brian Thomson
VisualAge C/C++ Chief Architect





From dehnert at baalbek.engr.sgi.com  Thu Aug 26 01:35:16 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 25 Aug 1999 18:35:16 -0700 (PDT)
Subject: Meeting tomorrow
Message-ID: <199908260135.SAA80937@baalbek.engr.sgi.com>

Hi,

I'm finally off the jury -- I'm sorry I haven't gotten the meeting
information off earlier.  I still haven't updated the web pages yet,
but I'll get them out this evening.

Reminder:  The phone number changes this week:  (650) 933-7952 .

Priti Shrivastav from Intel will be there by about 11:00 tomorrow,
and I expect to start the exception handling discussions.  Please
read the Intel and HP documents on the subject.

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu Aug 26 04:49:45 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 25 Aug 1999 21:49:45 -0700 (PDT)
Subject: RTTI draft proposal
References: <37BC2639.D8CEC18F@edg.com> <u93dxfieqy.fsf@yorick.cygnus.com>
Message-ID: <199908260449.VAA80183@baalbek.engr.sgi.com>

| From: Daveed Vandevoorde <daveed at edg.com>
| 
| Jason Merrill wrote:
| > 
| > >>>>> Daveed Vandevoorde <daveed at edg.com> writes:
| [...]
| >  > Assuming that after linking and loading only one type_info structure is
| >  > active for any particular type symbol
| > 
| > We've found that we can't always rely on that, when people build shared
| > libraries with -B symbolic.  So we fall back on strcmp of the mangled name.
| 
| Is there a -B symbolic option on IA-64? (Is it a base ABI issue, or can
| every vendor do what they please?) If so, that is quite unfortunate I 
| suppose. (Unless we cab "escape" from the -B somehow.)

As a command line option, -B symbolic is up to the linker vendor.
It is (or used to be) specified in the SVID, for whatever that's worth.
The IA-64 base ABI (indeed the new gABI) now has a representation
("protected" symbols) which provide the same semantics on a per-symbol
basis, and should ultimately cut down on the usage of -B symbolic.  This
is useful functionality, and we can't avoid it.

However, I see no reason why we couldn't specify that either (a)
type_info structure names may not be "protected" and they may not be
made so by -B symbolic, or maybe (b) if they are, they are treated as
distinct types in the different DSOs, with whatever consequences that
has.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at sgi.com  Thu Aug 26 04:56:50 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 25 Aug 1999 21:56:50 -0700
Subject: C++ ABI Summary
Message-ID: <37C4C912.9D40A850@sgi.com>

Attached are the summary and open issues pages.  The latter now
references the exception documents sent by Intel and HP last week
(though the Intel one, as PowerPoint, doesn't really work, and I
renamed them to reflect source and date).  I haven't included them,
but will if anyone wants them again.  Otherwise, I think the only
significant change was to add some email commentary on B-6 from
Brian, and Daveed's proposal (but not the commentary) for A-6.
(There were no changes in the closed issues page, and I'm not
including it.)
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990825/c4ea3542/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990825/c4ea3542/attachment-0001.html>

From jason at cygnus.com  Thu Aug 26 08:07:58 1999
From: jason at cygnus.com (Jason Merrill)
Date: 26 Aug 1999 01:07:58 -0700
Subject: RTTI draft proposal
In-Reply-To: Daveed Vandevoorde's message of "Thu, 19 Aug 1999 17:05:27 -0700"
References: <37BC2639.D8CEC18F@edg.com> <u93dxfieqy.fsf@yorick.cygnus.com> <37BC9BC7.21C71226@edg.com>
Message-ID: <u9k8qjdkwx.fsf@yorick.cygnus.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 >>  > 6. std::__qualifier_type_info is similar to std::__pointer_type_info but
 >>  > describes top level qualifiers as in "int const" and "char *const".
 >> 
 >> Where would this be used?  I included it in the G++ implementation, but
 >> have since come to the conclusion that it was a mistake.

 > How do you check qualification conversions when catching exceptions?

Qualification conversions only apply to pointers, and you already record
the qualification of a pointer's target type in the info about the pointer
type.

 >> In a typical downcast, the offset from src to dst will be negative.

 > Is the architecture biased? I.e., do we care about the sign convention
 > for this value?

Dunno; I just meant that you shouldn't have magic negative values for
src2dst_offset.

 >> FWIW, g++ turns all dynamic_casts into upcasts, using the original pointer
 >> for disambiguation.  I'm not yet convinced that there's a good way to
 >> accelerate downcasts.

 > I'm afraid you may be right.  Except perhaps that checking if a base
 > of type T is at the offset guessed by the base-to-derived cast may
 > be more efficient than a full-fledged complete-to-base conversion.

That makes sense.  When we dynamic_cast from V* to T*, if we see that T has
a public nonvirtual base of type V, we pass the offset from a T to a V into
__dynamic_cast.  In __dynamic_cast, we walk through the T bases, and if we
find one at the right position, we're done.

So I guess it does make sense to have magic negative values.

Jason



From jason at cygnus.com  Fri Aug 27 00:20:11 1999
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 26 Aug 1999 17:20:11 -0700
Subject: vtable layout
Message-ID: <199908270020.RAA05356@yorick.cygnus.com>

I just sent this summary to a gcc discussion list.  Does this sound
accurate to y'all?  In particular, does assigning the slot to the vtable most
non-virtually derived from the introducing vtable make sense?

---------

Rather than per-function offsets, we have per-target type offsets.  These
offsets (if any) are stored at a negative index from the vptr.  When a
derived class D overrides a virtual function F from a base class B, if no
previously allocated offset slot can be reused, we add one to the
beginning of the vtable(s) of the closest base(s) which are non-virtually
derived from B.  In the case of non-virtual inheritance, that would be D's
vtable; in simple virtual inheritance, it would be B's.  The vtables are
written out in one large block, laid out like an object of the class, so if
B is a non-virtual base of D, we can find the D vtable from the B vptr.

D::f then recieves a B*, loads the offset from the vtable, and makes the
adjustment to get a D*.  The plan is to also have a non-adjusting vtable
entry in D's vtable, so we don't have to do two adjustments to call D::f
with a D*; the implementation of this is up to the compiler.  I expect that
for g++, we will do the adjustment in a thunk which just falls into the
main function.

The performance problems with classic thunks occur when the thunk is
not close enough to the function it jumps to for a pc-relative branch.
This cannot be avoided in certain cases of virtual inheritance, where a
derived class must whip up a thunk for a new adjustment to a method it
doesn't override.

In this case, we will only ever have one thunk per function, so we don't
even have to jump.  Except in the case of covariant returns, that is,
where we will have one per return adjustment.  But we know all necessary
adjustments at the point of definition of the function, so they can all be
within pc-relative branch range.

Jason



From thomson at ca.ibm.com  Fri Aug 27 22:57:03 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Fri, 27 Aug 1999 18:57:03 -0400
Subject: vtable layout
Message-ID: <852567DA.007E2EC2.00@D51MTA06.pok.ibm.com>


Jason Merrill writes:

>Rather than per-function offsets, we have per-target type offsets.  These
>offsets (if any) are stored at a negative index from the vptr.  When a
>derived class D overrides a virtual function F from a base class B, if no
>previously allocated offset slot can be reused, we add one to the
>beginning of the vtable(s) of the closest base(s) which are non-virtually
>derived from B.  In the case of non-virtual inheritance, that would be D's
>vtable; in simple virtual inheritance, it would be B's.  The vtables are
>written out in one large block, laid out like an object of the class, so if
>B is a non-virtual base of D, we can find the D vtable from the B vptr.

No, I don't think this is quite what we have been discussing.

This vtable layout problem is unlike the layout decisions we are used to making.
Usually, the problem is to lay out a B vtable such that the layout is
consistent among vtables that "look like a B".  That is, we select function
and vbase offsets so they are invariant among the "B in D" vtables for all
(applicable) D, where "applicable" simply means that D is derived from B.

In this case, though, the free variable is different.  The requirement is to
select an (available) location for an adjust-to-D offset, such
that the B in D vtables for all (applicable) B can use the same offset.
For nonvirtual inheritance,
"applicable" means "where D overrides one or more functions introduced or
overridden in B, and B and D do not share a vtable".

Your statement of the rule would have us adding a slot to D's vtable,
but in fact that is what we never do, because a D vtable never needs
an "adjust to D" slot; instead we add slots to (some of) the secondary
vtables in a D object.

"Available" is also an interesting word, it means "for each of those
B base classes, and for each direct base X of D such that X derives
from B, the B in X vtable either doesn't use this slot, or uses it for an
adjust-to-Y adjustment that is no longer needed because all of Y's virtual
functions that required offsets are overridden somewhere in the D hierarchy".

Now, you could simplify this rule, at the expense of wasting some vtable space,
by not detecting those reusable adjust-to-Y slots, but I don't believe
there is any simplification that amounts to allocating a slot in D's table.

And, as I described in an earlier note, the mechanism is totally different
when B is a virtual base:  In that case, I believe we have to allocate a
separate slot for each function in B, otherwise reconvergent (diamond)
inheritance can introduce conflicts.


All of which leads me to remark ...

This is an interesting problem and all, but I am not entirely
comfortable with the amount of invention it involves.
Standards activities usually try to avoid being so creative.
This work is on a promising path, but I believe we should represent
it as an "experimental ABI" until it is proven by an implementation.





Brian Thomson
VisualAge C/C++ Chief Architect





From jason at cygnus.com  Sat Aug 28 00:32:50 1999
From: jason at cygnus.com (Jason Merrill)
Date: 27 Aug 1999 17:32:50 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Fri, 27 Aug 1999 18:57:03 -0400"
References: <852567DA.007E2EC2.00@D51MTA06.pok.ibm.com>
Message-ID: <u9aerc9231.fsf@yorick.cygnus.com>

>>>>> thomson  <thomson at ca.ibm.com> writes:

 > Your statement of the rule would have us adding a slot to D's vtable,
 > but in fact that is what we never do, because a D vtable never needs
 > an "adjust to D" slot; instead we add slots to (some of) the secondary
 > vtables in a D object.

It seemed simpler to me just to add the slot to D's vtable; since we know
the layout of the vtables, we can find it from any of the secondary vptrs.
But adding it to a secondary vtable from one of D's direct bases would also
work.

 > And, as I described in an earlier note, the mechanism is totally different
 > when B is a virtual base:  In that case, I believe we have to allocate a
 > separate slot for each function in B, otherwise reconvergent (diamond)
 > inheritance can introduce conflicts.

Hmm, yes.  Agreed.

 > All of which leads me to remark ...

 > This is an interesting problem and all, but I am not entirely
 > comfortable with the amount of invention it involves.
 > Standards activities usually try to avoid being so creative.

Fair enough.  But the existing solutions have significant drawbacks that
we'd like to avoid, and there are no backward compatibility concerns on a
new architecture.

 > This work is on a promising path, but I believe we should represent
 > it as an "experimental ABI" until it is proven by an implementation.

That would seem reasonable for the ABI as a whole.

Jason



From thomson at ca.ibm.com  Fri Aug 27 04:33:04 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Fri, 27 Aug 1999 00:33:04 -0400
Subject: vtable layout
Message-ID: <872567DB.00123E34.00@d53mta07h.boulder.ibm.com>




Jason Merrill:

>It seemed simpler to me just to add the slot to D's vtable; since we know
>the layout of the vtables, we can find it from any of the secondary vptrs.
>But adding it to a secondary vtable from one of D's direct bases would also
>work.

Well, the value you need to find depends on which secondary vptr you started
from; what needs to be common is the offset you add to each vptr to find its
associated adjustment.

But the more significant point to make, is that the inter-vtable navigation
you describe isn't possible with this design, since a B in D vtable may not
have the same number of adjustment slots that a B in D in DD has.  Only
if you know the most-derived type can you actually map the aggregated vtable.
You do know enough when you are referring to a vtable by name, but
not when you've been handed a "B in D in ?something?" vptr.


Brian Thomson
Visual Age C/C++ Chief Architect





From jason at cygnus.com  Sat Aug 28 03:57:23 1999
From: jason at cygnus.com (Jason Merrill)
Date: 27 Aug 1999 20:57:23 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Fri, 27 Aug 1999 00:33:04 -0400"
References: <872567DB.00123E34.00@d53mta07h.boulder.ibm.com>
Message-ID: <u94shk8sm4.fsf@yorick.cygnus.com>

>>>>> thomson  <thomson at ca.ibm.com> writes:

 > But the more significant point to make, is that the inter-vtable
 > navigation you describe isn't possible with this design, since a B in D
 > vtable may not have the same number of adjustment slots that a B in D in
 > DD has.

That's why we don't just add the slots to the B vtable; we add them to the
DD vtable (or the DD::D vtable, whichever).

Jason



From thomson at ca.ibm.com  Fri Aug 27 06:52:19 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Fri, 27 Aug 1999 02:52:19 -0400
Subject: vtable layout
Message-ID: <852567DB.001EF70D.00@D51MTA06.pok.ibm.com>


Jason Merrill:

>That's why we don't just add the slots to the B vtable; we add them to the
>DD vtable (or the DD::D vtable, whichever).

OK, I'm willing to be convinced.

For the hierarchy

struct A { virtual void f(); };
struct B : A { void f(); };
struct C : A { void f(); };
struct other { virtual void g(); }
struct D : other, B, C { void f(); }

where do you put the convert-B-to-D and convert-C-to-D slots, such that
D::f()'s secondary entry finds the right one?

You need to locate them so that the address differences

   &cvt-B-to-D - &B-in-D-vtable
   &cvt-C-to-D - &C-in-D-vtable

are equal, which means

   &cvt-B-to-D - &cvt-C-to-D  =  &B-in-D-vtable - &C-in-D-vtable

In general, if the involved secondary vtables span N bytes
then the conversion slots have to span N bytes too.

If slots are attached to the secondary vtables, like I said,
then we can do this without wasted space, and with
somewhat better data cache locality, at the cost of
making inter-vtable navigation impossible.

If instead they are attached (prepended) to D's vtable,
there will almost certainly be wasted slots.  Since the
purpose is to get consistent aggregate vtable layouts,
you will want to keep those slots in any classes
derived from D, even if they aren't really needed
anymore (because D::f is overridden), and that is
more waste.

Now, if this is worth doing, it is because the value of
being able to do the vtable navigation outweighs the
waste of vtable space.  What is that value?





From jason at cygnus.com  Sat Aug 28 06:01:39 1999
From: jason at cygnus.com (Jason Merrill)
Date: 27 Aug 1999 23:01:39 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Fri, 27 Aug 1999 02:52:19 -0400"
References: <852567DB.001EF70D.00@D51MTA06.pok.ibm.com>
Message-ID: <u9zozc78ak.fsf@yorick.cygnus.com>

>>>>> thomson  <thomson at ca.ibm.com> writes:

 > For the hierarchy

 > struct A { virtual void f(); };
 > struct B : A { void f(); };
 > struct C : A { void f(); };
 > struct other { virtual void g(); }
 > struct D : other, B, C { void f(); }

 > where do you put the convert-B-to-D and convert-C-to-D slots, such that
 > D::f()'s secondary entry finds the right one?

 > You need to locate them so that the address differences

 >    &cvt-B-to-D - &B-in-D-vtable
 >    &cvt-C-to-D - &C-in-D-vtable

 > are equal

I don't see why.  The D::C and D::B vtables can refer to different entry
points, so they can look in different places to find the 'this'
adjustment.

This does defeat my earlier claim that we would need at most two entry
points for virtual functions that don't use covariant returns.  Rather, we
get one per vtable where the function appears.

Jason



From thomson at ca.ibm.com  Sat Aug 28 22:08:15 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Sat, 28 Aug 1999 18:08:15 -0400
Subject: vtable layout
Message-ID: <852567DC.0072D0CA.00@D51MTA06.pok.ibm.com>


Jason Merrill:

>I don't see why.  The D::C and D::B vtables can refer to different entry
>points, so they can look in different places to find the 'this'
>adjustment.
>
>This does defeat my earlier claim that we would need at most two entry
>points for virtual functions that don't use covariant returns.  Rather, we
>get one per vtable where the function appears.

True enough, but once you have gone that far there is no point in storing
the adjustments in the vtable any more, you might as well inline them
into the entry points creating conventional adjustment thunks that are
collocated with their target function.

This isn't an outrageous idea, it only works for nonvirtual inheritance but
we are already on a path where the solutions for the virtual and nonvirtual
cases have to be different.  We end up with more entry points, but they
are simpler than the reach-back-into-the-vtable ones.






From jason at cygnus.com  Mon Aug 30 08:13:08 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 01:13:08 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Sat, 28 Aug 1999 18:08:15 -0400"
References: <852567DC.0072D0CA.00@D51MTA06.pok.ibm.com>
Message-ID: <u9g1117kkr.fsf@yorick.cygnus.com>

>>>>> thomson  <thomson at ca.ibm.com> writes:

 > once you have gone that far there is no point in storing the adjustments
 > in the vtable any more, you might as well inline them into the entry
 > points creating conventional adjustment thunks that are collocated with
 > their target function.

Makes sense to me.  What do others think?

Jason



From ddd at cup.hp.com  Mon Aug 30 16:18:31 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 30 Aug 1999 09:18:31 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Fri, 27 Aug 1999 18:57:03 -0400"
Message-ID: <199908301618.JAA10746@cllmail.cup.hp.com>

> >>>>> thomson  <thomson at ca.ibm.com> writes:
>
>  > Your statement of the rule would have us adding a slot to D's  
vtable,
>  > but in fact that is what we never do, because a D vtable never needs 
>  > an "adjust to D" slot; instead we add slots to (some of) the  
secondary
>  > vtables in a D object.
>
> It seemed simpler to me just to add the slot to D's vtable; since  
we know
> the layout of the vtables, we can find it from any of the  
secondary vptrs.
> But adding it to a secondary vtable from one of D's direct bases  
would also
> work.

I think your initial method would not work: a "convert to D" slot is  
added in D if there is a D::f. It must therefore not conflict with  
any base slot. It can't be computed before all bases are known.

>  > And, as I described in an earlier note, the mechanism is  
totally different
>  > when B is a virtual base:  In that case, I believe we have to  
allocate a
>  > separate slot for each function in B, otherwise reconvergent  
(diamond)
>  > inheritance can introduce conflicts.
>
> Hmm, yes.  Agreed.

There is no such problem if it is allocated in the derived class.  
There can be multiple slots per virtual base, though (if two sides of  
a diamond override the same member), which become unused as soon as  
the member is overriden.


>  > This work is on a promising path, but I believe we should represent 
>  > it as an "experimental ABI" until it is proven by an implementation. 
>
> That would seem reasonable for the ABI as a whole.

Agreed :-) And there is nothing really new or scary here: we just  
use for all methods what most implementations do for methods in  
virtual bases...

Cheers
Christophe



From ddd at cup.hp.com  Mon Aug 30 16:53:15 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 30 Aug 1999 09:53:15 -0700
Subject: vtable layout
Message-ID: <199908301653.JAA11914@cllmail.cup.hp.com>

> This isn't an outrageous idea, it only works for nonvirtual  
inheritance but
> we are already on a path where the solutions for the virtual and  
nonvirtual
> cases have to be different.  We end up with more entry points, but they 
> are simpler than the reach-back-into-the-vtable ones.

... And quite slower too ...

Also, let me restate that I don't think the solution I propose is  
different between the virtual and non virtual case. Please show an  
example.


Christophe



From ddd at cup.hp.com  Mon Aug 30 16:59:24 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 30 Aug 1999 09:59:24 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Fri, 27 Aug 1999 02:52:19 -0400"
Message-ID: <199908301659.JAA12008@cllmail.cup.hp.com>

>  > You need to locate them so that the address differences
>
>  >    &cvt-B-to-D - &B-in-D-vtable
>  >    &cvt-C-to-D - &C-in-D-vtable
>
>  > are equal
>
> I don't see why.  The D::C and D::B vtables can refer to different  
entry
> points, so they can look in different places to find the 'this'
> adjustment.

You could do that, but then that's no longer the scheme we  
discussed. The whole point of adjusting late is to have a single  
adjusting entry point, which is where speed and space benefits come  
from.


Christophe



From jason at cygnus.com  Mon Aug 30 17:04:26 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 10:04:26 -0700
Subject: vtable layout
In-Reply-To: Christophe de Dinechin's message of "Mon, 30 Aug 1999 09:18:31 -0700"
References: <199908301618.JAA10746@cllmail.cup.hp.com>
Message-ID: <u9zoz95het.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 >>  > And, as I described in an earlier note, the mechanism is totally
 >>  > different when B is a virtual base: In that case, I believe we have
 >>  > to allocate a separate slot for each function in B, otherwise
 >>  > reconvergent (diamond) inheritance can introduce conflicts.
 >> 
 >> Hmm, yes.  Agreed.

 > There is no such problem if it is allocated in the derived class.  
 > There can be multiple slots per virtual base, though (if two sides of  
 > a diamond override the same member), which become unused as soon as  
 > the member is overriden.

The testcase in question is

  struct A {
    virtual void f ();
    virtual void g ();
  };

  struct B: public virtual A {
    void f ();
  };

  struct C: public virtual A {
    void g ();
  };

  struct D: public B, public C { };

Under your scheme, B and C each add a slot to their A vtable.  In D, we
need to fix this up somehow, since they can't both use the same slot.  But
we've already set up B::f and C::g to look in the same place.  So we need a
third-party thunk.

As far as I can tell, the only way to avoid this sort of situation is to
add one slot per virtual function to the A vtable, as Brian suggested.
That way, B would use one, C would use the other, and they would not clash.

Jason



From jason at cygnus.com  Mon Aug 30 17:08:42 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 10:08:42 -0700
Subject: vtable layout
In-Reply-To: Christophe de Dinechin's message of "Mon, 30 Aug 1999 09:53:15 -0700"
References: <199908301653.JAA11914@cllmail.cup.hp.com>
Message-ID: <u9wvud5h7p.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 >> This isn't an outrageous idea, it only works for nonvirtual inheritance
 >> but we are already on a path where the solutions for the virtual and
 >> nonvirtual cases have to be different.  We end up with more entry
 >> points, but they are simpler than the reach-back-into-the-vtable ones.

 > ... And quite slower too ...

Why?

Jason



From jason at cygnus.com  Mon Aug 30 17:29:23 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 10:29:23 -0700
Subject: vtable layout
In-Reply-To: Christophe de Dinechin's message of "Mon, 30 Aug 1999 09:59:24 -0700"
References: <199908301659.JAA12008@cllmail.cup.hp.com>
Message-ID: <u9u2ph5g98.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 >>  > You need to locate them so that the address differences
 >> 
 >>  >    &cvt-B-to-D - &B-in-D-vtable
 >>  >    &cvt-C-to-D - &C-in-D-vtable
 >> 
 >>  > are equal
 >> 
 >> I don't see why.  The D::C and D::B vtables can refer to different
 >> entry points, so they can look in different places to find the 'this'
 >> adjustment.

 > You could do that, but then that's no longer the scheme we  
 > discussed.

OK, so you *were* proposing that we require something like the above?  I
see.  That's why you talked about the worst case of 2N slots.  We'd
need to pad out D's vtable with as many slots as there are slots between
the B and C vptrs.  I agree that this wouldn't require special handling for
virtual bases.

Jason




From thomson at ca.ibm.com  Mon Aug 30 17:53:23 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Mon, 30 Aug 1999 13:53:23 -0400
Subject: vtable layout
Message-ID: <852567DD.00625F11.00@D51MTA06.pok.ibm.com>


>OK, so you *were* proposing that we require something like the above?  I
>see.  That's why you talked about the worst case of 2N slots.  We'd
>need to pad out D's vtable with as many slots as there are slots between
>the B and C vptrs.  I agree that this wouldn't require special handling for
>virtual bases.

Jason, Christophe, I am not so quick.  I don't see how this solves my
diamond case

   struct V1 { virtual void f();  virtual void g(); };
   struct Other1 { virtual void ignore1(); }
   struct X : Other1, virtual V1 { virtual void f(); }

   struct Y : Other1, virtual V1 { virtual void g(); }

   struct ZZ: X, Y {}

You want the adjustment values allocated in the derived class vtable, so
aggregate vtables for X look something like this

               offset_X_to_V1            ; the adjustment value for X::f
_vft_X:        rtti/dyncast info?
               &X::f                          ; replicated, calls primary entry
_vft_Other1_X: rtti/dyncast
               &Other1::ignore1
_vft_V1_X:          rtti/dyncast
               &X::f__2                  ; calls secondary entry
               &V1::g

and for Y like this:

               offset_Y_to_V1            ; the adjustment value for Y::g
_vft_Y:        rtti/dyncast
               &Y::g                          ; replicated, calls primary entry
_vft_Other1_Y: rtti/dyncast
               &Other1::ignore1
_vft_V1_Y:          rtti/dyncast
               &V1::f
               &Y::g__2                  ; calls secondary entry


That means X::f__2 finds its adjustment offset at vptr-40, and the same goes for
Y::g__2.  Now how do you lay out the vtables for ZZ?



Brian Thomson
VisualAge C/C++ Chief Architect





From jason at cygnus.com  Mon Aug 30 18:09:02 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 11:09:02 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Mon, 30 Aug 1999 13:53:23 -0400"
References: <852567DD.00625F11.00@D51MTA06.pok.ibm.com>
Message-ID: <u9n1v95ef5.fsf@yorick.cygnus.com>

>>>>> thomson  <thomson at ca.ibm.com> writes:

 > I don't see how this solves my diamond case

 >    struct V1 { virtual void f();  virtual void g(); };
 >    struct Other1 { virtual void ignore1(); }
 >    struct X : Other1, virtual V1 { virtual void f(); }

 >    struct Y : Other1, virtual V1 { virtual void g(); }

 >    struct ZZ: X, Y {}

You're right, I didn't think it through far enough.  On the sides of the
diamonds, we decide where the adjustments go.  They end up in the first
available slot, which is slot -1 in both classes.  But only one adjustment
can be at that offset from the V1 vptr, so the adjustments from V1 to X and
Y must be identical.  Which they're not, so this doesn't work.  It gets
worse if the two classes have different numbers of virtual functions.

Christophe?

Jason



From ddd at cup.hp.com  Mon Aug 30 21:47:24 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 30 Aug 1999 14:47:24 -0700
Subject: vtable layout
In-Reply-To: thomson@ca.ibm.com's message of "Mon, 30 Aug 1999 13:53:23 -0400"
Message-ID: <199908302147.OAA20767@cllmail.cup.hp.com>

> >>>>> thomson  <thomson at ca.ibm.com> writes:
>
>  > I don't see how this solves my diamond case
>
>  >    struct V1 { virtual void f();  virtual void g(); };
>  >    struct Other1 { virtual void ignore1(); }
>  >    struct X : Other1, virtual V1 { virtual void f(); }
>
>  >    struct Y : Other1, virtual V1 { virtual void g(); }
>
>  >    struct ZZ: X, Y {}
>
> You're right, I didn't think it through far enough.  On the sides  
of the
> diamonds, we decide where the adjustments go.  They end up in the first 
> available slot, which is slot -1 in both classes.  But only one  
adjustment
> can be at that offset from the V1 vptr, so the adjustments from V1  
to X and
> Y must be identical.  Which they're not, so this doesn't work.  It gets 
> worse if the two classes have different numbers of virtual functions. 
>
> Christophe?

I get it now, sorry for my previous post. I believe that this  
example has been brought up earlier (two or three weeks ago). You are  
right, that's one of the two cases where we still need to emit a  
thunk. We also need a thunk in some cases of  covariant return type  
(to perform a "post" adjustment).

In terms of performance, the impact is limited, because it will  
occur only if you use an A* to call f() or g(). With a B*, a C* or a  
D*, the pair (vtable, offset) is unique. The same offset can be  
reused for f() and g() and mean, in one case, "convert_to_X", in the  
other case, "convert_to_Y". Same thing for non-virtual inheritance.  
Last, the thunk generated in that case is no worse than the thunk  
that would be generated otherwise: we win in other cases, and don't  
lose in this one.


>  >> This isn't an outrageous idea, it only works for nonvirtual  
inheritance
>  >> but we are already on a path where the solutions for the  
virtual and
>  >> nonvirtual cases have to be different.  We end up with more entry 
>  >> points, but they are simpler than the  
reach-back-into-the-vtable ones.
>
When we discussed the problem for covariant returns, someone  
(Jason?) pointed out that the ABI simply mandated the presence of the  
offsets in the vtable, but that you can be ABI-compatible and  
generate thunks that never use the offsets.

>  > ... And quite slower too ...
>
> Why?

A thunk approach means that your virtual calls will look like:

- Indirect branch, almost always mispredicted (probably well over 99%)
- I-Cache miss on thunk, since the thunk is quite "unique"
- Direct branch, almost always mispredicted, since prefetching did  
not have time to recover
- Possible I-Cache miss on target function


On the other hand, the method I proposed has the following benefits:
- The indirect branch mispredicts as before
 - Once its target is known, the I-cache and pipeline are filled  
with useful information (the target function)
- D-cache misses on the vtable offsets are unlikely if any virtual  
function of the same class was called recently
- Call-site adjustment costs zero, in the sense that it is needed to  
get the the vptr anyway.
- If call site adjustment is all that is needed, then the necessary  
adjustment is done at a place where scheduling is easier (the  
caller), rather than at a place where scheduling is impossible (the  
thunk)

For more details, see the complete code trail I sent with my initial  
proposal.


Best regards
Christophe



From jason at cygnus.com  Mon Aug 30 22:24:56 1999
From: jason at cygnus.com (Jason Merrill)
Date: 30 Aug 1999 15:24:56 -0700
Subject: vtable layout
In-Reply-To: Christophe de Dinechin's message of "Mon, 30 Aug 1999 14:47:24 -0700"
References: <199908302147.OAA20767@cllmail.cup.hp.com>
Message-ID: <u9906s6h53.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > In terms of performance, the impact is limited, because it will  
 > occur only if you use an A* to call f() or g(). With a B*, a C* or a  
 > D*, the pair (vtable, offset) is unique. The same offset can be  
 > reused for f() and g() and mean, in one case, "convert_to_X", in the  
 > other case, "convert_to_Y". Same thing for non-virtual inheritance.  

Yes, because it is non-virtual inheritance.

 > Last, the thunk generated in that case is no worse than the thunk  
 > that would be generated otherwise: we win in other cases, and don't  
 > lose in this one.

But it loses compared to the scheme Brian and I have been talking about,
which never requires a third-party thunk.

 >>  > ... And quite slower too ...
 >> 
 >> Why?

 > A thunk approach means that your virtual calls will look like:

 > - Indirect branch, almost always mispredicted (probably well over 99%)

Endemic to virtual functions; no way to get around this.

 > - I-Cache miss on thunk, since the thunk is quite "unique"
 > - Direct branch, almost always mispredicted, since prefetching did  
 > not have time to recover
 > - Possible I-Cache miss on target function

These effects are negated if the thunk is located immediately before the
target function, and you can use a pc-relative branch or just fall through.
And your method faces the same issues.  That's why I talk about third-party
thunks; they're the only ones that have performance problems.

 > On the other hand, the method I proposed has the following benefits:
 > - The indirect branch mispredicts as before
 >  - Once its target is known, the I-cache and pipeline are filled  
 > with useful information (the target function)

Why would this be any different with normal thunks?

 > - D-cache misses on the vtable offsets are unlikely if any virtual  
 > function of the same class was called recently

Even less likely if they aren't used...

 > - Call-site adjustment costs zero, in the sense that it is needed to  
 > get the the vptr anyway.
 > - If call site adjustment is all that is needed, then the necessary  
 > adjustment is done at a place where scheduling is easier (the  
 > caller), rather than at a place where scheduling is impossible (the  
 > thunk)

Again, how is this any different?  All schemes will involve adjusting
'this' to point to a subobject of the appropriate base for the call.

Unless you're talking about loading the offset from the vtable and applying
it in the caller, but that doesn't work with this scheme anyway.

Do you have an implementation of your layout code?  It seems to me that in
large hierarchies, deciding how to lay out the slots so that all the
offsets match up would get very complex.

Jason



From thomson at ca.ibm.com  Tue Aug 31 14:52:52 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Tue, 31 Aug 1999 10:52:52 -0400
Subject: vtable layout
Message-ID: <852567DE.005417BB.00@D51MTA06.pok.ibm.com>


Christophe:

>In terms of performance, the impact is limited, because it will
>occur only if you use an A* to call f() or g(). With a B*, a C* or a
>D*, the pair (vtable, offset) is unique. The same offset can be
>reused for f() and g() and mean, in one case, "convert_to_X", in the
>other case, "convert_to_Y". Same thing for non-virtual inheritance.
>Last, the thunk generated in that case is no worse than the thunk
>that would be generated otherwise: we win in other cases, and don't
>lose in this one.

I still don't fully understand.  What cases of virtual inheritance
will not require a thunk?  Is it when the virtual base appears only
once in the hierarchy (and so might as well not have been virtual)?
That is the only time when you can maintain the spatial relationship
between derived and virtual base vtables.

And, as Jason points out, you are using the worst kind of thunk, it
probably isn't even on the same page as any of the other code never mind
the same cache line.


Jason:

I think your response is complete except for one item,

>These effects are negated if the thunk is located immediately before the
>target function, and you can use a pc-relative branch or just fall through.
>And your method faces the same issues.  That's why I talk about third-party
>thunks; they're the only ones that have performance problems.

A thunk that can fall through has no penalty, but modern deeply
pipelined processors don't like taken branches even if they are correctly
predicted (as an unconditional, pc-relative branch would be).
Because prediction happens in a later stage the prefetcher
normally assumes fall-through control flow and gets corrected a cycle or two
later when the predictor kicks in.  Whether the resulting "bubble" in
instruction issue actually ends up affecting throughput will depend on how
full the rest of the pipeline was. I interpret some of Christophe's
earlier contributions to suggest that we are likely to have just
suffered a mispredicted indirect branch, and in words stolen from
Gulliver's Travels, which seems to have something to say about
almost any situation, we may find the pipeline "lank as a bladder".

Let's see how well I can summarize this for nonvirtual inheritance:

On the one hand we have Christophe's reach-back entry point which,
because of RAW dependencies, is intrinsically 3 cycles and may suffer
an extra D-cache miss, but which can always fall through.

On the other hand we have the thunks we have been discussing, which
are one cycle but only one of them can fall through.  Others will have
a taken branch penalty which may or may not affect throughput.

It looks to me that our performance is better in the fall-through case
and, as long as the penalty is 2 cycles or less, at least as good
in the other cases, and we don't risk the extra D-cache miss, and we have
avoided growing the vtables in a way that has a worst-case 2X expansion.




Brian Thomson
VisualAge C/C++ Chief Architect





From ddd at cup.hp.com  Tue Aug 31 18:10:46 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 31 Aug 1999 11:10:46 -0700
Subject: vtable layout
Message-ID: <199908311810.LAA12475@cllmail.cup.hp.com>

> Christophe:
>
> >In terms of performance, the impact is limited, because it will
> >occur only if you use an A* to call f() or g(). With a B*, a C* or a 
> >D*, the pair (vtable, offset) is unique. The same offset can be
> >reused for f() and g() and mean, in one case, "convert_to_X", in the 
> >other case, "convert_to_Y". Same thing for non-virtual inheritance. 
> >Last, the thunk generated in that case is no worse than the thunk 
> >that would be generated otherwise: we win in other cases, and don't 
> >lose in this one.
>
> I still don't fully understand.  What cases of virtual inheritance 
> will not require a thunk?  Is it when the virtual base appears only 
> once in the hierarchy (and so might as well not have been virtual)? 
> That is the only time when you can maintain the spatial relationship 
> between derived and virtual base vtables.

You always require the thunk _generation_. All I am saying is that  
as long as you use any of the non-virtual bases vtables, I think that  
you don't need to go through the thunk. In other words, you pay the  
thunk run-time penalty only when you call the virtual function  
through the virtual base's vtable (you always pay the space penalty).


> And, as Jason points out, you are using the worst kind of thunk, it 
> probably isn't even on the same page as any of the other code  
never mind
> the same cache line.

In the diamond case where the actually called functions are on each  
side of the diamond, you can't in general generate an adjustment  
thunk that is close to the target, whichever method you chose. But  
maybe I missed something in your discussion. Did you find a trick I  
did not understand?


> I interpret some of Christophe's
> earlier contributions to suggest that we are likely to have just
> suffered a mispredicted indirect branch, and in words stolen from
> Gulliver's Travels, which seems to have something to say about
> almost any situation, we may find the pipeline "lank as a bladder". 

This is indeed the appropriate interpretation :-) Some simulations  
we ran here showed 100% misprediction on the first branch in rather  
common cases.

Regarding whether the second branch would be correctly predicted or  
not... The documentation I have is quite difficult to decipher, so  
I'm not too sure. My impression is that at least on one  
implementation, the branch would predict correctly and not cause an  
additional penalty.


>
> Let's see how well I can summarize this for nonvirtual inheritance: 
>
> On the one hand we have Christophe's reach-back entry point which, 
> because of RAW dependencies, is intrinsically 3 cycles and may suffer 
> an extra D-cache miss, but which can always fall through.

Also note Jim's idea of predicating the adjustment, using the low  
bit of the function pointer. This would mean that the adjustment  
would probably cost much less than 3 cycles, with an extra cost at  
call site that we did not analyze yet.


> On the other hand we have the thunks we have been discussing, which 
> are one cycle but only one of them can fall through.  Others will have 
> a taken branch penalty which may or may not affect throughput.
>
> It looks to me that our performance is better in the fall-through case 
> and, as long as the penalty is 2 cycles or less, at least as good
> in the other cases, and we don't risk the extra D-cache miss, and  
we have
> avoided growing the vtables in a way that has a worst-case 2X  
expansion.

I think this is a slightly incomplete analysis. Unfortunately, it is  
unclear to me what exactly I can disclose here. Intel?


1/ Misprediction penalty

All I can say is that the hypothesis that the penalty is 2 cycles or  
less is way too optimistic (by at least a factor of an odd prime  
number, and even more on the first implementation. What? No, I did  
not say it!). But, as I said earlier, I don't think that's the major  
factor.


2/ I-cache

You considered a D-cache miss in my proposal. Fair enough. Just note  
that the memory access is in the vtable, which is frequently  
accessed. A D-cache miss is "unlikely", a page fault virtually ( :-)  
impossible. The same line will probably be reused at the next virtual  
call to a function of the same class.

On the other hand, an I-cache miss with a thunk model is very  
likely. The thunk is used for a single (class, member) combination  
(as opposed to the offset that depends on the class alone). What is  
close are probably thunks for the same member and different type,  
which would be reused only if I called the same member function with  
a different dynamic type.

Last comment on the subject: you _really_ don't want a cache miss,  
and the I-cache is _really_ small.


3/ Locality

In my proposal, the secondary entry point immediately precedes the  
function. Page faults, cache load and prefetching all benefit from  
this locality. Locality also exists for the data accesses, which are  
close to a location immediately accessed (the vtable).

For thunks, this can only be guaranteed to some extent at the  
page-fault level. A cache line is probably too small for a cache load  
at the thunk address to also load any code for the function.


4/ Memory usage

The memory usage is different. I think for small number of thunks,  
my proposal is worse (since it uses 48 bytes for the secondary entry  
point). On the other hand, as the number of adjustments grow, it gets  
better, since it uses 4 bytes per adjustment rather than 16.


5/ Summarizing the cost

Zeroing out what is common (the indirect branch and the possible  
I-cache miss on the target code), the penalties are something like:

- P1 * A + P2 * B + C for my proposal.

- P3 * A + P4 * B + P5 * D + E for thunks


The architectural variables A, B, C, D and E all depend on the IA64  
implementation being considered:

- A, B are the penalties for L0 cache miss and L1 cache miss

- C is the cost of the adjustment in my proposal. Currently, it is 3  
cycles, but could be less with Jim's idea.

- D is the cost of a resteer immediately following a mispredicted branch.

- E is the cost of a correctly predicted taken branch.


The P1, P2, P3, P4 and P5 are probabilities of something happening  
while executing C++ code:

- P1, P2 are the probabilities that a L0 or L1 data cache miss  
occurs in my proposal (either at the time the load is made, or later,  
because of additional cache pressure)

- P3, P4 are the probabilities that an L0 or L1  I-cache miss occurs  
for the thunk (or later, as above)

- P5 is the probability that a non-zero resteer occurs following the  
mispredicted branch. (It may be zero, I'm not sure).

I know for a fact that A and B are much larger than C, D and E. I  
also assume that P3 > P1 and P4 > P2, given both the cache locality  
and memory size. Therefore, I believe that the dominant factor is (P3  
- P1) * A + (P4 - P2) * B. Given the values for A, B, C, D and E on  
current implementations, this factor remains dominant as long as  
(P3-P1) or (P4-P2) is roughtly above 15 to 20% (for a C of 3). I  
believe that's the case, but this remains to be proven by a  
simulation.


Best regards
Christophe



From jason at cygnus.com  Tue Aug 31 19:34:46 1999
From: jason at cygnus.com (Jason Merrill)
Date: 31 Aug 1999 12:34:46 -0700
Subject: vtable layout
In-Reply-To: Christophe de Dinechin's message of "Tue, 31 Aug 1999 11:10:46 -0700"
References: <199908311810.LAA12475@cllmail.cup.hp.com>
Message-ID: <u9k8qb4ucp.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > You always require the thunk _generation_. All I am saying is that  
 > as long as you use any of the non-virtual bases vtables, I think that  
 > you don't need to go through the thunk. In other words, you pay the  
 > thunk run-time penalty only when you call the virtual function  
 > through the virtual base's vtable (you always pay the space penalty).

Hmm?  Where do you do the adjustment from a non-virtual base, if not in the
thunk?

 > In the diamond case where the actually called functions are on each  
 > side of the diamond, you can't in general generate an adjustment  
 > thunk that is close to the target, whichever method you chose. But  
 > maybe I missed something in your discussion. Did you find a trick I  
 > did not understand?

Brian's proposal was to allocate, in a virtual base's vtable, base
adjustment slots for all the virtual functions provided by that base.  This
prevents us from ever having to generate a third-party thunk, at the cost
of doubling the size of virtual base secondary vtables.  This is clearly a
tradeoff.

 > Also note Jim's idea of predicating the adjustment, using the low  
 > bit of the function pointer. This would mean that the adjustment  
 > would probably cost much less than 3 cycles, with an extra cost at  
 > call site that we did not analyze yet.

I still don't see how call-site adjustment can work under this model; we
don't know how to find the adjustment at the call site.

 > 1/ Misprediction penalty

 > All I can say is that the hypothesis that the penalty is 2 cycles or  
 > less is way too optimistic (by at least a factor of an odd prime  
 > number, and even more on the first implementation. What? No, I did  
 > not say it!). But, as I said earlier, I don't think that's the major  
 > factor.

Is there a term for the case when the branch predictor correctly predicts a
branch but the pipeline stalls because the prefetcher assumed no branch?
That's what I read from Brian's message.  I would expect the penalty for
that to be lower, especially since the pipeline hasn't had a chance to fill
after the indirect branch.  But I'll admit I don't know much about these
issues.

 > Regarding whether the second branch would be correctly predicted or  
 > not... The documentation I have is quite difficult to decipher, so  
 > I'm not too sure. My impression is that at least on one  
 > implementation, the branch would predict correctly and not cause an  
 > additional penalty.

What would be the excuse for mispredicting an unconditional forward
pc-relative branch?

 > 2/ I-cache
 
 > You considered a D-cache miss in my proposal. Fair enough. Just note  
 > that the memory access is in the vtable, which is frequently  
 > accessed. A D-cache miss is "unlikely", a page fault virtually ( :-)  
 > impossible. The same line will probably be reused at the next virtual  
 > call to a function of the same class.

Will it matter that the offset will be located before the function pointer
in the vtable?  In other words, does a load cause the cache to load data
from both sides of the requested address or does it only load forward?

 > On the other hand, an I-cache miss with a thunk model is very  
 > likely. The thunk is used for a single (class, member) combination  
 > (as opposed to the offset that depends on the class alone). What is  
 > close are probably thunks for the same member and different type,  
 > which would be reused only if I called the same member function with  
 > a different dynamic type.

 > Last comment on the subject: you _really_ don't want a cache miss,  
 > and the I-cache is _really_ small.

I assume you are referring here to an I-cache miss on the branch to the
main function?  If so, that's a question of...

 > 3/ Locality

 > In my proposal, the secondary entry point immediately precedes the  
 > function. Page faults, cache load and prefetching all benefit from  
 > this locality. Locality also exists for the data accesses, which are  
 > close to a location immediately accessed (the vtable).

 > For thunks, this can only be guaranteed to some extent at the  
 > page-fault level. A cache line is probably too small for a cache load  
 > at the thunk address to also load any code for the function.

A typical thunk consists of

  add 4 to %rthis
  branch to function

16 bytes, as you say.  Are cache lines really so small that several of
these won't fit?

 > 4/ Memory usage

 > The memory usage is different. I think for small number of thunks,  
 > my proposal is worse (since it uses 48 bytes for the secondary entry  
 > point). On the other hand, as the number of adjustments grow, it gets  
 > better, since it uses 4 bytes per adjustment rather than 16.

I assume you mean 8 bytes (64 bits).  And it uses more than that; in cases
where we use extra thunks, you have to pad out the vtable so that the
offsets line up.

 > 5/ Summarizing the cost

 > Zeroing out what is common (the indirect branch and the possible  
 > I-cache miss on the target code), the penalties are something like:

 > - P1 * A + P2 * B + C for my proposal.

 > - P3 * A + P4 * B + P5 * D + E for thunks

For thunks after the first, that is.  The first one will have no penalty.

 > - P1, P2 are the probabilities that a L0 or L1 data cache miss  
 > occurs in my proposal (either at the time the load is made, or later,  
 > because of additional cache pressure)

 > - P3, P4 are the probabilities that an L0 or L1  I-cache miss occurs  
 > for the thunk (or later, as above)

 > I know for a fact that A and B are much larger than C, D and E. I  
 > also assume that P3 > P1 and P4 > P2, given both the cache locality  
 > and memory size.

I'm not so sure about that.  Cache locality in your proposal depends on the
size of the D vtable (and any others between it and the vptr we're using),
and whether the cache loads backwards.  With thunks, cache locality depends
on the number of thunks generated; in other words, the number of times the
same function appears in distinct non-virtual bases.

Jason



From iancarm at cygnus.com  Tue Aug 31 20:22:11 1999
From: iancarm at cygnus.com (Ian Carmichael)
Date: Tue, 31 Aug 1999 20:22:11 +0000
Subject: vtable layout
References: <852567DE.005417BB.00@D51MTA06.pok.ibm.com>
Message-ID: <37CC3973.D39CD4BB@cygnus.com>

A couple of observations ...

=======

On the state of the art:

The Microsoft approach is worth mentioning.  (I haven't seen it
discussed -- though perhaps that is because of the patent situation.)

It allows zero-adjusting (i.e. non-thunking) calls for (almost) every
virtual function call in a non-virtual, multiple inheritance hierarchy.

For those that are unfamiliar, the idea is that all calls go via the
base class vft and overriding functions expect a pointer to the base
class type.  (That is, if D::f overrides B::f, it expects the first
parameter to be of type B*, not D*.)  The callee does the necessary
static adjustment to get to the derived class 'this' pointer as needed. 
It avoids requiring a thunk, and it's often the case that the cost is
zero in the callee because the this-adjustment can be folded into other
offset computations.

On the balance, it could well win over all the other approaches being
discussed here.  [Though, it may lose in some specific cases vs.
Christophe's approach where one would create additional extra entries in
the derived class vft.]

=======

On when to make extra virtual function table entries for functions:

One of Cristophe's suggestions is sort-of separate from the rest of the
discussion: making extra entries in the derived class' vft for some
overridden virtual functions.  It has the benefit of giving you a faster
calls if you happen to be in (or near) the derived class -- at the
expense of space in the vft.

Of course, you can always make the call through the introducing base
class, so these extra entries are a pure space/time performance trade
off (w/ some unpredictable D-cache effects) and the cost/benefit
analysis will depend a little on what the rest of the strategy looks
like.

The same idea is potentially applicable, no matter what strategy you
actually use for vft layout, and, different criteria for deciding what
extra entries to make are possible.  For example, creating an extra
entry when overriding a function introduced in a virtual base has the
added benefit of avoiding a cast to a virtual base at the call site.

-- 
Ian Carmichael
Cygnus Solutions - Toronto Office
2323 Yonge Street, Suite #502, Toronto, Ontario, M4P 2C9
E-Mail: iancarm at cygnus.com  Tel: 416-482-3946  Fax: 416-482-6299



From jason at cygnus.com  Tue Aug 31 20:53:26 1999
From: jason at cygnus.com (Jason Merrill)
Date: 31 Aug 1999 13:53:26 -0700
Subject: vtable layout
In-Reply-To: Ian Carmichael's message of "Tue, 31 Aug 1999 20:22:11 +0000"
References: <852567DE.005417BB.00@D51MTA06.pok.ibm.com> <37CC3973.D39CD4BB@cygnus.com>
Message-ID: <u94shf4qpl.fsf@yorick.cygnus.com>

>>>>> Ian Carmichael <iancarm at cygnus.com> writes:

 > The Microsoft approach is worth mentioning.  (I haven't seen it
 > discussed -- though perhaps that is because of the patent situation.)

That's why I haven't been discussing it, certainly.

 > One of Cristophe's suggestions is sort-of separate from the rest of the
 > discussion: making extra entries in the derived class' vft for some
 > overridden virtual functions.  It has the benefit of giving you a faster
 > calls if you happen to be in (or near) the derived class -- at the
 > expense of space in the vft.

Yep.  The plan is to add those extra entries regardless of the adjustment
strategy.

Jason



From thomson at ca.ibm.com  Tue Aug 31 23:41:27 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Tue, 31 Aug 1999 19:41:27 -0400
Subject: vtable layout
Message-ID: <852567DE.00827B0C.00@D51MTA06.pok.ibm.com>


> > 1/ Misprediction penalty
>
> > All I can say is that the hypothesis that the penalty is 2 cycles or
> > less is way too optimistic
>
>Is there a term for the case when the branch predictor correctly predicts a
>branch but the pipeline stalls because the prefetcher assumed no branch?

Yes, this is the difference between the "taken branch penalty", which is
typically small (0 to 2 cycles), and the "mispredicted branch penalty" which
is much higher, and in an aggressively pipelined state-of-the-art
processor could be 10 or 20 or more.

> > Regarding whether the second branch would be correctly predicted or
> > not... The documentation I have is quite difficult to decipher, so
> > I'm not too sure. My impression is that at least on one
> > implementation, the branch would predict correctly and not cause an
> > additional penalty.
>
>What would be the excuse for mispredicting an unconditional forward
>pc-relative branch?

To be fair, this is not unheard of.  There was an AMD processor years
ago that did this, and more recently the Pentium had the same problem.
It used the BTB to predict all branches, even unconditional
pc-relative ones, so if the branch hadn't already and fairly recently
been encountered they would get it wrong; I think the penalty was
3 cycles.

It seems easy enough to fix, all you have to do is do an add and you
can get the right answer.  But in hardware, doing an add somewhere
where I didn't do it before means building an extra adder.  This was
finally judged worth doing in the P6, when the cost of misprediction
grew to about 12 cycles.  The "static predictor" reduces this to
5, while a BTB-predicted taken branch cost only 1.

So there is precedent, and Christophe has access to more information
about the implementations than I have, but it would surprise me since
it certainly is a step in the wrong direction.  Especially since the
architecture takes some pains to support static prediction as an
alternative to dynamic, to reduce contention for BTB resources.




With regard to the virtual base side of this whole issue, IBM has
skin in the game in virtual bases because of our support for
the CORBA programming model.  CORBA in C++ implies lots of virtual
bases and lots of calls through introducing classes, and that is
why the possibility of avoiding the wandering thunk is particularly
interesting.



Brian Thomson
VisualAge C/C++ Chief Architect





