From dehnert at sgi.com  Tue Oct  5 01:37:31 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Mon, 04 Oct 1999 18:37:31 -0700
Subject: C++ ABI: COMDAT Proposal
Message-ID: <37F9565B.4494E260@sgi.com>

Attached is a proposal for a COMDAT implementation.
Take a look, and we can start discussion on Thursday if there's time.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991004/715261b6/attachment.html>

From coleen at zko.dec.com  Tue Oct  5 20:48:58 1999
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Tue, 05 Oct 1999 16:48:58 -0400
Subject: C++ ANSI Meeting in Hawaii.
Message-ID: <37FA643A.A75DA7A2@zko.dec.com>


Are many of the members of the consortium going to the ANSI C++
meeting in Hawaii?  If so, can we agree to meet during the meeting
one evening or for the conference call on Thursday Oct 21st at
8:00 AM Hawaii time?

I'm going to be there and since Compaq is new to the consortium,
I have some questions about things that have probably already been
discussed.

Thanks,
Coleen

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From austern at isolde.engr.sgi.com  Tue Oct  5 21:06:18 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Tue, 5 Oct 1999 14:06:18 -0700
Subject: C++ ANSI Meeting in Hawaii.
In-Reply-To: Coleen Phillimore <coleen@zko.dec.com>
        "C++ ANSI Meeting in Hawaii." (Oct  5,  4:48pm)
References: <37FA643A.A75DA7A2@zko.dec.com>
Message-ID: <9910051406.ZM153755@isolde.engr.sgi.com>

I'll be there, but the other SGI people (Jim and John) won't be.
I think that Christophe, Jason, and Daveed are planning to come to
Hawaii too.

Will you be the only Compaq person?

			--Matt



From coleen at zko.dec.com  Tue Oct  5 21:41:06 1999
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Tue, 05 Oct 1999 17:41:06 -0400
Subject: C++ ANSI Meeting in Hawaii.
References: <37FA643A.A75DA7A2@zko.dec.com> <9910051406.ZM153755@isolde.engr.sgi.com>
Message-ID: <37FA7072.A60F9A3@zko.dec.com>

Matt Austern wrote:
> 
> I'll be there, but the other SGI people (Jim and John) won't be.
> I think that Christophe, Jason, and Daveed are planning to come to
> Hawaii too.
> 
> Will you be the only Compaq person?
> 
>                         --Matt

Judy Ward will be there as our overall representative and will attend
the library meetings.  I'm going to attend the language meetings and
catch up on the ABI consortium.

Ron Brender attends the consortium conference calls.  I don't right now
because I don't work on Thursdays.  Apparently there's a lot that happens
on the whiteboard at the meetings that's hard to see from the phone.

Can we schedule to meet Wednesday around lunch so I can ask
you some questions?  They're mostly about abi layout, not exceptions.

Thanks,
Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From dehnert at sgi.com  Wed Oct  6 02:13:40 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 05 Oct 1999 19:13:40 -0700
Subject: SGI gABI Proposal 7x: Section Indices
Message-ID: <37FAB054.4808987F@sgi.com>

Attached is a proposal for eliminating the 16-bit limit on section
indices in ELF.  It is really a base generic ABI proposal, but as
it is motivated largely by the COMDAT proposal, I thought I'd pass
it by this group before submitting it there.  Please send me your
comments, or bring them up in the meeting.

Note that the gABI requires very little change for this purpose --
the ELF header needs two new fields and the symbol table needs a
new parallel table, both only for objects with >64K sections.  I
don't believe there is any further change required for the IA-64
psABI.  SGI has extensions which will require modifications for
this purpose, and I imagine some of the rest of you will too.

Also note that this is a totally compatible extension, and need
not be implemented by anyone until it is convenient and/or the
potential limitation becomes real.  Even if that doesn't occur
for a while, we think it is worth defining a common solution so
that it doesn't cause incompatible extensions later.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991005/8a44cbed/attachment.html>

From dehnert at baalbek.engr.sgi.com  Wed Oct  6 07:53:08 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 6 Oct 1999 00:53:08 -0700 (PDT)
Subject: Meeting Thursday
Message-ID: <199910060753.AAA68577@baalbek.engr.sgi.com>

I'll send updated status pages tomorrow (well, today).  Let's plan
on discussing the following:

 1) The COMDAT/section index proposals I've sent out the past couple
    of days.  It's desirable to get this into the base ABI group ASAP.
    Bring a linker rep if you need to, or perhaps just have them
    review it.  (Of course, there'll be another shot in the base ABI
    group.)

 2) RTTI descriptors, if Daveed can get a cleaned-up version out
    today?  Please?

 3) The updated vtable layout proposal from Jason.

 4) Based on (3), can we produce a clean description of a virtual
    function call?  If not, what's still missing?

I'll update this list when I send the status pages tomorrow.
BTW, I will miss the following week's meeting, unless I can call in.

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Wed Oct  6 17:52:37 1999
From: jason at cygnus.com (Jason Merrill)
Date: 06 Oct 1999 10:52:37 -0700
Subject: Your new dynamic_cast code?
In-Reply-To: Daveed Vandevoorde's message of "Wed, 06 Oct 1999 08:46:27 -0700"
References: <37FB6ED3.24BB081F@edg.com>
Message-ID: <u9puysv0ka.fsf@yorick.cygnus.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 > The other day you mentioned that the development tree of egcs now
 > contains code for the "accelerated dynamic_cast" idea we had
 > discussed.  Is it possible to send me a copy of that code (or
 > point me to where I can fetch it)?

Sure, here you go.  Note that the code for EH upcasts and dynamic_cast has
been split out, to make things simpler; the EH case really isn't a subset
of the dynamic_cast case.  In particular, it has to deal with null
pointers.  Also note that g++ currently handles vbases with a pointer in
the object; thus the *(void **)p stuff.

from gcc/cp/tinfo.{h,cc}:

// type_info for a class with no base classes (or an enum).

struct __user_type_info : public std::type_info {
  __user_type_info (const char *n) : type_info (n) {}

  // If our type can be upcast to a public and unambiguous base, then return
  // non-zero and set RES to point to the base object. OBJ points to the throw
  // object and can be NULL, if there is no object to adjust.
  int upcast (const type_info &target, void *obj, void **res) const;
  
  // If our type can be dynamicly cast to the target type, then return
  // pointer to the target object. OBJ is the pointer to the most derived
  // type and cannot be NULL. SUBTYPE and SUBOBJ indicate the static type
  // base object from whence we came, it cannot be NULL. SUBTYPE cannot be
  // the same as TARGET. TARGET cannot be a base of SUBTYPE.
  // BOFF indicates how SUBTYPE is related to TARGET.
  // BOFF >= 0, there is only one public non-virtual SUBTYPE base at offset
  //    BOFF, and there are no public virtual SUBTYPE bases.
  //    Therefore check if SUBOBJ is at offset BOFF when we find a target
  // BOFF == -1, SUBTYPE occurs as multiple public non-virtual bases.
  //    Lazily search the non-virtual bases of TARGET.
  // BOFF == -2, SUBTYPE occurs as multiple public virtual or non-virtual bases.
  //    Lazily search all the bases of TARGET.
  // BOFF == -3, SUBTYPE is not a public base.
  // For backwards compatibility set BOFF to -2, that is the safe `don't know'
  // value. We don't care about SUBTYPES as private bases of TARGET, as they
  // can never succeed as downcasts, only as crosscasts -- and then only if
  // they are virtual. This is more complicated that it might seem.
  void *dyncast (int boff,
                 const type_info &target, void *obj,
                 const type_info &subtype, void *subobj) const;
  
  // non_virtual_base_type is used to indicate that a base class is via a
  // non-virtual access path.
  static const type_info *const nonvirtual_base_type
      = static_cast <const type_info *> (0) + 1;
  
  // sub_kind tells us about how a base object is contained within a derived
  // object. We often do this lazily, hence the UNKNOWN value. At other times
  // we may use NOT_CONTAINED to mean not publicly contained.
  enum sub_kind
  {
    unknown = 0,              // we have no idea
    not_contained,            // not contained within us (in some
                              // circumstances this might mean not contained
                              // publicly)
    contained_ambig,          // contained ambiguously
    contained_mask = 4,       // contained within us
    contained_virtual_mask = 1, // via a virtual path
    contained_public_mask = 2,  // via a public path
    contained_private = contained_mask,
    contained_public = contained_mask | contained_public_mask
  };
  // some predicate functions for sub_kind
  static inline bool contained_p (sub_kind access_path)
  {
    return access_path >= contained_mask;
  }
  static inline bool contained_public_p (sub_kind access_path)
  {
    return access_path >= contained_public;
  }
  static inline bool contained_nonpublic_p (sub_kind access_path)
  {
    return (access_path & contained_public) == contained_mask;
  }
  static inline bool contained_nonvirtual_p (sub_kind access_path)
  {
    return (access_path & (contained_mask | contained_virtual_mask))
           == contained_mask;
  }
  
  struct upcast_result
  {
    void *target_obj;   // pointer to target object or NULL (init NULL)
    sub_kind whole2target;      // path from most derived object to target
    const type_info *base_type; // where we found the target, (init NULL)
                                // if in vbase the __user_type_info of vbase)
                                // if a non-virtual base then 1
                                // else NULL
    public:
    upcast_result ()
      :target_obj (NULL), whole2target (unknown), base_type (NULL)
      {}
  };
  struct dyncast_result
  {
    void *target_obj;   // pointer to target object or NULL (init NULL)
    sub_kind whole2target;      // path from most derived object to target
    sub_kind whole2sub;         // path from most derived object to sub object
    sub_kind target2sub;        // path from target to sub object
    
    public:
    dyncast_result ()
      :target_obj (NULL), whole2target (unknown),
       whole2sub (unknown), target2sub (unknown)
      {}
  };
  
  public:
  // Helper for upcast. See if TARGET is us, or one of our bases. ACCESS_PATH
  // gives the access from the start object. Return TRUE if we know the catch
  // fails.
  virtual bool do_upcast (sub_kind access_path,
                          const type_info &target, void *obj,
                          upcast_result &__restrict result) const;
  // Helper for dyncast. BOFF indicates how the SUBTYPE is related to TARGET.
  // ACCESS_PATH indicates the access from the most derived object.  It is
  // used to prune the DAG walk. All information about what we find is put
  // into RESULT. Return true, if the match we have found is ambiguous.
  virtual bool do_dyncast (int boff, sub_kind access_path,
                           const type_info &target, void *obj,
                           const type_info &subtype, void *subptr,
                           dyncast_result &__restrict result) const;
  public:
  // Indicate whether SUBPTR of type SUBTYPE is contained publicly within
  // OBJPTR. OBJPTR points to this base object. BOFF indicates how SUBTYPE
  // objects might be contained within this type.  If SUBPTR is one of our
  // SUBTYPE bases, indicate virtuality. Returns not_contained for non
  // containment or private containment.
  sub_kind find_public_subobj (int boff, const type_info &subtype,
                               void *objptr, void *subptr) const
  {
    if (boff >= 0)
      return ((char *)subptr - (char *)objptr) == boff
              ? contained_public : not_contained;
    if (boff == -3)
      return not_contained;
    return do_find_public_subobj (boff, subtype, objptr, subptr);
  }
  
  public:
  // Helper for find_subobj. BOFF indicates how SUBTYPE bases are inherited by
  // the type started from -- which is not necessarily the current type.
  // OBJPTR points to the current base.
  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,
                                          void *objptr, void *subptr) const;
};

// type_info for a class with one public, nonvirtual base class.

class __si_type_info : public __user_type_info {
  const __user_type_info &base;

public:
  __si_type_info (const char *n, const __user_type_info &b)
    : __user_type_info (n), base (b) { }

  private:
  virtual bool do_upcast (sub_kind access_path,
                          const type_info &target, void *obj,
                          upcast_result &__restrict result) const;
  virtual bool do_dyncast (int boff, sub_kind access_path,
                           const type_info &target, void *obj,
                           const type_info &subtype, void *subptr,
                           dyncast_result &__restrict result) const;
  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,
                                          void *objptr, void *subptr) const;
};

// type_info for a general class.

typedef unsigned int USItype	__attribute__ ((mode (SI)));

struct __class_type_info : public __user_type_info {
  enum access { PUBLIC = 1, PROTECTED = 2, PRIVATE = 3 };

  struct base_info {
    const __user_type_info *base;
    USItype offset: 29;
    bool is_virtual: 1;
    enum access access: 2;
  };

  const base_info *base_list;
  size_t n_bases;

  __class_type_info (const char *name, const base_info *bl, size_t bn)
    : __user_type_info (name), base_list (bl), n_bases (bn) {}

  public:
  virtual bool do_upcast (sub_kind access_path,
                          const type_info &target, void *obj,
                          upcast_result &__restrict result) const;
  virtual bool do_dyncast (int boff, sub_kind access_path,
                           const type_info &target, void *obj,
                           const type_info &subtype, void *subptr,
                           dyncast_result &__restrict result) const;
  virtual sub_kind do_find_public_subobj (int boff, const type_info &subtype,
                                          void *objptr, void *subptr) const;
};


// Upcast for catch checking. OBJPTR points to the thrown object and might be
// NULL. Return 0 on failure, non-zero on success. Set *ADJPTR to adjusted
// object pointer.
int __user_type_info::
upcast (const type_info &target, void *objptr,
        void **adjptr) const
{
  upcast_result result;
  
  if (do_upcast (contained_public, target, objptr, result))
    return 0;
  *adjptr = result.target_obj;
  return contained_public_p (result.whole2target);
}

// Down or cross cast for dynamic_cast. OBJPTR points to the most derrived
// object, SUBPTR points to the static base object. Both must not be NULL.
// TARGET specifies the desired target type, SUBTYPE specifies the static
// type. Both must be defined. Returns adjusted object pointer on success,
// NULL on failure. [expr.dynamic.cast]/8 says 'unambiguous public base'. This
// itself is an ambiguous statement. We choose it to mean the base must be
// separately unambiguous and public, rather than unambiguous considering only
// public bases.
void *__user_type_info::
dyncast (int boff,
         const type_info &target, void *objptr,
         const type_info &subtype, void *subptr) const
{
  dyncast_result result;
  
  do_dyncast (boff, contained_public,
              target, objptr, subtype, subptr, result);
  if (!result.target_obj)
    return NULL;
  if (contained_public_p (result.target2sub))
    return result.target_obj;
  if (contained_public_p (sub_kind (result.whole2sub & result.whole2target)))
    // Found a valid cross cast
    return result.target_obj;
  if (contained_nonvirtual_p (result.whole2sub))
    // Found an invalid cross cast, which cannot also be a down cast
    return NULL;
  if (result.target2sub == unknown)
    result.target2sub = static_cast <const __user_type_info &> (target)
                        .find_public_subobj (boff, subtype,
                                             result.target_obj, subptr);
  if (contained_public_p (result.target2sub))
    // Found a valid down cast
    return result.target_obj;
  // Must be an invalid down cast, or the cross cast wasn't bettered
  return NULL;
}

// Catch cast helper. ACCESS_PATH is the access from the complete thrown
// object to this base. TARGET is the desired type we want to catch. OBJPTR
// points to this base within the throw object, it might be NULL. Fill in
// RESULT with what we find. Return true, should we determine catch must fail.
bool __user_type_info::
do_upcast (sub_kind access_path,
           const type_info &target, void *objptr,
           upcast_result &__restrict result) const
{
  if (*this == target)
    {
      result.target_obj = objptr;
      result.base_type = nonvirtual_base_type;
      result.whole2target = access_path;
      return contained_nonpublic_p (access_path);
    }
  return false;
}

// dynamic cast helper. ACCESS_PATH gives the access from the most derived
// object to this base. TARGET indicates the desired type we want. OBJPTR
// points to this base within the object. SUBTYPE indicates the static type
// started from and SUBPTR points to that base within the most derived object.
// Fill in RESULT with what we find. Return true if we have located an
// ambiguous match.
bool __user_type_info::
do_dyncast (int, sub_kind access_path,
            const type_info &target, void *objptr,
            const type_info &subtype, void *subptr,
            dyncast_result &__restrict result) const
{
  if (objptr == subptr && *this == subtype)
    {
      // The subobject we started from. Indicate how we are accessible from
      // the most derived object.
      result.whole2sub = access_path;
      return false;
    }
  if (*this == target)
    {
      result.target_obj = objptr;
      result.whole2target = access_path;
      result.target2sub = not_contained;
      return false;
    }
  return false;
}

// find_public_subobj helper. Return contained_public if we are the desired
// subtype. OBJPTR points to this base type, SUBPTR points to the desired base
// object.
__user_type_info::sub_kind __user_type_info::
do_find_public_subobj (int, const type_info &, void *objptr, void *subptr) const
{
  if (subptr == objptr)
    // Must be our type, as the pointers match.
    return contained_public;
  return not_contained;
}

// catch helper for single public inheritance types. See
// __user_type_info::do_upcast for semantics.
bool __si_type_info::
do_upcast (sub_kind access_path,
           const type_info &target, void *objptr,
           upcast_result &__restrict result) const
{
  if (*this == target)
    {
      result.target_obj = objptr;
      result.base_type = nonvirtual_base_type;
      result.whole2target = access_path;
      return contained_nonpublic_p (access_path);
    }
  return base.do_upcast (access_path, target, objptr, result);
}

// dynamic cast helper for single public inheritance types. See
// __user_type_info::do_dyncast for semantics. BOFF indicates how SUBTYPE
// types are inherited by TARGET types.
bool __si_type_info::
do_dyncast (int boff, sub_kind access_path,
            const type_info &target, void *objptr,
            const type_info &subtype, void *subptr,
            dyncast_result &__restrict result) const
{
  if (objptr == subptr && *this == subtype)
    {
      // The subobject we started from. Indicate how we are accessible from
      // the most derived object.
      result.whole2sub = access_path;
      return false;
    }
  if (*this == target)
    {
      result.target_obj = objptr;
      result.whole2target = access_path;
      if (boff >= 0)
        result.target2sub = ((char *)subptr - (char *)objptr) == boff
              ? contained_public : not_contained;
      else if (boff == -3)
        result.target2sub = not_contained;
      return false;
    }
  return base.do_dyncast (boff, access_path,
                          target, objptr, subtype, subptr, result);
}

// find_public_subobj helper. See __user_type_info::do_find_public_subobj or
// semantics. BOFF indicates how SUBTYPE types are inherited by the original
// target object.
__user_type_info::sub_kind __si_type_info::
do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const
{
  if (subptr == objptr && subtype == *this)
    return contained_public;
  return base.do_find_public_subobj (boff, subtype, objptr, subptr);
}

// catch helper for multiple or non-public inheritance types. See
// __user_type_info::do_upcast for semantics.
bool __class_type_info::
do_upcast (sub_kind access_path,
           const type_info &target, void *objptr,
           upcast_result &__restrict result) const
{
  if (*this == target)
    {
      result.target_obj = objptr;
      result.base_type = nonvirtual_base_type;
      result.whole2target = access_path;
      return contained_nonpublic_p (access_path);
    }
  
  for (size_t i = n_bases; i--;)
    {
      upcast_result result2;
      void *p = objptr;
      sub_kind sub_access = access_path;
      if (p)
        p = (char *)p + base_list[i].offset;
      if (base_list[i].is_virtual)
        {
          if (p)
            p = *(void **)p;
	  sub_access = sub_kind (sub_access | contained_virtual_mask);
        }
      if (base_list[i].access != PUBLIC)
        sub_access = sub_kind (sub_access & ~contained_public_mask);
      if (base_list[i].base->do_upcast (sub_access, target, p, result2))
        return true; // must fail
      if (result2.base_type)
        {
          if (result2.base_type == nonvirtual_base_type
              && base_list[i].is_virtual)
            result2.base_type = base_list[i].base;
          if (!result.base_type)
            result = result2;
          else if (result.target_obj != result2.target_obj)
            {
              // Found an ambiguity.
	      result.target_obj = NULL;
	      result.whole2target = contained_ambig;
	      return true;
            }
          else if (result.target_obj)
            {
              // Ok, found real object via a virtual path.
              result.whole2target
                  = sub_kind (result.whole2target | result2.whole2target);
            }
          else
            {
              // Dealing with a null pointer, need to check vbase
              // containing each of the two choices.
              if (result2.base_type == nonvirtual_base_type
                  || result.base_type == nonvirtual_base_type
                  || !(*result2.base_type == *result.base_type))
                {
                  // Already ambiguous, not virtual or via different virtuals.
                  // Cannot match.
                  result.whole2target = contained_ambig;
                  return true;
                }
            }
        }
    }
  return false;
}

// dynamic cast helper for non-public or multiple inheritance types. See
// __user_type_info::do_dyncast for overall semantics.
// This is a big hairy function. Although the run-time behaviour of
// dynamic_cast is simple to describe, it gives rise to some non-obvious
// behaviour. We also desire to determine as early as possible any definite
// answer we can get. Because it is unknown what the run-time ratio of
// succeeding to failing dynamic casts is, we do not know in which direction
// to bias any optimizations. To that end we make no particular effort towards
// early fail answers or early success answers. Instead we try to minimize
// work by filling in things lazily (when we know we need the information),
// and opportunisticly take early success or failure results.
bool __class_type_info::
do_dyncast (int boff, sub_kind access_path,
            const type_info &target, void *objptr,
            const type_info &subtype, void *subptr,
            dyncast_result &__restrict result) const
{
  if (objptr == subptr && *this == subtype)
    {
      // The subobject we started from. Indicate how we are accessible from
      // the most derived object.
      result.whole2sub = access_path;
      return false;
    }
  if (*this == target)
    {
      result.target_obj = objptr;
      result.whole2target = access_path;
      if (boff >= 0)
        result.target2sub = ((char *)subptr - (char *)objptr) == boff
              ? contained_public : not_contained;
      else if (boff == -3)
        result.target2sub = not_contained;
      return false;
    }
  bool result_ambig = false;
  for (size_t i = n_bases; i--;)
    {
      dyncast_result result2;
      void *p = (char *)objptr + base_list[i].offset;
      sub_kind sub_access = access_path;
      if (base_list[i].is_virtual)
        {
	  p = *(void **)p;
	  sub_access = sub_kind (sub_access | contained_virtual_mask);
	}
      if (base_list[i].access != PUBLIC)
        sub_access = sub_kind (sub_access & ~contained_public_mask);
      
      bool result2_ambig
          = base_list[i].base->do_dyncast (boff, sub_access,
                                           target, p, subtype, subptr, result2);
      result.whole2sub = sub_kind (result.whole2sub | result2.whole2sub);
      if (result2.target2sub == contained_public
          || result2.target2sub == contained_ambig)
        {
          result.target_obj = result2.target_obj;
          result.whole2target = result2.whole2target;
          result.target2sub = result2.target2sub;
          // Found a downcast which can't be bettered or an ambiguous downcast
          // which can't be disambiguated
          return result2_ambig;
        }
      
      if (!result_ambig && !result.target_obj)
        {
          // Not found anything yet.
          result.target_obj = result2.target_obj;
          result.whole2target = result2.whole2target;
          result_ambig = result2_ambig;
        }
      else if (result.target_obj && result.target_obj == result2.target_obj)
        {
          // Found at same address, must be via virtual.  Pick the most
          // accessible path.
          result.whole2target =
              sub_kind (result.whole2target | result2.whole2target);
        }
      else if ((result.target_obj && result2.target_obj)
               || (result_ambig && result2.target_obj)
               || (result2_ambig && result.target_obj))
        {
          // Found two different TARGET bases, or a valid one and a set of
          // ambiguous ones, must disambiguate. See whether SUBOBJ is
          // contained publicly within one of the non-ambiguous choices.
          // If it is in only one, then that's the choice. If it is in
          // both, then we're ambiguous and fail. If it is in neither,
          // we're ambiguous, but don't yet fail as we might later find a
          // third base which does contain SUBPTR.
        
          sub_kind new_sub_kind = result2.target2sub;
          sub_kind old_sub_kind = result.target2sub;
          
          if (contained_nonvirtual_p (result.whole2sub))
            {
              // We already found SUBOBJ as a non-virtual base of most
              // derived. Therefore if it is in either choice, it can only be
              // in one of them, and we will already know.
              if (old_sub_kind == unknown)
                old_sub_kind = not_contained;
              if (new_sub_kind == unknown)
                new_sub_kind = not_contained;
            }
          else
            {
              const __user_type_info &t =
                  static_cast <const __user_type_info &> (target);
              
              if (old_sub_kind >= not_contained)
                ;// already calculated
              else if (contained_nonvirtual_p (new_sub_kind))
                // Already found non-virtually inside the other choice,
                // cannot be in this.
                old_sub_kind = not_contained;
              else
                old_sub_kind = t.find_public_subobj (boff, subtype,
                                                     result.target_obj, subptr);
          
              if (new_sub_kind >= not_contained)
                ;// already calculated
              else if (contained_nonvirtual_p (old_sub_kind))
                // Already found non-virtually inside the other choice,
                // cannot be in this.
                new_sub_kind = not_contained;
              else
                new_sub_kind = t.find_public_subobj (boff, subtype,
                                                     result2.target_obj, subptr);
            }
          
          // Neither sub_kind can be contained_ambig -- we bail out early
          // when we find those.
          if (contained_p (sub_kind (new_sub_kind ^ old_sub_kind)))
            {
              // Only on one choice, not ambiguous.
              if (contained_p (new_sub_kind))
                {
                  // Only in new.
                  result.target_obj = result2.target_obj;
                  result.whole2target = result2.whole2target;
                  result_ambig = false;
                  old_sub_kind = new_sub_kind;
                }
              result.target2sub = old_sub_kind;
              if (result.target2sub == contained_public)
                return false; // Can't be an ambiguating downcast for later discovery.
            }
          else if (contained_p (sub_kind (new_sub_kind & old_sub_kind)))
            {
              // In both.
              result.target_obj = NULL;
              result.target2sub = contained_ambig;
              return true;  // Fail.
            }
          else
            {
              // In neither publicly, ambiguous for the moment, but keep
              // looking. It is possible that it was private in one or
              // both and therefore we should fail, but that's just tough.
              result.target_obj = NULL;
              result.target2sub = not_contained;
              result_ambig = true;
            }
        }
      
      if (result.whole2sub == contained_private)
        // We found SUBOBJ as a private non-virtual base, therefore all
        // cross casts will fail. We have already found a down cast, if
        // there is one.
        return result_ambig;
    }

  return result_ambig;
}

// find_public_subobj helper for non-public or multiple inheritance types. See
// __user_type_info::do_find_public_subobj for semantics. We make use of BOFF
// to prune the base class walk.
__user_type_info::sub_kind __class_type_info::
do_find_public_subobj (int boff, const type_info &subtype, void *objptr, void *subptr) const
{
  if (objptr == subptr && subtype == *this)
    return contained_public;
  
  for (size_t i = n_bases; i--;)
    {
      if (base_list[i].access != PUBLIC)
        continue; // Not public, can't be here.
      void *p = (char *)objptr + base_list[i].offset;
      if (base_list[i].is_virtual)
        {
          if (boff == -1)
            continue; // Not a virtual base, so can't be here.
          p = *(void **)p;
        }

      sub_kind base_kind = base_list[i].base->do_find_public_subobj
                              (boff, subtype, p, subptr);
      if (contained_p (base_kind))
        {
          if (base_list[i].is_virtual)
            base_kind = sub_kind (base_kind | contained_virtual_mask);
          return base_kind;
        }
    }
  
  return not_contained;
}



From daveed at edg.com  Wed Oct  6 19:24:29 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 06 Oct 1999 12:24:29 -0700
Subject: Updated RTTI information
References: <37FB6ED3.24BB081F@edg.com> <u9puysv0ka.fsf@yorick.cygnus.com>
Message-ID: <37FBA1ED.B80D2CF1@edg.com>

Hi all,

Attached is the updated RTTI document (plain ASCII text).
I think the various changes we discussed a while back are 
now in there.

I have given up on trying to write up the actual algorithms
(dynamic_cast) and left only the interface (inspired by the
new GNU implementation).  The EH matching interface has
been removed since it is "personality specific".

I don't think we came to a definite conclusion about whether
only direct bases should be listed (GNU approach) or all
bases (Sun, HP, EDG).  I've kept the "all bases" approach
because I think it is faster (though bulkier).

There are probably still a few bits of info that might be
extraneous in __class_type_info.

Comments and corrections welcome as usual.

	Daveed
-------------- next part --------------
Run-time type information
=========================

The C++ programming language definition implies that information about types
be available at run time for three distinct purposes:
   (a) to support the typeid operator,
   (b) to match an exception handler with a thrown object, and
   (c) to implement the dynamic_cast operator.
(c) only requires type information about polymorphic class types, but (a) and
(b) may apply to other types as well; for example, when a pointer to an int is
thrown, it can be caught by a handler that catches "int const*".


Deliberations
-------------
The following conclusions were arrived at by the attending member of the
C++ IA-64 ABI group:

. The exact layout for type_info objects is dependent on whether a 32-bit
  or 64-bit model is supported.
. Advantage should be taken of COMDAT sections and symbol preemption: two
  type_info pointers point to equivalent types if and only if the pointers
  are equal.
. A simple dynamic_cast algorithm that is efficient in the common case of
  base-to-most-derived cast case is preferrable over more sophisticated ideas
  that handle deep-base-to-in-between-derived casts more efficiently at a
  slight cost to the common case.  Hence, the original scheme of providing
  a hash-table into the list of base classes (as is done e.g. in the HP aC++
  compiler) has been dropped.
. The GNU egcs development team has implemented an idea of this ABI group to
  accelerate dynamic_cast operations by a-posteriori checking a "likely
  outcome".  The interface of std::__dynamic_cast therefore keeps the
  src2dst_offset hint.
. std::__extended_type_info is dropped.


Place of emission
-----------------
It is probably desirable to minimize the number of places where a particular
bit of RTTI is emitted.  For polymorphic types, a similar problem occurs for
virtual function tables, and hence the information can be appended at the end
of the primary vtable for that type.  For other types, they must presumably be
emitted at the location where their use is implied: the object file containing
the typeid, throw or catch.

Basic type information (such as for "int", "bool", etc.) can be kept in the
run-time support library.  Specifically, this proposal is to place in the
run-time support library type_info objects for the following types:
	void*, void const*
and
	X, X* and X const*
for every X in: bool, wchar_t, char, unsigned char, signed char, short,
unsigned short, int, unsigned int, long, unsigned long, long long, unsigned
long long, float, double, long double.  (Note that various other type_info
objects for class types may reside in the run-time support library by virtue
of the preceding rules; e.g., that of std::bad_alloc.)


The typeid operator
-------------------
The typeid operator produces a reference to a std::type_info structure with
the following public interface:

	struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };

Assuming that after linking and loading only one type_info structure is active
for any particular type symbol, the equality and inequality operators can be
written as address comparisons: to type_info structures describe the same type
if and only if they are the same structure (at the same address).  In a flat
address space (such as that of the IA-64 architecture), the before() member is
also easily written in terms of an address comparison.  The only additional
piece of information that is required is the NTBS that encodes the name.  The
type_info structure itself can hold a pointer into a read-only segment that
contains the text bytes.


Matching throw expressions with handlers
----------------------------------------
When an object is thrown a copy is made of it and the type of that copy is TT.
A handler that catches type HT will match that throw if:
  . HT is equal to TT except that HT may be a reference and that HT may have
    top-level cv qualifiers (i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  . HT is a reference to a public and unambiguous base type of TT; or
  . HT has a pointer type to which TT can be converted by a standard pointer
    conversion (though only public, unambiguous derived-to-base conversions
    are permitted) and/or a qualification conversion.
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const and
volatile qualifications applied to types.


The dynamic_cast operator
-------------------------
Although dynamic_cast can work on pointers and references, from the point of
view of representation we need only to worry about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time and do
not need any RTTI.  There are then three kinds of truly dynamic cast
operations:
  . dynamic_cast<void cv*>, which returns a pointer to the complete lvalue,
  . dynamic_cast operation from a base class to a derived class, and
  . dynamic_cast across the hierarchy which can be seen as a cast to the
    complete lvalue and back to a sibling base.


RTTI layout
-----------

0. The RTTI layout for a given type depends on whether a 32-bit or 64-bit
mode is in effect.

1. Every vtable shall contain one entry describing the offset from a vptr
for that vtable to the origin of the object containing that vptr (or
equivalently: to the vptr for the primary vtable).  This entry is directly
useful to implement dynamic_cast<void cv*>, but is also needed for the other
truly dynamic casts.  This entry is located two words ahead of the location
pointed to by the vptr (i.e., entry "-2").

2. Every vtable shall contain one entry pointing to an object derived from
std::type_info.  This entry is located at the word preceding the location
pointed to by the vptr (i.e., entry "-1").

std::type_info contains just two pointers:
  . its vptr
  . a pointer to a NTBS representing the name of the type

The possible derived types are:
  . std::__fundamental_type_info
  . std::__pointer_type_info
  . std::__reference_type_info
  . std::__array_type_info
  . std::__function_type_info
  . std::__enum_type_info
  . std::__class_type_info
  . std::__ptr_to_member_type_info

3. std::__fundamental_type_info adds no fields to std::type_info.

4. std::__pointer_type_info adds two fields (in that order):
  . a word describing the cv-qualification of what is pointed to
    (e.g., "int volatile*" should have the "volatile" bit set in that word).
  . a pointer to the std::type_info derivation for the unqualified type
    being pointed to
Note that the first bits should not be folded into the pointer because we may
eventually need more qualifier bits (e.g. for "restrict").  The bit 0x1
encodes the "const" qualifier; the bit 0x2 encodes "volatile".

5. std::__reference_type_info is similar to std::__pointer_type_info but
describes references.

6. std::__array_type_info and std::__function_type_info do not add fields to
   std::type_info (these types are only produced by the typeid operator;
   they decay in other contexts).  std::__enum_type_info does not add fields
   either.

7. std::__class_type_info introduces a variable length structure.
The fixed length introduction adds the following fields to std::type_info:
  . a word with flags describing some details about the class:
      0x1: contains multiply inherited subobject
      0x2: is polymorphic
      0x4: has virtual bases
      0x8: has privately inherited base
  . the number of base class descriptions that follow it (std::size_t).

The variable part that follows consists of a sequence of base class
descriptions having the following structure:
    struct std::__base_class_info {
       std::type_info *type;
       std::ptrdiff_t offset;
       int is_direct: 1;
       int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
       int is_virtual: 1; /* Implies is_floating. */
       int is_shared: 1; /* Implies is_floating and the virtual subobject
                            appears on multiple derivation paths. */
       int is_accessible: 1;
       int is_ambiguous: 1;
    };

8. The std::__ptr_to_member_type_info type adds two fields to std::type_info:
  . a pointer to a std::__class_type_info (e.g., the "A" in "int A::*")
  . a_pointer to a std::type_info corresponding to the member type (e.g., the
    "int*" in "int A::*")


std::type_info::name()
----------------------
The NTBS returned by this routine is the mangled name of the type.


The dynamic_cast algorithm
--------------------------
Dynamic casts to "void cv*" are inserted inline at compile time.  So are
dynamic casts of null pointers and dynamic casts that are really static.

This leaves the following test to be implemented in the run-time library for
truly dynamic casts of the form "dynamic_cast<T>(v)":
  (see [expr.dynamic_cast] 5.2.7/8)
  . If, in the most derived object pointed (referred) to by v, v points
    (refers) to a public base class sub-object of a T object [note: this can
    be checked at compile time], and if only one object of type T is derived
    from the sub-object pointed (referred) to by v, the result is a pointer
    (an lvalue referring) to that T object.
  . Otherwise, if v points (refers) to a public base class sub-object of the
    most derived object, and the type of the most derived object has an
    unambiguous public base class of type T, the result is a pointer (an
    lvalue referring) to the T sub-object of the most derived object. 
  . Otherwise, the run-time check fails.

The first check corresponds to a "base-to-derived cast" and the second to a
"cross cast".  These tests are implemented by std::__dynamic_cast.

   void* std::__dynamic_cast(void *sub, std::__class_type_info *src,
                                        std::__class_type_info *dst,
                                        std::ptrdiff_t src2dst_offset);
   /* sub: source address to be adjusted; nonnull, and since the source
    *      object is polymoprhic, *(void**)sub is a vptr.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast<T>(v)").
    * src2dst_offset: a static hint about the adjustment needed on sub;
    *    since this adjustment cannot be 1, 2 or 3 those special values
    *    mean:
    *       1: no hint
    *       2: src is not a public base of dst
    *       3: src is a multiple public base type but never a virtual
    *          base type
    *    otherwise, the src type is a unique public nonvirtual base
    *    type of dst at offset -src2dst_offset from the origin of dst.
    */


The exception handler matching algorithm
----------------------------------------

Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document (beyond the layout of the
RTTI data).


From dehnert at sgi.com  Thu Oct  7 02:17:06 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 06 Oct 1999 19:17:06 -0700
Subject: Meeting Thursday and Status
References: <199910060753.AAA68577@baalbek.engr.sgi.com>
Message-ID: <37FC02A2.581840FA@sgi.com>

Attached is the gzipped tar file of the status pages.  PDF to follow.
Following is an updated agenda:
 
  1) The COMDAT/section index proposals I've sent out the past couple
     of days.  It's desirable to get this into the base ABI group ASAP.
     Bring a linker rep if you need to, or perhaps just have them
     review it.  (Of course, there'll be another shot in the base ABI
     group.)  See open issue B-5.
 
  2) RTTI descriptors.  See open issue A-6, and Daveed's cleaned
     up description in the ABI data layout document.  Thanks,
     Daveed, for getting this out.
 
  3) The updated vtable layout proposal from Jason.  See open issue
     B-6, and Jason's cleaned up description in the ABI data layout
     document.
 
  4) Based on (3), can we produce a clean description of a virtual
     function call?  If not, what's still missing?  See issue B-1.

  5) Same question for dynamic cast.  See issue B-8.

  6) Identify what remains to deal with C-5 and C-6 (calling
     constructors and destructors).

  7) I think we're ready to close D-5 through D-7 based on the
     exception discussions so far.  Please take a look and be
     prepared to raise any issues that concern you.

  8) If possible, let's discuss the varargs routine interface,
     as there's a possible C ABI issue there (G-5).

That should keep us occupied...

-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
A non-text attachment was scrubbed...
Name: status.tar.gz
Type: application/x-gzip
Size: 69715 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991006/269482b3/attachment.bin>

From dehnert at sgi.com  Thu Oct  7 02:31:26 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 06 Oct 1999 19:31:26 -0700
Subject: And the vtable example PDF
Message-ID: <37FC05FE.1972B8F9@sgi.com>

I don't remember whether I already sent the landscape form of this.
(It was probably black if I did.)  Here's another try, anyway...
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-vtable-ex.pdf
Type: application/pdf
Size: 37945 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991006/e37d0927/attachment.pdf>

From dehnert at sgi.com  Thu Oct  7 02:30:04 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 06 Oct 1999 19:30:04 -0700
Subject: PDF for status pages
Message-ID: <37FC05AC.26E8B1BE@sgi.com>

One file this time.  Please let me know if the color map problem is gone...
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.pdf
Type: application/pdf
Size: 320484 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991006/4a5e4b69/attachment.pdf>

From thomson at ca.ibm.com  Thu Oct  7 11:37:07 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Thu, 7 Oct 1999 07:37:07 -0400
Subject: COM compatibility
Message-ID: <85256803.003FD36B.00@D51MTA06.pok.ibm.com>

I won't be in the call today and Mark will be a little late,
so I will make my point this morning via email.

A while ago Jason was worried about COM compatibility.
Part of that is to ensure that vtables can be expressed in C.
But the resolution of issue B-4 says that a vtable contains
function descriptors rather than function descriptor pointers.

>From the standpoint of call performance that is a good thing,
but the result can't be built in C.  I know that we at least
will also have to rewrite parts of our C++ runtime that hand-build vtables.
Neither of these are critical for IBM but may be for others.


Brian Thomson
VisualAge C/C++ Chief Architect





From jds at sco.com  Thu Oct  7 13:47:23 1999
From: jds at sco.com (Silverstein  J.)
Date: Thu, 7 Oct 1999 09:47:23 -0400
Subject: comments on recent proposals
Message-ID: <19991007094723.A20037@sco.com>

Here are some comments from SCO on the recent section indices
and COMDAT proposals from an object file/linking point of view.

Section indices:

We are okay with the suggested approach of using a parallel
section of symbol table indices, except that we would
prefer the names SHT_SYMTAB_SHNDX and .symtab_shndx to
SHT_SYMTAB_IDX and .symtab_idx.  Just seems to say more
clearly what they are for.

We are a bit uncomfortable with the notion of a variable
sized ELF header.  A different approach
to this problem was proposed to the Intel TIS group
(Tool Interface Standards) back in March of 1995.
In that approach, you indicated that there were lots of
sections by putting a 1 in the e_shnum field of the ELF
header.   The first section header entry in an ELF file
always contains all zeros.  If the e_shnum field is 1,
then the sh_size field of the first entry would contain
the real number of sections.  Although this is not in
the TIS proposal, we could pick another field, say
sh_addralign, to contain the index of the section
header string table section.  This approach requires 
reading the section header table in 2 pieces for programs 
with more than the maxinum number of section header table entries,
but it keeps the ELF header a fixed size.

COMDAT:

We have 3 main concerns here.  First, the use of
a symbol table entry for the name of the COMDAT group
section and the requirement that if the same symbol is
defined in a non-COMDAT section, then all COMDAT groups
of that name are tossed.  This would cause, at least for our
linker, great complications in processing.  It would
mean you would need to read all the object files,
processing their symbol tables and saving COMDAT sections
on a list for later use.  Then you would need
to go back and decide which COMDAT groups to keep
and which to toss, undoing some of the things you
did to the symbol table in the process.  It may
also be difficult to keep sections in input order
with this approach.  In the HP approach, where the
name of the COMDAT group section was what you used for
comparison and you simply kept the first group with a 
given name, you could make decisions on which sections
and which symbols to toss as you were reading the input
files, making implementing COMDAT very simple for the linker.

We are also concerned with the assumption that seems to
be built into this approach (and HP's) that a relocatable
file can contain multiple sections with the same name
and attributes.  This may be simple to accomplish in
a compiler that goes right to object code, but it is more
difficult when you are generating assembly code: how
does an assembly file distinguish between the 10 sections
in this object named .text?  I guess there are ways, but
they seem awkward.  We would rather an approach where
COMDAT sections would be uniquely named within a relocatable,
and the individual sections had some way of specifying which
output section they should be merged with.  The Watcom
COMDAT proposal to TIS used the sh_link field of a COMDAT
section for this purpose.  If .foobar is an SHF_COMDAT section
and its sh_link field points to .text, then you merge .foobar
into the .text section on output.

Finally, we have real concerns about how DWARF2 interacts with
COMDAT.  We haven't worked our way through all the issues,
but at least 2 things stand out.  We assume the intention is 
that each COMDAT group would contain its own .debug_info 
and .debug_line sections?  It seems as if these sections
have to be either compilation unit entries in their own
rights, or pieces of compilation unit entries that can
be pasted together by the linker.  In the first case,
it seems that you would have to duplicate all of the DWARF
type information for the dot-o in each of the COMDAT
debug_info sections, since the type information is put
together with references that are relative to the beginning
of their containing compilation unit entry.  In the second
case you have the problem of the compilation unit header.
This header contains the length of the debugging information
entries for the entire compilation unit.  It is not clear
to us how to generate this length when you are pasting
together individual pieces of a single compilation unit record.

Has anyone had any experience in working through the interactions
of COMDAT with DWARF2?
-- 
Joel Silverstein and Dave Prosser
SCO Development Systems
jds at sco.com and dfp at sco.com



From brender at gemevn.zko.dec.com  Thu Oct  7 14:03:02 1999
From: brender at gemevn.zko.dec.com (Ron 603-884-2088)
Date: Thu, 7 Oct 1999 10:03:02 -0400
Subject: More regarding the ELF COMDAT proposal
Message-ID: <99100710030221@gemevn.zko.dec.com>


Ron, tomorrow they're going to talk about the linker support on IA64
for comdats.  They want to comdat vtables, which is a big lose unless
you comdat the virtual functions that are inlined and are referenced
by the vtables.  That's what we found on VMS, so we're changing it
back to the "trigger" method.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From brender at gemevn.zko.dec.com  Thu Oct  7 14:00:58 1999
From: brender at gemevn.zko.dec.com (Ron 603-884-2088)
Date: Thu, 7 Oct 1999 10:00:58 -0400
Subject: Regarding the ELF COMDAT proposal
Message-ID: <99100710005852@gemevn.zko.dec.com>

Following are comments from our local object file/linker person...

Ron

================================================================================

Ron, I've looked the proposal over.  What they're doing looks clean and
reasonable.  I have some comments regarding the three questions raised
at the end of the spec:


Do we want flags to specify checking prior to removal of duplicates,
e.g. for identical sections, same defined global symbols, etc.? If so,
should there be one flags word per section index, instead of per group? 
(We don't see a need, but this was suggested in other proposals.) 

    For the purpose of eliminating duplicate C++ definitions, the
    proposal is OK as it stands.  However, it has been the experience
    of Microsoft, in their PECOFF inplementation of COMDATs, that they
    are useful for other purposes.  For example, they perform a link-
    time optimization called "transitive COMDAT elimination" (TCE) that
    removes COMDAT groups not referenced (via relocations) from outside
    the group.  A single object file might implement a library of
    related routines, only one or two of which are actually used by the
    executable.  Space savings can be considerable if these routines are
    discarded.  In PECOFF, the compiler puts each routine in its own
    COMDAT group, and, when the linker does the TCE optimization, it
    builds a transitive reference graph (i.e., the executable references
    all non-COMDAT sections; section X references section Y (or Y's
    COMDAT group) if it has relocations for symbols in section Y).  The
    linker then excludes any COMDAT groups not in the graph.

    The proposal as it stands is insufficient to implement TCE.  Suppose
    we have an ordinary global routine named foo().  Were we to try to
    implement TCE, the compiler would generate a COMDAT group for foo()
    containing its .text and .data sections and associated sections for
    relocations and whatnot.  Now suppose that there is a second object
    file participating in the link that also implements foo().  Because
    both foo()s are COMDATs, under the proposal as it stands, the linker
    would discard one of them without raising the expected "multiple
    definition" error.  Microsoft's PECOFF solves this problem by
    implmenting a "COMDAT selection criterion" attribute associated
    with each COMDAT group.  For C++-style member function COMDAT
    matching, it uses the "select any" attribute (the linker is free to
    choose any one of the matching COMDAT groups).  For implementing TCE
    for the "hard" global definition case, PECOFF has a "no duplicates"
    attribute, which means that it is an error if a matching COMDAT
    group is found.

    I therefore propose that a flag be defined in the sh_flags field of
    a COMDAT group section header:

    SHF_COMDAT_SELECT_NODUPLICATES

    If set:  The linker issues a "multiply-defined symbol" error if
    either multiple COMDAT groups have the same identifier, or if a
    symbol matching the COMDAT group's identifier is defined in a non-
    COMDAT section in some object.

    If clear:  If multiple COMDAT groups in different object files are
    identified by symbols with the same name, the linker should remove
    all but one of the groups. If the identifying symbol is defined in
    a non-COMDAT section in some object, the linker should remove all
    of the COMDAT groups identified by that symbol. 


    Regarding the second part of the question (flags word per section
    vs. per group):  I think that per-group is sufficient.         


Do we want more control over when global symbols are removed vs. being
converted to UNDEF? Alternatively, should we simply require
that all symbols defined as addresses in the group be removed, and that
references to them from outside do so via distinct UNDEF global
symbols? 

    I think it's cleaner to have all references from outside the group
    be done via distinct UNDEF global symbols.  The only drawback to
    using distinct UNDEF globals is an increase in the size of the
    symbol table.

Do we want to replace the symbol rule by simply requiring that any
symbols defined as addresses in the group be defined in a .symtab
section that is itself in the group?

    Again, this is a cleaner way of doing things.  My big concern is
    that it would potentially mean a lot of .symtab sections, and ELF32
    currently has an architectural restriction of only 65535 sections
    per object file (due to e_shnum being a Elf32_Half).  Some ELF
    implementations are already running into this limit, even without
    the additional sections that will be created due to COMDATs.

--PSW



From ddd at cup.hp.com  Thu Oct  7 16:30:11 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 7 Oct 1999 09:30:11 -0700
Subject: COM compatibility
Message-ID: <199910071630.JAA17537@cllmail.cup.hp.com>

> A while ago Jason was worried about COM compatibility.
> Part of that is to ensure that vtables can be expressed in C.
> But the resolution of issue B-4 says that a vtable contains
> function descriptors rather than function descriptor pointers.

Did we resolve that issue that way? I was quite convinced we had  
finally decided for "every pointer is a C-style pointer" precisely  
because of this kind of problems. Mmmh, I'd better check today with  
the rest of the team. Are there other cases where we have a function  
pointer that is not a C-style function pointer?


Christophe



From dehnert at sgi.com  Thu Oct  7 22:20:02 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 07 Oct 1999 15:20:02 -0700
Subject: COM compatibility
References: <199910071630.JAA17537@cllmail.cup.hp.com>
Message-ID: <37FD1C92.A9607444@sgi.com>

Christophe de Dinechin wrote:
> 
> > A while ago Jason was worried about COM compatibility.
> > Part of that is to ensure that vtables can be expressed in C.
> > But the resolution of issue B-4 says that a vtable contains
> > function descriptors rather than function descriptor pointers.
> 
> Did we resolve that issue that way? I was quite convinced we had
> finally decided for "every pointer is a C-style pointer" precisely
> because of this kind of problems. Mmmh, I'd better check today with
> the rest of the team. Are there other cases where we have a function
> pointer that is not a C-style function pointer?
> 
> Christophe

I thought we had resolved it as:  If C uses function descriptors (i.e.
address/GP pairs), and C pointers point to them, we would put a function
descriptor in the Vtable; but if the C ABI were changed to not use
descriptors, we would put a simple pointer there.

(Since I think the latter is unlikely at this time, I tend to interpret
this as using descriptors.  I do think the savings of an indirection is
likely significant enough to make inability to directly express them in
C a worthwhile tradeoff.)



From dehnert at baalbek.engr.sgi.com  Thu Oct  7 23:06:36 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 7 Oct 1999 16:06:36 -0700 (PDT)
Subject: Invitation: Dwarf2
Message-ID: <199910072306.QAA72350@baalbek.engr.sgi.com>

Various efforts, many of them for IA-64, are raising questions about Dwarf.
While some are IA-64-specific, most are more general, and it seems
appropriate to revive a committee to deal with them.

I have sent this to the participants in the C and C++ ABI committees
for IA-64, along with a few other interested parties.  Please forward
it to the relevant people (if any) in your organization (or elsewhere),
and have the interested people send me name, email, phone, and FAX --
I'll construct a list.  (Please don't assume you're on it until you
let me know you're interested.)  After next week, I'll construct an
alias and we can use that instead.

I suggest that we construct an initial list of issues and participants,
and begin meeting in 2-3 weeks.  We can volunteer a location (more or
less central to Silicon Valley participants) and a call-in phone number
for remote participants.  I'll set this up, but as debugging isn't really
central to my activities, I'll be looking for a volunteer to drive
it.  Let me know if you want to (or just can) take this on...

Some of the issues I'm aware of are:

General:

  * C++ has a need to be able to remove duplicate copies of objects
    (functions, virtual tables, ...) at link time, and it is desirable
    to remove the associated Dwarf information along with them.  Define
    an approach for decomposing the Dwarf information in a relocatable
    object file so this can be achieved by just removing some sections.

  * The original Dwarf specification assumed 32-bit programs, and there
    is some disagreement about the appropriate extension to 64-bit data
    models.

  * Fortran-9x support.


IA-64:

  * Register bindings.

  * The IA-64 ABI defines stack traceback descriptors for such purposes
    as exception handling which (largely? entirely?) duplicate the
    .debug_frame info.  Can/should we just bind to it instead of
    duplicating the information in .debug_frame?

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From Bevin.Brett at Compaq.com  Fri Oct  8 12:27:59 1999
From: Bevin.Brett at Compaq.com (Brett, Bevin)
Date: Fri, 8 Oct 1999 07:27:59 -0500 
Subject: Invitation: Dwarf2
Message-ID: <21ECC6E090DCD21180D20000F809A18B02C3CE@exctay-02.tay.dec.com>

I am the contact for Compaq for Dwarf2, and have been tasked by my mgmt with
being very involved in getting the spec being actively maintained by a
committee again.

/Bevin

-----Original Message-----
From: dehnert at baalbek.engr.sgi.com [mailto:dehnert at baalbek.engr.sgi.com]
Sent: Thursday, October 07, 1999 7:07 PM
To: georgep at baalbek.engr.sgi.com; Brett, Bevin; rth at cygnus.com;
davea at cthulhu.engr.sgi.com; beshers at boston.sgi.com;
cxx-abi at baalbek.engr.sgi.com; ia64abi at baalbek.engr.sgi.com
Subject: Invitation: Dwarf2


Various efforts, many of them for IA-64, are raising questions about Dwarf.
While some are IA-64-specific, most are more general, and it seems
appropriate to revive a committee to deal with them.

I have sent this to the participants in the C and C++ ABI committees
for IA-64, along with a few other interested parties.  Please forward
it to the relevant people (if any) in your organization (or elsewhere),
and have the interested people send me name, email, phone, and FAX --
I'll construct a list.  (Please don't assume you're on it until you
let me know you're interested.)  After next week, I'll construct an
alias and we can use that instead.

I suggest that we construct an initial list of issues and participants,
and begin meeting in 2-3 weeks.  We can volunteer a location (more or
less central to Silicon Valley participants) and a call-in phone number
for remote participants.  I'll set this up, but as debugging isn't really
central to my activities, I'll be looking for a volunteer to drive
it.  Let me know if you want to (or just can) take this on...

Some of the issues I'm aware of are:

General:

  * C++ has a need to be able to remove duplicate copies of objects
    (functions, virtual tables, ...) at link time, and it is desirable
    to remove the associated Dwarf information along with them.  Define
    an approach for decomposing the Dwarf information in a relocatable
    object file so this can be achieved by just removing some sections.

  * The original Dwarf specification assumed 32-bit programs, and there
    is some disagreement about the appropriate extension to 64-bit data
    models.

  * Fortran-9x support.


IA-64:

  * Register bindings.

  * The IA-64 ABI defines stack traceback descriptors for such purposes
    as exception handling which (largely? entirely?) duplicate the
    .debug_frame info.  Can/should we just bind to it instead of
    duplicating the information in .debug_frame?

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at sgi.com  Wed Oct 13 01:01:20 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 12 Oct 1999 18:01:20 -0700
Subject: Meeting Thursday and Status -- 12 Oct 99
Message-ID: <3803D9E0.E434C3FF@sgi.com>

Attached is the gzipped tar file of the status pages.  PDF to follow.
I won't be at the meeting, but Matt and/or John will lead it.

Question for next week:  for those of you using the PDF version,
is anyone averse to getting the pages all zipped in onefile?  If it
works for everyone, I can cut down the message size...

Following is an updated agenda, based on last week's:
 
  1) The COMDAT/section index proposals are updated in issue B-5.
     Please identify whatever needs changing (or is an issue) --
     I'll submit it in whatever form to the base ABI group early
     next week, though we can modify the proposal even after that.
 
  2) RTTI descriptors.  See open issue A-6, and Daveed's cleaned
     up description in the ABI data layout document.
 
  3) The updated vtable layout proposal from Jason.  See open issue
     B-6, and Jason's cleaned up description in the ABI data layout
     document.
 
  4) Based on (3), can we produce a clean description of a virtual
     function call?  If not, what's still missing?  See issue B-1.

  5) Same question for dynamic cast.  See issue B-8.

  6) Identify what remains to deal with C-5 and C-6 (calling
     constructors and destructors).

  7) If possible, let's discuss the varargs routine interface,
     as there's a possible C ABI issue there (G-5).  Think about
     whether there's any chance of changing the C ABI version of
     this at this point...

That should keep you occupied...

-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.tar.gz
Type: application/x-gzip
Size: 82628 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991012/2764be52/attachment.bin>

From dehnert at sgi.com  Wed Oct 13 01:09:58 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 12 Oct 1999 18:09:58 -0700
Subject: C++ ABI status -- PDF files
Message-ID: <3803DBE6.265BAFA9@sgi.com>

Should I zip these next week to cut down on size?
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-summary.pdf
Type: application/pdf
Size: 42665 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991012/961dff4c/attachment.pdf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-open.pdf
Type: application/pdf
Size: 161961 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991012/961dff4c/attachment-0001.pdf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-closed.pdf
Type: application/pdf
Size: 49057 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991012/961dff4c/attachment-0002.pdf>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: abi-layout.pdf
Type: application/pdf
Size: 36557 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991012/961dff4c/attachment-0003.pdf>

From coleen at zko.dec.com  Wed Oct 13 17:59:01 1999
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Wed, 13 Oct 1999 13:59:01 -0400
Subject: is_floating - RTTI specification.
Message-ID: <3804C865.CBDE9D10@zko.dec.com>


In Daveeds RTTI paper, the defn of base class info is:

   struct std::__base_class_info {
    std::type_info *type; /* Null if unused. */
    std::ptrdiff_t offset;
    int is_direct: 1;
    int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
    int is_virtual: 1; /* Implies is_floating. */
    int is_shared: 1; /* Implies is_floating and the virtual subobject
                                 appears on multiple derivation paths. */
    int is_accessible: 1;
    int is_ambiguous: 1;
    };

What is is_floating vs. is_virtual?  This is the second reference I've
seen to "floating" base classes.  Can someone point to the description of
these?

Also, I take it that "offset" is the offset in the vtable if the base
class is virtual, rather than real offset into the object?

Thanks,
Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From daveed at edg.com  Wed Oct 13 18:26:02 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 13 Oct 1999 11:26:02 -0700
Subject: is_floating - RTTI specification.
References: <3804C865.CBDE9D10@zko.dec.com>
Message-ID: <3804CEBA.CD6155CE@edg.com>

Coleen Phillimore wrote:
> 
> In Daveeds RTTI paper, the defn of base class info is:
> 
>    struct std::__base_class_info {
>     std::type_info *type; /* Null if unused. */
>     std::ptrdiff_t offset;
>     int is_direct: 1;
>     int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
>     int is_virtual: 1; /* Implies is_floating. */
>     int is_shared: 1; /* Implies is_floating and the virtual subobject
>                                  appears on multiple derivation paths. */
>     int is_accessible: 1;
>     int is_ambiguous: 1;
>     };
> 
> What is is_floating vs. is_virtual? 

An example makes it clearer:

	struct B {};
	struct V: B {};
	struct D: virtual V {};

The base V is a virtual base of D and therefore its location with respect to
the origin of a D object may "float".  The subbase B is not virtual, but
because it is part of a virtual base subobject, it still has that "floating"
attribute.

> This is the second reference I've
> seen to "floating" base classes.  Can someone point to the description of
> these?
> 
> Also, I take it that "offset" is the offset in the vtable if the base
> class is virtual, rather than real offset into the object?

That was not what I had in mind, but it would also work.  Do you see an
advantage to that approach?

	Daveed



From coleen at zko.dec.com  Wed Oct 13 18:56:49 1999
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Wed, 13 Oct 1999 14:56:49 -0400
Subject: is_floating - RTTI specification.
References: <3804C865.CBDE9D10@zko.dec.com> <3804CEBA.CD6155CE@edg.com>
Message-ID: <3804D5F1.B595D348@zko.dec.com>

Daveed Vandevoorde wrote:
> 
> Coleen Phillimore wrote:
> >
> > In Daveeds RTTI paper, the defn of base class info is:
> >
> >    struct std::__base_class_info {
> >     std::type_info *type; /* Null if unused. */
> >     std::ptrdiff_t offset;
> >     int is_direct: 1;
> >     int is_floating: 1; /* I.e., virtual or base of virtual subobject. */
> >     int is_virtual: 1; /* Implies is_floating. */
> >     int is_shared: 1; /* Implies is_floating and the virtual subobject
> >                                  appears on multiple derivation paths. */
> >     int is_accessible: 1;
> >     int is_ambiguous: 1;
> >     };
> >
> > What is is_floating vs. is_virtual?
> 
> An example makes it clearer:
> 
>         struct B {};
>         struct V: B {};
>         struct D: virtual V {};
> 
> The base V is a virtual base of D and therefore its location with respect to
> the origin of a D object may "float".  The subbase B is not virtual, but
> because it is part of a virtual base subobject, it still has that "floating"
> attribute.

Oh, terminology skew.  I suppose "float"'s as good as any word to put it.

> 
> > This is the second reference I've
> > seen to "floating" base classes.  Can someone point to the description of
> > these?
> >
> > Also, I take it that "offset" is the offset in the vtable if the base
> > class is virtual, rather than real offset into the object?
> 
> That was not what I had in mind, but it would also work.  Do you see an
> advantage to that approach?
> 
>         Daveed

Well, it depends on if you're representing both indirect and direct base
classes in the RTTI.  If you're representing both, there's no advantage.
But if you're representing only direct and then using the RTTI for the direct
base classes to get to indirect classes, you can't put absolute offsets
to "floating"/virtual subobjects, 'cause they, uh, well, float.  The latter
is how our EDG compiler works today.  Only representing direct base clases
saves space, but costs time in dynamic cast and exception handling.

Also, the DEC object model has virtual base class tables today with
offsets to virtual base classes (like Microsoft) and instead of
putting the btable offsets in the RTTI, we put "thunks" to do the
conversions to virtual base classes.  With the vptr first in the object, 
we can probably just use the vtable(btable part) index as the offset, I think.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From jason at cygnus.com  Wed Oct 13 19:41:22 1999
From: jason at cygnus.com (Jason Merrill)
Date: 13 Oct 1999 12:41:22 -0700
Subject: is_floating - RTTI specification.
In-Reply-To: Coleen Phillimore's message of "Wed, 13 Oct 1999 14:56:49 -0400"
References: <3804C865.CBDE9D10@zko.dec.com> <3804CEBA.CD6155CE@edg.com> <3804D5F1.B595D348@zko.dec.com>
Message-ID: <u9u2nvnj4t.fsf@yorick.cygnus.com>

>>>>> Coleen Phillimore <coleen at zko.dec.com> writes:

 > Well, it depends on if you're representing both indirect and direct base
 > classes in the RTTI.  If you're representing both, there's no advantage.
 > But if you're representing only direct and then using the RTTI for the
 > direct base classes to get to indirect classes, you can't put absolute
 > offsets to "floating"/virtual subobjects, 'cause they, uh, well, float.
 > The latter is how our EDG compiler works today.  Only representing
 > direct base clases saves space, but costs time in dynamic cast and
 > exception handling.

I feel pretty strongly that we should only represent direct base classes.
We want to minimize the impact of RTTI and EH on code that doesn't use it;
making throws and dynamic_cast a bit slower doesn't seem like a problem to
me.

Jason



From austern at isolde.engr.sgi.com  Sat Oct 16 00:53:21 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Fri, 15 Oct 1999 17:53:21 -0700
Subject: Notes from the 14 October IA-64 C++ ABI meeting
Message-ID: <9910151753.ZM205799@isolde.engr.sgi.com>

                              ISSUE B-5

Discussion: Jason suggests changing the name from SHT_COMDAT_GROUP to
SHT_GROUP.  The motivation is that these really aren't COMDAT sections
unless the SHF_COMDAT flag is set.  It's a grouping proposal, so the
name ought to have no connotations other than grouping.

There is a mild consensus in favor of this change, which is minor but
pervasive.  Nobody was opposed to it.  There is a consensus that we
recommend this change to the base ABI committee, but that we accept
whichever name they choose to adopt.

ACTION ITEM: Jim---push the proposal over to the base ABI committee,
telling them about our naming preference.  This issue is tabled, but
not closed.  We will revisit it after the base ABI committee acts.


                              ISSUE A-6

Discussion:

(1) Do we keep pointers to direct bases only, or to indirect bases as
well.  It is believed that keeping pointers to indirect bases speeds
up dynamic_cast by a constant factor, but at the cost of extra space
even when dynamic_cast is never used.  There is a general preference
for keeping direct bases only.

(2) The current proposal has a flag to differentiate single
inheritance from multiple inheritance case.  Jason suggests instead
splitting the two cases into two separate classes, and there was
general agreement that this is a good idea.

(3) The current proposal has separate classes for various kinds of
non-class types.  Jason suggests merging all non-class types into a
single class.  Nobody had strong feelings, or strong arguments either
for or against this change.  In the absence of a consensus in favor of
this change, we'll keep the proposal as is.

(4) Minor changes: there's a typo in the pointer to member part, which
Daveed will fix.  Jason suggests flipping the sign on the offset, and
nobody objected.

ACTION ITEMS: Daveed---make these changes.  Jim---incorporate these
changes into the open issues list.  We are almost ready to close this
issue; we intend to close it at the 28 October meeting, after we've
all had a change to go over the modified writeup.


                              ISSUE B-6

Discussion:

(1) Do we promote base offsets out of base class vtables?  Answer: we
promote them out of virtual bases, but we do not promote them out of
nonvirtual bases.  It's a time/space tradeoff.  The time saving is
large for virtual bases, but to small to bother with for nonvirtual
bases.

(2) Do we have rtti fields for classes that have virtual bases but no
virtual functions?  The C++ standard regards such classes as
nonpolymorphic, so performing rtti operations on them is undefined.
Decision: we will keep the rtti fields themselves in the vtable, in
the interest of having a uniform vtable format.  The slot of offset to
beginning of complete type will be filled in, and the slot for offset
to typeinfo object will contain 0.

(3) When we discussed issue B-8, we agreed that we would have an
offset to typeinfo object rather than a pointer to typeinfo object.
This means that the typeinfo object is now part of the vtable.  It
will go at the very beginning, i.e. at a negative offset from where
the vtpr points.  (Comment: We discussed B-6 before discussing B-8.
Does making this change interfere with having a uniform vtable offset,
since we won't have a typeinfo object at the beginning of a vtable
for a nonpolymorphic class with virtual bases?  Should we revisit
decision (2) or (3), or am I just being paranoid?)

ACTION ITEMS: Jason---update writeup to reflect these three changes.
Our decision on issue B-8 will require a one-sentence change.  All of
us: study the revised version.  We are almost ready to close this
issue, and if we agree with the revised version we can close it at the
21 October meeting.  (Yes, I really do mean the meeting when most of
us will be in Hawaii.)


                              ISSUE B-8

Discussion: This is closely related to issues A-6 and B-6.  It is
agreed that what we need is an offset to the beginning of the complete
object, and a pointer or offset to the typeinfo object.  We choose to
have an offset to the typeinfo object instead of a pointer, which
effectively means that the typeinfo object is part of the vtable.  We
will put it at the very beginning, at a negative offset from the vptr.

ACTION ITEMS: See B-6.

This issue is now closed.


                              ISSUE G-5

Discussion: We would want to reject option (3), even if it were still
possible to change the base ABI.  The present scheme is compatible
with K&R C methods, the proposed change would not be.

Decision: Close with no action.  We're using multiple entry points for
covariant return types, not thunks, so there's no need for doing
anything different for varargs functions with covariant return types
than for any other varargs functions.


                          ISSUES C-6 and C-6

Discussion: One solution to the problem with destructors is to have
two destructor entry points, and two destructor slots in the vtable.
One entry point destroys the object and then calls operator delete,
the other destroys the object without calling operator delete.  We can
use a similar solution for constructors (but without any impact on the
vtable layout): one entry point for constructing a complete object,
another for constructing a subobject.

Note that one of the entry points may call the other, but that's not
an ABI issue and can be left to individual implementors.

There was general agreement that this is a promising idea.  We don't
have a detailed proposal yet.  HP is working on a prototype
implementation.

Action item: Christophe---submit a writeup.



From daveed at edg.com  Mon Oct 18 18:05:14 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 18 Oct 1999 11:05:14 -0700
Subject: Updated RTTI description
References: <9910151753.ZM205799@isolde.engr.sgi.com> <380B6117.6D5E154B@edg.com>
Message-ID: <380B615A.73580D03@edg.com>

(oops, forgot to add the attachment in the previous message.)

Hi all,

Attached it the updated document.  I believe it reflects all the
decisions made at the meeting last Thursday, but the decision to
split the std::__class_type_info could be implemented in various
ways.  Please check that what I have done is agreeable to you.

All other comments and corrections are also welcome,

        Daveed
-------------- next part --------------
Run-time type information
=========================

The C++ programming language definition implies that information about types
be available at run time for three distinct purposes:
   (a) to support the typeid operator,
   (b) to match an exception handler with a thrown object, and
   (c) to implement the dynamic_cast operator.
(c) only requires type information about polymorphic class types, but (a) and
(b) may apply to other types as well; for example, when a pointer to an int is
thrown, it can be caught by a handler that catches "int const*".


Deliberations
-------------
The following conclusions were arrived at by the attending members of the
C++ IA-64 ABI group:

. The exact layout for type_info objects is dependent on whether a 32-bit
  or 64-bit model is supported.
. Advantage should be taken of COMDAT sections and symbol preemption: two
  type_info pointers point to equivalent types if and only if the pointers
  are equal.
. A simple dynamic_cast algorithm that is efficient in the common case of
  base-to-most-derived cast case is preferrable over more sophisticated ideas
  that handle deep-base-to-in-between-derived casts more efficiently at a
  slight cost to the common case.  Hence, the original scheme of providing
  a hash-table into the list of base classes (as is done e.g. in the HP aC++
  compiler) has been dropped.
. The GNU egcs development team has implemented an idea of this ABI group to
  accelerate dynamic_cast operations by a-posteriori checking a "likely
  outcome".  The interface of std::__dynamic_cast therefore keeps the
  src2dst_offset hint.
. std::__extended_type_info is dropped.
. It was decided to only keep direct base information about a class type.
  Indirect base information can be found by chasing type_info pointers
  (and care should be taken to determine ambiguous base class types).
. Different class types are introduced for class that (a) have no bases,
  (b) use only single inheritance, and (c) use multiple inheritance.
. The typeinfo structure for a class type with associated virtual tables is
  emitted as part of the set of virtual tables.  It precedes the tables proper
  (not explicitly decided, but assumed: it also precedes auxiliary tables for
  locating construction vtables).


Place of emission
-----------------
It is probably desirable to minimize the number of places where a particular
bit of RTTI is emitted.  For polymorphic types, a similar problem occurs for
virtual function tables, and hence the information can be appended at the end
of the primary vtable for that type.  For other types, they must presumably be
emitted at the location where their use is implied: the object file containing
the typeid, throw or catch.

Basic type information (such as for "int", "bool", etc.) can be kept in the
run-time support library.  Specifically, this proposal is to place in the
run-time support library type_info objects for the following types:
	void*, void const*
and
	X, X* and X const*
for every X in: bool, wchar_t, char, unsigned char, signed char, short,
unsigned short, int, unsigned int, long, unsigned long, long long, unsigned
long long, float, double, long double.  (Note that various other type_info
objects for class types may reside in the run-time support library by virtue
of the preceding rules; e.g., that of std::bad_alloc.)


The typeid operator
-------------------
The typeid operator produces a reference to a std::type_info structure with
the following public interface:

	struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };

Assuming that after linking and loading only one type_info structure is active
for any particular type symbol, the equality and inequality operators can be
written as address comparisons: to type_info structures describe the same type
if and only if they are the same structure (at the same address).  In a flat
address space (such as that of the IA-64 architecture), the before() member is
also easily written in terms of an address comparison.  The only additional
piece of information that is required is the NTBS that encodes the name.  The
type_info structure itself can hold a pointer into a read-only segment that
contains the text bytes.


Matching throw expressions with handlers
----------------------------------------
When an object is thrown a copy is made of it and the type of that copy is TT.
A handler that catches type HT will match that throw if:
  . HT is equal to TT except that HT may be a reference and that HT may have
    top-level cv qualifiers (i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  . HT is a reference to a public and unambiguous base type of TT; or
  . HT has a pointer type to which TT can be converted by a standard pointer
    conversion (though only public, unambiguous derived-to-base conversions
    are permitted) and/or a qualification conversion.
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const and
volatile qualifications applied to types underlying pointers.


The dynamic_cast operator
-------------------------
Although dynamic_cast can work on pointers and references, from the point of
view of representation we need only to worry about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time and do
not need any RTTI.  There are then three kinds of truly dynamic cast
operations:
  . dynamic_cast<void cv*>, which returns a pointer to the complete lvalue,
  . dynamic_cast operation from a base class to a derived class, and
  . dynamic_cast across the hierarchy which can be seen as a cast to the
    complete lvalue and back to a sibling base.
The most common kind of dynamic_cast is base-to-derived in a singly inherited
hierarchy.


RTTI layout
-----------

0. The RTTI layout for a given type depends on whether a 32-bit or 64-bit
mode is in effect.

1. Every vtable shall contain one entry describing the offset from a vptr
for that vtable to the origin of the object containing that vptr (or
equivalently: to the vptr for the primary vtable).  This entry is directly
useful to implement dynamic_cast<void cv*>, but is also needed for the other
truly dynamic casts.  This entry is located two words ahead of the location
pointed to by the vptr (i.e., entry "-2").  This entry is also present in
vtables for classes having virtual bases, but no virtual functions.

2. Every vtable shall contain one entry pointing to an object derived from
std::type_info.  This entry is located at the word preceding the location
pointed to by the vptr (i.e., entry "-1").  The entry is also allocated in
vtables for classes having virtual bases, but no virtual functions; however,
in those cases, the entry is zero.  This entry is coded as an offset with
respect to the virtual table origin, rather than as a pointer (thereby saving
the need for more run-time relocations).

std::type_info contains just two pointers:
  . its vptr
  . a pointer to a NTBS representing the name of the type

The possible derived types are:
  . std::__fundamental_type_info
  . std::__pointer_type_info
  . std::__reference_type_info
  . std::__array_type_info
  . std::__function_type_info
  . std::__enum_type_info
  . std::__class_type_info
  . std::__si_class_type_info
  . std::__vmi_class_type_info
  . std::__ptr_to_member_type_info

3. std::__fundamental_type_info adds no fields to std::type_info.

4. std::__pointer_type_info adds two fields (in that order):
  . a word describing the cv-qualification of what is pointed to
    (e.g., "int volatile*" should have the "volatile" bit set in that word).
  . a pointer to the std::type_info derivation for the unqualified type
    being pointed to
Note that the first bits should not be folded into the pointer because we may
eventually need more qualifier bits (e.g. for "restrict").  The bit 0x1
encodes the "const" qualifier; the bit 0x2 encodes "volatile".

5. std::__reference_type_info is similar to std::__pointer_type_info but
describes references.

6. std::__array_type_info and std::__function_type_info do not add fields to
   std::type_info (these types are only produced by the typeid operator;
   they decay in other contexts).  std::__enum_type_info does not add fields
   either.

7. Three different types are used to represent type information.

(a) std::__class_type_type is used for class types having no bases, and is
also a base type for the other two class type representations.  It derived from
std::type_info and adds one word with flags describing some details about the
class:
  . a word with flags describing some details about the class (most of these
    are for use by the derived classes):
      0x1: contains multiply inherited subobject
      0x2: is polymorphic
      0x4: has virtual bases
      0x8: has privately inherited base

(b) For classes containing only a single, nonvirtual inheritance hierarchy,
class std::__si_class_type_info is used.  It adds to std::__class_type_type
a single pointer to the type_info structure for the base type.

(c) For class containing (directly or indirectly) a multiple or virtual
inheritance component in their hierarchy, std::__vmi_class_type_info is used.
It is derived from std::__class_type_info, and adds:
  . a word with the number of direct base class descriptions that follow it
  . base class descriptions for every direct base; each description is of
    the type:
      struct std::__base_class_info {
         std::type_info *type;
         std::ptrdiff_t offset;
         int is_virtual: 1;
         int is_public: 1;
      };

8. The std::__ptr_to_member_type_info type adds three fields to
std::type_info:
  . a pointer to a std::__class_type_info (e.g., the "A" in "int A::*")
  . a_pointer to a std::type_info corresponding to the member type (e.g., the
    "int" in "int A::*")
  . a word describing the cv-qualification of what is pointed to
    (see std::__pointer_type_info)


std::type_info::name()
----------------------
The NTBS returned by this routine is the mangled name of the type.


The dynamic_cast algorithm
--------------------------
Dynamic casts to "void cv*" are inserted inline at compile time.  So are
dynamic casts of null pointers and dynamic casts that are really static.

This leaves the following test to be implemented in the run-time library for
truly dynamic casts of the form "dynamic_cast<T>(v)":
  (see [expr.dynamic_cast] 5.2.7/8)
  . If, in the most derived object pointed (referred) to by v, v points
    (refers) to a public base class sub-object of a T object [note: this can
    be checked at compile time], and if only one object of type T is derived
    from the sub-object pointed (referred) to by v, the result is a pointer
    (an lvalue referring) to that T object.
  . Otherwise, if v points (refers) to a public base class sub-object of the
    most derived object, and the type of the most derived object has an
    unambiguous public base class of type T, the result is a pointer (an
    lvalue referring) to the T sub-object of the most derived object. 
  . Otherwise, the run-time check fails.

The first check corresponds to a "base-to-derived cast" and the second to a
"cross cast".  These tests are implemented by std::__dynamic_cast.

   void* std::__dynamic_cast(void *sub, std::__class_type_info *src,
                                        std::__class_type_info *dst,
                                        std::ptrdiff_t obj2sub_offset);
   /* sub: source address to be adjusted; nonnull, and since the source
    *      object is polymoprhic, *(void**)sub is a vptr.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast<T>(v)").
    * obj2sub_offset: a static hint about the location of the source subobject
    *    with respect to the complete object; special negative values are:
    *       -1: no hint
    *       -2: src is not a public base of dst
    *       -3: src is a multiple public base type but never a virtual
    *           base type
    *       (note: more values may be used for the some virtual inheritance
    *              cases?)
    *    otherwise, the src type is a unique public nonvirtual base
    *    type of dst at offset obj2syb_offset from the origin of dst.
    */


The exception handler matching algorithm
----------------------------------------

Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document (beyond the layout of the
RTTI data).


From daveed at edg.com  Mon Oct 18 18:04:07 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 18 Oct 1999 11:04:07 -0700
Subject: Updated RTTI description
References: <9910151753.ZM205799@isolde.engr.sgi.com>
Message-ID: <380B6117.6D5E154B@edg.com>

Hi all,

Attached it the updated document.  I believe it reflects all the
decisions made at the meeting last Thursday, but the decision to
split the std::__class_type_info could be implemented in various
ways.  Please check that what I have done is agreeable to you.

All other comments and corrections are also welcome,

	Daveed



From daveed at edg.com  Mon Oct 18 18:12:51 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 18 Oct 1999 11:12:51 -0700
Subject: Name mangling
References: <9910151753.ZM205799@isolde.engr.sgi.com> <380B6117.6D5E154B@edg.com>
Message-ID: <380B6323.70CC5589@edg.com>

It's probably time to start working on this.

I think we'll first need to agree on what we want to mangle, and 
how much "optional info" we wish to have in mangled names (like 
return types).

To get the ball rolling, I've jotted down some notes collecting
"aspects of the problem"  (attached).

Please verify what items I might have left out.  If someone has
an authoritative answer as to which characters are allowed in
linkable names, please post them (or send them to me), and I'll 
add them to the document.

Opinions, fears, comments, insights and all those sorts of things
are eagerly sought ;-)

Cheers,

	Daveed
-------------- next part --------------
Name mangling
=============

Entities with linkable names
----------------------------
. functions and members functions (including operators)
. namespace scope variables and static data members
. virtual function tables
. any auxiliary tables used for installing construction vtables
. RTTI structures (std::type_info derivations)
. EH structures?

For entities with C name linkage, the entity's linkable name is identical to
its base name (as usual).


Decomposition of linkable names for function-like entities:
-----------------------------------------------------------
For function-like entities with C++ name linkage, the following components
MUST be part of the of the name:
  . an encoding of the base name (presumably, the base name itself)
  . an encoding of the declarative scope (classes and namespaces), when
    applicable
  . an encoding of each parameter type (with known positions)
  . an encoding of each template argument and the parameter it is associated
    with, when applicable

[ For the last item, consider:
    template<typename T1, typename T2> void f(T1, T2);
    template<typename T1, typename T2> void f(T2, T1);
  The encoding of each of these templates instantiated for <char, char> should
  be distinct. ]

In addition, it may be desirable to encode the following components:
  . the function's return type
  . the function's exception specifications
(Combined with the parameter types, this encodes the type of the function.
Note that even though exception specifications are not considered part of the
function type in the C++ standard; it actually is.)


Decomposition of linkable names for namespace scope variables and static
data members
------------
Such entities' linkable name must include at least:
  . an encoding of the base name (presumably, the base name itself)
  . an encoding of the declarative scope (classes and namespaces), when
    applicable

In addition, it may be desirable to encode the following components:
  . the variable's type (possibly including exception specifications)


General structure
-----------------


Available characters
--------------------
C++ identifiers consist of the following characters:
   'a'..'z'  'A'..'Z'  '0'..'9'  '_'
   Universal character codes: \u<hex-quad>, \U<hex-quad><hex-quad>

Overloadable C++ operators can contain the following additional characters:
   '['  ']'  '('  ')'  '<'  '>'  '%'  '*'  '+'  '-'  '/'
   '^'  '&'  '|'  '~'  '!'  '='  ','

All these should be encoded using the following characters acceptable in
linkable names:

   ???

subject to the following constraints:
  . encodings cannot collide with valid C names
  . ???


Special indicators (operators, tables, ...)
-------------------------------------------


Fundamental types and type operators
------------------------------------


Compression
-----------


From ddd at cup.hp.com  Mon Oct 18 22:33:06 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 18 Oct 1999 15:33:06 -0700
Subject: Name mangling
Message-ID: <199910182233.PAA09766@cllmail.cup.hp.com>

> Entities with linkable names
> ----------------------------
> .. functions and members functions (including operators)
> .. namespace scope variables and static data members
> .. virtual function tables
> .. any auxiliary tables used for installing construction vtables
> .. RTTI structures (std::type_info derivations)
> .. EH structures?
>
> For entities with C name linkage, the entity's linkable name is  
identical to
> its base name (as usual).
>
>

Entities with no linkable name, but which need to be referenced  
accross translation units (inlining, template instantiations):

1. String constants
2. Static local variables

Note that to enable a "compiler-driven" inlining, these need to be  
named inside any function, not only inline ones.


> Such entities' linkable name must include at least:
>   . an encoding of the base name (presumably, the base name itself) 
>   . an encoding of the declarative scope (classes and namespaces), when 
>     applicable

Note the special case of anonymous namespaces. We don't need to  
agree on the unique name generation, but it may be useful to agree on  
its structure.

>
> In addition, it may be desirable to encode the following components: 
>   . the variable's type (possibly including exception specifications) 

For variable size, we may have a problem with array sizes. What  
about linking:

foo.C:	extern int a[10];
bar.C:	int a[200000];

Problem: short data space. the declaration in foo.C may seem like a  
good 'short' candidate, whereas the definition is not.


Regards
Christophe



From daveed at edg.com  Mon Oct 18 22:47:30 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 18 Oct 1999 15:47:30 -0700
Subject: Name mangling
References: <199910182233.PAA09766@cllmail.cup.hp.com>
Message-ID: <380BA382.2C9B5B27@edg.com>

Thanks for your remarks Christophe.  I have integrated them in the
"document" (big word for a little file right now ;-).

I also added an item about identifier extensions.  I know that several
vendors have a mode that accepts '$' as part of a C/C++ identifier.  Are
there any other such extended characters that should go through unencoded
(i.e., we could encode them along the strategy we'll select for universal
character names, but I doubt that's what we want for '$' for example.)

	Daveed



From loewis at informatik.hu-berlin.de  Tue Oct 19 07:27:42 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 19 Oct 1999 09:27:42 +0200
Subject: Name mangling
In-Reply-To: <199910182233.PAA09766@cllmail.cup.hp.com> (message from
	Christophe de Dinechin on Mon, 18 Oct 1999 15:33:06 -0700)
References: <199910182233.PAA09766@cllmail.cup.hp.com>
Message-ID: <199910190727.JAA17130@pandora>

> Entities with no linkable name, but which need to be referenced  
> accross translation units (inlining, template instantiations):
> 
> 1. String constants
> 2. Static local variables
> 

I can see the usage of these being referenceable for
inlining. However, I don't think that such a feature is mandated by
the C++ standard, at least for string literals.

In particular, string literals may not appear as template parameters
(see http://www.informatik.hu-berlin.de/~loewis/corer8.html#100 for a
ready issue), and neither can static local variables
([temp.arg.nontype]/1).

The only case were the ABI needs to define something is static local
variables in inline functions:

inline void foo()
{
  static Bar object(42);
}

In this case, I believe you need *two* well-known assembler symbols:
one for the name of foo::object, and one for the flag whether
foo::object has been initialized. Of course, that would also require
to define specific values for the flag.

> Note that to enable a "compiler-driven" inlining, these need to be  
> named inside any function, not only inline ones.

Does this need to be part of the ABI? I.e. is there any chance that
such compiler-driven inlining is works across compilers?

> For variable size, we may have a problem with array sizes. What  
> about linking:
> 
> foo.C:	extern int a[10];
> bar.C:	int a[200000];
> 
> Problem: short data space. the declaration in foo.C may seem like a  
> good 'short' candidate, whereas the definition is not.

Isn't this ill-formed? AFAIK, it would be ok if you get a linker
error. Alternatively, it would be ok if it links fine and later
crashes.

Regards,
Martin




From loewis at informatik.hu-berlin.de  Tue Oct 19 08:18:37 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 19 Oct 1999 10:18:37 +0200
Subject: Name mangling
In-Reply-To: <380B6323.70CC5589@edg.com> (message from Daveed Vandevoorde on
	Mon, 18 Oct 1999 11:12:51 -0700)
References: <9910151753.ZM205799@isolde.engr.sgi.com> <380B6117.6D5E154B@edg.com> <380B6323.70CC5589@edg.com>
Message-ID: <199910190818.KAA17614@pandora>

> Fundamental types and type operators
> ------------------------------------

Maybe the following list can serve as a starting point here:

fundamental types:
 
  void
  [signed|unsigned] {char, short, int, long} (long long?, int<n>_t)
  bool
  float, double, (long double?)
  wchar_t
  ellipsis {not strictly a type}
  (complex)

type modifiers/constructors:

  const, volatile (restrict?)
  array {with size} of type
  pointer to type
  reference to type
  function expecting type*, returning type
  pointer to member function of type, expecting type*, returning type
  pointer to member of type T, having type U (i.e. "U T::*")

The types in parentheses are available in C99, but not in standard
C++.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Tue Oct 19 17:27:28 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 19 Oct 1999 19:27:28 +0200
Subject: Name mangling
In-Reply-To: <199910191648.JAA01057@cllmail.cup.hp.com> (message from
	Christophe de Dinechin on Tue, 19 Oct 1999 09:48:00 -0700)
References: <199910191648.JAA01057@cllmail.cup.hp.com>
Message-ID: <199910191727.TAA11648@pandora>

> >   void
> 
> I thought void was not strictly a type. Well, here, I guess we may  
> consider it a type.

It appears as part of a composite type, e.g. "pointer to void" or
"pointer to function returning void", so it is certainly relevant for
mangling.

> >   function expecting type*, returning type
> >   pointer to member function of type, expecting type*, returning type 
> >   pointer to member of type T, having type U (i.e. "U T::*")
> 
> As Daveed pointed out, the throw spec should be part of the function  
> types in C++.

It would only appear on functions (and methods), not on function
types, right?

Also, it is not strictly necessary, is it (being in Daveed's
nice-to-have list)?

> Regarding pointers, for anytbody supportingf ILP32 (is that just  
> us?), we may have a need for some "long pointer". This could be a  
> __far modifier. In any case, in ILP32, there is to be a 'long long'  
> type (64 bit) in the ABI.

That seems like a useful feature. Is it reasonable to consider __far
in the same category as the cv-qualifiers?

Regards,
Martin



From loewis at informatik.hu-berlin.de  Tue Oct 19 17:11:08 1999
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 19 Oct 1999 19:11:08 +0200
Subject: Name mangling
In-Reply-To: <199910191642.JAA00950@cllmail.cup.hp.com> (message from
	Christophe de Dinechin on Tue, 19 Oct 1999 09:42:56 -0700)
References: <199910191642.JAA00950@cllmail.cup.hp.com>
Message-ID: <199910191711.TAA11108@pandora>

> I was considering inlining as a bigger issue than templates. Consider:
> 
> inline char *get_name() { return "ABC"; }
> 
> From two different translation units, get_name() is supposed to  
> return the same value. So we need to name the "ABC" constant and make  
> it a COMDAT.

I agree with that (although I admit this is the first time I noticed
7.1.2/4).

> My point is that if you don't assume any function can become inline,  
> you prevent such an inliner to do its job on ABI-compliant .o files.  
> So you drive the compiler vendor to use an incompatible .o format in  
> that case. This optimization is quite significant, so I guess we  
> want to enable it.

Ok. I find it hard to believe you that it is possible to inline
functions generated by a different compiler at link time, but I guess
I should trust you.

Regards,
Martin



From ddd at cup.hp.com  Tue Oct 19 17:20:24 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 19 Oct 1999 10:20:24 -0700
Subject: Name mangling
In-Reply-To: <199910191642.JAA00950@cllmail.cup.hp.com> (message fromChristophe de Dinechin on Tue, 19 Oct 1999 09:42:56 -0700)
Message-ID: <199910191720.KAA01877@cllmail.cup.hp.com>

> > My point is that if you don't assume any function can become  
inline,
> > you prevent such an inliner to do its job on ABI-compliant .o  
files.
> > So you drive the compiler vendor to use an incompatible .o  
format in
> > that case. This optimization is quite significant, so I guess we   
> > want to enable it.
>
> Ok. I find it hard to believe you that it is possible to inline
> functions generated by a different compiler at link time, but I guess 
> I should trust you.

Oh, I find this as hard to believe as you do. That's not my  
objective. What I don't want is some sort of "parallel format" to  
emerge just because a given vendor cannot do something with what we  
define.


Christophe



From ddd at cup.hp.com  Tue Oct 19 16:42:56 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 19 Oct 1999 09:42:56 -0700
Subject: Name mangling
In-Reply-To: <199910182233.PAA09766@cllmail.cup.hp.com> (message fromChristophe de Dinechin on Mon, 18 Oct 1999 15:33:06 -0700)
Message-ID: <199910191642.JAA00950@cllmail.cup.hp.com>

> > Entities with no linkable name, but which need to be referenced   
> > accross translation units (inlining, template instantiations):
> >
> > 1. String constants
> > 2. Static local variables
> >
>
> I can see the usage of these being referenceable for
> inlining. However, I don't think that such a feature is mandated by 
> the C++ standard, at least for string literals.
>
> In particular, string literals may not appear as template parameters 
> (see http://www.informatik.hu-berlin.de/~loewis/corer8.html#100 for a 
> ready issue), and neither can static local variables
> ([temp.arg.nontype]/1).

I was considering inlining as a bigger issue than templates. Consider:

inline char *get_name() { return "ABC"; }

>From two different translation units, get_name() is supposed to  
return the same value. So we need to name the "ABC" constant and make  
it a COMDAT. Not many compilers pass that test, though. Same thing  
for statics in inlines, as you pointed out. Several compilers pass  
that second test by just preventing inlining in that case.

The same problem arises in theory with template instantiations, but  
is probably already solved for us, since we already agreed to COMDAT  
the template instantiations. I was unable to build a case where a  
string or local static would be instantiated without instantiating a  
template function first :-)


> > Note that to enable a "compiler-driven" inlining, these need to be   
> > named inside any function, not only inline ones.
>
> Does this need to be part of the ABI? I.e. is there any chance that 
> such compiler-driven inlining is works across compilers?

My point is that if you don't assume any function can become inline,  
you prevent such an inliner to do its job on ABI-compliant .o files.  
So you drive the compiler vendor to use an incompatible .o format in  
that case. This optimization is quite significant, so I guess we  
want to enable it.


> > For variable size, we may have a problem with array sizes. What   
> > about linking:
> >
> > foo.C:	extern int a[10];
> > bar.C:	int a[200000];
> >
> > Problem: short data space. the declaration in foo.C may seem like a   
> > good 'short' candidate, whereas the definition is not.
>
> Isn't this ill-formed? AFAIK, it would be ok if you get a linker
> error. Alternatively, it would be ok if it links fine and later
> crashes.

Sorry, I acknowledge that my point was quite unclear. I would like  
that we encode array size in the variable type, to get a linker error  
for the above (and thus enable the 'short space' optimization.) I  
was saying "we may have a problem" because of:

extern int a[];
int a[1000];


Thank you for your comments
Christophe



From ddd at cup.hp.com  Tue Oct 19 16:48:00 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 19 Oct 1999 09:48:00 -0700
Subject: Name mangling
In-Reply-To: <380B6323.70CC5589@edg.com> (message from Daveed Vandevoorde onMon, 18 Oct 1999 11:12:51 -0700)
Message-ID: <199910191648.JAA01057@cllmail.cup.hp.com>

>   void

I thought void was not strictly a type. Well, here, I guess we may  
consider it a type.

>   function expecting type*, returning type
>   pointer to member function of type, expecting type*, returning type 
>   pointer to member of type T, having type U (i.e. "U T::*")

As Daveed pointed out, the throw spec should be part of the function  
types in C++.

Regarding pointers, for anytbody supportingf ILP32 (is that just  
us?), we may have a need for some "long pointer". This could be a  
__far modifier. In any case, in ILP32, there is to be a 'long long'  
type (64 bit) in the ABI.


Christophe



From dehnert at baalbek.engr.sgi.com  Tue Oct 19 22:39:54 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 15:39:54 -0700 (PDT)
Subject: Name mangling
Message-ID: <199910192239.PAA05842@baalbek.engr.sgi.com>

This bounced from the reflector for some unknown reason.  Trying again...


>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:

    Christophe> As Daveed pointed out, the throw spec should be part
    Christophe> of the function types in C++.

Hmm.  You can't overload on the throw spec, so it's not really
necessary, is it?

The point would be to avoid accidentally declaring the function
differently (in one translation unit) from the way it was defined in
another.  This is just a special case of the general ODR problem.  At
CenterLine, we built a working, but financially unsuccessful, tool to
solve this problem; it worked by adding a special section with
information about various things not covered by mangling (like the
full data layout of every type, so that you could tell if you failed
to recompile a module after changing the size of types that the
functions in that module depended upon.)

So, *in general*, I'd be inclined not to try to incorporate this kind
of information in the mangling.  Maybe the throw spec is worth putting
in the mangling, maybe not.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at sgi.com  Wed Oct 20 03:58:34 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 20:58:34 -0700
Subject: Notes from 14 October -- RTTI offset
References: <9910151753.ZM205799@isolde.engr.sgi.com>
Message-ID: <380D3DEA.9D6D1E15@sgi.com>

Matt Austern wrote:
>                               ISSUE B-6
> 
> (3) When we discussed issue B-8, we agreed that we would have an
> offset to typeinfo object rather than a pointer to typeinfo object.
> This means that the typeinfo object is now part of the vtable.  It
> will go at the very beginning, i.e. at a negative offset from where
> the vtpr points.  (Comment: We discussed B-6 before discussing B-8.
> Does making this change interfere with having a uniform vtable offset,
> since we won't have a typeinfo object at the beginning of a vtable
> for a nonpolymorphic class with virtual bases?  Should we revisit
> decision (2) or (3), or am I just being paranoid?)

I thought we needed the RTTI pointer to be unique so it can be compared.
Am I remembering incorrectly?



From dehnert at sgi.com  Wed Oct 20 06:13:46 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 23:13:46 -0700
Subject: IA-64 gABI Proposal 74: Section Indices
Message-ID: <380D5D9A.6612ECDD@sgi.com>

Attached is the C++ ABI group's proposal for eliminating the
current 64K limit on section count.  We believe this to be an
important problem given the COMDAT proposal.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991019/3f7e3e7d/attachment.html>

From dehnert at sgi.com  Wed Oct 20 06:13:42 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 23:13:42 -0700
Subject: IA-64 gABI Issue 72: COMDAT
Message-ID: <380D5D96.88908677@sgi.com>

Attached is the C++ ABI group's proposal for grouping sections
for duplicate removal and other purposes.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991019/8951075a/attachment.html>

From dehnert at sgi.com  Wed Oct 20 06:25:10 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 23:25:10 -0700
Subject: Updated pages (from 14 October)
Message-ID: <380D6046.944DE8D5@sgi.com>

Attached is the gzipped tar file for the status pages,
updated for the 14 October meeting.  Thanks to Matt for
taking minutes, which are most of what's included, and
to Daveed for the updated RTTI proposal.  Note that I've
done some editorial modifications to the latter (in
abi-layout.html) -- please look it over.

Tomorrow I'll add Daveed's mangling information (and
followups) and come up with an agenda for Thursday.

The COMDAT and section limitation proposals have been
sent to the base ABI group.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.tar.gz
Type: application/x-gzip
Size: 87466 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991019/d0144d4b/attachment.bin>

From dehnert at sgi.com  Wed Oct 20 06:45:55 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Tue, 19 Oct 1999 23:45:55 -0700
Subject: Updated PDF status pages
Message-ID: <380D6523.A88C72D6@sgi.com>

Attached is a zip file with the modified pages.
Is this usable by everyone that wants PDF?
If not, I'll send them separately tomorrow.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.zip
Type: application/x-zip-compressed
Size: 257259 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991019/1e507ec8/attachment.bin>

From dehnert at baalbek.engr.sgi.com  Thu Oct 21 16:15:41 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 21 Oct 1999 09:15:41 -0700 (PDT)
Subject: Meeting today -- 21 Oct 99
Message-ID: <199910211615.JAA11273@baalbek.engr.sgi.com>

Following is an updated agenda, based on last week's:
 
  1) The COMDAT/section index proposals are updated in issue B-5.
     Please identify whatever needs changing (or is an issue) --
     I'll submit it in whatever form to the base ABI group early
     next week, though we can modify the proposal even after that.

     ==> This has been done.
 
  2) RTTI descriptors.  See open issue A-6, and Daveed's cleaned
     up description in the ABI data layout document.

     ==> Last week's work looks good to me, and it sounds like
     we're about done with this except for the issue I raised in email.
     I think we were counting on a unique RTTI record so the addresses
     could be compared, which may affect whether we can put it in
     (i.e. immediately preceding) the vtable.
 
  3) The updated vtable layout proposal from Jason.  See open issue
     B-6, and Jason's cleaned up description in the ABI data layout
     document.

     ==> Matt's minutes indicate that we're ready to close this today.
 
  4) Based on (3), can we produce a clean description of a virtual
     function call?  If not, what's still missing?  See issue B-1.

  5) Same question for dynamic cast.  See issue B-8.

     ==> Closed last week

  6) Identify what remains to deal with C-4, C-5, and C-6 (calling
     constructors and destructors).

  7) If possible, let's discuss the varargs routine interface,
     as there's a possible C ABI issue there (G-5).  Think about
     whether there's any chance of changing the C ABI version of
     this at this point...

     ==> Closed last week

  8) Let's start the discussion of mangling.  Think about Daveed's
     list and any ideas you might have.


Next week, I'd like to return to the initialization/finalization issues
(I have an action item there), and to exception handling (Christophe
has one).

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at isolde.engr.sgi.com  Wed Oct 27 17:39:22 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 27 Oct 1999 10:39:22 -0700
Subject: Pointer to RTTI information in vtable
Message-ID: <9910271039.ZM241572@isolde.engr.sgi.com>

At the October 14 meeting we decided to include RTTI information as
part of the vtable block, and to include an offset to RTTI information
in the vtable rather than a pointer to RTTI information.  (We decided
on this change so that we would have fewer symbols to resolve at link
time.)

Jim came up with a serious objection at the October 21 meeting:
during construction we need different RTTI information at different
points.  A few of us talked about this at Kona, and my impression is
that Jim's objection is fatal.  We could imagine having base class
typeinfo objects in every vtable block, but (1) this would kill any
performance advantage we'd get by using an offset rather than a
pointer; and (2) we'd lose the ability to use simple pointer identity
as a way of telling whether two typeinfos represent the same type.

I propose that we abandon that decision, and go back to using pointers.
Does everyone agree?

			--Matt



From jason at cygnus.com  Wed Oct 27 18:34:16 1999
From: jason at cygnus.com (Jason Merrill)
Date: 27 Oct 1999 11:34:16 -0700
Subject: Pointer to RTTI information in vtable
In-Reply-To: "Matt Austern"'s message of "Wed, 27 Oct 1999 10:39:22 -0700"
References: <9910271039.ZM241572@isolde.engr.sgi.com>
Message-ID: <u91zagbql3.fsf@yorick.cygnus.com>

>>>>> Matt Austern <austern at isolde.engr.sgi.com> writes:

 > I propose that we abandon that decision, and go back to using pointers.
 > Does everyone agree?

Yes.

Jason



From dehnert at sgi.com  Wed Oct 27 23:03:24 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 27 Oct 1999 16:03:24 -0700
Subject: Meeting tomorrow -- 28 Oct 99
Message-ID: <381784BC.6EB8A7B4@sgi.com>


Following is an updated agenda, based on last week's.
We should be able to get further this time.
 
  1) RTTI descriptors.  See open issue A-6, and Daveed's cleaned
     up description in the ABI data layout document.

     ==> Resolve the issue I raised in email.
     I think we were counting on a unique RTTI record so the addresses
     could be compared, which may affect whether we can put it in
     (i.e. immediately preceding) the vtable.
 
  2) The updated vtable layout proposal from Jason.  See open issue
     B-6, and Jason's cleaned up description in the ABI data layout
     document.

     ==> Matt's minutes indicate that we're ready to close this.
 
  3) Based on (2), can we produce a clean description of a virtual
     function call?  If not, what's still missing?  See issue B-1.
     I think we need a volunteer to write this up.

  4) Identify what remains to deal with C-4, C-5, and C-6 (calling
     constructors and destructors).

  5) Let's start the discussion of mangling.  Think about Daveed's
     list and any ideas you might have.  I've incorporated Daveed's
     email and the responses into open issue F-1.

The following is some external status:

 1) The COMDAT and section index proposals should be discussed in
    the base ABI group on 5 November.

 2) We have begun a DWARF-2 standard committee, and will begin
    dealing with IA-64 bindings next week.  If you were interested
    in participating in that activity, you need to email me with
    contact info (name, organization, phone, FAX) to get on the
    mailing list.

Next week, I'd like to return to the initialization/finalization issues
(I have an action item there), and to exception handling (Christophe
has one).

Attached is the tar file of the current files.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.tar.gz
Type: application/x-gzip
Size: 85912 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991027/a1cf08c7/attachment.bin>

From dehnert at baalbek.engr.sgi.com  Wed Oct 27 23:11:19 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 27 Oct 1999 16:11:19 -0700 (PDT)
Subject: TAKE -- more updates for C++ ABI
Message-ID: <199910272311.QAA26192@baalbek.engr.sgi.com>


Wed Oct 27 16:10:11 PDT 1999
The following file(s) were checked into tiler.engr:/isms/osprey.src/osprey1.0

owebpages/Design/ABI/cxxABI/cxx-closed.html - 1.9
	- Add update to B-8 message:  pointer instead of offset for RTTI. 
owebpages/Design/ABI/cxxABI/cxx-open.html - 1.20
	- Add update to B-8 message:  pointer instead of offset for RTTI. Add
	  update to F-1 message: integrate Daveed's information and responses. 




From ddd at cup.hp.com  Wed Oct 27 23:25:20 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 27 Oct 1999 16:25:20 -0700
Subject: Meeting tomorrow -- 28 Oct 99
Message-ID: <199910272325.QAA16453@cllmail.cup.hp.com>

A non-text attachment was scrubbed...
Name: not available
Type: text/enriched
Size: 231 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991027/64cd2a07/attachment.bin>

From dehnert at sgi.com  Thu Oct 28 05:42:08 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 27 Oct 1999 22:42:08 -0700
Subject: Open issues PDF
Message-ID: <3817E230.BA69B29A@sgi.com>

Attached, zipped.

Jim
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-open.zip
Type: application/x-zip-compressed
Size: 227943 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991027/f9fd10e9/attachment.bin>

From dehnert at sgi.com  Thu Oct 28 05:42:56 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 27 Oct 1999 22:42:56 -0700
Subject: Other pages' PDF
Message-ID: <3817E260.A9B06A77@sgi.com>

Zipped...

Jim
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxx-status.zip
Type: application/x-zip-compressed
Size: 236061 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19991027/237dac00/attachment.bin>

