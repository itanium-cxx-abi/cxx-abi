From mark at codesourcery.com  Sun Jan  2 05:23:38 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 01 Jan 2000 21:23:38 -0800
Subject: Class layout algorithm
In-Reply-To: <199912291956.LAA06907@baalbek.engr.sgi.com>
References: <199912291956.LAA06907@baalbek.engr.sgi.com>
Message-ID: <20000101212338U.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I'll fix these.

Thanks!  I've read what you wrote, and its a big improvement.  Here's
one minor comment:

  If D is a base class, this step allocates only its non-virtual part,
  i.e. excluding any direct or indirect bases.

should be `direct or indirect virtual bases'.  (Note the addition of
the word `virtual'.)
  
--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Jan  3 06:12:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 02 Jan 2000 22:12:58 -0800
Subject: Virtual base alignment
In-Reply-To: <199912300147.RAA08553@baalbek.engr.sgi.com>
References: <199912300147.RAA08553@baalbek.engr.sgi.com>
Message-ID: <20000102221258P.mitchell@codesourcery.com>


I think the current proposal for allocating virtual bases is still a
little suboptimal.  In particular, given:

  struct A { void f(); };
  struct B : virtual public A {};
  struct C : virtual public A, virtual public B {};

we'll give `C' a larger size than for:

  struct C : virtual public B, virtual public A {};

where we'll reuse the `A' part of `B' rather than reallocating it.
  
I know that ordering can already affect size (principally because of
alignment issues) but I think that in this case we might as well not
punish programmers for choosing the "wrong" ordering.

I think we should change the green A-17 proposed resolution to
indicate that if one of the virtual bases is a (direct or indirect)
primary base of one of the other virtual bases then we need not
allocate a fresh copy.

FWIW, it turns out to actually be easier in GCC to code the more
generous version.

The algorithm to do this is linear in the size of the hierarchy: just
iterate through the inheritance DAG marking all primary bases.  Any
virtual base classes that remain unmarked need to be allocated in step
III.  A slight formalization of this sentence might be a good way to
express which bases to choose for III.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Mon Jan  3 22:25:53 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 3 Jan 2000 14:25:53 -0800 (PST)
Subject: Virtual base alignment
References: <199912300147.RAA08553@baalbek.engr.sgi.com>
Message-ID: <200001032225.OAA11445@baalbek.engr.sgi.com>

I've added this comment to the A-17 issue.  A couple of observations
though:

1) A similar discussion occurred w.r.t. the choice of a non-virtual
primary base class, and the decision to use strict declaration order
rather than attempting to optimize was based on the desire to allow a
programmer to make the choice, whether optimal or not.

This is not quite the same situation -- at least I can't come up with
convincing cases where Mark's proposal would be worse, but that angle
should be considered.

2) Mark's proposal affects I-2a as well as III.

Jim

> From: Mark Mitchell <mark at codesourcery.com>
> Date: Sun, 02 Jan 2000 22:12:58 -0800
> 
> I think the current proposal for allocating virtual bases is still a
> little suboptimal.  In particular, given:
> 
>   struct A { void f(); };
>   struct B : virtual public A {};
>   struct C : virtual public A, virtual public B {};
> 
> we'll give `C' a larger size than for:
> 
>   struct C : virtual public B, virtual public A {};
> 
> where we'll reuse the `A' part of `B' rather than reallocating it.
>   
> I know that ordering can already affect size (principally because of
> alignment issues) but I think that in this case we might as well not
> punish programmers for choosing the "wrong" ordering.
> 
> I think we should change the green A-17 proposed resolution to
> indicate that if one of the virtual bases is a (direct or indirect)
> primary base of one of the other virtual bases then we need not
> allocate a fresh copy.
> 
> FWIW, it turns out to actually be easier in GCC to code the more
> generous version.
> 
> The algorithm to do this is linear in the size of the hierarchy: just
> iterate through the inheritance DAG marking all primary bases.  Any
> virtual base classes that remain unmarked need to be allocated in step
> III.  A slight formalization of this sentence might be a good way to
> express which bases to choose for III.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Mon Jan  3 23:44:45 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Jan 2000 15:44:45 -0800
Subject: Virtual base alignment
In-Reply-To: <200001032225.OAA11445@baalbek.engr.sgi.com>
References: <199912300147.RAA08553@baalbek.engr.sgi.com>
	<200001032225.OAA11445@baalbek.engr.sgi.com>
Message-ID: <20000103154445A.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> This is not quite the same situation -- at least I can't come
    Jim> up with convincing cases where Mark's proposal would be
    Jim> worse, but that angle should be considered.

Agreed - on both counts.  If there's a reason why my proposal would be
worse, we should definitely consider that, but I can't see how that
could come about.  I think we can prove that no ordering uses less
space.

    Jim> 2) Mark's proposal affects I-2a as well as III.

Good point!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Jan  4 05:58:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 3 Jan 2000 21:58:40 -0800 (PST)
Subject: Exception handling psABI
Message-ID: <200001040558.VAA21944@baalbek.engr.sgi.com>

I have integrated the HP psABI-level exception handling specification
(i.e. Section 8) into the draft exception handling document on the C++
ABI website, with some rearrangement, elaboration, minor name changes
(in red), added questions, and miscellaneous editting.  If you will all
read it and prepare comments before Thursday (or even email them before
then), perhaps we can send this off to the psABI group.

The data layout document and open issues also reflect Mark's latest
mail.  The PDF versions of these will be updated tomorrow (so don't
look for this stuff there now).

Jim
-		Jim Dehnert  x3-4272



From allen.chan at ca.ibm.com  Wed Jan  5 16:45:35 2000
From: allen.chan at ca.ibm.com (allen.chan at ca.ibm.com)
Date: Wed, 5 Jan 2000 11:45:35 -0500
Subject: RTTI dynamic_cast implementation
Message-ID: <8725685D.005D78C4.00@d53mta04h.boulder.ibm.com>



Hi all,

We are in the process of implementing the RTTI proposal as outlined in the
ABI document. Is there any plan to make the implementation of
__dynamic_cast publicly available? or must we all spend the time to
implement our own version of __dynamic_cast?

regards,
Allen

--
Internet: allen.chan at ca.ibm.com
Notes: Allen Chan/Toronto/IBM at IBMCA
IBM TieLine 8-778-3908 / Tel 416-448-3908
VisualAge C++ Kernel Development
My opinions are my own.





From dehnert at baalbek.engr.sgi.com  Wed Jan  5 20:44:16 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jan 2000 12:44:16 -0800 (PST)
Subject: RTTI dynamic_cast implementation
Message-ID: <200001052044.MAA01282@baalbek.engr.sgi.com>

Well, Jason has an open action item to provide pseudocode for this --
does anyone else have plans for it?  Freely usable?

> Hi all,
> 
> We are in the process of implementing the RTTI proposal as outlined in the
> ABI document. Is there any plan to make the implementation of
> __dynamic_cast publicly available? or must we all spend the time to
> implement our own version of __dynamic_cast?
> 
> regards,
> Allen
> 
> --
> Internet: allen.chan at ca.ibm.com
> Notes: Allen Chan/Toronto/IBM at IBMCA
> IBM TieLine 8-778-3908 / Tel 416-448-3908
> VisualAge C++ Kernel Development
> My opinions are my own.
> 
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Jan  6 00:24:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jan 2000 16:24:07 -0800 (PST)
Subject: Agenda for tomorrow
Message-ID: <200001060024.QAA02377@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Exception handling.

  B) Data layout.

  C) Initialization.

  D) Mangling.

So, take a look at the material associated with these issues:

  1) D-*:  Exceptions.  Any adjustments to my base ABI (level 1)
     adaptation of Christophe's Chapter 8, so we can do a submission to
     the base ABI group.  Any further issues with the accepted
     proposal?  (I haven't incorporated last meeting's issues into the
     open issues list on the web site, but will later today.)

  2) D-9:  My impression is that this issue is resolved except for
     details like the name.  Can we choose a name for the full-cleanup
     version of longjmp and close this?

  3) A-16/17/18:  Resolve layout issues inspired by Mark.

  4) C-2:  Static link initialization and priorities.
     Is there any further feedback from members about preferences?

  5) F-*:  Mangling.  We're awaiting a proposal from Daveed.

Issues that are active and awaiting proposals:

  a) C-4:  Daveed will write up construction vtables so we can
     verify.  Wait.

  b) F-1, F-2:  Daveed will produce an initial proposal.  Wait.

Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Thu Jan  6 04:23:41 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jan 2000 20:23:41 -0800
Subject: RTTI dynamic_cast implementation
In-Reply-To: <8725685D.005D78C4.00@d53mta04h.boulder.ibm.com>
References: <8725685D.005D78C4.00@d53mta04h.boulder.ibm.com>
Message-ID: <20000105202341F.mitchell@codesourcery.com>

>>>>> "allen" == allen chan <allen.chan at ca.ibm.com> writes:

    allen> Hi all,

    allen> We are in the process of implementing the RTTI proposal as
    allen> outlined in the ABI document. Is there any plan to make the
    allen> implementation of __dynamic_cast publicly available? or
    allen> must we all spend the time to implement our own version of
    allen> __dynamic_cast?

We are implementing it as well for use in g++.  That version will
*not* be under the GPL -- it will bear the following license.  Note
the last paragraph.  Only a lawyer could tell you whether this license
will allow you to use it in your system or not, I'm afraid -- I
genuinely can't parse all of the details.  It *sounds* like you could
only use this file if at least one file in the application was
compiled by g++, but I don't know that for sure.

// This file is part of GNU CC.

// GNU CC is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.

// GNU CC is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with GNU CC; see the file COPYING.  If not, write to
// the Free Software Foundation, 59 Temple Place - Suite 330,
// Boston, MA 02111-1307, USA. 

// As a special exception, if you link this library with other files,
// some of which are compiled with GCC, to produce an executable,
// this library does not by itself cause the resulting executable
// to be covered by the GNU General Public License.
// This exception does not however invalidate any other reasons why
// the executable file might be covered by the GNU General Public License.


--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Thu Jan  6 04:33:50 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jan 2000 20:33:50 -0800 (PST)
Subject: Status update
Message-ID: <200001060433.UAA03614@baalbek.engr.sgi.com>

The status pages on the web site have been updated with a number of
issues raised at the last meeting -- see D-10 through D-16.  I think
I captured everything significant that was raised, but may have garbled
something -- please take a look and (a) verify correct description and
(b) think about resolutions.

Jim
-		Jim Dehnert  x3-4272



From nathan at acm.org  Thu Jan  6 11:20:09 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Thu, 06 Jan 2000 11:20:09 +0000
Subject: RTTI queries
Message-ID: <38747A69.E5717C1E@acm.org>

Hi,
I'm in the process of implementing the runtime rtti code in g++ for
CodeSourcery LLC. I have a number of queries and comments on the 
C++ ABI for IA64: Data Layout document
(http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html)

1) the declaration of __vmi_class_info uses a helper class of the
following
        struct __base_class_info {
        type_info *type;
        ptrdiff_t offset;
        int vmi_flags;
        }
1.1) I beleive `type' should be declared `__class_type_info const *type'
(the description of __ptr_to_member_type_info has such a pointer and uses
__class_type_info). The description of __si_class_type_info is vague on the
base pointer's type, but that too should be `__class_type_info const *type'.

1.2) From the description of __vmi_class_info it appears that the base
class array uses the trailing array struct hack. This is ok, because
it is always generated by the compiler. This is not documented.

1.3) I cannot find a definition of what the `offset' member of
__base_class_info is an offset for. For a virtual base it cannot be
the offset from this base to the virtual base as that changes for different
bases in a heirarchy. I presume it must be the offset in the vtable to the
base offset. This is not documented.

2) The ABI document specifies

void *__dynamic_cast (void *sub, __class_type_info *src,
                __class_type_info *dst, ptrdiff_t sr2dst_offset);

this is not const correct, I beleive it should be

void *__dynamic_cast (const void *sub, const __class_type_info *src,
                const __class_type_info *dst, ptrdiff_t sr2dst_offset);

3) __class_type_info contains a set of details flags. Whilst these look
useful, I'm not sure that they are. When porting g++'s current dynamic_cast
machinery (which as the document points out is semantically the same), these
flags showed little use.

3.1) flag 0x8 says `has privately inherited base'. Does this really mean
private or does it actually mean non-public? both catch matching and dynamic
cast distinguish public and non-public, not private and non-private.

3.2) More useful for dynamic cast, (and possibly catch matching) would be
the following flags
	* Contains non-diamond shaped multiple base object
	* Is diamond shaped
	* has virtual base
	* has non-virtual base
	* has public base
	* has non-public base
Note that the virtual/non-virtual and public/non-public are not mutually
exclusive. Also note that I have not actually implemented anything with these
flags, so I could be wrong.

4) The name mangling scheme for type_info objects is not defined. Therefore
I don't know how to name the type_info objects required in the runtime for
the fundamental types (and their pointers). I see this is on today's agenda.

nathan

-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/



From sidwell at codesourcery.com  Thu Jan  6 12:52:49 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Thu, 06 Jan 2000 12:52:49 +0000
Subject: RTTI inconsistency
Message-ID: <38749021.DE2E1B3D@codesourcery.com>

Hi,
there is an inconsistency in the documentation of how a vtable
points to the type_info object for that type.

The abi layout document Run-Time Type Information (RTTI) section states,

3.Every vtable shall contain one entry pointing to an object derived
	from std::type_info. This entry is located at the word preceding
	the location pointed to by the vptr (i.e., entry "-1"). The
	entry is allocated in all vtables; for classes having virtual bases
	but no virtual functions, the entry is zero. This entry is coded
	as an offset with respect to the virtual table origin, rather than as
	a pointer (thereby avoiding run-time relocations). 

but the closed issues document section A-6 ends by saying
	[991028 all] The current definition, in the ABI data layout document,
	has been updated with Daveed's changes, and is accepted. Note that we
	are back to using a pointer to RTTI in the vtable (see B-8), since we
	need uniqueness, and since we need an external symbol in any case, the
	ABI will make no statement about where RTTI is allocated. It is likely
	that implementations will use COMDAT for it. 

Also the Virtual Table Layout section of the ABI document says,
	The typeinfo pointer points to the typeinfo object used for RTTI.
	All entries in each of the vtables for a given class must point to the
	same typeinfo object. A correct implementation of typeinfo equality is
	to check pointer equality. 

so which is it? An offset or a pointer? (I think it has to be a pointer to
get uniqueness.)

nathan

-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/



From ddd at cup.hp.com  Thu Jan  6 17:13:57 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 06 Jan 2000 17:13:57 +0000
Subject: Agenda for tomorrow
References: <200001060024.QAA02377@baalbek.engr.sgi.com>
Message-ID: <3874CD55.2EB45E55@cup.hp.com>

Jim,


As far as I know, Daveed is still in vacation in Belgium. I guess we will still
wait...


Christophe

Jim Dehnert wrote:
 
>   5) F-*:  Mangling.  We're awaiting a proposal from Daveed.
> 
> Issues that are active and awaiting proposals:
> 
>   a) C-4:  Daveed will write up construction vtables so we can
>      verify.  Wait.
> 
>   b) F-1, F-2:  Daveed will produce an initial proposal.  Wait.
> 
> Jim
> 
> -               Jim Dehnert  x3-4272



From alainm at cup.hp.com  Fri Jan  7 15:06:21 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 07 Jan 2000 15:06:21 +0000
Subject: missing "virtual" in data layout (typo)
Message-ID: <387600ED.549C8A64@cup.hp.com>


Not very important but I think that a "virtual" is missing:

http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html
Non-POD Class Types 
I.Initialization 
   2.If C is a polymorphic type: 
	a second par.
	I think there is a "virtual" missing :
	This step allocates only B's non-virtual part, i.e. excluding any
direct or indirect __virtual__ bases.

(if it's supposed to be implicit, note that it's mentioned in the
corresponding sentence in II. 2)

Alain



From dehnert at baalbek.engr.sgi.com  Tue Jan 11 06:32:54 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 10 Jan 2000 22:32:54 -0800 (PST)
Subject: Updates
Message-ID: <200001110632.WAA19129@baalbek.engr.sgi.com>

I have updated the data layout issues, including proposed wording in
the data layout document, based on the meeting.  The changes are on
the web site (HTML, not PDF yet).  Please take a look.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 12 03:50:42 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 11 Jan 2000 19:50:42 -0800 (PST)
Subject: Exception issues
Message-ID: <200001120350.TAA21960@baalbek.engr.sgi.com>

I think I've updated the exception issues for last week, with a couple
of exceptions.  The HTML is on the web site (but not PDF yet).
The exceptions are:

 1) I didn't close D-9.  If someone will confirm that what I wrote is
    what we decided (note that I essentially copied a SysV longjmp
    prototype), I'll close it.

 2) I need to look up and include the email for D-14, probably closing it.

 3) I need to make the corrections in the abi-eh.html document.

Please check these out and send any comments.

Note that Christophe has information to send on D-11 and D-16, Colleen
on D-13, and everyone has homework on D-16.

I'll send an agenda tomorrow...


Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu Jan 13 06:34:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 12 Jan 2000 22:34:24 -0800 (PST)
Subject: Meeting agenda
Message-ID: <200001130634.WAA28916@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Exception handling.

  B) Data layout.

  C) Initialization.

  D) Mangling.

So, take a look at the material associated with these issues:

  1) D-*:  Exceptions.  Verify my writeup of _Unwind_ForcedUnwind,
     and any other issues with the document.  Answer the "Outstanding
     Questions" at the beginning of the document.

  2) D-9:  Validate my last writeup, along with the forced unwind
     definition, and close this.

  3) D-12:  Unwind table location.  (I did not do my duty and call
     Cary.  Did Christophe talk to him?)

  4) D-14:  Can we close this?

  5) D-16:  Any feedback from implementors?

  6) A-17/18/19:  Resolve layout issues inspired by Mark.

  4) C-2:  Static link initialization and priorities.
     Is there any further feedback from members about preferences?

  5) F-*:  Mangling.  We're awaiting a proposal from Daveed.

Issues that are active and awaiting proposals:

  a) C-4:  Daveed will write up construction vtables so we can
     verify.  Wait.

  b) F-1, F-2:  Daveed will produce an initial proposal.  Wait.

Jim

-		Jim Dehnert  x3-4272



From coleen at zko.dec.com  Thu Jan 13 16:39:08 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 13 Jan 2000 11:39:08 -0500
Subject: Test cases for sharing virtual base vptrs 2 of 3.
Message-ID: <200001131639.AA25470@philli.zko.dec.com>

/*
Test case for sharing virtual bases.
In Most_Derived,
the primary base class is Nonvirt1,
Nonvirt2 and Nonvirt3 share vptrs with
virtual base Shared_Virt.  Shared_Virt
should be at the same offset as Nonvirt2.
Should get:
67% a.out
(long)(Nonvirt1 *)dd - (long)dd = 0
(long)(Nonvirt2 *)dd - (long)dd = 8
(long)(Nonvirt3 *)dd - (long)dd = 16
(long)(Shared_Virt *)dd - (long)dd = 8
*/

struct Shared_Virt {
    virtual void foo();
};
struct Nonvirt2 : virtual Shared_Virt {
	virtual void bar();
};
struct Nonvirt3 : virtual Shared_Virt {
	virtual void baz();
};

struct Nonvirt1 {
	virtual void foo();
};

struct Most_Derived : Nonvirt1, Nonvirt2, Nonvirt3 {
	virtual void bar();
};

void Shared_Virt::foo() {}
void Nonvirt2::bar() {}
void Nonvirt3::baz() {}
void Nonvirt1::foo() {}
void Most_Derived::bar() {}


extern "C" int printf(const char *,...);
#define EVAL(EXPR) printf( #EXPR " = %d\n", (EXPR) );
main()
{
  Most_Derived *dd = new Most_Derived;
  EVAL((long)(Nonvirt1 *)dd - (long)dd);
  EVAL((long)(Nonvirt2 *)dd - (long)dd);
  EVAL((long)(Nonvirt3 *)dd - (long)dd);
  EVAL((long)(Shared_Virt *)dd - (long)dd);
}



From coleen at zko.dec.com  Thu Jan 13 16:39:29 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 13 Jan 2000 11:39:29 -0500
Subject: Test cases for sharing virtual base vptrs 3 of 3.
Message-ID: <200001131639.AA23459@philli.zko.dec.com>

/*
Test case for sharing virtual bases.
In Most_Derived, share the vptr with
Interface2 but not Interface3, since
Interface3 is indirectly inherited.

Should get:
(long)(Interface1 *)dd - (long)dd = 0
(long)(Interface2 *)dd - (long)dd = 0
(long)(Interface3 *)dd - (long)dd = 8
(long)(Concrete1 *)dd - (long)dd = 8
*/

struct Interface1 {
    virtual void foo();
};
struct Interface2 : virtual Interface1 {
	virtual void bar();
};
struct Interface3 : virtual Interface2 {
	virtual void baz();
};

struct Concrete1 : virtual Interface3 {
	virtual void foo();
	int i; // important.
};

struct Most_Derived : virtual Interface1, 
		      virtual Interface2,
		      virtual Concrete1 {
	virtual void bar();
};

void Interface1::foo() {}
void Interface2::bar() {}
void Interface3::baz() {}
void Concrete1::foo() {}
void Most_Derived::bar() {}


extern "C" int printf(const char *,...);
#define EVAL(EXPR) printf( #EXPR " = %d\n", (EXPR) );
main()
{
  Most_Derived *dd = new Most_Derived;
  EVAL((long)(Interface1 *)dd - (long)dd);
  EVAL((long)(Interface2 *)dd - (long)dd);
  EVAL((long)(Interface3 *)dd - (long)dd);
  EVAL((long)(Concrete1 *)dd - (long)dd);
}



From coleen at zko.dec.com  Thu Jan 13 16:38:45 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 13 Jan 2000 11:38:45 -0500
Subject: Test cases for sharing virtual base vptrs 1 of 3.
Message-ID: <200001131638.AA24759@philli.zko.dec.com>

/*
Test case for sharing virtual bases.
In Derived_too,
the primary base class is NewShareme,
The bases Base and Shareme share vptr's
with Derived and are allocated at the
same offset as Derived.
Should get:
60% a.out
(long)(NewShareme *)dd - (long)dd = 0
(long)(Derived *)dd - (long)dd = 8
(long)(Base *)dd - (long)dd = 8
(long)(Shareme *)dd - (long)dd = 8
*/

struct Shareme {
    virtual void foo();
};
struct Base : virtual Shareme {
	virtual void bar();
};
struct Derived : virtual Base {
	virtual void baz();
};

struct NewShareme {
	virtual void foo();
};

struct Derived_too : virtual NewShareme, virtual Derived {
	virtual void bar();
};

void Shareme::foo() {}
void Base::bar() {}
void Derived::baz() {}
void NewShareme::foo() {}
void Derived_too::bar() {}


extern "C" int printf(const char *,...);
#define EVAL(EXPR) printf( #EXPR " = %d\n", (EXPR) );
main()
{
  Derived_too *dd = new Derived_too;
  EVAL((long)(NewShareme *)dd - (long)dd);
  EVAL((long)(Derived *)dd - (long)dd);
  EVAL((long)(Base *)dd - (long)dd);
  EVAL((long)(Shareme *)dd - (long)dd);
}



From ddd at cup.hp.com  Thu Jan 13 17:29:43 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 13 Jan 2000 17:29:43 +0000
Subject: Meeting agenda
References: <200001130634.WAA28916@baalbek.engr.sgi.com>
Message-ID: <387E0B87.81C5B6EE@cup.hp.com>

A few comments:

- Why would we need the beginning of the info block? All the routines I
specified were routines that I actually use in my implementation. I have no need
for the beginning of the info block. I don't remember the request either :-)

- You changed the stop function to return a bool rather than an int. I think
this is not sufficient. The value EH_INSTALL_CONTEXT may still need to be
returned, otherwise you would not be able to call the landing pads.

- You forgot the description of what happens if the stop function is NULL. I
think we agreed that the stop parameter would be a frame pointer in that case.


Christophe


Jim Dehnert wrote:
> 
> Following is an updated agenda.  The status pages are updated and on
> the web at:
> 
>         http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html
> 
> The contact info page is now also there, in password-protected PDF only
> for privacy.  The password is "not an orc".
> 
> The agenda is based on these priorities:
> 
>   A) Exception handling.
> 
>   B) Data layout.
> 
>   C) Initialization.
> 
>   D) Mangling.
> 
> So, take a look at the material associated with these issues:
> 
>   1) D-*:  Exceptions.  Verify my writeup of _Unwind_ForcedUnwind,
>      and any other issues with the document.  Answer the "Outstanding
>      Questions" at the beginning of the document.
> 
>   2) D-9:  Validate my last writeup, along with the forced unwind
>      definition, and close this.
> 
>   3) D-12:  Unwind table location.  (I did not do my duty and call
>      Cary.  Did Christophe talk to him?)
> 
>   4) D-14:  Can we close this?
> 
>   5) D-16:  Any feedback from implementors?
> 
>   6) A-17/18/19:  Resolve layout issues inspired by Mark.
> 
>   4) C-2:  Static link initialization and priorities.
>      Is there any further feedback from members about preferences?
> 
>   5) F-*:  Mangling.  We're awaiting a proposal from Daveed.
> 
> Issues that are active and awaiting proposals:
> 
>   a) C-4:  Daveed will write up construction vtables so we can
>      verify.  Wait.
> 
>   b) F-1, F-2:  Daveed will produce an initial proposal.  Wait.
> 
> Jim
> 
> -               Jim Dehnert  x3-4272



From coleen at zko.dec.com  Thu Jan 13 19:59:29 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 13 Jan 2000 14:59:29 -0500
Subject: Alternate picking virtual bases to share vptrs.
Message-ID: <200001131959.AA28424@philli.zko.dec.com>

/*
Jason had a good point about virtual base dominators, since (below)
Concrete1 dominates Interface1,2,and 3, it appears that virtual function
calls to 'foo' first convert to a Concrete1 before being called.  So in
this case, there's no point in sharing the vptr of Interface1 2 or 3
with the Most_Derived class.  (Correct me if I'm wrong about this
please, this is all experimental).

The alternate algorithm could then be:

Pick the first virtual base class in dfs order (I vote no
declaration order on the base class specifier list) that's not a
primary base class of any subobject of derived class to be
the primary base class of the derived class.  If there is no such
virtual base class, don't pick one.

I like dfs (depth first search) order because it's how our representation
stores them - it's painfully (and surprisingly) difficult to get back to
the order on the base class specifier list after it's parsed.

I just implemented this, it's pretty simple.

Test case for sharing virtual bases.  In Most_Derived, share the vptr with
Interface2 but not Interface3, since Interface3 is indirectly inherited.

Should get:
(long)(Interface1 *)dd - (long)dd = 8
(long)(Interface2 *)dd - (long)dd = 8
(long)(Interface3 *)dd - (long)dd = 8
(long)(Interface4 *)dd - (long)dd = 0
(long)(Concrete1 *)dd - (long)dd = 8
*/

struct Interface1 {
    virtual void foo();
};
struct Interface2 : virtual Interface1 {
	virtual void foo();
};
struct Interface3 : virtual Interface2 {
	virtual void foo();
};

struct Interface4 {
	virtual void foo();
};
struct Concrete1 : virtual Interface3, virtual Interface4 {
	virtual void foo();
	int i; // important.
};

struct Most_Derived : virtual Interface1, 
		      virtual Interface2,
		      virtual Concrete1 {
	virtual void bar();
};

void Interface1::foo() {}
void Interface2::foo() {}
void Interface3::foo() {}
void Interface4::foo() {}
void Concrete1::foo() {}
void Most_Derived::bar() {}


extern "C" int printf(const char *,...);
#define EVAL(EXPR) printf( #EXPR " = %d\n", (EXPR) );
main()
{
  Most_Derived *dd = new Most_Derived;
  EVAL((long)(Interface1 *)dd - (long)dd);
  EVAL((long)(Interface2 *)dd - (long)dd);
  EVAL((long)(Interface3 *)dd - (long)dd);
  EVAL((long)(Interface4 *)dd - (long)dd);
  EVAL((long)(Concrete1 *)dd - (long)dd);
  dd->foo();
}



From jason at cygnus.com  Thu Jan 13 21:27:36 2000
From: jason at cygnus.com (Jason Merrill)
Date: 13 Jan 2000 13:27:36 -0800
Subject: Alternate picking virtual bases to share vptrs.
In-Reply-To: Coleen Phillimore's message of "Thu, 13 Jan 2000 14:59:29 -0500"
References: <200001131959.AA28424@philli.zko.dec.com>
Message-ID: <u91z7lhdbr.fsf@yorick.cygnus.com>

>>>>> Coleen Phillimore <coleen at zko.dec.com> writes:

 > Jason had a good point about virtual base dominators, since (below)
 > Concrete1 dominates Interface1,2,and 3, it appears that virtual function
 > calls to 'foo' first convert to a Concrete1 before being called.  So in
 > this case, there's no point in sharing the vptr of Interface1 2 or 3
 > with the Most_Derived class.  (Correct me if I'm wrong about this
 > please, this is all experimental).

Actually, I disagree.  Let's consider:

A) Interface1 (or 2, 3, 4) is the primary base of Most_Derived
B) Interface1 is not the primary base of Most_Derived.

1) Calls to Interface1 functions overridden by Most_Derived
2) Calls to Interface1 functions overridden by Concrete1 and not Most_Derived

----

A) M_D gets I1's vtable at offset 0.
B) M_D gets its own vtable at offset 0.

A) Converting to I1 is a nop.
B) Converting to I1 requires a load from the vtable.

1A) The call requires no conversion.
1B) The call requires a load from the C1 secondary vtable.

2A) The call requires a load from the C1 secondary vtable.
2B) The call requires a load from the C1 secondary vtable.

----

It seems to me that choosing one of the virtual bases to be primary is a
definite win.

 > Pick the first virtual base class in dfs order (I vote no
 > declaration order on the base class specifier list) that's not a
 > primary base class of any subobject of derived class to be
 > the primary base class of the derived class.  If there is no such
 > virtual base class, don't pick one.

I would change this to:

Pick the first mostly-empty virtual base class in dfs order that is not
already at a fixed offset in M_D (i.e. not already the primary base of a
non-virtual base).

Jason



From mark at codesourcery.com  Sun Jan 16 20:40:52 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 16 Jan 2000 12:40:52 -0800
Subject: Terminology
Message-ID: <20000116124052G.mitchell@codesourcery.com>


Folks --

  This is a nit.

  I think we should find a term other than "polymorphic" to use in the
data layout specification. 

  The C++ standard says:

    [class.virtual]

    A class that declares or inherits a virtual function is called a
    polymorphic class. 

  but the ABI document says:

    polymorphic class:

    A class requiring a virtual table pointer (because it or its bases
    have one or more virtual member functions or virtual base
    classes).

  The ABI definition is broader than the C++ standard; the C++
standard does not include a class with no virtual functions but with
virtual bases.  That's a confusing overloading of terms.  For example,
g++ has an internal predicate called TYPE_POLYMORHPIC_P which uses the
C++ standard sense of the term, making for easy readibility.

  Unfortunately, the best term I can come up with is
"vptr-containing".  That is, after all, what distinguishes them.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Sun Jan 16 22:21:24 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 16 Jan 2000 14:21:24 -0800
Subject: Virtual base class offsets in vtables
Message-ID: <20000116142124L.mitchell@codesourcery.com>


Folks --

  o Why do we have two different ways of computing the order in
    which vbase offsets are laid out in the vtable?  (Category 3
    says left to right in declaration order; Category 4 says 
    in left-to-right depth-first order.)

  o Furthermore, it's unclear whether or not offsets for indirect
    virtual bases should be stored.  The Category 3 description
    seems to indicate that only *direct* bases should be stored;
    otherwise left-to-right declaration order isn't really
    well-defined.  But, Category 4 clearly says direct or indirect 
    bases.

  o The term `visible' used in the Category 4 specification is
    undefined.  This is a bad choice of terminolgy; visibility is
    used in the C++ standard to contrast with `hidden'.  Here, I
    think visible is meant to denote classes in the inheritance
    hierarchy dominated by the base.

  I suggest that we clarify this as follows:

  o Use a term other than `visible' and define it.
  o Remove the current descriptions of vbase offset ordering, and 
    replace them with:

  In the primary vtable, the vbase offsets are in the reverse order in
  which the virtual bases are encountered in a depth-first,
  left-to-right traversal of the inheritance graph.  In the secondary
  vtables for a given base B, offsets are only included for those
  virtual bases present in the primary vtable for B, and are present
  in the same order.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Jan 17 04:35:33 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 16 Jan 2000 20:35:33 -0800
Subject: Vtable offsets
Message-ID: <20000116203533Y.mitchell@codesourcery.com>


Folks --

  In the description of vcall offsets, we have:

    The vcall offset entries are allocated from the inside out, in the
    same order as the functions appear in A's vtables.

  I'm not sure what `from the inside out' means, but I think this is
meant to say something like:

    The vcall offset entries are allocated in the reverse order of
    the order in which the corresponding functions appear in A's
    vtables.  For example, the first entry in the vtable corresponds
    to the vcall offset entry closest to the point where the virtual
    function table pointer points.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From nathan at acm.org  Mon Jan 17 09:34:00 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Mon, 17 Jan 2000 09:34:00 +0000
Subject: RTTI data layout flaw
Message-ID: <3882E208.9B35466F@codesourcery.com>

Hi,

There is a flaw in the specified rtti data structures. The data
structures work only when a complete linked program has a definition of
all the required classes. However, C++ does not guarantee this. Here is
an example

-- fn1.cc
struct Foo;

void fn () {
  throw (Foo **)0;
}
-- main1.cc
struct Foo;
struct Bar;
void fn ();
int main () {
  try { fn ();}
  catch (Bar const *const *) { printf ("wrong\n");}
  catch (Foo const *const *) { printf ("ok\n");}
  return 0;
}

Notice, I'm dealing with **, which is a pointer to complete type, so
[except.throw]/3 and [except.handle]/1 do not prevent this.

A complete program consisting of fn1.o and main1.o, is well defined and
should print "ok\n", not "wrong\n". The difficulty is that the compiler
never saw any definition of Foo or Bar, so what does it output as the
type_info object for them? The type_info object for Foo ** consists of
__pointer_type_info
->__pointer_type_info
  ->What?

We cannot use weak linkage for a Foo type_info object, as, in this case
that would resolve to zero, and be indistinguishable from the Bar in
Bar **.

Another choice would be to emit an empty __class_type_info object, but
then what ensures that the real __class_type_info object is resolved to,
when linked with an object file which does contain a definition of Foo?

One choice which might work is some kind of __class_proxy_type_info,
which contains a single member pointing to the real __class_type_info
object with weak linkage. The name mangling for a
__class_proxy_type_info will be different to that of a __class_type_info
object. In the above case, Foo ** would be represented as
__pointer_type_info
->__pointer_type_info
  ->__class_proxy_type_info
    ->(weakly)__class_type_info.
The final __class_type_info object is not emitted in the compilation
unit, as Foo's definition is never seen. Now, we can distinguish
`Bar const *const *' from `Foo const *const *', as the inner pointers
will point to different __class_proxy_type_info objects.

In pointer_type_info's we do not need to go via a
__class_proxy_type_info, if the compilation unit has seen the
definition of the pointed-to class. The catch matching algorithm will
need to be aware that it might be given two paths, one of which goes
via a class_proxy_type_info, and one that does not. In this case, the
class_proxy_type_info should point to the real class.

type_info::operator == is not affected by proxies. Proxies are only
important when traversing the pointer heirarchy in catch matching.

There is a difficulty with DSO's containing the definition of the
class, and loaded into programs without the definition. Here is an
example, with some pseudo code describing the loading.

--fn2.cc
struct Foo {};
struct Bar : Foo {};
void fn1 () {
  throw (Foo const **)0;
}
void fn2 () {
  try
    { throw (Bar *)0;}
  catch (Foo *)
    {}
  catch (...)
    {abort ();}
}
--main2.cc
struct Foo;

int main ()
{
  handle == dlopen ("fn2"); // load the library
  void (*f1) () = dlsymbol (handle, "fn1"); // get fn1 entry
  void (*f2) () = dlsymbol (handle, "fn2"); // get fn2 entry
  
  try
    { (*f1) ();}
  catch (Foo **)
    { printf ("ok\n");}
  (*f2) ();
}

This should print "ok\", and not call abort in fn2. But, consider what
the type_info objects look like. Here I've assumed a name mangling,

fn2.o (before loading)
__ti_Foo:__class_type_info
        Foo's descriptor
__ti_pFoo:__pointer_type_info
        target = &__ti_Foo
__ti_ppFoo:__pointer_type_info
        target = &__ti_pFoo
__ti_Bar:__si_class_type_info
        Bar's descriptor
        base = &__ti_Foo
__ti_pBar:__pointer_type_info
        target = &__ti_Bar

main2.o (before loading)
__ti_proxy_Foo:__class_proxy_type_info
        target = &__ti_Foo (weak, zero)
__ti_pFoo:__pointer_type_info
        target = &__ti_proxy_Foo
__ti_ppFoo:__pointer_type_info
        target = &__ti_pFoo (this will be NULL)

When fn2 is loaded, COMDAT linkage will resolve some of the symbols in
fn2, to those in main2. Namely __ti_pFoo & __ti_ppFoo.
Consider what happens in the catch clause of fn2. The thrown type_info
will be __ti_pBar, which fully describes a pointer to Bar. The catch
type_info will be __ti_pFoo, which is the instance defined in main2.
This does not fully describe a pointer to Foo, as the proxy's target is
NULL. To get this to work, the proxy's target needs adjusting.

I'm not familiar with the nitty gritty details of DSO loading, nor with
SO loading, to know whether the above behaves as desired. As the ABI
should support shared libraries, we need to ensure it works for those. I
do not know whether another goal is to support DSO's.

nathan
-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From loewis at informatik.hu-berlin.de  Mon Jan 17 11:32:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 17 Jan 2000 12:32:55 +0100
Subject: RTTI data layout flaw
In-Reply-To: <3882E208.9B35466F@codesourcery.com> (message from Nathan Sidwell
	on Mon, 17 Jan 2000 09:34:00 +0000)
References: <3882E208.9B35466F@codesourcery.com>
Message-ID: <200001171132.MAA06918@pandora>

> One choice which might work is some kind of __class_proxy_type_info,
> which contains a single member pointing to the real __class_type_info
> object with weak linkage.

Alternatively, wouldn't it be sufficient to hava an
__incomplete_type_info, with no additional data? That could have weak
linkage, and be overridden by the __class_type_info, if one is
provided in the complete program.

Regards,
Martin




From loewis at informatik.hu-berlin.de  Mon Jan 17 12:37:17 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 17 Jan 2000 13:37:17 +0100
Subject: Terminology
In-Reply-To: <20000116124052G.mitchell@codesourcery.com> (message from Mark
	Mitchell on Sun, 16 Jan 2000 12:40:52 -0800)
References: <20000116124052G.mitchell@codesourcery.com>
Message-ID: <200001171237.NAA08250@pandora>

>   Unfortunately, the best term I can come up with is
> "vptr-containing".  That is, after all, what distinguishes them.

As an opposite to POD: SND - striking new data :-)

Martin



From mark at codesourcery.com  Mon Jan 17 18:26:04 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 17 Jan 2000 10:26:04 -0800
Subject: Terminology
In-Reply-To: <200001171237.NAA08250@pandora>
References: <20000116124052G.mitchell@codesourcery.com>
	<200001171237.NAA08250@pandora>
Message-ID: <20000117102604K.mitchell@codesourcery.com>

>>>>> "Martin" == Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

    >> Unfortunately, the best term I can come up with is
    >> "vptr-containing".  That is, after all, what distinguishes
    >> them.

    Martin> As an opposite to POD: SND - striking new data :-)

:-) indeed!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Tue Jan 18 14:06:23 2000
From: jason at cygnus.com (Jason Merrill)
Date: 18 Jan 2000 06:06:23 -0800
Subject: Virtual base class offsets in vtables
In-Reply-To: Mark Mitchell's message of "Sun, 16 Jan 2000 14:21:24 -0800"
References: <20000116142124L.mitchell@codesourcery.com>
Message-ID: <u9r9ffcw4g.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >   o Furthermore, it's unclear whether or not offsets for indirect
 >     virtual bases should be stored.  The Category 3 description
 >     seems to indicate that only *direct* bases should be stored;
 >     otherwise left-to-right declaration order isn't really
 >     well-defined.  But, Category 4 clearly says direct or indirect 
 >     bases.

The idea is to promote vbase offsets, like virtual function entries, out of
virtual bases and not non-virtual bases.

 >   In the primary vtable, the vbase offsets are in the reverse order in
 >   which the virtual bases are encountered in a depth-first,
 >   left-to-right traversal of the inheritance graph.  In the secondary
 >   vtables for a given base B, offsets are only included for those
 >   virtual bases present in the primary vtable for B, and are present
 >   in the same order.

I'm not sure what you mean by "present in the primary vtable".

Jason



From jason at cygnus.com  Tue Jan 18 14:06:41 2000
From: jason at cygnus.com (Jason Merrill)
Date: 18 Jan 2000 06:06:41 -0800
Subject: Vtable offsets
In-Reply-To: Mark Mitchell's message of "Sun, 16 Jan 2000 20:35:33 -0800"
References: <20000116203533Y.mitchell@codesourcery.com>
Message-ID: <u9ogajcw3y.fsf@yorick.cygnus.com>

Yup, that's what I had in mind.

Jason



From mark at codesourcery.com  Tue Jan 18 18:26:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 18 Jan 2000 10:26:58 -0800
Subject: Vtable offsets
In-Reply-To: <u9ogajcw3y.fsf@yorick.cygnus.com>
References: <20000116203533Y.mitchell@codesourcery.com>
	<u9ogajcw3y.fsf@yorick.cygnus.com>
Message-ID: <20000118102658B.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> Yup, that's what I had in mind.

Thanks for clarifying.  

Perhaps some variant on the wording I used will make it into the spec
itself.  For reference, here it is again:

    The vcall offset entries are allocated in the reverse order of
    the order in which the corresponding functions appear in A's
    vtables.  For example, the first entry in the vtable corresponds
    to the vcall offset entry closest to the point where the virtual
    function table pointer points.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Jan 18 18:34:34 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 18 Jan 2000 10:34:34 -0800
Subject: Virtual base class offsets in vtables
In-Reply-To: <u9r9ffcw4g.fsf@yorick.cygnus.com>
References: <20000116142124L.mitchell@codesourcery.com>
	<u9r9ffcw4g.fsf@yorick.cygnus.com>
Message-ID: <20000118103434A.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    >> o Furthermore, it's unclear whether or not offsets for indirect
    >> virtual bases should be stored.  The Category 3 description
    >> seems to indicate that only *direct* bases should be stored;
    >> otherwise left-to-right declaration order isn't really
    >> well-defined.  But, Category 4 clearly says direct or indirect
    >> bases.

    Jason> The idea is to promote vbase offsets, like virtual function
    Jason> entries, out of virtual bases and not non-virtual bases.

I'm not sure I understand.  But, let's see if this is what we want:

  For a primary vtable, there is exactly one vbase offset entry for
  each direct and indirect virtual base class.  The order in which
  these entries appear in the vtable is in the reverse order of the
  order in which the virtual bases are encountered in a left-to-right
  depth-first traversal of the inheritance heirarchy.  In other words,
  the offset for the first base encountered on the traversal is stored
  closest to the point where the vptr will point.

  For an S-as-T vtable, the vbase offset entries from the primary
  vtable for T are replaced with appropriate offsets given the
  completed hierarchy.

I think that's a uniform definition that should cover both Category 3
and Category 4.

    Jason> I'm not sure what you mean by "present in the primary
    Jason> vtable".

OK -- I tried to clarify this in the indented second pargraph above.

Thanks for your feedback,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Tue Jan 18 22:29:49 2000
From: jason at cygnus.com (Jason Merrill)
Date: 18 Jan 2000 14:29:49 -0800
Subject: Virtual base class offsets in vtables
In-Reply-To: Mark Mitchell's message of "Tue, 18 Jan 2000 10:34:34 -0800"
References: <20000116142124L.mitchell@codesourcery.com> <u9r9ffcw4g.fsf@yorick.cygnus.com> <20000118103434A.mitchell@codesourcery.com>
Message-ID: <u91z7fc8te.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:
 >>> o Furthermore, it's unclear whether or not offsets for indirect
 >>> virtual bases should be stored.  The Category 3 description
 >>> seems to indicate that only *direct* bases should be stored;
 >>> otherwise left-to-right declaration order isn't really
 >>> well-defined.  But, Category 4 clearly says direct or indirect
 >>> bases.

 Jason> The idea is to promote vbase offsets, like virtual function
 Jason> entries, out of virtual bases and not non-virtual bases.

 > I'm not sure I understand.  But, let's see if this is what we want:

 >   For a primary vtable, there is exactly one vbase offset entry for
 >   each direct and indirect virtual base class.

Not exactly; we only have entries for indirect virtual base classes that
are reached through another virtual base.

Jason



From mark at codesourcery.com  Tue Jan 18 23:02:14 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 18 Jan 2000 15:02:14 -0800
Subject: Virtual base class offsets in vtables
In-Reply-To: <u91z7fc8te.fsf@yorick.cygnus.com>
References: <u9r9ffcw4g.fsf@yorick.cygnus.com>
	<20000118103434A.mitchell@codesourcery.com>
	<u91z7fc8te.fsf@yorick.cygnus.com>
Message-ID: <20000118150214I.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> Not exactly; we only have entries for indirect virtual base
    Jason> classes that are reached through another virtual base.

OK -- I see.  So, to find an indirect virtual base that is not reached
through another virtual base, we first convert though non-virtual
bases until we reach the point where the virtual base is a direct
base; then we use the vbase offset that we can find in the vtable for
that base.

What about:

  struct S { };
  struct T : virtual public S {};
  struct U : virtual public T {};
  struct V : public T, virtual public U {};

Do we have a vbase offset in `V' for `S'?  It's reachable by
non-virtual inheritance as the direct base of `T', but it is also
reachable through a virtual base.  The sentence quoted above would
seem to suggest that we do have a vbase offset for it -- but that
doesn't make a lot of sense given that we wouldn't were `U' entirely
out of the picture.

I'm not sure I think this degree of complexity is a good idea.  The
chances of misimplementing the ABI (and thereby making it less
valuable) increase with each bit of complexity.  

And, entries in vtables are very cheap -- that's the motivation for
putting the vbase entries there in the first place.  Why make it more
expensive to convert to an indirect virtual base than a direct virtual
base, just to save a few entries in the statically initialized vtable?
Or, conversely, why put *any* entries for indirect vbases in the
vtable when you could always just walk a path to the vbase, even if
doing so required going through several other vbases?  Why is this the
right tradeoff?

In any case, such analysis aside, would you mind writing up a more
rigorous description of the scheme that's been decided upon?  That
description will make it much easier to make sure that we're all
getting this stuff right.

Thanks again for your help,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Jan 19 00:47:01 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Jan 2000 16:47:01 -0800 (PST)
Subject: Terminology
Message-ID: <200001190047.QAA42324@baalbek.engr.sgi.com>

> Folks --
> 
>   This is a nit.
> 
>   I think we should find a term other than "polymorphic" to use in the
> data layout specification. 
> 
>   The C++ standard says:
> 
>     [class.virtual]
> 
>     A class that declares or inherits a virtual function is called a
>     polymorphic class. 
> 
>   but the ABI document says:
> 
>     polymorphic class:
> 
>     A class requiring a virtual table pointer (because it or its bases
>     have one or more virtual member functions or virtual base
>     classes).
> 
>   The ABI definition is broader than the C++ standard; the C++
> standard does not include a class with no virtual functions but with
> virtual bases.  That's a confusing overloading of terms.  For example,
> g++ has an internal predicate called TYPE_POLYMORHPIC_P which uses the
> C++ standard sense of the term, making for easy readibility.
> 
>   Unfortunately, the best term I can come up with is
> "vptr-containing".  That is, after all, what distinguishes them.

I agree that being at variance with a Standard definition is bad,
but I'm not too fond of "vptr-containing".  Anyone have a better
suggestion?  Better, I think, but still not ideal, might be
pseudo-polymorphic...

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 19 03:11:30 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Jan 2000 19:11:30 -0800 (PST)
Subject: Virtual base class offsets in vtables
References: <u9r9ffcw4g.fsf@yorick.cygnus.com>
    <20000118103434A.mitchell@codesourcery.com>
    <u91z7fc8te.fsf@yorick.cygnus.com>
Message-ID: <200001190311.TAA42360@baalbek.engr.sgi.com>

Mark,

Thanks for continuing to identify sources of confusion.  I've attempted
to fix the questions related to this thread, and have posted the
updated abi-layout.html on the web site.  (There will be more changes
for other issues soon.)  The relevant stuff is in red, and includes
your example.

> From: Mark Mitchell <mark at codesourcery.com>
> 
> Folks --
> 
>   o Why do we have two different ways of computing the order in
>     which vbase offsets are laid out in the vtable?  (Category 3
>     says left to right in declaration order; Category 4 says 
>     in left-to-right depth-first order.)

Unintentional.  It's the same now.

>   o Furthermore, it's unclear whether or not offsets for indirect
>     virtual bases should be stored.  The Category 3 description
>     seems to indicate that only *direct* bases should be stored;
>     otherwise left-to-right declaration order isn't really
>     well-defined.  But, Category 4 clearly says direct or indirect 
>     bases.

Cleaned up.

>   o The term `visible' used in the Category 4 specification is
>     undefined.  This is a bad choice of terminolgy; visibility is
>     used in the C++ standard to contrast with `hidden'.  Here, I
>     think visible is meant to denote classes in the inheritance
>     hierarchy dominated by the base.

"visible" is now gone.


> From: Mark Mitchell <mark at codesourcery.com>
> 
> OK -- I see.  So, to find an indirect virtual base that is not reached
> through another virtual base, we first convert though non-virtual
> bases until we reach the point where the virtual base is a direct
> base; then we use the vbase offset that we can find in the vtable for
> that base.
> 
> What about:
> 
>   struct S { };
>   struct T : virtual public S {};
>   struct U : virtual public T {};
>   struct V : public T, virtual public U {};
> 
> Do we have a vbase offset in `V' for `S'?  It's reachable by
> non-virtual inheritance as the direct base of `T', but it is also
> reachable through a virtual base.  The sentence quoted above would
> seem to suggest that we do have a vbase offset for it -- but that
> doesn't make a lot of sense given that we wouldn't were `U' entirely
> out of the picture.

My proposed rewriting is that if something is accessible either via a
virtual or a non-virtual base, the first (left-to-right) determines.
It's arbitrary but clear, I think.

> I'm not sure I think this degree of complexity is a good idea.  The
> chances of misimplementing the ABI (and thereby making it less
> valuable) increase with each bit of complexity.  
> 
> And, entries in vtables are very cheap -- that's the motivation for
> putting the vbase entries there in the first place.  Why make it more
> expensive to convert to an indirect virtual base than a direct virtual
> base, just to save a few entries in the statically initialized vtable?
> Or, conversely, why put *any* entries for indirect vbases in the
> vtable when you could always just walk a path to the vbase, even if
> doing so required going through several other vbases?  Why is this the
> right tradeoff?

I believe that the secondary vtables for non-virtual bases are at known
offsets from the derived class vtable.  At least that was once the
intent, if we haven't lost it.  In that case, it's not more expensive
to get at an indirect virtual base -- its offset is always at a known
point, whether negative (direct virtual) or positive (indirect virtual
via non-virtual base).

> In any case, such analysis aside, would you mind writing up a more
> rigorous description of the scheme that's been decided upon?  That
> description will make it much easier to make sure that we're all
> getting this stuff right.

Is what's there now better?  Enough?

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From daveed at edg.com  Wed Jan 19 05:31:13 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Tue, 18 Jan 2000 21:31:13 -0800
Subject: Mangling: initial attempt
Message-ID: <38854C21.A0AAC0E@edg.com>

Hi all & Happy New Year 2000!

I've finally gotten around to put together a name mangling proposal.
It's not complete, not tested, and not formally validated, but it's
a start derived from intuitin.

Hopefully the description is sufficiently clear from the examples;
I admit the words are terse. (There are a bunch of examples at the
end.)

Feedback welcome,

	Daveed
-------------- next part --------------
Name mangling
=============

[ Notes:
   1) Most of the "special entities" spec is still missing.
   2) The truncation+hashing approach needs to be described if desired.
   3) A proof of nonambiguity is needed.
   4) Many things (e.g., the <prefix>) may need tweaking.
--end Notes ]

Entities with C linkage and file scope variables are not mangled.

General structure
-----------------

    <prefix><length><name><specialization>opt<type>opt<scope>opt

<prefix> is one of:
   . "_0" for namespace scope variables and static data members
   . "_1" for nontemplate nonoperator functions
   . "_2" for template nonoperator functions
   . "_3" for nontemplate operator functions
   . "_4" for template operator functions
   . "_5" for special entities (constructors etc; see below)

<length> is the decimal representation of the length of <name>.

<name> is one of:
   . the unqualified variable name for namespace scope variables
   . the unqualified member name for static data members
   . the unqualified function name for nonoperator nontemplate functions
   . the unqualified function template name for nonoperator template functions
   . an encoding of the operator for operator functions
   . a reserved encoding special entities (constructors etc; see below)

<specialization> encodes the template arguments for function templates.

<type> is used to disambiguate overloaded functions, but also to
distinguish the various virtual tables associated with a given complete
class type.  For nontemplate functions, <type> lists the parameter types
only. For template functions, <type> lists the return type followed by
the parameter types. <type> is omitted for variables and static data
members.

<scope> encodes the class or namespace scope that the function belongs to.
For virtual tables and RTTI structures, <scope> encodes the type for which
it is defined.

Operator encodings
------------------

Operators appear as function names, but also in nontype template argument
expressions.
   new           nw
   new[]         na
   delete        dl
   delete[]      da
   - (unary)     ng
   & (unary)     ad
   * (unary)     de
   ~             co
   +             pl
   -             mi
   *             ml
   /             dv
   %             rm
   &             an
   |             or
   ^             eo
   =             aS
   +=            pL
   -=            mI
   *=            mL
   /=            dV
   %=            rM
   &=            aN
   |=            oR
   ^=            eO
   <<            ls
   >>            rs
   <<=           lS
   >>=           rS
   ==            eq
   !=            ne
   <             lt
   >             gt
   <=            le
   >=            ge
   !             nt
   &&            aa
   ||            oo
   ++            pp
   --            mm
   ,             cm
   ->*           pm
   ->            pt
   ()            cl
   []            ix
   ?             qu
   (cast)        cv

Unlike Cfront, unary and binary operators using the same symbol have
different encodings.  All operators are encoded using exactly two letters,
the first of which is lowercase.

Other special functions and entities
------------------------------------

   TV            virtual table
   TI            typeinfo structure
   C1            complete object constructor
   C2            base object constructor
   D0            deleting destructor
   D1            complete object destructor
   D2            base object destructor


Type encodings
--------------
Types are encoded as follows:

builtin types: (one letter)
   void                     v
   wchar_t                  w
   bool                     b
   char                     c
   signed char              a
   unsigned char            h
   short                    s
   unsigned short           t
   int                      i
   unsigned int             j
   long                     l
   unsigned long            m
   long long                x
   unsigned long long       y
   float                    f
   double                   d
   long double              e
   ellipsis                 z

classes & enums:
   <decimal length of unqualified name><unqualified-name>
   Class names can optionally be followed by the encoding of a template
   argument list (see below).

template params (including nontype parameters):
   T<param num>_
   TT<param num>_  // For template template parameters

other dependent names: (see below)
   N<qual 1>...<qual N><unqual name>E

template argument list: (see below)
   I<arg1>...<argN>E

function types:
   F<return type><param type 1>...<param type N>E

array types:
   A<dimension>_<element type encoding>

pointers, references:
   P<encoding pointed-to type>
   R<encoding pointed-to type>

pointer-to-member:
   M<class type encoding><member type encoding>

cv-qualifiers:
   K const
   V volatile
   r restrict


Scope encoding
--------------
Namespace names are encoded like those of classes and enumerations.
The encoding for the <scope> segment (i.e., a qualifier) has the following
format:
   Q<qual 1>...<qual N>E
where each <qualJ> is the encoding of a class name or a namespace name.

Scope can also appear inside <type> to denote dependent types or bind
specific names as arguments. In that case the format is:
   N<qual 1>...<qual N><unqual name>E


Template argument encoding
--------------------------
Template-ids are encoded by following the unqualified name with
	I<arguments>E
This is used for the <specialization> segment in particular, but also in the
<type> and <scope> segments.

Type arguments appear using their regular encoding.  For example, the
template class "A<char, float>" is encoded as "1AIcfE".  A slightly more
involved example might be a dependent function parameter type "A<T2>::X"
(T2 is the second template parameter) which is encoded as "N1AIT2_E1XE",
where the "N...E" construct is used to describe a qualified name.

Nontype arguments can be:
   a) a literal, e.g. "A<42L>": these are encoded as "L<num><type>E";
      hence "A<42L>" becomes "1AIL42lEE". (false is "0b"; true is "1b")
   b) a reference to an entity with external linkage: encoded with
      "L<mangled name>E".  For example:
          void foo(char); // mangled as _13fooc
          template<void (&)(char)> struct CB;
          // CB<foo> is encoded with "2CBIL_13foocEE"
   c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix traversal
      of the operators involved, delimited by "X...E".  The operators are
      encoded using their two letter mangled names.  For example, "B<(J+1)/2>"
      becomes "1BI Xdv pl T1_ L1iE L2iE E E" (the blanks were inserted to
      visualize the decomposition).
    
Compression
-----------
The subsequence
   S<num>_
is used to repeat the num-th most recently encoded type (in right-to-left
order, starting at "1"), but only if "S<num>_" is strictly shorter that the
previous encoding.


Truncation
----------
If the mangled name exceeds 255 characters in length, it is reduced as
follows:
    (description of strong hash and truncation)



Examples
--------

1) "f": The C function or variable "f" or a file scope variable "f".

2) "_11f": Ret? f();

3) "_11fi": Ret? f(int);

4) "_13foo3bar": Ret? foo(bar);

5) "_3rm1X1X": Ret? operator%(X, X);

6) "_3plR1XR1X": Ret? operator+(X&, X&);

7) "_3lsRK1XS1_": Ret? operator(X const&, X const&);
       (Note: strlen("S1_")<strlen("RK1X"))

8) "_21fIiE": void f<int>();

9) "_21fIiEvi": void f<int>(/*nondependent*/int);
       (Note: the return type is always explicitly encoded for template
              functions taking parameters.)

10) "_25firstI3DuoEvS2_": void first<Duo>(/*nondependent*/Duo);
       (Note: "S1_" would refer to the "void" return type.)

11) "_25firstI3DuoEvT1_": void first<Duo>(/*T1=*/Duo);

12) "_11fQ1N": Ret? N::f();

13) "_14beepQ6System5Sound: Ret? System::Sound::beep();

14) "_05levelQ5Arena": Type? Arena::level;

15) "_05levelQ5StackIiiE": Type? Stack<int, int>::level

16) "_21fI1XEvPVN1AIT1_E1TE": void f<X>(A</*T1=*/X>::T volatile*);
                |         |
                |         `------> end dependent name encoding
                `----------------> start of dependent name A<T1>::T

17) "_4ngIL42iEEvN1AIXplT1_L2iEE1TE": void operator-</*int J=*/42>(A<J+2>::T);


From dehnert at baalbek.engr.sgi.com  Wed Jan 19 06:26:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Jan 2000 22:26:35 -0800 (PST)
Subject: RTTI inconsistency
Message-ID: <200001190626.WAA43447@baalbek.engr.sgi.com>

> From: Nathan Sidwell <sidwell at codesourcery.com>
> 
> Hi,
> there is an inconsistency in the documentation of how a vtable
> points to the type_info object for that type.
> 
> The abi layout document Run-Time Type Information (RTTI) section states,
> 
> 3.Every vtable shall contain one entry pointing to an object derived
> 	from std::type_info. This entry is located at the word preceding
> 	the location pointed to by the vptr (i.e., entry "-1"). The
> 	entry is allocated in all vtables; for classes having virtual bases
> 	but no virtual functions, the entry is zero. This entry is coded
> 	as an offset with respect to the virtual table origin, rather than as
> 	a pointer (thereby avoiding run-time relocations). 

This one is incorrect.  I've fixed it.  Thanks for the observation.

> but the closed issues document section A-6 ends by saying
> 	[991028 all] The current definition, in the ABI data layout document,
> 	has been updated with Daveed's changes, and is accepted. Note that we
> 	are back to using a pointer to RTTI in the vtable (see B-8)...
> 
> Also the Virtual Table Layout section of the ABI document says,
> 	The typeinfo pointer points to the typeinfo object used for RTTI.
> 	All entries in each of the vtables for a given class must point to the
> 	same typeinfo object. A correct implementation of typeinfo equality is
> 	to check pointer equality. 
> 
> so which is it? An offset or a pointer? (I think it has to be a pointer to
> get uniqueness.)

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 19 06:42:00 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Jan 2000 22:42:00 -0800 (PST)
Subject: RTTI queries
Message-ID: <200001190642.WAA26128@baalbek.engr.sgi.com>

Hi, all,

I can't answer these questions with confidence, so I'd like to go over
them in the meeting Thursday (unless someone can reliably answer them
in email Wednesday).

Also, I observe in looking at this the "polymorphic" flag in
__class_type_info.  Do we mean the Standard definition of this,
or do we mean our ABI pseudo-polymorphic definition, i.e. "has a
vtable?"

Jim

> Date: Thu, 06 Jan 2000 11:20:09 +0000
> From: Nathan Sidwell <nathan at acm.org>
> 
> Hi,
> I'm in the process of implementing the runtime rtti code in g++ for
> CodeSourcery LLC. I have a number of queries and comments on the 
> C++ ABI for IA64: Data Layout document
> (http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html)
> 
> 1) the declaration of __vmi_class_info uses a helper class of the
> following
>         struct __base_class_info {
>         type_info *type;
>         ptrdiff_t offset;
>         int vmi_flags;
>         }
> 1.1) I beleive `type' should be declared `__class_type_info const *type'
> (the description of __ptr_to_member_type_info has such a pointer and uses
> __class_type_info). The description of __si_class_type_info is vague on the
> base pointer's type, but that too should be `__class_type_info const *type'.
> 
> 1.2) From the description of __vmi_class_info it appears that the base
> class array uses the trailing array struct hack. This is ok, because
> it is always generated by the compiler. This is not documented.
> 
> 1.3) I cannot find a definition of what the `offset' member of
> __base_class_info is an offset for. For a virtual base it cannot be
> the offset from this base to the virtual base as that changes for different
> bases in a heirarchy. I presume it must be the offset in the vtable to the
> base offset. This is not documented.

This appears to be correct.

> 2) The ABI document specifies
> 
> void *__dynamic_cast (void *sub, __class_type_info *src,
>                 __class_type_info *dst, ptrdiff_t sr2dst_offset);
> 
> this is not const correct, I beleive it should be
> 
> void *__dynamic_cast (const void *sub, const __class_type_info *src,
>                 const __class_type_info *dst, ptrdiff_t sr2dst_offset);
> 
> 3) __class_type_info contains a set of details flags. Whilst these look
> useful, I'm not sure that they are. When porting g++'s current dynamic_cast
> machinery (which as the document points out is semantically the same), these
> flags showed little use.
> 
> 3.1) flag 0x8 says `has privately inherited base'. Does this really mean
> private or does it actually mean non-public? both catch matching and dynamic
> cast distinguish public and non-public, not private and non-private.
> 
> 3.2) More useful for dynamic cast, (and possibly catch matching) would be
> the following flags
> 	* Contains non-diamond shaped multiple base object
> 	* Is diamond shaped
> 	* has virtual base
> 	* has non-virtual base
> 	* has public base
> 	* has non-public base
> Note that the virtual/non-virtual and public/non-public are not mutually
> exclusive. Also note that I have not actually implemented anything with these
> flags, so I could be wrong.
> 
> 4) The name mangling scheme for type_info objects is not defined. Therefore
> I don't know how to name the type_info objects required in the runtime for
> the fundamental types (and their pointers). I see this is on today's agenda.

And we'll finally get to it two weeks later :-).

> nathan
> 
> -- 
> Dr Nathan Sidwell :: sidwell at codesourcery.com
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/
> 
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 19 10:01:26 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 19 Jan 2000 02:01:26 -0800 (PST)
Subject: Exception handling
Message-ID: <200001191001.CAA43738@baalbek.engr.sgi.com>

I've updated the EH specification based on last week's meeting.
In addition to a variety of minor items, there are a couple of substantive
areas of change that you should look at.  I've tried to identify them
with a red font in the HTML (PDF is not yet updated).

  - I've added a unified list of reason codes, with the _Unwind prefix,
    and referenced it in multiple places, including the throw routines.
    In particular, I've used its type in several places instead of int
    and uint64 -- we need to identify the right type.

  - I've cleaned up the _Unwind_ForcedUnwind definition.

Please take a close look.  We'll talk about it Thursday.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From sidwell at codesourcery.com  Wed Jan 19 10:23:16 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Wed, 19 Jan 2000 10:23:16 +0000
Subject: More rtti queries
Message-ID: <38859094.F763A77F@codesourcery.com>

Hi,

1)
Am I just having a thinko, but when would a type_info of a reference
ever be generated? (So why __ref_type_info?)

typeid(T) will strip the reference [expr.typeid]/4
a thrown type will never be a reference, [except.throw]/3
a catch type ignores a reference [expr.handle]/3
an exception specification can contain a reference, but behaves the same
as a catch would. [except.spec]

2)
Is __ptr_to_member_type_info for just member data, or both member data
and member functions. The standard uses `pointer to member' to mean
`pointer to member data', but given the inconsistency which as popped
up with polymorphic, I'm not sure. It's also named inconsistently to
__pointer_type_info, and might be considered a subclass of that :-)

nathan
-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From brender at gemevn.zko.dec.com  Wed Jan 19 13:19:30 2000
From: brender at gemevn.zko.dec.com (Ron 603-884-2088)
Date: Wed, 19 Jan 2000 08:19:30 -0500
Subject: Terminology
Message-ID: <00011908193077@gemevn.zko.dec.com>


>I agree that being at variance with a Standard definition is bad,
>but I'm not too fond of "vptr-containing".  Anyone have a better
>suggestion?  Better, I think, but still not ideal, might be
>pseudo-polymorphic...

How does super-polymorphic grab ya, since the ABI notion is a superset of
the language term? It sounds a bit grandios, but perhaps captures the right
concept...

Ron



From loewis at informatik.hu-berlin.de  Wed Jan 19 16:29:31 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 19 Jan 2000 17:29:31 +0100
Subject: Terminology
In-Reply-To: <00011908193077@gemevn.zko.dec.com> (brender@gemevn.zko.dec.com)
References: <00011908193077@gemevn.zko.dec.com>
Message-ID: <200001191629.RAA28640@pandora>

> How does super-polymorphic grab ya, since the ABI notion is a superset of
> the language term? It sounds a bit grandios, but perhaps captures the right
> concept...

Sounds alright to me.

Regards,
Martin



From cary at cup.hp.com  Wed Jan 19 20:32:04 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 19 Jan 2000 12:32:04 -0800
Subject: Terminology
Message-ID: <200001192031.MAA18551@adlmail.cup.hp.com>

I suggest "simple class" vs. "complex class".

-cary



From austern at isolde.engr.sgi.com  Thu Jan 20 05:33:05 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 19 Jan 2000 21:33:05 -0800
Subject: Array placement new
In-Reply-To: Christophe de Dinechin <ddd@cup.hp.com>
        "Why __cxa_end_catch does not take an argument..." (Dec 17,  1:19am)
References: <38598FAA.2A9E827F@cup.hp.com>
Message-ID: <10001192133.ZM93722@isolde.engr.sgi.com>

Sorry about sending this so late.  As usual, I didn't remember to
write it up until Jim prodded me.

			--Matt

WHAT THE STANDARD SAYS. (3.7.3.1, 5.3.4, and 18.4.1.3)

Array placement new has the form "new(ARGS) T[n]".  After finding
the appropriate operation new, it obtains storage with
    void* p = operator new[](n1, ARGS),
where n1 >= n * sizeof(T).  It then constructs n objects of type
T starting at position p1, where p1 = p + delta.  The return
value is p1.

If T is "char" or "unsigned char" we are guaranteed that delta is
a nonnegative multiple of the most stringent alignment constraint
for objects of size less than or equal to n (5.3.4/10).
Otherwise the only restriction is that delta is nonnegative.

Some implementations store the number of elements in the array at
a negative offset from p1.  The standard neither requires nor
forbids it.

There's a predefined array operator new,
    ::operator new[](size_t n1, void* p),
that does nothing but return p.  p must be a pointer to the
beginning of some array of size at least n1.  The standard
doesn't tell users how large an array they need.  Many users
probably assume that it's sufficient for the array to be of size
n * sizeof(T), but there's no basis in the standard for that
assumption.

WHAT THE ABI NEEDS TO SPECIFY

(1) Given n, T, sizeof(T), and alignof(T), what are n1 and delta?
    (a) Are T=char and T=unsigned char special cases?  (Or,
        perhaps, is sizeof(T)=1 a special case?)
    (b) Is ::operator new[](size_t, void*) a special case?
(2) Do we store n at a negative offset from the return value of
    operator new[]? (This affects the answer to question 1.)
    If so, we need to specify precisely what that offset is.
    Note that (3.7.3.1/2) we are guaranteed that the return value
    of ::operator new[] is suitably aligned for objects of any
    type.




From dehnert at baalbek.engr.sgi.com  Thu Jan 20 07:24:36 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 19 Jan 2000 23:24:36 -0800 (PST)
Subject: Agenda for 20 January
Message-ID: <200001200724.XAA52015@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Exception handling.

  B) Data layout.

  C) Mangling.

So, take a look at the material associated with these issues:

  1) D-10:  Exceptions.  The primary changes in my writeup are in
     color, and we'll go over them, primarily reason codes and the
     _Unwind_ForcedUnwind definition.  Answer the "Outstanding
     Questions" at the beginning of the document.

  2) D-11:  Reminder to Christophe to provide a list of pthreads
     functions required and their interfaces (e.g. man pages).

  3) D-12:  Unwind table location.  (I have called Cary but not
     heard from him.)

  4) D-13:  This should be closed along with D-10.  But promised a
     description of thread cancellation a while back, and Christophe
     promised a writeup as another example for _Unwind_ForcedUnwind.

  5) D-14:  I think I should have closed this.

  6) A-19:  Primary virtual base classes.  Does the writeup in the
     layout document look OK?  Note the email from Coleen and Jason.

  7) A-20:  Operator new array cookies.  Does the proposed resolution
     look OK?

  8) A-*:  Go over the colored items in the layout document for
     validation.  I've switched terminology to super-polymorphic -- any
     better ideas?  Cary suggests simple vs. complex classes, which
     would also be OK.

  9) A-*:  Nathan raised several questions about RTTI.  Let's go
     through them and either answer them or identify issues.

 10) F-*:  Mangling.  We have a proposal from Daveed.  Let's start
     the discussion.

 11) A-21:  Placement new array cookies.  Read Matt's description.
     Can we decide what to do?  What we need to decide?

Issues that are active and awaiting proposals:

  a) C-4:  Daveed will write up construction vtables so we can
     verify.  Wait.


Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Thu Jan 20 08:04:20 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 20 Jan 2000 00:04:20 -0800
Subject: Virtual base class offsets in vtables
In-Reply-To: <200001190311.TAA42360@baalbek.engr.sgi.com>
References: <20000118103434A.mitchell@codesourcery.com>
	<u91z7fc8te.fsf@yorick.cygnus.com>
	<200001190311.TAA42360@baalbek.engr.sgi.com>
Message-ID: <20000120000420S.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> Mark,

    Jim> Thanks for continuing to identify sources of confusion.

It's a wonder what trying to implement this stuff will do for you... :-)

    Jim> Is what's there now better?  Enough?

Definitely better.  And I think enough.  I'll let you know if I can't
make it work. :-)

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Thu Jan 20 11:18:42 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 20 Jan 2000 12:18:42 +0100
Subject: Array placement new
In-Reply-To: <10001192133.ZM93722@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <38598FAA.2A9E827F@cup.hp.com> <10001192133.ZM93722@isolde.engr.sgi.com>
Message-ID: <200001201118.MAA05093@pandora>

> (2) Do we store n at a negative offset from the return value of
>     operator new[]?

I believe the answer to this question must be 'no'. operator new[] is
a replaceable signature (18.4.1). If there is a user-provided
definition of operator new[], there is no guarantee that anything at
negative offsets is accessible.

I just noticed there is a terminology problem. I'd call the outcome of

  ::operator new[](size)

the return value of operator new[], and the outcome of

  new T[size]

the return value of the new-expression.

> Some implementations store the number of elements in the array at
> a negative offset from p1.  The standard neither requires nor
> forbids it.

The standard requires that, if T is a class type, the appropriate
number of constructors are invoked when the array is
deleted. Therefore, delete[] has to have knowledge about the number of
elements in the array.

I believe g++ uses the following strategy: If T has a destructor, the
array size is stored within the array. If T is primitive, or POD, only
the total size of all objects is requested.

> (1) Given n, T, sizeof(T), and alignof(T), what are n1 and delta?
>     (a) Are T=char and T=unsigned char special cases?  (Or,
>         perhaps, is sizeof(T)=1 a special case?)

No. Types without destructor are a special case. That gives the
special behaviour for new char[], as well.

<proposal>
If T has an explicitly declared destructor (either directly or in a
base), then 

  delta = max(sizeof(size_t),alignof(T)) 
  n1 = n*sizeof(T) + delta

If result of the operator-new-call is p, then the result of the
new-expression is

  p1 = p+delta

If T has no explicit destructor, then delta=0, and a delete-expression
only invokes operator delete[] with the given address.
</proposal>

I believe this differs from the current g++ solution, which always
uses delta = biggest_alignment for destructable types.

>     (b) Is ::operator new[](size_t, void*) a special case?

No. The standard clearly says that it must return its argument. So if
people allocate only n*sizeof(T) memory in a placement-new for an
array of destructable elements, then it will overwrite some random
memory.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Jan 20 11:24:05 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 20 Jan 2000 12:24:05 +0100
Subject: Agenda for 20 January
In-Reply-To: <200001200724.XAA52015@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200001200724.XAA52015@baalbek.engr.sgi.com>
Message-ID: <200001201124.MAA05157@pandora>

>   7) A-20:  Operator new array cookies.  Does the proposed resolution
>      look OK?

I may be missing some part of the discussion. Was the option not to
have a cookie if there is no destructor just not considered, or was it
considered and rejected. If so, for what reason?

Regards,
Martin



From daveed at edg.com  Thu Jan 20 15:43:31 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 20 Jan 2000 07:43:31 -0800
Subject: Agenda for 20 January
References: <200001200724.XAA52015@baalbek.engr.sgi.com>
Message-ID: <38872D23.2B40F8CD@edg.com>

Jim Dehnert wrote:
[...]
>   8) A-*:  Go over the colored items in the layout document for
>      validation.  I've switched terminology to super-polymorphic -- any
>      better ideas?  Cary suggests simple vs. complex classes, which
>      would also be OK.

I like "dynamic class" vs. "struct-like class" ("nondynamic" would be
possible too).

	Daveed



From ddd at cup.hp.com  Thu Jan 20 18:30:34 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 20 Jan 2000 18:30:34 +0000
Subject: Agenda for 20 January
References: <200001200724.XAA52015@baalbek.engr.sgi.com>
Message-ID: <3887544A.5F1C775E@cup.hp.com>

Jim Dehnert wrote:
>   2) D-11:  Reminder to Christophe to provide a list of pthreads
>      functions required and their interfaces (e.g. man pages).
> 

Data types:
	pthread_key_t
	pthread_once_t

Functions:
	pthread_key_create
	pthread_once
	pthread_getspecific
	pthread_setspecific


Extra expected functionality:
	A way to identify if pthread is linked, or, alternatively, stubs in libc.




>   3) D-12:  Unwind table location.  (I have called Cary but not
>      heard from him.)

I will try to get more about this.


Best regards
Christophe



From jason at cygnus.com  Fri Jan 21 06:37:38 2000
From: jason at cygnus.com (Jason Merrill)
Date: 20 Jan 2000 22:37:38 -0800
Subject: Mangling: initial attempt
In-Reply-To: Daveed Vandevoorde's message of "Tue, 18 Jan 2000 21:31:13 -0800"
References: <38854C21.A0AAC0E@edg.com>
Message-ID: <u9d7qwhqvg.fsf@casey.cygnus.com>

Some notes:

I thought we had decided to use a unique prefix which could not appear
in C, something like '_.'.  _[0-9] doesn't qualify; it's even in the
user's namespace.

I thought we had decided to abandon the idea of truncation (perhaps
that was decided at one of the meetings you missed).

For Compression, why the n'th most recently encoded type, rather than
the n'th encoded type?

It would be useful to remember names as well as types, in case we have
multiple instantiations of the same template in one mangling.

Jason



From austern at isolde.engr.sgi.com  Fri Jan 21 18:16:55 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Fri, 21 Jan 2000 10:16:55 -0800
Subject: array new-expressions: proposal
Message-ID: <10001211016.ZM96896@isolde.engr.sgi.com>

WHAT THE STANDARD SAYS. (3.7.3.1, 5.3.4, and 18.4.1.3)

Array new has the form "new(ARGS) T[n]".  The "(ARGS)"
part is optional.  If it's present then this is a placement
new-expression, and we use a version of operator new[] with
two or more arguments, otherwise it's an ordinary new-
expression, and we use a version of operator new[] with one
argument.  For the purposes of this proposal the distinction
isn't all that important.

After finding the appropriate operator new, a new-expression
obtains storage with
    void* p = operator new[](n1, ARGS),
where n1 >= n * sizeof(T).  It then constructs n objects of type
T starting at position p1, where p1 = p + delta.  The return
value is p1.

It is required (3.7.3.1/2) that the return value of any operator
new[], whether it's built-in or provided by the user, must be
suitably aligned for objects of any type.

If T is "char" or "unsigned char" the standard requires that
delta is a nonnegative multiple of the most stringent alignment
constraint for objects of size less than or equal to n
(5.3.4/10).  Otherwise the only restriction is that delta is
nonnegative.

Some implementations store the number of elements in the array at
a negative offset from p1.  The standard neither requires nor
forbids it.

There's a predefined placement version of array operator new,
    ::operator new[](size_t n1, void* p),
that does nothing but return p.  p must be a pointer to the
beginning of some array of size at least n1.  The standard
doesn't tell users how large an array they need.  Many users
probably assume that it's sufficient for the array to be of size
n * sizeof(T), but there's no basis in the standard for that
assumption.

IA-64 SPECIFICS

On IA-64 long double is 80 bits.  long double has 128-bit alignment,
as do classes and unions containing long double, so sizeof(long double)
is 16.  All other types have 64-bit alignment.

WHAT THE ABI NEEDS TO SPECIFY

(1) Given n, and T, what are n1 and delta?
    (a) Are T=char and T=unsigned char special cases?  (Or,
        perhaps, is sizeof(T)=1 a special case?)
    (b) Is ::operator new[](size_t, void*) a special case?
    (c) Is ::operator new[](size_t), which is used for
        non-placement new, a special case?
    (d) Is ::operator new[](size_t, const nothrow_t&) a
        special case?  I can't find anything in the standard
        guaranteeing that you can delete an array allocated
        with nothrow array new using an ordinary array delete-
        expression, but users probably expect it, and
        legitimately so.
(2) Do we store n at a negative offset from p1?  (This affects
    the answer to question 1.)  If so, we need to specify
    precisely what that offset is.


PROPOSAL A.

No version of operator new[] is a special case.  For any array
new-expression we store the number of elements in the array,
as a size_t, at an offset of -sizeof(size_t) from the pointer
returned by the new-expression.  For any type T other than char,
unsigned char, long double, or a type containing a long double,
n1 = n * sizeof(T) + sizeof(size_t).   For those three types,
since we need to preserve long double alignment, n1 = n * sizeof(T) +
sizeof(long double).

Pseudocode for new(ARGS) T[n] under this proposal:

    if T = char or unsigned char, or if it has long double alignment,
      padding = sizeof(long double)
    else
      padding = sizeof(size_t)

    p = operator new[](n * sizeof(T) + padding, ARGS)

    p1 = (T*) (p + padding)
    ((unsigned long*) p1 - 1) = n

    for i = [0, n)
      create a T, using the default constructor, at p1[i]

    return p1


PROPOSAL B.

::operator new[](size_t, void*) is a special case.  For that
version of operator new[] only, n1 = n * sizeof(T).  We do not
store the number of elements in such an array anywhere.

Pseudocode for new(ARGS) T[n] under this proposal:

    If the expression is new(p) T[n], and if overload resolution
    determines we're using ::operator new[](size_t, void*), then
      p1 = (T*) p

      for i = [0, n)
        create a T, using the default constructor, at p1[i]

      return p1

    For all other cases, same as proposal A.


Proposal A is simpler, but proposal B probably conforms more
closely to user expectations.



From jfw at cthulhu.engr.sgi.com  Fri Jan 21 19:33:08 2000
From: jfw at cthulhu.engr.sgi.com (John Wilkinson)
Date: Fri, 21 Jan 2000 11:33:08 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com>
Message-ID: <3888B474.B69CAEB6@engr.sgi.com>

Matt Austern wrote:
> 
> WHAT THE STANDARD SAYS. (3.7.3.1, 5.3.4, and 18.4.1.3)
> 
> Array new has the form "new(ARGS) T[n]".  The "(ARGS)"
> part is optional.  If it's present then this is a placement
> new-expression, and we use a version of operator new[] with
> two or more arguments, otherwise it's an ordinary new-
> expression, and we use a version of operator new[] with one
> argument.  For the purposes of this proposal the distinction
> isn't all that important.
> 
> After finding the appropriate operator new, a new-expression
> obtains storage with
>     void* p = operator new[](n1, ARGS),
> where n1 >= n * sizeof(T).  It then constructs n objects of type
> T starting at position p1, where p1 = p + delta.  The return
> value is p1.
> 
> It is required (3.7.3.1/2) that the return value of any operator
> new[], whether it's built-in or provided by the user, must be
> suitably aligned for objects of any type.
> 
> If T is "char" or "unsigned char" the standard requires that
> delta is a nonnegative multiple of the most stringent alignment
> constraint for objects of size less than or equal to n
> (5.3.4/10).  Otherwise the only restriction is that delta is
> nonnegative.
> 
> Some implementations store the number of elements in the array at
> a negative offset from p1.  The standard neither requires nor
> forbids it.
> 
> There's a predefined placement version of array operator new,
>     ::operator new[](size_t n1, void* p),
> that does nothing but return p.  p must be a pointer to the
> beginning of some array of size at least n1.  The standard
> doesn't tell users how large an array they need.  Many users
> probably assume that it's sufficient for the array to be of size
> n * sizeof(T), but there's no basis in the standard for that
> assumption.
> 
> IA-64 SPECIFICS
> 
> On IA-64 long double is 80 bits.  long double has 128-bit alignment,
> as do classes and unions containing long double, so sizeof(long double)
> is 16.  All other types have 64-bit alignment.
> 
> WHAT THE ABI NEEDS TO SPECIFY
> 
> (1) Given n, and T, what are n1 and delta?
>     (a) Are T=char and T=unsigned char special cases?  (Or,
>         perhaps, is sizeof(T)=1 a special case?)
>     (b) Is ::operator new[](size_t, void*) a special case?
>     (c) Is ::operator new[](size_t), which is used for
>         non-placement new, a special case?
>     (d) Is ::operator new[](size_t, const nothrow_t&) a
>         special case?  I can't find anything in the standard
>         guaranteeing that you can delete an array allocated
>         with nothrow array new using an ordinary array delete-
>         expression, but users probably expect it, and
>         legitimately so.
> (2) Do we store n at a negative offset from p1?  (This affects
>     the answer to question 1.)  If so, we need to specify
>     precisely what that offset is.
> 
> PROPOSAL A.
> 
> No version of operator new[] is a special case.  For any array
> new-expression we store the number of elements in the array,
> as a size_t, at an offset of -sizeof(size_t) from the pointer
> returned by the new-expression.  For any type T other than char,
> unsigned char, long double, or a type containing a long double,
> n1 = n * sizeof(T) + sizeof(size_t).   For those three types,
> since we need to preserve long double alignment, n1 = n * sizeof(T) +
> sizeof(long double).
> 
> Pseudocode for new(ARGS) T[n] under this proposal:
> 
>     if T = char or unsigned char, or if it has long double alignment,
>       padding = sizeof(long double)
>     else
>       padding = sizeof(size_t)
> 
>     p = operator new[](n * sizeof(T) + padding, ARGS)
> 
>     p1 = (T*) (p + padding)
>     ((unsigned long*) p1 - 1) = n
> 
>     for i = [0, n)
>       create a T, using the default constructor, at p1[i]
> 
>     return p1
> 
> PROPOSAL B.
> 
> ::operator new[](size_t, void*) is a special case.  For that
> version of operator new[] only, n1 = n * sizeof(T).  We do not
> store the number of elements in such an array anywhere.
> 
> Pseudocode for new(ARGS) T[n] under this proposal:
> 
>     If the expression is new(p) T[n], and if overload resolution
>     determines we're using ::operator new[](size_t, void*), then
>       p1 = (T*) p
> 
>       for i = [0, n)
>         create a T, using the default constructor, at p1[i]
> 
>       return p1
> 
>     For all other cases, same as proposal A.
> 
> Proposal A is simpler, but proposal B probably conforms more
> closely to user expectations.

After thinking about this for most of the morning, I have concluded that
placement array new is too clumsy to be really useful anyway;  my vote
is for Proposal A.

-- 
John Wilkinson



From daveed at edg.com  Fri Jan 21 21:20:04 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 21 Jan 2000 13:20:04 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com>
Message-ID: <3888CD84.9B138F3A@edg.com>

Matt Austern wrote:
[...]
> PROPOSAL A.
> 
> No version of operator new[] is a special case.
[...]
> PROPOSAL B.
> 
> ::operator new[](size_t, void*) is a special case.  For that
> version of operator new[] only, n1 = n * sizeof(T).  We do not
> store the number of elements in such an array anywhere.

There is a reason that placement new is called _placement_ new:
the intent was to allow the placement of objects and arrays at a 
given address.  In effect, it's a way to specify a "this" pointer
to a constructor.

So I think Proposal A is really not a good idea.

	Daveed



From jfw at cthulhu.engr.sgi.com  Fri Jan 21 22:08:06 2000
From: jfw at cthulhu.engr.sgi.com (John Wilkinson)
Date: Fri, 21 Jan 2000 14:08:06 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com>
Message-ID: <3888D8C6.1C7EE67A@engr.sgi.com>

Daveed Vandevoorde wrote:
> 
> Matt Austern wrote:
> [...]
> > PROPOSAL A.
> >
> > No version of operator new[] is a special case.
> [...]
> > PROPOSAL B.
> >
> > ::operator new[](size_t, void*) is a special case.  For that
> > version of operator new[] only, n1 = n * sizeof(T).  We do not
> > store the number of elements in such an array anywhere.
> 
> There is a reason that placement new is called _placement_ new:
> the intent was to allow the placement of objects and arrays at a
> given address.  In effect, it's a way to specify a "this" pointer
> to a constructor.
> 
> So I think Proposal A is really not a good idea.
> 
>         Daveed

Certainly that was the intent; it's just that it doesn't work very well
in the vector case.  There's no good way to run the destructors except
by overriding operator delete; but then delete[] won't release storage
for a normal vector new.  I think it would have been better if hiding
the allocation overhead had been the responsibility of operator new[]
and not of the new expression; it would have been better to allow
delete[] to call a placement delete function (which could be stashed
along with the count); but that's not the way it is.  I don't have
really strong feelings about the choice between A and B, however.  I'm
leaning towards A today out of frustration.

-- 
John Wilkinson



From ddd at cup.hp.com  Fri Jan 21 23:01:57 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 21 Jan 2000 23:01:57 +0000
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com>
Message-ID: <3888E565.868EA4D0@cup.hp.com>

Daveed Vandevoorde wrote:
> 
> Matt Austern wrote:
> [...]
> > PROPOSAL A.
> >
> > No version of operator new[] is a special case.
> [...]
> > PROPOSAL B.
> >
> > ::operator new[](size_t, void*) is a special case.  For that
> > version of operator new[] only, n1 = n * sizeof(T).  We do not
> > store the number of elements in such an array anywhere.
> 
> There is a reason that placement new is called _placement_ new:
> the intent was to allow the placement of objects and arrays at a
> given address.  In effect, it's a way to specify a "this" pointer
> to a constructor.
> 
> So I think Proposal A is really not a good idea.
> 
>         Daveed

I sent a message to the -libraries mailing list. Although I agree with the
intent, there is also the question of how you expect people to delete[] it. If I
were to vote today, I'd agree with Daveed (and disallow delete[] on the result),
but I'm not sure enough though has been given to it.


Regards
Christophe



From jfw at cthulhu.engr.sgi.com  Fri Jan 21 23:09:44 2000
From: jfw at cthulhu.engr.sgi.com (John Wilkinson)
Date: Fri, 21 Jan 2000 15:09:44 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <3888E565.868EA4D0@cup.hp.com>
Message-ID: <3888E738.6076DA57@engr.sgi.com>

Christophe de Dinechin wrote:
> 
> Daveed Vandevoorde wrote:
> >
> > Matt Austern wrote:
> > [...]
> > > PROPOSAL A.
> > >
> > > No version of operator new[] is a special case.
> > [...]
> > > PROPOSAL B.
> > >
> > > ::operator new[](size_t, void*) is a special case.  For that
> > > version of operator new[] only, n1 = n * sizeof(T).  We do not
> > > store the number of elements in such an array anywhere.
> >
> > There is a reason that placement new is called _placement_ new:
> > the intent was to allow the placement of objects and arrays at a
> > given address.  In effect, it's a way to specify a "this" pointer
> > to a constructor.
> >
> > So I think Proposal A is really not a good idea.
> >
> >         Daveed
> 
> I sent a message to the -libraries mailing list. Although I agree with the
> intent, there is also the question of how you expect people to delete[] it. If I
> were to vote today, I'd agree with Daveed (and disallow delete[] on the result),
> but I'm not sure enough though has been given to it.
> 
> Regards
> Christophe

Note that in earlier drafts of the Standard (up till Stockholm at
least), delete[] WAS forbidden on pointers obtained from placement
vector new.

-- 
John Wilkinson



From daveed at edg.com  Sat Jan 22 00:23:54 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 21 Jan 2000 16:23:54 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <3888E565.868EA4D0@cup.hp.com>
Message-ID: <3888F89A.47E3C7F5@edg.com>

Christophe de Dinechin wrote:
[...]
> I sent a message to the -libraries mailing list. Although I agree with the
> intent, there is also the question of how you expect people to delete[] it.

If the allocation was on the stack, they shouldn't delete it.
If they are "overconstructing" as in:

	p = new T[100];
	// ...
	(void)new(p+25) T[50]; // End lifetime of middle 50 objects and
	                       // replace by 50 new ones.

they should be able to just use a delete[] expression for the desired effect.

It's a bit unfortunate that all the multi-argument allocation functions are
called "placement new".  Only this one and the corresponding object-new
really qualify.  Note also that these are the ones a user is not allowed to
override, thereby further suggesting that they are "intrinsic" and more 
about "placement" than "allocation".

I agree with John Wilkinson that the array case is an order of magnitude 
less interesting than the object case.  However, the user is king and
you'll have a hard time explaining to your customer that this doesn't
work when "it always worked that way" and "that other platform has no
trouble with it and they also store a count at negative offsets in the
other cases".  It might be that noone actually does this kind of thing,
but I'm not comfortable betting on it---there is some really weird C++
middleware source code out there.

	Daveed



From jason at cygnus.com  Sun Jan 23 09:40:23 2000
From: jason at cygnus.com (Jason Merrill)
Date: 23 Jan 2000 01:40:23 -0800
Subject: array new-expressions: proposal
In-Reply-To: Daveed Vandevoorde's message of "Fri, 21 Jan 2000 16:23:54 -0800"
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <3888E565.868EA4D0@cup.hp.com> <3888F89A.47E3C7F5@edg.com>
Message-ID: <u9r9f96s8o.fsf@yorick.cygnus.com>

It's really a question of which is more common: people wanting to delete[]
pointers from placement new, or people wanting placement new to return the
same pointer.  I believe that the latter is more common.  At least, I've
heard from some such people, whereas I have heard from nobody in the former
category.

Matt:  Why not just say

  padding = max (sizeof (size_t), alignof (T))

?  I don't see any reason to mention long double by name, and I don't
see much of a reason to treat char specially, either.  Are there any
alignment constraints on 'new char' in the standard?

Jason



From mendell at ca.ibm.com  Sun Jan 23 19:08:23 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Sun, 23 Jan 2000 14:08:23 -0500
Subject: array new-expressions: proposal
Message-ID: <8725686F.0068F9A6.00@d53mta04h.boulder.ibm.com>



Does it make sense to always use a 16 byte padding, since the operator new
will not have access to the alignment of the type?

Mark





From jason at cygnus.com  Mon Jan 24 09:52:07 2000
From: jason at cygnus.com (Jason Merrill)
Date: 24 Jan 2000 01:52:07 -0800
Subject: array new-expressions: proposal
In-Reply-To: mendell@ca.ibm.com's message of "Sun, 23 Jan 2000 14:08:23 -0500"
References: <8725686F.0068F9A6.00@d53mta04h.boulder.ibm.com>
Message-ID: <u9iu0j7q60.fsf@yorick.cygnus.com>

>>>>> mendell  <mendell at ca.ibm.com> writes:

 > Does it make sense to always use a 16 byte padding, since the operator new
 > will not have access to the alignment of the type?

No; the size of the padding is determined by the new-expression, not the
operator new.

Jason



From sidwell at codesourcery.com  Mon Jan 24 10:17:28 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Mon, 24 Jan 2000 10:17:28 +0000
Subject: rtti data layout notes
Message-ID: <388C26B8.48F7145B@codesourcery.com>

Hi,
more rtti data issues, these are documentation clarifications

1) place of emission
This does not mention that a type_info for 'void' is emitted in the
runtime. However, it must be because 'void *' will reference it.
Suggest not special casing void, and including it in the second bullet
point with the remaining fundamental types.

2) place of emission of vtables.
The vtables for the type_info derrived classes must be in the runtime.
Other translation units must not emit vtables. Rationale: the runtime
will expect certain implementation defined virtual member functions
for these classes. A foreign translation unit must not override the
runtime's vtable.

3) si_class_type_info is for a single nonvirtual inheritance heirarchy.
Presumably this single non-virtual inheritance is between the derrived
and the base (the base may or may not have multiple or virtual bases).
An additional constraint is that, if the derrived class is polymorphic,
the base class is too. Rationale: if the derrived class adds
polymorphism, the base will be at a non-zero offset.

nathan
-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From loewis at informatik.hu-berlin.de  Mon Jan 24 14:59:46 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 15:59:46 +0100
Subject: array new-expressions: proposal
In-Reply-To: <3888CD84.9B138F3A@edg.com> (message from Daveed Vandevoorde on
	Fri, 21 Jan 2000 13:20:04 -0800)
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com>
Message-ID: <200001241459.PAA29179@pandora>

> > PROPOSAL A.
> > 
> > No version of operator new[] is a special case.
[...]
> There is a reason that placement new is called _placement_ new:
> the intent was to allow the placement of objects and arrays at a 
> given address.  In effect, it's a way to specify a "this" pointer
> to a constructor.
> 
> So I think Proposal A is really not a good idea.

Why not? Under the proposal, it would have exactly the effect of
"specifying the 'this' pointer to a constructor". Of course, when you
create an array, you invoke more than one constructor, so you see more
than one 'this' pointer.

Under proposal A, the field elements are all allocated within the
specified space passed into the new expression. That's what you would
expect to happen, and that's what actually happens.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Mon Jan 24 15:55:26 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 16:55:26 +0100
Subject: Mangling: initial attempt
In-Reply-To: <38854C21.A0AAC0E@edg.com> (message from Daveed Vandevoorde on
	Tue, 18 Jan 2000 21:31:13 -0800)
References: <38854C21.A0AAC0E@edg.com>
Message-ID: <200001241555.QAA01156@pandora>

> For template functions, <type> lists the return type followed by the
> parameter types.

Why is it necessary to have the return type in a template function
instance?

Also, for covariant returns, there will be two entries in the
vtable. Shouldn't there be the return type in virtual functions which
return covariantly?

> 12) "_11fQ1N": Ret? N::f();

This should be _11fQ1NE.

> 13) "_14beepQ6System5Sound: Ret? System::Sound::beep();

Likewise, this shoud be _14beepQ6System5SoundE.

Regards,
Martin



From daveed at edg.com  Mon Jan 24 17:19:55 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 24 Jan 2000 09:19:55 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <200001241459.PAA29179@pandora>
Message-ID: <388C89BA.FA9A6E19@edg.com>

Martin von Loewis wrote:
> 
> > > PROPOSAL A.
> > >
> > > No version of operator new[] is a special case.
> [...]
> > There is a reason that placement new is called _placement_ new:
> > the intent was to allow the placement of objects and arrays at a
> > given address.  In effect, it's a way to specify a "this" pointer
> > to a constructor.
> >
> > So I think Proposal A is really not a good idea.
> 
> Why not? Under the proposal, it would have exactly the effect of
> "specifying the 'this' pointer to a constructor". Of course, when you
> create an array, you invoke more than one constructor, so you see more
> than one 'this' pointer.

My understanding is that the new expression would first store the
number of elements to be destructed.  That means that besides just
specifying a this pointer to the repeated ctor calls, we also clobber
another location in the buffer.  That prevents me to overconstruct
subarrays and the like.

Or do I misunderstand?

	Daveed



From daveed at edg.com  Mon Jan 24 17:35:30 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 24 Jan 2000 09:35:30 -0800
Subject: Mangling: initial attempt
References: <38854C21.A0AAC0E@edg.com> <200001241555.QAA01156@pandora>
Message-ID: <388C8D61.D8B51762@edg.com>

Martin von Loewis wrote:
> 
> > For template functions, <type> lists the return type followed by the
> > parameter types.
> 
> Why is it necessary to have the return type in a template function
> instance?

Because you can have multiple function template that differ only by
return types (and you can instantiate/call them by taking their address).

Isn't that cool in a devious kindof way <grin> ?

> Also, for covariant returns, there will be two entries in the
> vtable. Shouldn't there be the return type in virtual functions which
> return covariantly?

That might be the best option.  I haven't thought much about the
impact of virtual tables on the mangling yet.  But what you say
sound right.

> > 12) "_11fQ1N": Ret? N::f();
> 
> This should be _11fQ1NE.
> 
> > 13) "_14beepQ6System5Sound: Ret? System::Sound::beep();
> 
> Likewise, this shoud be _14beepQ6System5SoundE.

You're right.  At first, I intended to have Q...E segments for all
qualified names.  However, that led to some ambiguity.  So now there
is a different N...E segment, and only the last segment is Q...E.
So in fact we can drop the last E since it is implicit in the end
of the string.

What do you think?

	Daveed



From jfw at cthulhu.engr.sgi.com  Mon Jan 24 18:01:13 2000
From: jfw at cthulhu.engr.sgi.com (John Wilkinson)
Date: Mon, 24 Jan 2000 10:01:13 -0800
Subject: array new-expressions: proposal
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <3888E565.868EA4D0@cup.hp.com> <3888F89A.47E3C7F5@edg.com> <u9r9f96s8o.fsf@yorick.cygnus.com>
Message-ID: <388C9369.B5B9BE5C@engr.sgi.com>

Jason Merrill wrote:
> 
> It's really a question of which is more common: people wanting to delete[]
> pointers from placement new, or people wanting placement new to return the
> same pointer.  I believe that the latter is more common.  At least, I've
> heard from some such people, whereas I have heard from nobody in the former
> category.
> 
> Matt:  Why not just say
> 
>   padding = max (sizeof (size_t), alignof (T))
> 
> ?  I don't see any reason to mention long double by name, and I don't
> see much of a reason to treat char specially, either.  Are there any
> alignment constraints on 'new char' in the standard?
> 
> Jason

I agree with most of what Jason says here.  I have, however, had
customer complaints about not being able to delete[] pointers returned
by placement new, but these referred to user-defined placement new. 

The standard does impose special restraints on new char[], as I believe
Matt pointed out.  That's the reason for the extra complexity.


-- 
John Wilkinson



From loewis at informatik.hu-berlin.de  Mon Jan 24 18:05:58 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 19:05:58 +0100
Subject: array new-expressions: proposal
In-Reply-To: <388C89BA.FA9A6E19@edg.com> (message from Daveed Vandevoorde on
	Mon, 24 Jan 2000 09:19:55 -0800)
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <200001241459.PAA29179@pandora> <388C89BA.FA9A6E19@edg.com>
Message-ID: <200001241805.TAA03467@pandora>

> My understanding is that the new expression would first store the
> number of elements to be destructed.  That means that besides just
> specifying a this pointer to the repeated ctor calls, we also clobber
> another location in the buffer.  That prevents me to overconstruct
> subarrays and the like.
> 
> Or do I misunderstand?

No, you are right, overconstructing of sub-arrays would not work.

I believe standard C++ does not support overconstruction of arrays,
because it allows arbitrary padding before the first element. OTOH, I
can see that this is a useful feature.

It seems to me that not having the array size in a placement-new
breaks the requirement that the corresponding delete expression will
call all element's destructors (in reverse order). If that is a
limitation of the ABI, that's fine with me. 

Regards,
Martin



From austern at isolde.engr.sgi.com  Mon Jan 24 18:10:17 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Mon, 24 Jan 2000 10:10:17 -0800
Subject: array new-expressions: proposal
In-Reply-To: Martin von Loewis <loewis@informatik.hu-berlin.de>
        "Re: array new-expressions: proposal" (Jan 24,  7:05pm)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <200001241459.PAA29179@pandora> 
	<388C89BA.FA9A6E19@edg.com>  <200001241805.TAA03467@pandora>
Message-ID: <10001241010.ZM99326@isolde.engr.sgi.com>

On Jan 24,  7:05pm, Martin von Loewis wrote:
>
> It seems to me that not having the array size in a placement-new
> breaks the requirement that the corresponding delete expression will
> call all element's destructors (in reverse order). If that is a
> limitation of the ABI, that's fine with me.
>
> Regards,
> Martin
>-- End of excerpt from Martin von Loewis

Depends on what you mean by placement-new.  Do you mean
   char buf[100 * sizeof(T)];
   new(buf) T[100];,
or do you mean, more generally, any array new where you
provide extra arguments?

If you mean the latter, then we'd be saying that the pointer
we get from
   new(std::nothrow) T[100]
can't be deleted.  That, in my opinion, is not fine at all.
That's why I didn't propose it as an alternative.  I think
either we should say that we store the number of elements in
the array for all kinds of placement new, or else that we
should do it for everything but the special case
  ::operator new[](std::size_t, const std::nothrow_t&).


			--Matt



From austern at isolde.engr.sgi.com  Mon Jan 24 18:29:44 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Mon, 24 Jan 2000 10:29:44 -0800
Subject: array new-expressions: proposal
In-Reply-To: Jason Merrill <jason@cygnus.com>
        "Re: array new-expressions: proposal" (Jan 23,  1:40am)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <3888E565.868EA4D0@cup.hp.com> 
	<3888F89A.47E3C7F5@edg.com> 
	<u9r9f96s8o.fsf@yorick.cygnus.com>
Message-ID: <10001241029.ZM102394@isolde.engr.sgi.com>

On Jan 23,  1:40am, Jason Merrill wrote:

> Matt:  Why not just say
>
>   padding = max (sizeof (size_t), alignof (T))
>
> ?  I don't see any reason to mention long double by name, and I don't
> see much of a reason to treat char specially, either.  Are there any
> alignment constraints on 'new char' in the standard?

There are specific constraints on char and unsigned char, yes.
(But not, interestingly enough, on signed char or on any other
type of size 1.)

5.3.4/10: "For arrays of char and unsigned char, the difference between
the result of the new-expression and the address returned by the
allocation function shall be an integral multiple of the most stringent
alignment requirement of the object type whose size is no greater than
the size of the array being created."

We could just put in 16-byte padding for all types, but I think that's
a waste.  There's no reason to do it.  It's just as easy to use 8-
byte padding in general, and 16 only when we have to.

			--Matt




From loewis at informatik.hu-berlin.de  Mon Jan 24 18:46:15 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 19:46:15 +0100
Subject: Mangling: initial attempt
In-Reply-To: <388C8D61.D8B51762@edg.com> (message from Daveed Vandevoorde on
	Mon, 24 Jan 2000 09:35:30 -0800)
References: <38854C21.A0AAC0E@edg.com> <200001241555.QAA01156@pandora> <388C8D61.D8B51762@edg.com>
Message-ID: <200001241846.TAA03719@pandora>

> Because you can have multiple function template that differ only by
> return types (and you can instantiate/call them by taking their address).
> 
> Isn't that cool in a devious kindof way <grin> ?

Very interesting indeed - learn something new about C++ every day.

> You're right.  At first, I intended to have Q...E segments for all
> qualified names.  However, that led to some ambiguity.  So now there
> is a different N...E segment, and only the last segment is Q...E.
> So in fact we can drop the last E since it is implicit in the end
> of the string.
> 
> What do you think?

It seems that would work. However, I feel it is inconsistent to use
one way of qualifying for nested names, and another way for the
toplevel name. Instead, I'd say that, instead of

  <prefix><length><name>

you have

  <prefix><identifier>

and <identifier> is either

  <length><name>
or
  Q{<length><name>}*E

So instead of _11fQ1N, you get _1Q1N1fE. So method name would be
mangled just as a class name.

Regards,
Martin



From austern at isolde.engr.sgi.com  Mon Jan 24 18:53:18 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Mon, 24 Jan 2000 10:53:18 -0800
Subject: array new-expressions: proposal
In-Reply-To: Martin von Loewis <loewis@informatik.hu-berlin.de>
        "Re: array new-expressions: proposal" (Jan 24,  7:51pm)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <200001241459.PAA29179@pandora> 
	<388C89BA.FA9A6E19@edg.com>  <200001241805.TAA03467@pandora> 
	<10001241010.ZM99326@isolde.engr.sgi.com> 
	<200001241851.TAA03740@pandora>
Message-ID: <10001241053.ZM102278@isolde.engr.sgi.com>

On Jan 24,  7:51pm, Martin von Loewis wrote:

> Did you mean ::operator new[](std::size_t, void*), here? That is the
> one where special-casing is useful.

Oops, yes.  That was a typo or something.  My "Proposal A" is to
have no special cases, and my "Proposal B" is to treat
  ::operator new[](std::size_t, void*)
as a special case.

			--Matt





From loewis at informatik.hu-berlin.de  Mon Jan 24 18:51:02 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 19:51:02 +0100
Subject: array new-expressions: proposal
In-Reply-To: <10001241010.ZM99326@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <200001241459.PAA29179@pandora> 
	<388C89BA.FA9A6E19@edg.com>  <200001241805.TAA03467@pandora> <10001241010.ZM99326@isolde.engr.sgi.com>
Message-ID: <200001241851.TAA03740@pandora>

> Depends on what you mean by placement-new.  Do you mean
>    char buf[100 * sizeof(T)];
>    new(buf) T[100];,
> or do you mean, more generally, any array new where you
> provide extra arguments?

I was only talking about the (void*) variant, here.

> 
> If you mean the latter, then we'd be saying that the pointer
> we get from
>    new(std::nothrow) T[100]
> can't be deleted.  That, in my opinion, is not fine at all.
> That's why I didn't propose it as an alternative.  I think
> either we should say that we store the number of elements in
> the array for all kinds of placement new, or else that we
> should do it for everything but the special case
>   ::operator new[](std::size_t, const std::nothrow_t&).

Did you mean ::operator new[](std::size_t, void*), here? That is the
one where special-casing is useful.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Mon Jan 24 18:55:22 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 24 Jan 2000 19:55:22 +0100
Subject: array new-expressions: proposal
In-Reply-To: <10001241029.ZM102394@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <3888E565.868EA4D0@cup.hp.com> 
	<3888F89A.47E3C7F5@edg.com> 
	<u9r9f96s8o.fsf@yorick.cygnus.com> <10001241029.ZM102394@isolde.engr.sgi.com>
Message-ID: <200001241855.TAA03757@pandora>

> We could just put in 16-byte padding for all types, but I think that's
> a waste.  There's no reason to do it.  It's just as easy to use 8-
> byte padding in general, and 16 only when we have to.

I'd like to repeat my proposal that there is *no padding* if the type
does not have a destructor. In that case, you could use the outcome of
operator new directly for arrays of char and unsigned char; the
multiple mentioned in 5.3.4/10 would be 0.

Regards,
Martin



From daveed at edg.com  Mon Jan 24 19:00:29 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 24 Jan 2000 11:00:29 -0800
Subject: Mangling: initial attempt
References: <38854C21.A0AAC0E@edg.com> <200001241555.QAA01156@pandora> <388C8D61.D8B51762@edg.com> <200001241846.TAA03719@pandora>
Message-ID: <388CA14D.54595BD1@edg.com>

Martin von Loewis wrote:
[...]
> It seems that would work. However, I feel it is inconsistent to use
> one way of qualifying for nested names, and another way for the
> toplevel name. Instead, I'd say that, instead of
> 
>   <prefix><length><name>
> 
> you have
> 
>   <prefix><identifier>
> 
> and <identifier> is either
> 
>   <length><name>
> or
>   Q{<length><name>}*E
> 
> So instead of _11fQ1N, you get _1Q1N1fE. So method name would be
> mangled just as a class name.

I like that.  It would remove a case where something that appears
early in the demangled representation (the qualifier) is encoded
later (here: at the end).

(I think the only other case of this is return types; should we
change that?  My inclination is "no".)

Unless there are objections, I'll go that way.  Actually, I think
we can use the N...E segment for that and do away with Q altogether:

	_1N1N1fE --> Ret? N::f()

	Daveed



From jason at cygnus.com  Mon Jan 24 19:13:02 2000
From: jason at cygnus.com (Jason Merrill)
Date: 24 Jan 2000 11:13:02 -0800
Subject: array new-expressions: proposal
In-Reply-To: Martin von Loewis's message of "Mon, 24 Jan 2000 19:55:22 +0100"
References: <10001211016.ZM96896@isolde.engr.sgi.com> <3888CD84.9B138F3A@edg.com> <3888E565.868EA4D0@cup.hp.com> <3888F89A.47E3C7F5@edg.com> <u9r9f96s8o.fsf@yorick.cygnus.com> <10001241029.ZM102394@isolde.engr.sgi.com> <200001241855.TAA03757@pandora>
Message-ID: <u9901f7075.fsf@yorick.cygnus.com>

>>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

 >> We could just put in 16-byte padding for all types, but I think that's
 >> a waste.  There's no reason to do it.  It's just as easy to use 8-
 >> byte padding in general, and 16 only when we have to.

 > I'd like to repeat my proposal that there is *no padding* if the type
 > does not have a destructor. In that case, you could use the outcome of
 > operator new directly for arrays of char and unsigned char; the
 > multiple mentioned in 5.3.4/10 would be 0.

Agreed.  So there's no need for a special case.

Jason



From austern at isolde.engr.sgi.com  Mon Jan 24 23:21:49 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Mon, 24 Jan 2000 15:21:49 -0800
Subject: array new-expressions: proposal
In-Reply-To: Martin von Loewis <loewis@informatik.hu-berlin.de>
        "Re: array new-expressions: proposal" (Jan 24,  7:55pm)
References: <10001211016.ZM96896@isolde.engr.sgi.com> 
	<3888CD84.9B138F3A@edg.com>  <3888E565.868EA4D0@cup.hp.com> 
	<3888F89A.47E3C7F5@edg.com> 
	<u9r9f96s8o.fsf@yorick.cygnus.com> 
	<10001241029.ZM102394@isolde.engr.sgi.com> 
	<200001241855.TAA03757@pandora>
Message-ID: <10001241521.ZM99602@isolde.engr.sgi.com>

On Jan 24,  7:55pm, Martin von Loewis wrote:
> Subject: Re: array new-expressions: proposal
> > We could just put in 16-byte padding for all types, but I think that's
> > a waste.  There's no reason to do it.  It's just as easy to use 8-
> > byte padding in general, and 16 only when we have to.
>
> I'd like to repeat my proposal that there is *no padding* if the type
> does not have a destructor. In that case, you could use the outcome of
> operator new directly for arrays of char and unsigned char; the
> multiple mentioned in 5.3.4/10 would be 0.
>
> Regards,
> Martin
>-- End of excerpt from Martin von Loewis

That's an interesting idea, and it's yet another example of why
there really might be good reason for the standard to have granted
implementors as much freedom as it did.  It's certainly tempting
not to waste 8 bytes when we don't have to.

One of the things I'll have to think about is whether there are
any reasons that users might want to have that array count for
their own versions of placement new, provided that they're willing
to write nonportable code.  (And if they're not willing to write
nonportable code, then they shouldn't be using array placement
new.)

			--Matt



From mark at codesourcery.com  Tue Jan 25 18:38:13 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 25 Jan 2000 10:38:13 -0800
Subject: Vcall/vbase offset clarification
Message-ID: <20000125103813V.mitchell@codesourcery.com>


It is unclear from the draft what sign these offsets should have.  (In
other words, to compute the address of the vbase, do we add the vbase
offset, or subtract it?  To compute the adjusted `this' pointer do we
add the offset, or subtract it?)

I expect the intention was to make these additive, but we should add
some explicit language.  How about:

  The vbase offset is the value that must be added to the address of
  the derived class in order to obtain the address of the virtual 
  base.

  The vcall offset is the value that must be added to the `this' 
  pointer in the most-derived class in order to obtain the correct
  `this' pointer for the function called.

Also, it is probably worth noting in the Category 3/Category 4 section
on class layout that the algorithm for calculating what vbase offsets
you need is actually uniform.  The complication in Category 4 about
whether an indirect virtual base is inherited directly via a
non-virtual base cannot arise in Category 3 -- but it is correct to
simply code the Category 4 algorithm and apply it everywhere.  

In other words, the Category 3 algorithm is merely an optimization
over the Category 4 algorithm; the results obtained either way will be
identical.

At least I think so. :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Jan 25 21:54:23 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Jan 2000 13:54:23 -0800 (PST)
Subject: Memories...
Message-ID: <200001252154.NAA63545@baalbek.engr.sgi.com>

In updating the layout document, I realize that my memory is inadequate.
We talked extensively about A-19 (choosing a primary base), and my
cryptic notes suggest that we settled on considering all direct and
indirect virtual bases, but my memory is that we ended up with just
looking at direct ones.  My memory is probably faulty, but can anyone
else confirm?

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Tue Jan 25 23:24:59 2000
From: jason at cygnus.com (Jason Merrill)
Date: 25 Jan 2000 15:24:59 -0800
Subject: Memories...
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Tue, 25 Jan 2000 13:54:23 -0800 (PST)"
References: <200001252154.NAA63545@baalbek.engr.sgi.com>
Message-ID: <u9n1pt4tv8.fsf@yorick.cygnus.com>

My memory is that we settled on looking at indirect ones, too.

Jason



From dehnert at baalbek.engr.sgi.com  Wed Jan 26 01:30:39 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Jan 2000 17:30:39 -0800 (PST)
Subject: RTTI queries
Message-ID: <200001260130.RAA67025@baalbek.engr.sgi.com>

Following are the resolutions to Nathan's questions/suggestions from
last week's meeting.  I've also included them in the layout document.
I've also added a question at the end.

> Date: Thu, 06 Jan 2000 11:20:09 +0000
> From: Nathan Sidwell <nathan at acm.org>
> 
> 1) the declaration of __vmi_class_info uses a helper class of the
> following
>         struct __base_class_info {
>         type_info *type;
>         ptrdiff_t offset;
>         int vmi_flags;
>         }
> 1.1) I beleive `type' should be declared `__class_type_info const *type'
> (the description of __ptr_to_member_type_info has such a pointer and uses
> __class_type_info). The description of __si_class_type_info is vague on the
> base pointer's type, but that too should be `__class_type_info const *type'.

Yes.

> 1.2) From the description of __vmi_class_info it appears that the base
> class array uses the trailing array struct hack. This is ok, because
> it is always generated by the compiler. This is not documented.

Yes.

> 1.3) I cannot find a definition of what the `offset' member of
> __base_class_info is an offset for. For a virtual base it cannot be
> the offset from this base to the virtual base as that changes for different
> bases in a heirarchy. I presume it must be the offset in the vtable to the
> base offset. This is not documented.

Correct.  Now it is.

> 2) The ABI document specifies
> 
> void *__dynamic_cast (void *sub, __class_type_info *src,
>                 __class_type_info *dst, ptrdiff_t sr2dst_offset);
> 
> this is not const correct, I beleive it should be
> 
> void *__dynamic_cast (const void *sub, const __class_type_info *src,
>                 const __class_type_info *dst, ptrdiff_t sr2dst_offset);

Corrected.

> 3) __class_type_info contains a set of details flags. Whilst these look
> useful, I'm not sure that they are. When porting g++'s current dynamic_cast
> machinery (which as the document points out is semantically the same), these
> flags showed little use.

Discussion revealed some interest in this information for purposes
other than dynamic cast.  We decided not to think about removing them
until we get further along in the implementations.

> 3.1) flag 0x8 says `has privately inherited base'. Does this really mean
> private or does it actually mean non-public? both catch matching and dynamic
> cast distinguish public and non-public, not private and non-private.

Agreed that non-public is better.
 
> 3.2) More useful for dynamic cast, (and possibly catch matching) would be
> the following flags
> 	* Contains non-diamond shaped multiple base object
> 	* Is diamond shaped
> 	* has virtual base
> 	* has non-virtual base
> 	* has public base
> 	* has non-public base
> Note that the virtual/non-virtual and public/non-public are not mutually
> exclusive. Also note that I have not actually implemented anything with these
> flags, so I could be wrong.

Discussion was positive in principle.  We need a more precise
definition of "diamond shaped".  Can you provide that?

> 4) The name mangling scheme for type_info objects is not defined. Therefore
> I don't know how to name the type_info objects required in the runtime for
> the fundamental types (and their pointers). I see this is on today's agenda.

There's been some email discussion now, and we'll discuss it Thursday.
Daveed, will you send an update of your proposal based on the email?

I also notice that the document currently specifies namespace std:: for
many of the type_info classes.  Is this what we want, or should we use
our namespace abi::?  Also, can someone who knows please check that,
whichever it is, it is present everywhere it belongs (and not
elsewhere)?  Thanks.

> nathan
> 
> -- 
> Dr Nathan Sidwell :: sidwell at codesourcery.com
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/
> 
-		Jim Dehnert  x3-4272

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 26 04:05:11 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Jan 2000 20:05:11 -0800 (PST)
Subject: More rtti queries
Message-ID: <200001260405.UAA67854@baalbek.engr.sgi.com>

More feedback from the meeting:

> From: Nathan Sidwell <sidwell at codesourcery.com>
> 
> 1)
> Am I just having a thinko, but when would a type_info of a reference
> ever be generated? (So why __ref_type_info?)
> 
> typeid(T) will strip the reference [expr.typeid]/4
> a thrown type will never be a reference, [except.throw]/3
> a catch type ignores a reference [expr.handle]/3
> an exception specification can contain a reference, but behaves the same
> as a catch would. [except.spec]

Concern  remains that we may need to deal with pointers to ref
members.

> 2)
> Is __ptr_to_member_type_info for just member data, or both member data
> and member functions. The standard uses `pointer to member' to mean
> `pointer to member data', but given the inconsistency which as popped
> up with polymorphic, I'm not sure. It's also named inconsistently to
> __pointer_type_info, and might be considered a subclass of that :-)

I have fixed the spelling.  Someone at the meeting claims that the
standard uses `pointer to member' to mean both `pointer to member data'
and `pointer to member function'.

> nathan
> -- 
> Dr Nathan Sidwell :: sidwell at codesourcery.com
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 26 05:36:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Jan 2000 21:36:05 -0800 (PST)
Subject: Unwind table location
Message-ID: <200001260536.VAA68349@baalbek.engr.sgi.com>

> From cary at cup.hp.com  Thu Jan 20 09:40:51 2000
> 
> The first bullet you listed is the intended method. Both the unwind table 
> and the unwind info blocks are intended to be in the same segment as the 
> text with which they're associated. Thus, any segment-relative addresses 
> in those tables are understood to refer to locations in the same segment.
> 
> ...
> 
> The advantages to this scheme are that there are no dynamic relocations 
> for any unwind information (except function pointers in the GOT created 
> by LTOFF_FPTR), and that the unwind information does not cause any 
> increase in the application's per-process data space.
> 
> In order to unwind correctly, it's important that there is a one-to-one 
> relationship between text segments and unwind tables. The dynamic loader 
> needs to keep track of these relationships, so that the unwinder can find 
> the appropriate unwind table, given a pc value.
> 
> Instead of a table of triples, there is a PT_UNWIND program header table 
> entry that locates the unwind information for a load module; this entry 
> is intended to refer to a subset of the text segment. It's through this 
> entry that the dynamic loader finds the unwind table.

My concern with this comes from the possibility of generating multiple
text segments.  In such a case, if an implementation wants to put the
unwind information in a separate segment from text, there's no longer a
trivial way to find the associated text segments for fixup.  And
although I have no objection to putting these in text today for C++,
I'm concerned that a future requirement for C++ or some other language
might make it desirable to put them in data.  If there's a simple way
of making this work, I'd like to pursue it.

Does the ABI require that the segment table be allocated?
Easy to find?  As I recall, the runtime doesn't generally have easy
access to the file itself -- I think in Irix we generally use dynamic
tags to find things instead of the program header table for that reason.
But I don't know the details.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jan 26 06:38:03 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Jan 2000 22:38:03 -0800 (PST)
Subject: Updated status files
Message-ID: <200001260638.WAA68624@baalbek.engr.sgi.com>

I've updated the status files with most of the non-exception material
from last week's meeting.  I'll try to finish it all tomorrow.
HTML only so far, but a new contact info page in PDF.  Note that the
phone number changes this week, to (650) 933-7969.

-		Jim Dehnert  x3-4272



From sidwell at codesourcery.com  Wed Jan 26 10:54:24 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Wed, 26 Jan 2000 10:54:24 +0000
Subject: RTTI queries
References: <200001260130.RAA67025@baalbek.engr.sgi.com>
Message-ID: <388ED260.E29E4356@codesourcery.com>

Jim Dehnert wrote:
> 
> Following are the resolutions to Nathan's questions/suggestions from
> last week's meeting.  I've also included them in the layout document.
Great!

> > 3.2) More useful for dynamic cast, (and possibly catch matching) would be
> > the following flags
> >       * Contains non-diamond shaped multiple base object
> >       * Is diamond shaped
> >       * has virtual base
> >       * has non-virtual base
> >       * has public base
> >       * has non-public base
> > Note that the virtual/non-virtual and public/non-public are not mutually
> > exclusive. Also note that I have not actually implemented anything with these
> > flags, so I could be wrong.
> 
> Discussion was positive in principle.  We need a more precise
> definition of "diamond shaped".  Can you provide that?
[class.mi] (clause 10.1) provides good examples.
Paragraph 4 gives a non-diamond shaped graph with multiple base object.
At least one of the multiply inherited base objects must be non-virtual.
	struct L {};
	struct A : L {};
	struct B : L {};
	struct C : A, B {};
There are two distinct L base objects in C. C would have the non-diamond
shaped multiple inheritance flag set. A, B and C would have the non-virtual
base flag and public base flag set.

Paragraph 5 gives a diamond shaped graph. Such a multiply inherited base
object must be virtual.
	struct V {};
	struct A : virtual V {};
	struct B : virtual V {};
	struct C : A, B {};
This time C would have the diamond shaped flag set. A, B & C would have
the virtual base flag set and the public base flag set. C would also have
the non-virtual base flag set.

Paragraph 6 gives a graph which contains both features. Here there is
one non-virtual base and one virtual base.
	struct B {};
	struct X : virtual B {};
	struct Y : virtual B {};
	struct Z : B {};
	struct AA : X, Y, Z {};
In that example, AA would have both diamond and non-diamond flags set.
all would have the public base flag set, AA & Z would have the non-virtual
base flag set, AA, X & Y would have the virtual base flag set.

The above is treating the non-virtual and virtual base flags differently,
they should have the following meaning
	has non-virtual direct base
	has virtual direct or indirect base
similarly the public and non-public flags mean
	has public direct base (to have an indirect public base,
				there must be a direct public base)
	has non-public direct or indirect base

My thinking is that for dynamic_cast, having such information will allow
pruning parts of the inheritance graph walk. For instance, there can only
be distinct multiple target base objects when the non-diamond shaped flag
is set in the complete object. When we find them, the base sub-object started
from can only be a common base for both of them, if the diamond shaped flag
is set in the complete object. Alternatively, there can only be (at most)
one instance of the target type when the non-diamond shaped flag is clear.
When we find it via a non-public path, there could only be an alternative
public path if the complete object has the diamond shaped flag set. Similar
pruning should be possible for catch matching. Without such information,
the graph walk has to be pessimistic, which I beleive will slow down the
common case.

nathan
-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From sidwell at codesourcery.com  Wed Jan 26 11:03:13 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Wed, 26 Jan 2000 11:03:13 +0000
Subject: More rtti queries
References: <200001260405.UAA67854@baalbek.engr.sgi.com>
Message-ID: <388ED471.B33546A@codesourcery.com>

Jim Dehnert wrote:
> 
> More feedback from the meeting:
> Concern  remains that we may need to deal with pointers to ref
> members.
[dcl.mptr] (8.3.3)/3
	'A pointer to member shall not point to ... a member with
	reference type'
Wouldn't such a thing be a language extension, could this be documented?

> I have fixed the spelling.  Someone at the meeting claims that the
> standard uses `pointer to member' to mean both `pointer to member data'
> and `pointer to member function'.
Yes, they are correct. [dcl.mptr]/2 gives such an example, which I'd
missed. I'd got misled by [basic.compound]/3 which talks about (non-member)
pointers to object.

thanks for the clarifications

nathan

-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From sidwell at codesourcery.com  Wed Jan 26 14:21:35 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Wed, 26 Jan 2000 14:21:35 +0000
Subject: rtti data structures (again)
Message-ID: <388F02EF.A80C7B0E@codesourcery.com>

Hi,
Sorry, there are still some problems with the rtti data layout, which
I'd not noticed (cos I implemented what I thought was written, not
what's actually written).

1) The amended (25th Jan) RTTI says
	'Note that the full structure described by an RTTI descriptor may
	include incomplete types not required by the Standard to be
	completed, although not in contexts where it would cause ambiguity.'
I don't believe this is the case, the example I posted a couple of weeks
back pointed this out. Here it is, in a slightly more compact form

	struct A;
	struct B;

	int main ()
	{
	  try {
	    throw (B **)0;
	  } catch (A const * const *) { 
	    abort ();
	  } catch (B const * const *) {
	    ;//ok
	  } catch (...) {
	    abort ();
 	  }
	}
I believe this is well formed and should not abort. The RTTI document
indicates that `typeid (A const * const *)' and
`typeid (B const * const *)' will produce __pointer_type_info chains that
end at a weak symbol reference for A and B respectively. These will both
resolve to zero. How is catch matching able to determine the difference
between `A const * const *' and `B const * const *' under these
circumstances? If this is a shortcoming of the ABI, or considered a defect
in the standard, it should be documented.

There seems to be no discussion of this case.

2) __si_class_type_info is documented for a single non-virtual heirarcy,
and __vmi_class_type_info for a class containing (directly or indirectly)
a multiple or virtual inheritance component. My mistake was to use
__si_class_type_info for a class with a single base, regardless of the
heirachy within the base (that is the current g++ behaviour). I can see
that for dynamic_cast, knowing that __si_class_type_info has only single
inheritance could speed up checking for the original source base started
from, in certain circumstances. Primarily these are target to source
checks. However, those cases where the singly inherited nature
of __si_class_type_info helps, are exactly those cases where the
src2dst_offset hint tells us anyway. That hint is more general as it works
in multiple heirarchies too. Hence, we have not gained in restricting
__si_class_type_info to entirely singly inherited classes. We have lost
for cases where a class has a single base which happens to contain
multiple or virtual inheritance. That has to go through the complexity
of the general case.

An additional surprise is in the following,
	struct A {int non_empty;};
	struct B : A {virtual ~B ();};
	struct C : B {};
These are singly inherited graphs. C will be layed out in an
__si_class_type_info. However, B cannot be, because it has introduced
a vtable, which will be at offset zero. So the A base of B will be at
some non-zero offset, which is not representable by __si_class_type_info.
So within an __si_class_type_info heirarchy, there can exist
__vmi_class_type_info nodes.

If it is intended that __si_class_type_info is for completely single
inheritance, could the rationale be documented?

3) __si_class_type_info is for both public and non-public inheritance
(again, something I'd not noticed, thinking it was for public only). For
this to work, the __class_type_info flag bit 0x8 'non-publicly inherited
base' must mean `non-publicly inherited direct base'. Please can the wording
about bases here explicitly say `direct base' `indirect base' or `direct or
indirect base'. The description currently use `contains' and `has' which
are open to interpretation.

In dynamic casting, access is important. In a cross cast from base A via
complete type C to another base B, both B and A must be publicly accessible
from C. It might be that dynamic_cast locates B, and, knowing that C does
not have multiply inherited subobjects, determines it need look no further.
However, it must determine access. If C has no non-public direct or indirect
bases, access must be OK, without further inspection. However the hint flag
0x8 can't be indicating that, as it is only for direct bases. (This was the
one case where I was able to take advantage of these flags, but alas it seems
I can't.) 

nathan
-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From daveed at edg.com  Wed Jan 26 15:59:41 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 26 Jan 2000 07:59:41 -0800
Subject: RTTI queries
References: <200001260130.RAA67025@baalbek.engr.sgi.com>
Message-ID: <388F19ED.7F66B6EB@edg.com>

Jim Dehnert wrote:
[...]
> > 4) The name mangling scheme for type_info objects is not defined. Therefore
> > I don't know how to name the type_info objects required in the runtime for
> > the fundamental types (and their pointers). I see this is on today's agenda.
> 
> There's been some email discussion now, and we'll discuss it Thursday.
> Daveed, will you send an update of your proposal based on the email?

Yes.  It's not going to be complete by any means, but I've incorporated
most of the inputs.  I'll send it out after fixing the examples.

	Daveed



From daveed at edg.com  Thu Jan 27 00:11:44 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 26 Jan 2000 16:11:44 -0800
Subject: Updated mangling specs
Message-ID: <388F8D40.6FB44DD5@edg.com>

Attached are the slightly updated name mangling specifications.

	Daveed
-------------- next part --------------
Name mangling
=============

[ Notes:
   1) Most of the "special entities" spec is still missing.
   2) The truncation+hashing approach needs to be described if desired.
   3) A proof of nonambiguity is needed.
   4) Many things (e.g., the <prefix>) may need tweaking.
--end Notes ]

Entities with C linkage and file scope variables are not mangled.

General structure
-----------------

    <prefix><name><type>opt

<prefix> is one of:
   . "_D" for namespace scope variables and static data members
   . "_F" for functions and operators (also those generated from a template)
   . "_S" for special entities (constructors etc; see below)

<length> is the decimal representation of the length of <name>.

<name> is one of:
   <unqualified-name>
      <length><function name>
      <length><function name>I<template-args>E
      <operator-name>
      <operator-name>I<template-args>E
      <special-name>
         (see below: ctors, vtables, ...)   
   <qualified-name>
      N<qual-1>...<qual-J><unqualified-name>E

<type> is used to disambiguate overloaded functions, but also to
distinguish the various virtual tables associated with a given complete
class type.  For nontemplate functions, <type> lists the parameter types
only. For template functions, <type> lists the return type followed by
the parameter types.  <type> is omitted for variables and static data
members.


Operator encodings
------------------

Operators appear as function names, but also in nontype template argument
expressions.
   new           nw
   new[]         na
   delete        dl
   delete[]      da
   - (unary)     ng
   & (unary)     ad
   * (unary)     de
   ~             co
   +             pl
   -             mi
   *             ml
   /             dv
   %             rm
   &             an
   |             or
   ^             eo
   =             aS
   +=            pL
   -=            mI
   *=            mL
   /=            dV
   %=            rM
   &=            aN
   |=            oR
   ^=            eO
   <<            ls
   >>            rs
   <<=           lS
   >>=           rS
   ==            eq
   !=            ne
   <             lt
   >             gt
   <=            le
   >=            ge
   !             nt
   &&            aa
   ||            oo
   ++            pp
   --            mm
   ,             cm
   ->*           pm
   ->            pt
   ()            cl
   []            ix
   ?             qu
   (cast)        cv

Unlike Cfront, unary and binary operators using the same symbol have
different encodings.  All operators are encoded using exactly two letters,
the first of which is lowercase.


Other special functions and entities
------------------------------------

   TV            virtual table
   TI            typeinfo structure
   C1            complete object constructor
   C2            base object constructor
   D0            deleting destructor
   D1            complete object destructor
   D2            base object destructor


Type encodings
--------------
Types are encoded as follows:

builtin types: (one letter)
   void                     v
   wchar_t                  w
   bool                     b
   char                     c
   signed char              a
   unsigned char            h
   short                    s
   unsigned short           t
   int                      i
   unsigned int             j
   long                     l
   unsigned long            m
   long long                x
   unsigned long long       y
   float                    f
   double                   d
   long double              e
   ellipsis                 z

classes & enums:
   <decimal length of unqualified name><unqualified-name>
   Class names can optionally be followed by the encoding of a template
   argument list (see below).

template params (including nontype and template template parameters):
   T<param num>_
   TT<param num>_  // For template parameters

other dependent names: (see below)
   N<qual 1>...<qual N><unqual name>E

template argument list: (see below)
   I<arg1>...<argN>E

function types:
   F<return type><param type 1>...<param type N>E

array types:
   A<dimension>_<element type encoding>

pointers, references:
   P<encoding pointed-to type>
   R<encoding pointed-to type>

pointer-to-member:
   M<class type encoding><member type encoding>

cv-qualifiers:
   K const
   V volatile
   r restrict


Scope encoding
--------------
Scope is encoded as the qualifier of qualified names: it can be the top-level
name qualification or it can appear inside <type> to denote dependent types
or bind specific names as arguments.  Qualified names are encoded as:
   N<qual 1>...<qual N><unqual name>E
where each <qual K> is the encoding of a namespace name or a class name (with
the latter possibly including a template argument list).


Template argument encoding
--------------------------
Template-ids are encoded by following the unqualified name with
	I<arguments>E
This is used for the <specialization> segment in particular, but also in the
<type> and <scope> segments.

Type arguments appear using their regular encoding.  For example, the
template class "A<char, float>" is encoded as "1AIcfE".  A slightly more
involved example might be a dependent function parameter type "A<T2>::X"
(T2 is the second template parameter) which is encoded as "N1AIT2_E1XE",
where the "N...E" construct is used to describe a qualified name.

Nontype arguments can be:
   a) a literal, e.g. "A<42L>": these are encoded as "L<type><num>E";
      negative integer <num> are preceded with "n"; false is "Lb0E";
      true is "Lb1E".  For example, "A<-42L>" becomes "1AILln42EE".
   b) a reference to an entity with external linkage: encoded with
      "L<mangled name>E".  For example:
          void foo(char); // mangled as _F3fooc
          template<void (&)(char)> struct CB;
          // CB<foo> is encoded with "2CBIL_F3foocEE"
   c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix traversal
      of the operators involved, delimited by "X...E".  The operators are
      encoded using their two letter mangled names.  For example, "B<(J+1)/2>"
      becomes "1BI Xdv pl T1_ Li1E Li2E E E" (the blanks were inserted to
      visualize the decomposition).


Compression
-----------
The subsequence
   S<num>_
is used to repeat the num-th most recently encoded type (in right-to-left
order, starting at "1"), but only if "S<num>_" is strictly shorter that the
previous encoding.

(Work on numbering other entities like templates, function names and variable
names.)


Truncation
----------
If the mangled name exceeds 255 characters in length, it is reduced as
follows:
    (description of strong hash and truncation)



Examples
--------

1) "f": The C function or variable "f" or a file scope variable "f".

2) "_F1f": Ret? f();

3) "_F1fi": Ret? f(int);

4) "_F3foo3bar": Ret? foo(bar);

5) "_Frm1X1X": Ret? operator%(X, X);

6) "_FplR1XR1X": Ret? operator+(X&, X&);

7) "_FlsRK1XS1_": Ret? operator(X const&, X const&);
       (Note: strlen("S1_")<strlen("RK1X"))

8) "_F1fIiE": void f<int>();

9) "_F1fIiEvi": void f<int>(/*nondependent*/int);
       (Note: the return type is always explicitly encoded for template
              functions taking parameters.)

10) "_F5firstI3DuoEvS2_": void first<Duo>(/*nondependent*/Duo);
       (Note: "S1_" would refer to the "void" return type.)

11) "_F5firstI3DuoEvT1_": void first<Duo>(/*T1=*/Duo);

12) "_FN1N1fE": Ret? N::f();

13) "_FN6System5Sound4beepE: Ret? System::Sound::beep();

14) "_DN5Arena5levelE": Type? Arena::level;

15) "_DN5StackIiiE5levelE": Type? Stack<int, int>::level

16) "_F1fI1XEvPVN1AIT1_E1TE": void f<X>(A</*T1=*/X>::T volatile*);
                |         |
                |         `------> end dependent name encoding
                `----------------> start of dependent name A<T1>::T

17) "_FngIL42iEEvN1AIXplT1_L2iEE1TE": void operator-</*int J=*/42>(A<J+2>::T);

18) "_F4makeI7FactoryiETT1_IT2_E": T1<T2> make();
                                          // T1 == template template parameter


From cary at cup.hp.com  Thu Jan 27 00:21:48 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 26 Jan 2000 16:21:48 -0800
Subject: Unwind table location
Message-ID: <200001270021.QAA16805@adlmail.cup.hp.com>

>My concern with this comes from the possibility of generating multiple
>text segments.  In such a case, if an implementation wants to put the
>unwind information in a separate segment from text, there's no longer a
>trivial way to find the associated text segments for fixup.  And
>although I have no objection to putting these in text today for C++,
>I'm concerned that a future requirement for C++ or some other language
>might make it desirable to put them in data.  If there's a simple way
>of making this work, I'd like to pursue it.

Re. multiple text segments...

Our position is that we would only need more than one text segment in a 
single load module where we need to establish different access 
permissions for some text pages than for others. In such a case, we 
consider them to be separate -- but contiguous -- text segments from the 
loader's point of view, and a single text segment from the unwinder's 
point of view. Therefore, we still need only one unwind table per load 
module.

This points out the hazy definition of "segment" and "program header 
table entry" in the ELF specification. Some program header table entries 
describe segments that are disjoint from all other segments, while others 
(like PT_DYNAMIC and PT_UNWIND) describe "sub-segments" that are really 
part of another segment.

Re. unwind tables in data...

The performance bigots here would *never* let me put the unwind tables in 
the data segment. Nevertheless, if some language-specific data really 
needs to be in data, it can be arranged by putting "LTV" pointers in the 
language-specific data that point to an auxiliary block of info in the 
data segment. A much earlier version of our C++ exception handling tables 
in fact did just that.

("LTV" pointers are "link-time virtual" addresses. At link time, an LTV 
relocation works just like the corresponding DIR relocation, except that 
no dynamic relocation is generated, so the associated word can be placed 
in a read-only segment. The consumer of that pointer must, at run time, 
figure out what segment the link-time virtual address refers to and apply 
the appropriate relocation factor to the address. The required 
information can be obtained from the dynamic loader. Note that this 
scheme requires that the linker-assigned addresses for all of the 
loadable segments do not overlap.)

>Does the ABI require that the segment table be allocated?
>Easy to find?  As I recall, the runtime doesn't generally have easy
>access to the file itself -- I think in Irix we generally use dynamic
>tags to find things instead of the program header table for that reason.
>But I don't know the details.

No, but the dynamic loader does have access to it. When we need to find 
an unwind table, we ask the dynamic loader: given a pc value, its 
dlmodinfo() entry point locates the load module containing that text 
segment, and returns a struct load_module_desc, which contains, among 
other things, a pointer to the unwind table for that load module.

-cary



From mendell at ca.ibm.com  Thu Jan 27 01:51:09 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Wed, 26 Jan 2000 20:51:09 -0500
Subject: Updated mangling specs
Message-ID: <85256873.0009F9AD.00@D51MTA05.pok.ibm.com>

Does anyone implement this for templates?

   c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix traversal
      of the operators involved, delimited by "X...E".  The operators are
      encoded using their two letter mangled names.  For example,
"B<(J+1)/2>"
      becomes "1BI Xdv pl T1_ Li1E Li2E E E" (the blanks were inserted to
      visualize the decomposition).


We certainly don't.  The expression gets converted to an integer value in
our compiler, and the integer is what is encoded.

Can you tell me what part of the standard applies here?

Mark





From daveed at edg.com  Thu Jan 27 02:39:37 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 26 Jan 2000 18:39:37 -0800
Subject: Updated mangling specs
References: <85256873.0009F9AD.00@D51MTA05.pok.ibm.com>
Message-ID: <388FAFE9.1FE5AD84@edg.com>

mendell at ca.ibm.com wrote:
> 
> Does anyone implement this for templates?
> 
>    c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix traversal
>       of the operators involved, delimited by "X...E".  The operators are
>       encoded using their two letter mangled names.  For example,
> "B<(J+1)/2>"
>       becomes "1BI Xdv pl T1_ Li1E Li2E E E" (the blanks were inserted to
>       visualize the decomposition).
> 
> We certainly don't.  The expression gets converted to an integer value in
> our compiler, and the integer is what is encoded.
> 
> Can you tell me what part of the standard applies here?

Sure: it's 14.5.5.1 (most paragraphs).

	Daveed



From dehnert at baalbek.engr.sgi.com  Thu Jan 27 07:01:51 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 26 Jan 2000 23:01:51 -0800 (PST)
Subject: Meeting agenda for 27 Jan
Message-ID: <200001270701.XAA73109@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Exception handling.

  B) Mangling.

  C) Data layout.

So, take a look at the material associated with these issues:

  1) D-10/13:  Exceptions.  The writeup changes from last week are in
     color.  I've closed the issues.  If you have comments, bring them
     up at the meeting or via email by Friday -- at that point, I'll
     remove the color and send it to the base psABI group.

  2) D-11:  Let's discuss approaches to providing the pthreads entries.

  3) D-12:  Unwind table location.  See the exchange with Cary (HP)
     in the open issues document.

  4) F-*:  Mangling.  Discuss updated proposal from Daveed.

  5) A-*:  Nathan raised more questions about RTTI.  Let's go
     through them and either answer them or identify issues.

  6) A-19:  Primary virtual base classes (closed).  Does the writeup
     in the layout document look OK?  Bring it up if you have a comment
     -- I don't plan to discuss it otherwise.

  7) A-21:  Placement new array cookies.  Discuss the options if
     there's time

Issues that are active and awaiting proposals:

  a) C-4:  Daveed will write up construction vtables so we can
     verify.  Wait.

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Thu Jan 27 11:37:16 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 27 Jan 2000 12:37:16 +0100
Subject: Updated mangling specs
In-Reply-To: <388F8D40.6FB44DD5@edg.com> (message from Daveed Vandevoorde on
	Wed, 26 Jan 2000 16:11:44 -0800)
References: <388F8D40.6FB44DD5@edg.com>
Message-ID: <200001271137.MAA19795@pandora>

> 18) "_F4makeI7FactoryiETT1_IT2_E": T1<T2> make();
>                                           // T1 == template template parameter

What happened to Factory, int? Is this

   Factory<int> make<Factory,int>();

Regards,
Martin



From mendell at ca.ibm.com  Thu Jan 27 14:23:19 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Thu, 27 Jan 2000 09:23:19 -0500
Subject: Updated mangling specs
Message-ID: <87256873.004ED825.00@d53mta04h.boulder.ibm.com>



Our template/standard guy thinks that this is not essential.  His words:



   My understanding of 14.5.5.1 is that it says that this mangling is not
   required.  Paragraphs 6 to 8 define equivalent and functionally
   equivalent expressions and function templates.

   'I + 10' and 'I + 1 + 2 + 3 + 4' are not equivalent but they are
   functionally equivalent.

   I think the mangling described below could be used to make all
   nonequivalent functions disctinct, but these paragraphs state that only
   functionally equivalent function template are distinct.

   Quotes from paragraph 8 of 14.5.5.1.

   'This rule quarantees that equivalent declarations will be linked with
   one another, while not requiring implementations to use heroic efforts
   to guarantee that functionally equivalent declarations will be treated
   as distinct'.  I believe the mangling described below is the heroic
   effort mentioned here.

   '// Ill-formed, no diagnostic required
    template <int I> void f(A<I>, A<I+10>);
    template <int I> void f(A<I>, A<I+1+2+3+4>);'

   I'm guessing that the mangling below would be used to make this well
   formed by making these two functions distinct.

   Having said all this, I'm not 100% sure that I'm right.






mendell at ca.ibm.com wrote:
>
> Does anyone implement this for templates?
>
>    c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix
traversal
>       of the operators involved, delimited by "X...E".  The operators are
>       encoded using their two letter mangled names.  For example,
> "B<(J+1)/2>"
>       becomes "1BI Xdv pl T1_ Li1E Li2E E E" (the blanks were inserted to
>       visualize the decomposition).
>
> We certainly don't.  The expression gets converted to an integer value in
> our compiler, and the integer is what is encoded.
>
> Can you tell me what part of the standard applies here?

Sure: it's 14.5.5.1 (most paragraphs).

     Daveed





From ddd at cup.hp.com  Thu Jan 27 18:12:46 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 27 Jan 2000 18:12:46 +0000
Subject: Warning: Phone number change
Message-ID: <38908A9E.9FBCF5E0@cup.hp.com>

As a reminder, the phone number for the conference has changed. The new phone
number is 650-933-7969.

Regards
Christophe



From daveed at edg.com  Thu Jan 27 18:08:35 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 27 Jan 2000 10:08:35 -0800
Subject: Updated mangling specs
References: <388F8D40.6FB44DD5@edg.com> <200001271137.MAA19795@pandora>
Message-ID: <389089A3.989AADE8@edg.com>

Martin von Loewis wrote:
> 
> > 18) "_F4makeI7FactoryiETT1_IT2_E": T1<T2> make();
> >                                           // T1 == template template parameter
> 
> What happened to Factory, int? Is this
> 
>    Factory<int> make<Factory,int>();

Oops!  Yes, that's exactly it.  T1 is a template template parameter.
I'm actually no longer convinced that we need to distinguish template
template parameters from type and nontype template parameters.  If so,
TT1_ in the above could probably just be T1_.

	Daveed



From daveed at edg.com  Thu Jan 27 19:39:07 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 27 Jan 2000 11:39:07 -0800
Subject: Updated mangling specs
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com>
Message-ID: <38909EDB.422AFD14@edg.com>

mendell at ca.ibm.com wrote:
> 
> Our template/standard guy thinks that this is not essential.  His words:
> 
>    My understanding of 14.5.5.1 is that it says that this mangling is not
>    required.  Paragraphs 6 to 8 define equivalent and functionally
>    equivalent expressions and function templates.
> 
>    'I + 10' and 'I + 1 + 2 + 3 + 4' are not equivalent but they are
>    functionally equivalent.
>
>    I think the mangling described below could be used to make all
>    nonequivalent functions disctinct, but these paragraphs state that only
>    functionally equivalent function template are distinct.

That only goes for the nondependent constant expressions (you're free to
evaluate them or not).

However, if the depend components of the expression differ, the template
signatures differ.

Consider the following example:

	// file 1:
	template<int I> int f(A<I+1>::X) { return 1; }
	template void f<1>(A<2>::X);

	// file 2:
	template<int I> int f(A<2*I>::X) { return 2; }
	template void f<1>(A<2>::X);

Two distinct functions are instantiated in this program and that is fine.
So we must be able to differentiate them.

This is in fact what paragraph 5 of 14.5.5.1 says:

	When an expression that references a template parameter is used in
	the function parameter list or the return type in the declaration of
	a function template, the expression that references the template
	parameter is part of the signature of the function template. This is
	necessary to permit a declaration of a function template in one
	translation unit to be linked with another declaration of the function
	template in another translation unit and, conversely, to ensure that
	function templates that are intended to be distinct are not linked
	with one another. [Example: 

	      template <int I, int J> A<I+J> f(A<I>, A<J>);   //  #1
	      template <int K, int L> A<K+L> f(A<K>, A<L>);   //  same as #1
	      template <int I, int J> A<I-J> f(A<I>, A<J>);   //  different from #1

	--- end example] [Note: Most expressions that use template parameters
	use non-type template parameters, but it is possible for an expression
	to reference a type parameter. For example, a template type parameter
	can be used in the sizeof operator. ] 


	Daveed



From loewis at informatik.hu-berlin.de  Fri Jan 28 18:07:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 28 Jan 2000 19:07:55 +0100
Subject: Updated mangling specs
In-Reply-To: <38909EDB.422AFD14@edg.com> (message from Daveed Vandevoorde on
	Thu, 27 Jan 2000 11:39:07 -0800)
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com> <38909EDB.422AFD14@edg.com>
Message-ID: <200001281807.TAA09173@pandora>

> Consider the following example:
> 
> 	// file 1:
> 	template<int I> int f(A<I+1>::X) { return 1; }
> 	template void f<1>(A<2>::X);
> 
> 	// file 2:
> 	template<int I> int f(A<2*I>::X) { return 2; }
> 	template void f<1>(A<2>::X);

Maybe I'm having problem with the English language here. The phrase is

# Two expressions involving template parameters that are not
# equivalent are functionally equivalent if, for any given set of
# template arguments, the evaluation of the expression results in the
# same value.

Does that mean: They are functionally equivalent if there exists a set
of arguments so they evaluate to the same value?

Or does that mean: They are functionally equivalent if they evaluate
to the same value for every set of template arguments?

I'd interpret that as meaning the former: I+1 and 2*I are functionally
eqivalent, because there is an I (I=1) for which the value is the
same.

As a result, your example would ill-formed: It defines two templates
which are functionally equivalent but not equivalent.

Of course, if it meant the latter, your example would be
well-formed. I'm not sure what kinds of heroic efforts the distinction
of functionally equivalent and equivalent would save you, though.

Regards,
Martin

P.S. Under my interpretation, the example in 14.5.5.1/5 (which you had
quoted) would be ill-formed, as the instantiations would be
indistinguishable for I=J=K=L=0. I'd claim this as a defect, though.



From daveed at edg.com  Fri Jan 28 18:26:51 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Jan 2000 10:26:51 -0800
Subject: Updated mangling specs
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com> <38909EDB.422AFD14@edg.com> <200001281807.TAA09173@pandora>
Message-ID: <3891DF6B.2CB3DE90@edg.com>

Martin von Loewis wrote:
> 
> > Consider the following example:
> >
> >       // file 1:
> >       template<int I> int f(A<I+1>::X) { return 1; }
> >       template void f<1>(A<2>::X);
> >
> >       // file 2:
> >       template<int I> int f(A<2*I>::X) { return 2; }
> >       template void f<1>(A<2>::X);
> 
> Maybe I'm having problem with the English language here. The phrase is
> 
> # Two expressions involving template parameters that are not
> # equivalent are functionally equivalent if, for any given set of
> # template arguments, the evaluation of the expression results in the
> # same value.
> 
> Does that mean: They are functionally equivalent if there exists a set
> of arguments so they evaluate to the same value?
> 
> Or does that mean: They are functionally equivalent if they evaluate
> to the same value for every set of template arguments?
> 
> I'd interpret that as meaning the former: I+1 and 2*I are functionally
> eqivalent, because there is an I (I=1) for which the value is the
> same.

It's definitely the latter interpretation.  The intent was to express the
"inverted A" quantifier, though it probably would have been clearer to
say "for all" instead of "for any".

> As a result, your example would ill-formed: It defines two templates
> which are functionally equivalent but not equivalent.
> 
> Of course, if it meant the latter, your example would be
> well-formed. I'm not sure what kinds of heroic efforts the distinction
> of functionally equivalent and equivalent would save you, though.
> 
> Regards,
> Martin
> 
> P.S. Under my interpretation, the example in 14.5.5.1/5 (which you had
> quoted) would be ill-formed, as the instantiations would be
> indistinguishable for I=J=K=L=0. I'd claim this as a defect, though.

Its not a defect: this was a deliberate decision by the C++ committee,
and the example was put in specifically to clarify that.

	Daveed



From loewis at informatik.hu-berlin.de  Fri Jan 28 18:43:05 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 28 Jan 2000 19:43:05 +0100
Subject: Updated mangling specs
In-Reply-To: <3891DF6B.2CB3DE90@edg.com> (message from Daveed Vandevoorde on
	Fri, 28 Jan 2000 10:26:51 -0800)
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com> <38909EDB.422AFD14@edg.com> <200001281807.TAA09173@pandora> <3891DF6B.2CB3DE90@edg.com>
Message-ID: <200001281843.TAA10422@pandora>

> It's definitely the latter interpretation.  The intent was to express the
> "inverted A" quantifier, though it probably would have been clearer to
> say "for all" instead of "for any".

I trust you that this was indeed the intent. However, it seems that
the only reasonable implementation is to encode all expressions as
they appear in the source. If that is done, what can be saved by not
having to tell functionally-equivalent templates apart? Using an
expression encoding, 'I+10' and 'I+1+2+3+4' would turn out to be
different, so why explicitly mention that an implementation could
consider them equivalent?

Regards,
Martin




From daveed at edg.com  Fri Jan 28 19:06:23 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Jan 2000 11:06:23 -0800
Subject: Updated mangling specs
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com> <38909EDB.422AFD14@edg.com> <200001281807.TAA09173@pandora> <3891DF6B.2CB3DE90@edg.com> <200001281843.TAA10422@pandora>
Message-ID: <3891E8AF.F2390669@edg.com>

Martin von Loewis wrote:
> 
> > It's definitely the latter interpretation.  The intent was to express the
> > "inverted A" quantifier, though it probably would have been clearer to
> > say "for all" instead of "for any".
> 
> I trust you that this was indeed the intent. However, it seems that
> the only reasonable implementation is to encode all expressions as
> they appear in the source. If that is done, what can be saved by not
> having to tell functionally-equivalent templates apart? Using an
> expression encoding, 'I+10' and 'I+1+2+3+4' would turn out to be
> different, so why explicitly mention that an implementation could
> consider them equivalent?

You can either mangle the sequence of tokens after normalizing the
parameter tokens (e.g., "J+10" and "L+10" are definitely equivalent
if L and J are both first template parameters of the nontype kind),
or you can construct a mangled representation of the tree structure
representing the expression.  In the latter case, you might have
constant-folded nondependent subexpressions.

The EDG front end does the former, but HP aC++ does the latter.

	// File 1:
	template<int I> void f(double (&)[I+1+2]) {}
	template void f<1>(double (&)[4]);  // (1)

	// File 2:
	template<int I> void f(double (&)[I+3]) {}
	template void f<1>(double (&)[4]);  // Links up with (1) on aC++
	                                    // but not with EDG

	Daveed



From jason at cygnus.com  Fri Jan 28 02:04:34 2000
From: jason at cygnus.com (Jason Merrill)
Date: 27 Jan 2000 18:04:34 -0800
Subject: Unwind table location
In-Reply-To: Cary Coutant's message of "Wed, 26 Jan 2000 16:21:48 -0800"
References: <200001270021.QAA16805@adlmail.cup.hp.com>
Message-ID: <u9r9f39cjx.fsf@casey.cygnus.com>

Cary Coutant <cary at cup.hp.com> writes:

> Our position is that we would only need more than one text segment in a 
> single load module where we need to establish different access 
> permissions for some text pages than for others. In such a case, we 
> consider them to be separate -- but contiguous -- text segments from the 
> loader's point of view, and a single text segment from the unwinder's 
> point of view. Therefore, we still need only one unwind table per load 
> module.

Is there a reloc in the base ABI for the difference between labels in
different sections?  I'm assuming so; it would seem necessary to write
the self-relative offset from the unwind info table to a function in
another text segment (which will be combined with the primary text
segment at link time).

Jason



From mendell at ca.ibm.com  Fri Jan 28 20:08:04 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Fri, 28 Jan 2000 15:08:04 -0500
Subject: Updated mangling specs
Message-ID: <87256874.006E657F.00@d53mta04h.boulder.ibm.com>



More questions:

This was one of the questions I wanted to ask Daveed.

The other one (maybe it's two) is:

Does this rule only distinguish between instantiation that would be
ambiguous if both template definition were visible at the instantiation
point?  If so, do you know why the committee made this decision?

translation unit 1
void f(char);
void g() { f(1); }

translation unit 2
void f(int);
void h() { f(1); }

This is legal code, but I think is fairly obvious a blemish on the
language.  External functions are usually declared in header files, so in
general the programmer isn't going to know which f is being called and the
inclusion of another header is going to change the behaviour of the
program.  Paragraph 5 of 14.5.5.1 seems to me to be there solely to make
this situation worse.  What am I missing?






From cary at cup.hp.com  Fri Jan 28 23:51:13 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Fri, 28 Jan 2000 15:51:13 -0800
Subject: Unwind table location
Message-ID: <200001282350.PAA24742@adlmail.cup.hp.com>

>Is there a reloc in the base ABI for the difference between labels in
>different sections?  I'm assuming so; it would seem necessary to write
>the self-relative offset from the unwind info table to a function in
>another text segment (which will be combined with the primary text
>segment at link time).

Yes. In particular, the self-relative offsets can be relocated using 
PCREL relocations. For other unanticipated situations, there is a 
subtract relocation and a composition rule (thanks to Jim) allowing you 
to apply a DIR relocation and a SUB relocation to the same location to 
form the difference between two labels.

-cary



From daveed at edg.com  Sat Jan 29 00:02:09 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Jan 2000 16:02:09 -0800
Subject: Updated mangling specs
References: <87256874.006E657F.00@d53mta04h.boulder.ibm.com>
Message-ID: <38922E01.CFAA0C43@edg.com>

mendell at ca.ibm.com wrote:
> 
> More questions:
> 
> This was one of the questions I wanted to ask Daveed.
> 
> The other one (maybe it's two) is:
> 
> Does this rule only distinguish between instantiation that would be
> ambiguous if both template definition were visible at the instantiation
> point? 

I believe that that is true.

> If so, do you know why the committee made this decision?

It grew out of discussions of what it meant for two template declarations
to refer to the same entity.  A number of people felt it was important
not to outlaw examples like the ones we have been discussing.  Not enough
people cared to defend the opposite situation.  Back then I was naive and
unexperienced ;-)  Oh, and I had no vote---don't shoot the messenger ;-)

> translation unit 1
> void f(char);
> void g() { f(1); }
> 
> translation unit 2
> void f(int);
> void h() { f(1); }
> 
> This is legal code, but I think is fairly obvious a blemish on the
> language. 

Hmmm, I cannot make up my mind about that.  Even when I transpose that
to a real module system, I see such situations as a possibility.

> External functions are usually declared in header files, so in
> general the programmer isn't going to know which f is being called and the
> inclusion of another header is going to change the behaviour of the
> program.  Paragraph 5 of 14.5.5.1 seems to me to be there solely to make
> this situation worse.  What am I missing?

I also find it to have little technical benefit.

It does guarantee us a job for life though <grin>.

	Daveed



From daveed at edg.com  Sat Jan 29 00:04:44 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Jan 2000 16:04:44 -0800
Subject: Updated mangling specs
References: <87256873.004ED825.00@d53mta04h.boulder.ibm.com> <38909EDB.422AFD14@edg.com> <200001281807.TAA09173@pandora> <3891DF6B.2CB3DE90@edg.com> <200001281843.TAA10422@pandora> <3891E8AF.F2390669@edg.com>
Message-ID: <38922E9C.ED52AF28@edg.com>

[...]
> You can either mangle the sequence of tokens after normalizing the
> parameter tokens (e.g., "J+10" and "L+10" are definitely equivalent
> if L and J are both first template parameters of the nontype kind),
> or you can construct a mangled representation of the tree structure
> representing the expression.  In the latter case, you might have
> constant-folded nondependent subexpressions.
> 
> The EDG front end does the former, but HP aC++ does the latter.

Actually, upon closer investigation it appears that EDG also does the 
latter, but only simple kinds of folding are applied: since I+1+2
is really (I+1)+2 no folding is done, but 1+2+I would be (1+2)+I and
we fold that to 3+I.

	Daveed



From jason at cygnus.com  Sat Jan 29 01:47:23 2000
From: jason at cygnus.com (Jason Merrill)
Date: 28 Jan 2000 17:47:23 -0800
Subject: More rtti queries
In-Reply-To: Nathan Sidwell's message of "Wed, 26 Jan 2000 11:03:13 +0000"
References: <200001260405.UAA67854@baalbek.engr.sgi.com> <388ED471.B33546A@codesourcery.com>
Message-ID: <u9puul1wes.fsf@yorick.cygnus.com>

>>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:

 > Jim Dehnert wrote:
 >> 
 >> More feedback from the meeting:
 >> Concern  remains that we may need to deal with pointers to ref
 >> members.
 > [dcl.mptr] (8.3.3)/3
 > 	'A pointer to member shall not point to ... a member with
 > 	reference type'
 > Wouldn't such a thing be a language extension, could this be documented?

Thanks for the citation.  Based on that, I definitely think reference
type_info can go away.

Jason



From jason at cygnus.com  Sat Jan 29 01:55:53 2000
From: jason at cygnus.com (Jason Merrill)
Date: 28 Jan 2000 17:55:53 -0800
Subject: rtti data structures (again)
In-Reply-To: Nathan Sidwell's message of "Wed, 26 Jan 2000 14:21:35 +0000"
References: <388F02EF.A80C7B0E@codesourcery.com>
Message-ID: <u9n1pp1w0m.fsf@yorick.cygnus.com>

>>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:

 > 1) The amended (25th Jan) RTTI says
 > 	'Note that the full structure described by an RTTI descriptor may
 > 	include incomplete types not required by the Standard to be
 > 	completed, although not in contexts where it would cause ambiguity.'
 > I don't believe this is the case, the example I posted a couple of weeks
 > back pointed this out. Here it is, in a slightly more compact form

 > 	struct A;
 > 	struct B;

 > 	int main ()
 > 	{
 > 	  try {
 > 	    throw (B **)0;
 > 	  } catch (A const * const *) { 
 > 	    abort ();
 > 	  } catch (B const * const *) {
 > 	    ;//ok
 > 	  } catch (...) {
 > 	    abort ();
 >  	  }
 > 	}

We decided on Thursday that this can be handled by not emitting info for A
and B, just referring to them using weak references.  The EH matcher will
never look past the inner pointers.

 > 2) __si_class_type_info is documented for a single non-virtual heirarcy,
 > and __vmi_class_type_info for a class containing (directly or indirectly)
 > a multiple or virtual inheritance component. My mistake was to use
 > __si_class_type_info for a class with a single base, regardless of the
 > heirachy within the base (that is the current g++ behaviour).

 > 3) __si_class_type_info is for both public and non-public inheritance
 > (again, something I'd not noticed, thinking it was for public only).

We decided on Thursday was that your "mistakes" are what we want.  __si
will be for any class with a single direct base at offset 0 which is public
and non-virtual.

We also decided that the flags should move from __class_type_info into
__vmi_class_type_info, and that the polymorphic flag should be removed.

Note that you're probably thinking about this stuff in greater depth than
any of us who are actually at the meetings, so if you think something
should change, please feel free to propose it.

Jason



From sidwell at codesourcery.com  Sat Jan 29 15:20:15 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Sat, 29 Jan 2000 15:20:15 +0000
Subject: rtti data structures (again)
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com>
Message-ID: <3893052F.E3AB18F5@codesourcery.com>

Jason Merrill wrote:
> 
> >>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:

>  >      struct A;
>  >      struct B;
> 
>  >      int main ()
>  >      {
>  >        try {
>  >          throw (B **)0;
>  >        } catch (A const * const *) {
>  >          abort ();
>  >        } catch (B const * const *) {
>  >          ;//ok
>  >        } catch (...) {
>  >          abort ();
>  >        }
>  >      }
> 
> We decided on Thursday that this can be handled by not emitting info for A
> and B, just referring to them using weak references.  The EH matcher will
> never look past the inner pointers.
I'm sorry, I'm just not getting this. The type_infos for `B **' and `B *'
will be, (I'm using g++'s existing name mangling, but these are new-abi
structures)
__tiPP1B:
        .long   __vt_19__pointer_type_info
        .long   .LC2
        .long   0
        .long   __tiP1B

__tiP1B:
        .long   __vt_19__pointer_type_info
        .long   .LC3
        .long   0
        .long   __ti1B	;; not emitted, will resolve to zero

In the catch matching, the type_infos for `A const *const *' and `A const *'
will be,

__tiPCPC1A:
        .long   __vt_19__pointer_type_info
        .long   .LC1
        .long   1
        .long   __tiPC1A

__tiPC1A:
        .long   __vt_19__pointer_type_info
        .long   .LC4
        .long   1
        .long   __ti1A ;; not emitted, will resolve to zero

and those for `B const *const *' and `B const *'

__tiPCPC1B:
        .long   __vt_19__pointer_type_info
        .long   .LC0
        .long   1
        .long   __tiPC1B

__tiPC1B:
        .long   __vt_19__pointer_type_info
        .long   .LC5
        .long   1
        .long   __ti1B ;; not emitted, will resolve to zero

I fail to see how the catch matcher can get different results comparing
__tiPP1B to __tiPCPC1A as opposed to comparing __tiPP1B to __tiPCPC1B.
They both look like qualification conversions of pointers to pointers to
incomplete type. In the first case we'll end up comparing __tiP1B to
__tiPC1A, which still is a valid qualification conversion, then have
two NULL pointers for the pointed to types, which somehow we have to
tell apart. In the second case we'll end up comparing __tiP1B to
__tiPC1B, and again have two NULL pointers for the pointed to types,
but this time we have to consider them the same type.
I don't see anything in [conv.qual] saying that qualification conversions
don't have to deal with incomplete types.
N.B old-abi g++ seg faults on the above code because it does wander into
the NULL pointers.

> We decided on Thursday was that your "mistakes" are what we want.  __si
> will be for any class with a single direct base at offset 0 which is public
> and non-virtual.
great.

> We also decided that the flags should move from __class_type_info into
> __vmi_class_type_info, and that the polymorphic flag should be removed.
I think this moving of the flags is a mistake. If I understood correctly,
they indicated information about direct and indirect bases (whether there
was virtuality anywhere in the heirarchy for instance). Such information
can speed up dynamic cast. When walking the inheritance graph, we can
take some early outs, if we know there are no multiple sub object types
within the complete graph. With the flags in every class's type_info, it
becomes easier to get hold of that info. With it only for vmi classes,
we have to remember `unknown' when presented with a complete object of
si type, and fill the information in when/if we find a vmi base. Another
case is in a potential cross-cast case, which I had in the previous email.
Suppose we've found the target base, which we know is unique, but not
found the source base (because we early outed, maybe). To be a valid
cross-cast both the source and target base objects must be public in the
complete object. If we know the complete heirarchy has no non-public bases,
there's no need to search for the source base in this case.

Now, these might both seem small optimizations, but they're the two
most evident uses (to me) of the flags. It would be rash to remove such
information from si_class_type_info.


nathan
-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From jason at cygnus.com  Sat Jan 29 21:11:44 2000
From: jason at cygnus.com (Jason Merrill)
Date: 29 Jan 2000 13:11:44 -0800
Subject: rtti data structures (again)
In-Reply-To: Nathan Sidwell's message of "Sat, 29 Jan 2000 15:20:15 +0000"
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com>
Message-ID: <u9emb01t2n.fsf@yorick.cygnus.com>

>>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:

 > I fail to see how the catch matcher can get different results comparing
 > __tiPP1B to __tiPCPC1A as opposed to comparing __tiPP1B to __tiPCPC1B.
 > They both look like qualification conversions of pointers to pointers to
 > incomplete type.

Good point.  I was forgetting about multi-level qualification conversions.

I think that leaves us with something like what EDG does now: namely,
comparisons are done by comparing the addresses of one-byte commons rather
than of the type_info nodes themselves.  Then we could emit incomplete info
in one file and complete info in another file and they would compare the
same because both refer to the same ID proxy.

We could mangle the complete and incomplete versions differently, so they
would not be combined by the linker.

This would also change how we refer to type_infos; under the current
scheme, references to type_infos in the EH type table need to be via relocs
that will be resolved by the dynamic linker at runtime.  If we don't need
to compare addresses, we could use gp-relative references.  Of course, we'd
still have the absolute references in the type_infos to the ID proxies, so
we're no better off.

 >> We also decided that the flags should move from __class_type_info into
 >> __vmi_class_type_info, and that the polymorphic flag should be removed.

 > I think this moving of the flags is a mistake. If I understood correctly,
 > they indicated information about direct and indirect bases (whether there
 > was virtuality anywhere in the heirarchy for instance). Such information
 > can speed up dynamic cast. When walking the inheritance graph, we can
 > take some early outs, if we know there are no multiple sub object types
 > within the complete graph. With the flags in every class's type_info, it
 > becomes easier to get hold of that info. With it only for vmi classes,
 > we have to remember `unknown' when presented with a complete object of
 > si type, and fill the information in when/if we find a vmi base.

So what you're saying is if we try to dynamic_cast from A* to B*, where B
has a unique A subobject and the A* does not actually point to part of a B,
if we know that B has no multiple subobjects we can check the passed
offset, see that it doesn't match, and return failure.  Without that
information, we would have to recurse up the single-inheritance chain until
we either reach the A or a class with multiple or virtual bases.

I think I'd rather pay that small performance hit than add a word to the
type_info for each class.  Matt, would this affect locales?

 > Another case is in a potential cross-cast case, which I had in the
 > previous email.  Suppose we've found the target base, which we know is
 > unique, but not found the source base (because we early outed,
 > maybe). To be a valid cross-cast both the source and target base objects
 > must be public in the complete object. If we know the complete heirarchy
 > has no non-public bases, there's no need to search for the source base
 > in this case.

But cross-casts only come up in the context of classes with multiple bases,
so it wouldn't make sense to look for this in single inheritance classes
anyway.

Jason



From mark at codesourcery.com  Sun Jan 30 01:36:36 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 29 Jan 2000 17:36:36 -0800
Subject: Virtual function calls
Message-ID: <20000129173636G.mitchell@codesourcery.com>


This is a nit.

I don't think:

  The caller adjusts the 'this' argument to point to the class which
  last overrode the function being called. The result provides both the
  'this' argument and the vtable pointer for finding the function we
  want.

is very clear.  For example, consider:

  struct S1 { virtual void f(); };
  struct S2 : virtual public S1 { virtual void f(); };
  struct T : virtual public S1, virtual public S2 {};

This is legal C++, but is `S2' or `S1' the base which last overrode
`f'?  The answer is `S2', but we need to find a better way of
expressing this.

I think its easiest to use terms straight out of the standard:

  The caller adjusts the `this' argument to point to the class
  that contains the unique final overrider (as defined in
  [class.virtual]) for the function being called.  The result provides
  both the 'this' argument and the vtable pointer for finding the
  function we want.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From sidwell at codesourcery.com  Sun Jan 30 11:04:54 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Sun, 30 Jan 2000 11:04:54 +0000
Subject: rtti data structures (again)
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com> <u9emb01t2n.fsf@yorick.cygnus.com>
Message-ID: <38941AD6.D589FC40@codesourcery.com>

Jason Merrill wrote:
> 
> >>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:
> 
>  > I fail to see how the catch matcher can get different results comparing
>  > __tiPP1B to __tiPCPC1A as opposed to comparing __tiPP1B to __tiPCPC1B.
>  > They both look like qualification conversions of pointers to pointers to
>  > incomplete type.
> 
> Good point.  I was forgetting about multi-level qualification conversions.
> 
> I think that leaves us with something like what EDG does now: namely,
> comparisons are done by comparing the addresses of one-byte commons rather
> than of the type_info nodes themselves.  Then we could emit incomplete info
> in one file and complete info in another file and they would compare the
> same because both refer to the same ID proxy.
> 
> We could mangle the complete and incomplete versions differently, so they
> would not be combined by the linker.
This is essentially what I described in the first email I wrote about
this problem (`RTTI data layout flaw'). I'm not quite sure what you mean by
`one byte commons'. I would have thought the proxy would need a pointer to
the complete type (weak linkage of course), and a vtable. Here's what I wrote
before

> One choice which might work is some kind of __class_proxy_type_info,
> which contains a single member pointing to the real __class_type_info
> object with weak linkage. The name mangling for a
> __class_proxy_type_info will be different to that of a __class_type_info
> object. In the above case, Foo ** would be represented as
> __pointer_type_info
> ->__pointer_type_info
>   ->__class_proxy_type_info
>     ->(weakly)__class_type_info.
> The final __class_type_info object is not emitted in the compilation
> unit, as Foo's definition is never seen. Now, we can distinguish
> `Bar const *const *' from `Foo const *const *', as the inner pointers
> will point to different __class_proxy_type_info objects.

> In pointer_type_info's we do not need to go via a
> __class_proxy_type_info, if the compilation unit has seen the
> definition of the pointed-to class. The catch matching algorithm will
> need to be aware that it might be given two paths, one of which goes
> via a class_proxy_type_info, and one that does not. In this case, the
> class_proxy_type_info should point to the real class.

> type_info::operator == is not affected by proxies. Proxies are only
> important when traversing the pointer heirarchy in catch matching.

Is that what you had in mind? Martin wondered why we needed the proxy,
wouldn't an __incomplete_type_info node be sufficient? But I think that
would fail across multiple object files. I.e. fileA and fileB have
`struct A' as incomplete and fileC has `struct A' as complete. The linker
has to know that the objects named __ti1A in fileA and fileB must be
discarded in favour of that in fileC, should all three be linked together.
If only fileA and fileB are linked, then the two must be commonized. I
don't think ELF can deal with that, can it?

There's a bit of strangeness with loading & unloading a DSO which contains
the complete definition of `struct A', into an executable which has the
incomplete info. That too is in the original email. If both DSO and
executable have __tiP1A (struct A *), they'll be merged, presumably
with the DSO's copy ignored. However, the __tiP1A in the executable
will point at the proxy incomplete A type_info (which will have already
been filled with a weak NULL for its target). Somehow we have to arrange
that the proxy is altered to now point at the __ti1A (struct A) type_info
that the DSO supplied. If we don't do that, throwing `struct A *' in the
DSO (which is valid, `cos the DSO source had complete information), will
throw the __tiP1A in the executable which points to incomplete. Hence
we wont find any base conversions if we're trying to catch a base of A.

I hope you see what I mean here -- I don't know enough about DSO loading
details to know what'll happen.

[I'll get to your other points when I've some more time, thanks]

nathan
-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From jason at cygnus.com  Sun Jan 30 18:52:48 2000
From: jason at cygnus.com (Jason Merrill)
Date: 30 Jan 2000 10:52:48 -0800
Subject: rtti data structures (again)
In-Reply-To: Nathan Sidwell's message of "Sun, 30 Jan 2000 11:04:54 +0000"
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com> <u9emb01t2n.fsf@yorick.cygnus.com> <38941AD6.D589FC40@codesourcery.com>
Message-ID: <u9aeln1jen.fsf@yorick.cygnus.com>

>>>>> Nathan Sidwell <sidwell at codesourcery.com> writes:

 >> I think that leaves us with something like what EDG does now: namely,
 >> comparisons are done by comparing the addresses of one-byte commons rather
 >> than of the type_info nodes themselves.  Then we could emit incomplete info
 >> in one file and complete info in another file and they would compare the
 >> same because both refer to the same ID proxy.
 >> 
 >> We could mangle the complete and incomplete versions differently, so they
 >> would not be combined by the linker.

 > This is essentially what I described in the first email I wrote about
 > this problem (`RTTI data layout flaw'). I'm not quite sure what you mean
 > by `one byte commons'. I would have thought the proxy would need a
 > pointer to the complete type (weak linkage of course), and a
 > vtable.

It would work either way: I was talking about an identity proxy that the
type_infos point to; you were talking about an incomplete type proxy that
points to the real type_info for the type.  Your proposal might be
smaller.

 > Is that what you had in mind? Martin wondered why we needed the proxy,
 > wouldn't an __incomplete_type_info node be sufficient? But I think that
 > would fail across multiple object files. I.e. fileA and fileB have
 > `struct A' as incomplete and fileC has `struct A' as complete. The linker
 > has to know that the objects named __ti1A in fileA and fileB must be
 > discarded in favour of that in fileC, should all three be linked together.
 > If only fileA and fileB are linked, then the two must be commonized. I
 > don't think ELF can deal with that, can it?

No, I agree.

 > There's a bit of strangeness with loading & unloading a DSO which contains
 > the complete definition of `struct A', into an executable which has the
 > incomplete info. That too is in the original email. If both DSO and
 > executable have __tiP1A (struct A *), they'll be merged, presumably
 > with the DSO's copy ignored. However, the __tiP1A in the executable
 > will point at the proxy incomplete A type_info (which will have already
 > been filled with a weak NULL for its target). Somehow we have to arrange
 > that the proxy is altered to now point at the __ti1A (struct A) type_info
 > that the DSO supplied. If we don't do that, throwing `struct A *' in the
 > DSO (which is valid, `cos the DSO source had complete information), will
 > throw the __tiP1A in the executable which points to incomplete. Hence
 > we wont find any base conversions if we're trying to catch a base of A.

 > I hope you see what I mean here -- I don't know enough about DSO loading
 > details to know what'll happen.

I do see what you mean.  I don't think that the EDG scheme I was talking
about would have a problem with this situation.

Jason



From jason at cygnus.com  Sun Jan 30 19:03:49 2000
From: jason at cygnus.com (Jason Merrill)
Date: 30 Jan 2000 11:03:49 -0800
Subject: Unwind table location
In-Reply-To: Cary Coutant's message of "Fri, 28 Jan 2000 15:51:13 -0800"
References: <200001282350.PAA24742@adlmail.cup.hp.com>
Message-ID: <u990171iwa.fsf@yorick.cygnus.com>

Working through this for my benefit:

I think we all agree that we want to avoid runtime relocations for the EH
info.  To accomplish that, relocs must be relative, either self-relative
(easy to handle) or relative to some other location we know about.  The
only other location I can think of is the GP.

As I understand it, on ia64 (as on hppa) there is no guarantee that the
text and data segments will be at a fixed offset from each other, so it is
not feasible to use GP-relative offsets to refer to code locations.  I'm
guessing that .rdata is allocated with .data.  Or to be more general, that
all sections with the CODE attribute are allocated in one group, and those
with the DATA attribute are in another, such that self-relative references
work within a group but not between them.  Is this accurate?

Therefore, the EH info that refers to absolute code locations (i.e. the
start and end of the procedure fragment) must be in a CODE section.

The LSDA starts with a pointer to the beginning of the landing pad;
conceivably this could be made relative to the fragment start, allowing the
LSDA to go into data, but I see no reason to prefer that.

In the case of non-contiguous text segments (such as for embedded systems,
as Jim suggested yesterday), it seems to makes sense to have separate
tables for each.  A system that requires something like this could define
its own means of accessing the different tables, though we still need to
define how that works for the normal case.

So I think the status quo (i.e. living in text) makes sense for the unwind
table and info block.

The type tables are a somewhat different matter, because they only refer to
type_info nodes, which live in data.  The current document says that these
references are GP-relative, but that assumes that all type_infos live in
the same DSO, which is not the case under the current scheme; the
references must be fixed up by the dynamic loader, which means the type
table can't live in text.

Furthermore, moving the type table into data allows us to share it between
multiple text segments.

Given this, I would like to move the type table into data and make the
reference from the LSDA to the type table GP-relative rather than
self-relative.

Jason



From jason at cygnus.com  Sun Jan 30 21:29:32 2000
From: jason at cygnus.com (Jason Merrill)
Date: Sun, 30 Jan 2000 13:29:32 -0800
Subject: More issues
Message-ID: <200001302129.NAA01685@yorick.cygnus.com>

More things we should decide on:

How constructors/destructors are run for arrays.  Many compilers use a
__vec_new function; g++ doesn't, to allow for inlining of constructors.

Return values of constructors.  I don't see any reason to return a value
from constructors, since we will always pass in the address of the object.
g++ currently returns that address, for historical reasons (previously, to
support assignment to 'this').

Jason



From mendell at ca.ibm.com  Mon Jan 31 14:34:00 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Mon, 31 Jan 2000 09:34:00 -0500
Subject: More issues
Message-ID: <87256877.0050026C.00@d53mta04h.boulder.ibm.com>



>> Return values of constructors.  I don't see any reason to return a value
>> from constructors, since we will always pass in the address of the
object.
>> g++ currently returns that address, for historical reasons (previously,
to
>> support assignment to 'this')

Currently, we use the returned value from the ctor for cases like S().i.
It
wouldn't be hard to change the compiler, but we do need a decision one way
or
another

Mark





From daveed at edg.com  Mon Jan 31 17:38:00 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 31 Jan 2000 09:38:00 -0800
Subject: rtti data structures (again)
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com>
Message-ID: <3895C878.398279BB@edg.com>

Nathan Sidwell wrote:
[...]
> > We also decided that the flags should move from __class_type_info into
> > __vmi_class_type_info, and that the polymorphic flag should be removed.
> I think this moving of the flags is a mistake. If I understood correctly,
> they indicated information about direct and indirect bases (whether there
> was virtuality anywhere in the heirarchy for instance). Such information
> can speed up dynamic cast. When walking the inheritance graph, we can
> take some early outs, if we know there are no multiple sub object types
> within the complete graph. With the flags in every class's type_info, it
> becomes easier to get hold of that info. With it only for vmi classes,
> we have to remember `unknown' when presented with a complete object of
> si type, and fill the information in when/if we find a vmi base. Another
> case is in a potential cross-cast case, which I had in the previous email.
> Suppose we've found the target base, which we know is unique, but not
> found the source base (because we early outed, maybe). To be a valid
> cross-cast both the source and target base objects must be public in the
> complete object. If we know the complete heirarchy has no non-public bases,
> there's no need to search for the source base in this case.

Yes, I think that was indeed the original purpose of the flags.

> Now, these might both seem small optimizations, but they're the two
> most evident uses (to me) of the flags. It would be rash to remove such
> information from si_class_type_info.

I'll second Nathan on this.

	Daveed



From jason at cygnus.com  Mon Jan 31 17:58:13 2000
From: jason at cygnus.com (Jason Merrill)
Date: 31 Jan 2000 09:58:13 -0800
Subject: rtti data structures (again)
In-Reply-To: Daveed Vandevoorde's message of "Mon, 31 Jan 2000 09:38:00 -0800"
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com> <3895C878.398279BB@edg.com>
Message-ID: <u9iu0ayvgq.fsf@yorick.cygnus.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 >> Now, these might both seem small optimizations, but they're the two
 >> most evident uses (to me) of the flags. It would be rash to remove such
 >> information from si_class_type_info.

 > I'll second Nathan on this.

Did you see my response?

Jason



From daveed at edg.com  Mon Jan 31 18:28:26 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Mon, 31 Jan 2000 10:28:26 -0800
Subject: rtti data structures (again)
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com> <3895C878.398279BB@edg.com> <u9iu0ayvgq.fsf@yorick.cygnus.com>
Message-ID: <3895D44A.2E893AE6@edg.com>

Jason Merrill wrote:
> 
> >>>>> Daveed Vandevoorde <daveed at edg.com> writes:
> 
>  >> Now, these might both seem small optimizations, but they're the two
>  >> most evident uses (to me) of the flags. It would be rash to remove such
>  >> information from si_class_type_info.
> 
>  > I'll second Nathan on this.
> 
> Did you see my response?

I saw it but hadn't read it all through---sorry about that.

I still think I prefer adding the word to have a small performance
benefit.  But I could be swayed.

	Daveed



From ddd at cup.hp.com  Mon Jan 31 19:01:51 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 31 Jan 2000 19:01:51 +0000
Subject: More issues
References: <200001302129.NAA01685@yorick.cygnus.com>
Message-ID: <3895DC1F.E8A93CE9@cup.hp.com>

Jason Merrill wrote:
> 
> More things we should decide on:
> 
> How constructors/destructors are run for arrays.  Many compilers use a
> __vec_new function; g++ doesn't, to allow for inlining of constructors.
> 
> Return values of constructors.  I don't see any reason to return a value
> from constructors, since we will always pass in the address of the object.
> g++ currently returns that address, for historical reasons (previously, to
> support assignment to 'this').
> 
> Jason

We need it if we have an entry point calling operator new. For:

	C* c = new C;

if there is no C::operator new, we will do something like:

	C* c = __ct__1C.entry1

In that case, we need the returned value.


Christophe



From jason at cygnus.com  Mon Jan 31 19:12:38 2000
From: jason at cygnus.com (Jason Merrill)
Date: 31 Jan 2000 11:12:38 -0800
Subject: More issues
In-Reply-To: Christophe de Dinechin's message of "Mon, 31 Jan 2000 19:01:51 +0000"
References: <200001302129.NAA01685@yorick.cygnus.com> <3895DC1F.E8A93CE9@cup.hp.com>
Message-ID: <u9aelmys0p.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > We need it if we have an entry point calling operator new. 

But we decided not to have such an entry point.

Jason



From ddd at cup.hp.com  Mon Jan 31 20:04:46 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 31 Jan 2000 20:04:46 +0000
Subject: More issues
References: <200001302129.NAA01685@yorick.cygnus.com> <3895DC1F.E8A93CE9@cup.hp.com> <u9aelmys0p.fsf@yorick.cygnus.com>
Message-ID: <3895EADE.68203123@cup.hp.com>

Jason Merrill wrote:
> 
> >>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
>  > We need it if we have an entry point calling operator new.
> 
> But we decided not to have such an entry point.
> 

Did we? Well, you seem right: C-6 is indicated as closed in October. I certainly
did not notice :-(

Is there any conclusive argument against having a COMDAT-generated allocation
entry point whenever you have a new expression?  I guess that you can do that
without impacting the ABI... The writeup on C-6 is definitely very short.


Christophe



From jason at cygnus.com  Mon Jan 31 23:24:55 2000
From: jason at cygnus.com (Jason Merrill)
Date: 31 Jan 2000 15:24:55 -0800
Subject: More issues
In-Reply-To: Christophe de Dinechin's message of "Mon, 31 Jan 2000 20:04:46 +0000"
References: <200001302129.NAA01685@yorick.cygnus.com> <3895DC1F.E8A93CE9@cup.hp.com> <u9aelmys0p.fsf@yorick.cygnus.com> <3895EADE.68203123@cup.hp.com>
Message-ID: <u9wvopygc8.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > Is there any conclusive argument against having a COMDAT-generated
 > allocation entry point whenever you have a new expression?  I guess that
 > you can do that without impacting the ABI... The writeup on C-6 is
 > definitely very short.

You could certainly expand 

  new A;

into

  __call_and_construct_A ();

COMDAT A* __call_and_construct_A () {
  return {normal code for new A};
}

Whether or not you call this function a constructor is of little
importance, though I suppose emitting it with the other constructors might
improve locality.

Jason



