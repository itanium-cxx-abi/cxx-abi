<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Issue summaries and status
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20Issue%20summaries%20and%20status&In-Reply-To=%3C199906300707.AAA64874%40baalbek.engr.sgi.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000137.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Issue summaries and status</H1>
    <B>Jim Dehnert</B> 
    <A HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20Issue%20summaries%20and%20status&In-Reply-To=%3C199906300707.AAA64874%40baalbek.engr.sgi.com%3E"
       TITLE="Issue summaries and status">dehnert at baalbek.engr.sgi.com
       </A><BR>
    <I>Wed Jun 30 07:07:15 UTC 1999</I>
    <P><UL>
        <LI>Previous message: <A HREF="000137.html">Placement of vtables, inlines and such
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#138">[ date ]</a>
              <a href="thread.html#138">[ thread ]</a>
              <a href="subject.html#138">[ subject ]</a>
              <a href="author.html#138">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Attached are the current summary, open, and closed lists.  Note that
I've incorporated some of the edited email into the open issues list.
Let me know if I've screwed anything up...

-------------- next part --------------
&lt;HTML&gt;

&lt;HEAD&gt;
&lt;title&gt;C++ ABI Summary&lt;/title&gt;

&lt;link rel=stylesheet href=small-table.css type=&quot;text/css&quot;&gt;

&lt;hr&gt;

&lt;font size=6&gt;&lt;i&gt;&lt;b&gt;
&lt;p&gt;
C++ ABI Summary
&lt;/b&gt;&lt;/i&gt;&lt;/font&gt;

&lt;p&gt;
&lt;i&gt;Revised 28 June 1999&lt;/i&gt;

&lt;/center&gt;

&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;p&gt;
See also the full
&lt;a href=cxx-open.html&gt;Open&lt;/a&gt; and
&lt;a href=cxx-closed.html&gt;Closed&lt;/a&gt; issues lists.

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt;Meetings&lt;/h4&gt;

&lt;p&gt;
&lt;table align=center border=on cellpadding=3&gt;

&lt;tr class=small&gt;
&lt;th colspan=2&gt; When &lt;/th&gt;
&lt;th&gt; Where &lt;/th&gt;
&lt;th&gt; Phone &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 24 June &lt;/td&gt; &lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td align=left colspan=2&gt; completed &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 1 July &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 8 July &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 15 July &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 22 July &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 29 July &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 5 August &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 12 August &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt;
&lt;td&gt; 19 August &lt;/td&gt;
&lt;td&gt; 10:00-12:00 PDT &lt;/td&gt;
&lt;td&gt; SGI Sapphire 20L &lt;/td&gt;
&lt;td&gt; 650-933-7976 &lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
Note:  When calling the SGI telephone bridges,
the first caller continues to ring until the second party joins.
To get rid of it, you can call from a second phone,
and I believe you can hang it up right away.

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt;Participants&lt;/h4&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr class=small&gt;
&lt;th&gt; Company &lt;/th&gt;
&lt;th&gt; Name &lt;/th&gt;
&lt;th&gt; Telephone &lt;/th&gt;
&lt;th&gt; Fax &lt;/th&gt;
&lt;th&gt; Email &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=1&gt; &lt;/th&gt;
&lt;td colspan=3&gt; overall reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi at postofc.corp.sgi.com</A>&gt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi at corp.sgi.com</A>&lt;/a&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=6&gt; SGI &lt;/th&gt;
&lt;td&gt; Jim Dehnert &lt;/td&gt;
&lt;td&gt; (650) 933-4272 &lt;/td&gt;
&lt;td&gt; (650) 932-4272 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">dehnert at sgi.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">dehnert at sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Matt Austern &lt;/td&gt;
&lt;td&gt; (650) 933-4196 &lt;/td&gt;
&lt;td&gt; (650) 932-4196 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">austern at engr.sgi.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">austern at engr.sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Hans Boehm &lt;/td&gt;
&lt;td&gt; (650) 933-7144 &lt;/td&gt;
&lt;td&gt; (650) 932-7144 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">boehm at engr.sgi.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">boehm at engr.sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Shin-Ming Liu &lt;/td&gt;
&lt;td&gt; (650) 933-4287 &lt;/td&gt;
&lt;td&gt; (650) 932-4287 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">shin at engr.sgi.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">shin at engr.sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; John Wilkinson &lt;/td&gt;
&lt;td&gt; (650) 933-4298 &lt;/td&gt;
&lt;td&gt; (650) 932-4298 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jfw at engr.sgi.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jfw at engr.sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td colspan=3&gt; reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi-sgi at engr.sgi.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi-sgi at engr.sgi.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=4&gt; Cygnus &lt;/th&gt;
&lt;td&gt; Jason Merrill &lt;/td&gt;
&lt;td&gt; (408) 542-9665 &lt;/td&gt;
&lt;td&gt; (408) 542-9765 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jason at cygnus.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jason at cygnus.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Ian Carmichael &lt;/td&gt;
&lt;td&gt; (416) 482-3946 &lt;/td&gt;
&lt;td&gt; (416) 482-6299 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">iancarm at cygnus.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">iancarm at cygnus.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Ulrich Drepper &lt;/td&gt;
&lt;td&gt; (408) 765-4699 &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">drepper at cygnus.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">drepper at cygnus.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td colspan=3&gt; reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">c++abi at cygnus.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">c++abi at cygnus.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=1&gt; EDG &lt;/th&gt;
&lt;td&gt; Daveed Vandevoorde &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">daveed at edg.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">daveed at edg.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=1&gt; EPC &lt;/th&gt;
&lt;td&gt; Colin McPhail &lt;/td&gt;
&lt;td&gt; +44 (131) 225-6262 &lt;/td&gt;
&lt;td&gt; +44 (131) 225-6644 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">colin at epc.co.uk</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">colin at epc.co.uk</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=4&gt; Hewlett- Packard &lt;/th&gt;
&lt;td&gt; Cary Coutant &lt;/td&gt;
&lt;td&gt; (408) 447-5759 &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cary at cup.hp.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cary at cup.hp.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Christophe de Dinechin &lt;/td&gt;
&lt;td&gt; (408) 447-5491 &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">ddd at cup.hp.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">ddd at cup.hp.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Sassan Hazeghi &lt;/td&gt;
&lt;td&gt; (408) 447-5007 &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">sassan at cup.hp.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">sassan at cup.hp.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td colspan=3&gt; reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi-hp at cllmail.cup.hp.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi-hp at cllmail.cup.hp.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=3&gt; IBM &lt;/th&gt;
&lt;td&gt; Mark Mendell &lt;/td&gt;
&lt;td&gt; (416) 448-3485 &lt;/td&gt;
&lt;td&gt; (416) 448-4414 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">mendell at ca.ibm.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">mendell at ca.ibm.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Allan H. Kielstra &lt;/td&gt;
&lt;td&gt; (416) 448-3558 &lt;/td&gt;
&lt;td&gt; (416) 448-4414 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">kielstra at ca.ibm.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">kielstra at ca.ibm.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td colspan=3&gt; reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">CxxABI-ADTC-CAN at ca.ibm.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">CxxABI-ADTC-CAN at ca.ibm.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=4&gt; Intel &lt;/th&gt;
&lt;td&gt; Sunil Saxena &lt;/td&gt;
&lt;td&gt; (408) 765-5272 &lt;/td&gt;
&lt;td&gt; (408) 653-8511 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Sunil.Saxena at Intel.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Sunil.Saxena at Intel.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Suresh Rao &lt;/td&gt;
&lt;td&gt; (408) 765-5416 &lt;/td&gt;
&lt;td&gt; (408) 765-5165 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Suresh.K.Rao at Intel.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Suresh.K.Rao at Intel.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Priti Shrivastav &lt;/td&gt;
&lt;td&gt; (408) 765-4699 &lt;/td&gt;
&lt;td&gt; (408) 765-5165 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Priti.Shrivastav at Intel.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">Priti.Shrivastav at Intel.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td colspan=3&gt; reflector &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi at unix-os.sc.intel.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">cxx-abi at unix-os.sc.intel.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=1&gt; SCO &lt;/th&gt;
&lt;td&gt; Jonathan Schilling &lt;/td&gt;
&lt;td&gt; (908) 790-2364 &lt;/td&gt;
&lt;td&gt; (908) 790-2426 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jls at sco.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">jls at sco.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=tiny&gt;
&lt;th rowspan=4&gt; Sun &lt;/th&gt;
&lt;td&gt; George Vasick &lt;/td&gt;
&lt;td&gt; (650) 786-5123 &lt;/td&gt;
&lt;td&gt; (650) 786-9551 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">george.vasick at eng.sun.com</A>&gt;
<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">george.vasick at eng.sun.com</A> &lt;a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Michael Lam &lt;/td&gt;
&lt;td&gt; (650) 786-3492 &lt;/td&gt;
&lt;td&gt; (650) 786-9551 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">michael.lam at eng.sun.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">michael.lam at eng.sun.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Michael Ball &lt;/td&gt;
&lt;td&gt; (650) 786-9109 &lt;/td&gt;
&lt;td&gt; (650) 786-9551 &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">michael.ball at eng.sun.com</A>&gt; <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">michael.ball at eng.sun.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=tiny&gt;
&lt;td&gt; Reza Monajjemi &lt;/td&gt;
&lt;td&gt; (650) 786-6175 &lt;/td&gt;
&lt;td&gt; ? &lt;/td&gt;
&lt;td&gt; &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">reza.monajjemi at eng.sun.com</A>&gt;
     <A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">reza.monajjemi at eng.sun.com</A> &lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt; Objectives &lt;/h4&gt;

&lt;ul&gt;
&lt;p&gt;
&lt;li&gt;
Interoperable C++ compilation on IA-64:
we want users to be able to build relocatable objects with
different compilers and link them together,
and if possible even to ship common DSOs.
This objective implies agreement on:
    &lt;ul&gt;    
    &lt;li&gt; Data representation
    &lt;li&gt; Object file representation
    &lt;li&gt; Library API
    &lt;/ul&gt;

&lt;p&gt;
&lt;li&gt;
ISO Standard C++:
highest priority is functionality and performance of standard-compliant code.
It should not be sacrificed for the benefit of language extensions or
legacy implementations (though considering them as tie-breakers is fine).

&lt;p&gt;
&lt;li&gt;
Some areas will be easier to agree on than others.
Our priorities should be based on achieving as much
interoperability as possible if we can't attain perfection.
That is, it is better to end up with a few restrictions being required
for interoperable code, than to have no interoperability at all.
This suggests priorities as follows:
    &lt;ol&gt;
    &lt;li&gt; Items requiring base ABI changes that might affect other
	languages, and will therefore become impossible soon.
	Examples include exception handling / stack unwind,
	or ELF changes (not extensions).
    &lt;li&gt; Core features where differences will prevent virtually any
	C++ object code from porting.
	Examples include data layout and calling conventions.
    &lt;li&gt; Limited usage features,
	where users can achieve portability by avoiding the feature.
	An example might be multi-threading.
    &lt;li&gt; Peripheral features,
	where the requirements on users to achieve
	portability are clear and easy to implement.
	An example is non-explicit inlining,
	where compilers would presumably allow it to just be suppressed.
    &lt;li&gt; Tool interfaces, which affect how users build code,
	rather than what they build.
	An example is the compilation command line.
    &lt;/ol&gt;

&lt;p&gt;
&lt;li&gt;
Mechanisms/methods which allow coexistence of incompatible
implementations may be suitable in some cases.
For instance, packaging vendor-specific compiler support runtimes
in DSOs occupying distinct namespaces might allow multiple such DSOs to
be loaded for mixed objects and avoid requiring that all vendors have
the same support runtimes.

&lt;/ul&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt; Action Item Status &lt;/h4&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr class=small&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Action &lt;/th&gt;
&lt;th&gt; Who &lt;/th&gt;
&lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Opened &lt;/th&gt;
&lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 1 &lt;/td&gt;
&lt;td&gt; Distribute Sun C++ ABI &lt;/td&gt;
&lt;td&gt; Mike Ball &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 2 &lt;/td&gt;
&lt;td&gt; Distribute Sun C++ ABI Rationale &lt;/td&gt;
&lt;td&gt; Mike Ball &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 3 &lt;/td&gt;
&lt;td&gt; Distribute Taligent C++ ABI &lt;/td&gt;
&lt;td&gt; Cary Coutant &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 4 &lt;/td&gt;
&lt;td&gt; Expedite IA-64 RT Arch doc release &lt;/td&gt;
&lt;td&gt; Cary Coutant &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 5 &lt;/td&gt;
&lt;td&gt; Set up n-way NDA for eligible members &lt;/td&gt;
&lt;td&gt; Priti Shrivastav &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 6 &lt;/td&gt;
&lt;td&gt; Organize/summarize object layout issues and alternatives &lt;/td&gt;
&lt;td&gt; Matt Austern &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 7 &lt;/td&gt;
&lt;td&gt; Write-up of Vtable issues,
     including Vtable layout, Vfunc call protocol
&lt;/td&gt;
&lt;td&gt; Christophe de Dinechin &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990610 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 8 &lt;/td&gt;
&lt;td&gt; Write-up of object layout strawman &lt;/td&gt;
&lt;td&gt; Matt Austern &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; 990610 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 9 &lt;/td&gt;
&lt;td&gt; Check with c++-core about empty base placement &lt;/td&gt;
&lt;td&gt; Jason Merrill &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990610 &lt;/td&gt;
&lt;td&gt; 990618 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 10 &lt;/td&gt;
&lt;td&gt; Describe dynamic cast / inaccessible base issue &lt;/td&gt;
&lt;td&gt; Daveed Vandevoorde &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990617 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 11 &lt;/td&gt;
&lt;td&gt; Summarize ctor/dtor issues &lt;/td&gt;
&lt;td&gt; Michael Lam &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990617 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; 12 &lt;/td&gt;
&lt;td&gt; Describe Intel exception model &lt;/td&gt;
&lt;td&gt; Priti Shrivastav &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;/table&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt; Issue Status &lt;/h4&gt;

In the following table,
the &lt;b&gt;&lt;i&gt;class&lt;/i&gt;&lt;/b&gt; column attempts to classify the issue on the
basis of what it likely affects.
The identifiers used are:

&lt;table&gt;
&lt;tr class=small&gt; &lt;td&gt; call &lt;/td&gt;
&lt;td&gt; Function call interface, i.e. call linkage &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; data &lt;/td&gt;
&lt;td&gt; Data layout &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; lib &lt;/td&gt;
&lt;td&gt; Runtime library support &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; lif &lt;/td&gt;
&lt;td&gt; Library interface, i.e. API &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; g &lt;/td&gt;
&lt;td&gt; Potential gABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; ps &lt;/td&gt;
&lt;td&gt; Potential psABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; source &lt;/td&gt;
&lt;td&gt; Source code conventions (i.e. API, not ABI) &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; May affect how program construction tools interact &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;
&lt;hr width=50%&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr class=small&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt;
&lt;th&gt; Class &lt;/th&gt;
&lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt;
&lt;th&gt; Opened &lt;/th&gt;
&lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; A &lt;/th&gt;
&lt;th colspan=6&gt; &lt;a href=issues-C++-layout.html&gt; Object Layout &lt;/a&gt; &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-1 &lt;/td&gt;
&lt;td&gt; Vptr location &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-2 &lt;/td&gt;
&lt;td&gt; Virtual base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-3 &lt;/td&gt;
&lt;td&gt; Multiple inheritance &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-4 &lt;/td&gt;
&lt;td&gt; Empty base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-5 &lt;/td&gt;
&lt;td&gt; Empty parameters &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-6 &lt;/td&gt;
&lt;td&gt; RTTI (&lt;code&gt;type_info&lt;/code&gt;) .o representation &lt;/td&gt;
&lt;td&gt; data call ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-7 &lt;/td&gt;
&lt;td&gt; Vptr sharing with primary base class &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-8 &lt;/td&gt;
&lt;td&gt; (Virtual) base class alignment &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-9 &lt;/td&gt;
&lt;td&gt; Sorting fields as allowed by [class.mem]/12 &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-10 &lt;/td&gt;
&lt;td&gt; Class parameters in registers &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-11 &lt;/td&gt;
&lt;td&gt; Representation of pointers to members &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-12 &lt;/td&gt;
&lt;td&gt; Merging secondary vtables &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990610 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; A-13 &lt;/td&gt;
&lt;td&gt; Parameter struct field promotion &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; B &lt;/th&gt;
&lt;th colspan=6&gt; &lt;a href=issues-C++-layout.html#vfunc&gt;
Virtual Function Handling &lt;/a&gt; &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-1 &lt;/td&gt;
&lt;td&gt; Adjustment of &quot;this&quot; pointer (e.g. thunks) &lt;/td&gt;
&lt;td&gt; data call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-2 &lt;/td&gt;
&lt;td&gt; Covariant return types &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-3 &lt;/td&gt;
&lt;td&gt; Allowed caching of vtable contents &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-4 &lt;/td&gt;
&lt;td&gt; Function descriptors in vtable &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-5 &lt;/td&gt;
&lt;td&gt; Where are vtables emitted? &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-6 &lt;/td&gt;
&lt;td&gt; Virtual function table layout &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-7 &lt;/td&gt;
&lt;td&gt; Vtables in shared memory &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; B-8 &lt;/td&gt;
&lt;td&gt; dynamic_cast &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990628 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; C &lt;/th&gt;
&lt;th colspan=6&gt; Object Construction/Destruction &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-1 &lt;/td&gt;
&lt;td&gt; Interaction with .init/.fini &lt;/td&gt;
&lt;td&gt; lif ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-2 &lt;/td&gt;
&lt;td&gt; Order of ctors/dtors w.r.t. link &lt;/td&gt;
&lt;td&gt; lif ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-3 &lt;/td&gt;
&lt;td&gt; Order of ctors/dtors w.r.t. DSOs &lt;/td&gt;
&lt;td&gt; ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-4 &lt;/td&gt;
&lt;td&gt; Calling vfuncs in ctors/dtors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-5 &lt;/td&gt;
&lt;td&gt; Calling virtual destructors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-6 &lt;/td&gt;
&lt;td&gt; Extra parameters to ctors/dtors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-7 &lt;/td&gt;
&lt;td&gt; Passing value parameters by reference &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; All &lt;/td&gt;
&lt;td&gt; 990625 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; C-8 &lt;/td&gt;
&lt;td&gt; Returning classes with non-trival copy constructors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; All &lt;/td&gt;
&lt;td&gt; 990625 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; D &lt;/th&gt;
&lt;th colspan=6&gt; Exception Handling &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-1 &lt;/td&gt;
&lt;td&gt; Language-specific data area format &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-2 &lt;/td&gt;
&lt;td&gt; Unwind personality routines &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-3 &lt;/td&gt;
&lt;td&gt; Unwind process clarification &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-4 &lt;/td&gt;
&lt;td&gt; Unwind routines nested? &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-5 &lt;/td&gt;
&lt;td&gt; Interaction with other languages (e.g. Java) &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-6 &lt;/td&gt;
&lt;td&gt; Allow resumption in other languages? &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-7 &lt;/td&gt;
&lt;td&gt; Interaction with signals or asynch events &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; D-8 &lt;/td&gt;
&lt;td&gt; Interaction with threads packages &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; E &lt;/th&gt;
&lt;th colspan=6&gt; Template Instantiation Model &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; E-1 &lt;/td&gt;
&lt;td&gt; When does instantiation occur? &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; E-2 &lt;/td&gt;
&lt;td&gt; Separate compilation model &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; E-3 &lt;/td&gt;
&lt;td&gt; Template repository &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; F &lt;/th&gt;
&lt;th colspan=6&gt; Name Mangling &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; F-1 &lt;/td&gt;
&lt;td&gt; Mangling convention &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; F-2 &lt;/td&gt;
&lt;td&gt; Mangled name size &lt;/td&gt;
&lt;td&gt; call g &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; F-3 &lt;/td&gt;
&lt;td&gt; Distinguish template instantiation and specialization
&lt;/td&gt;
&lt;td&gt; call g &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; G &lt;/th&gt;
&lt;th colspan=6&gt; Miscellaneous &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; G-1 &lt;/td&gt;
&lt;td&gt; Basic command line options &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; G-2 &lt;/td&gt;
&lt;td&gt; Detection of 1-def rule violations &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; G-3 &lt;/td&gt;
&lt;td&gt; Inlined routine linkage &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; G-4 &lt;/td&gt;
&lt;td&gt; Dynamic init of local static objects and multithreading &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SCO &lt;/td&gt;
&lt;td&gt; 990607 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;/tr&gt;
&lt;tr class=small&gt; &lt;th&gt; H &lt;/th&gt;
&lt;th colspan=6&gt; Runtime Library Interface &lt;/th&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; H-1 &lt;/td&gt;
&lt;td&gt; Runtime library DSO name &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990616 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;

&lt;tr class=small&gt; &lt;td&gt; H-1 &lt;/td&gt;
&lt;td&gt; Runtime library API &lt;/td&gt;
&lt;td&gt; lif &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990616 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;


&lt;/table&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
&lt;h4&gt;Notes from 3 June 1999 &lt;/h4&gt;

&lt;ul&gt;
&lt;p&gt;
&lt;li&gt; Introductions

&lt;p&gt;
&lt;li&gt; Objectives: see above

&lt;p&gt;
&lt;li&gt; Procedure

  &lt;ul&gt;
  &lt;li&gt; Meetings:  10-12 Thursdays at SGI for the near term.
  &lt;li&gt; Intel NDA:  Generally unnecessary.  Priti will set up n-way
       for eligible members for cases where needed.  Cary expects RT
       architecture/software conventions document to be released in the
       next month or two, removing most of the issues.
  &lt;li&gt; Communication:  Use of reflector encouraged for discussion.
       NDA communication will be handled with password-protected PDF
       once Intel sets up n-way.
  &lt;li&gt; Available documents:  Parties with existing, relevant documents
       (includes Sun, HP) will send them to group.
  &lt;li&gt; Intellectual property:  Participants don't expect problems with
       release of any of their IP.  Microsoft has extensive patents in
       the area, but they are excessively broad (covering obvious ideas
       and prior art), so expectation is that they are not a problem.
       Nonetheless, we should be aware of them.
  &lt;/ul&gt;

&lt;p&gt;
&lt;li&gt; Issue Identification:  new issues reflected in status table.

&lt;/ul&gt;

&lt;p&gt;
&lt;h4&gt;Notes from 10 June 1999 &lt;/h4&gt;

&lt;p&gt;
Matt Austern presented an initial assessment of the object layout issues.
He categorized them as trivial
(requiring agreement, but without significant performance implications)
or significant.  The trivial issues are:

&lt;ol&gt;
&lt;p&gt;
&lt;li&gt; (A-1) Where is the Vptr stored in an object?
Given the absence of addressing modes with displacements on IA-64,
the consensus is at the beginning of the object.

&lt;p&gt;
&lt;li&gt; (A-9) What is the order of members in an object?
Discussion of the possibilities for reordering between access
specifications suggests that we might find significance here.

&lt;p&gt;
&lt;li&gt; (A-4) Empty base class optimization:
when can an empty base class be stored at the same offset as another member?

&lt;p&gt;
&lt;li&gt; (A-1) What is the order of the Vtable?

&lt;p&gt;
&lt;li&gt; (B-5) What is the external name of a global Vtable?

&lt;p&gt;
&lt;li&gt; (B-5) Where is a global Vtable emitted?

&lt;/ol&gt;

&lt;p&gt;
The significant issues are:

&lt;ol&gt;
&lt;p&gt;
&lt;li&gt; (A-3) How are virtual functions handled given multiple inheritance?
That is, where is the &quot;this&quot; pointer adjusted?

&lt;p&gt;
&lt;li&gt; (A-2) How are virtual functions handled given virtual base types?

&lt;p&gt;
&lt;li&gt; (B-2) How are virtual functions with covariant return types handled?
That is, where is the result pointer adjusted?

&lt;p&gt;
&lt;li&gt; (A-6) How does RTTI interact with exceptions?

&lt;/ol&gt;

&lt;p&gt;
&lt;h4&gt;Notes from 17 June 1999 &lt;/h4&gt;

&lt;p&gt;
&lt;b&gt; Issues A-1, A-2, A-9&lt;/b&gt; (Matt):
See the open issues list.

&lt;p&gt;
&lt;b&gt; Actions&lt;/b&gt;:
Christophe will write a Vtable layout definition strawman,
including a description of covariant returns,
and more generally the virtual function protocol.
Daveed will write up the issue with dynamic casts and inaccessible bases.

&lt;p&gt;
Michael Lam will write summaries for the ctor/dtor issues for next week.

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
Please send corrections to &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">dehnert at sgi.com</A>&gt;Jim Dehnert&lt;/a&gt;.


&lt;/BODY&gt;
&lt;/HTML&gt;
-------------- next part --------------
&lt;HTML&gt;

&lt;HEAD&gt;
&lt;title&gt;C++ ABI Open Issues&lt;/title&gt;

&lt;link rel=stylesheet href=small-table.css type=&quot;text/css&quot;&gt;
&lt;link rel=stylesheet href=code.css type=&quot;text/css&quot;&gt;

&lt;hr&gt;

&lt;font size=6&gt;&lt;i&gt;&lt;b&gt;
&lt;p&gt;
C++ ABI Open Issues
&lt;/b&gt;&lt;/i&gt;&lt;/font&gt;

&lt;font size=-1&gt;
&lt;p&gt;
&lt;i&gt;Revised 28 June 1999&lt;/i&gt;

&lt;/center&gt;

&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Revisions &lt;/h3&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990625]&lt;/font&gt;
Closed A-1, A-2, A-4, A-8, A-9.
Additions to A-3, A-5, A-7, B-4, B-5, B-7, G-3, G-4.
New issues B-6, B-7, B-8, C-7, C-8.

&lt;p&gt;
&lt;font color=blue&gt;[990616]&lt;/font&gt;
Added HP summaries.
Added sketchy notes from 990610 discussions (A and B issues).
A-10 was intended by HP as something different than I described,
so it was renamed, and a new issue A-13 opened as an SGI issue.
HP did not submit A-12, so relabeled as Sun's (is that right?).
Added library interface issues, H-1 and H-2.


&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Definitions &lt;/h3&gt;

&lt;p&gt;
The issues below make use of the following definitions:

&lt;dl&gt;

&lt;p&gt;
&lt;dt&gt; &lt;i&gt;empty class&lt;/i&gt; &lt;/dt&gt;
&lt;dd&gt;
A class with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)

&lt;p&gt;
&lt;dt&gt; &lt;i&gt;nearly empty class&lt;/i&gt; &lt;/dt&gt;
&lt;dd&gt;
A class, the objects of which contain only a Vptr.

&lt;p&gt;
&lt;dt&gt; &lt;i&gt;vague linkage&lt;/i&gt; &lt;/dt&gt;
&lt;dd&gt;
The treatment of entities --
e.g. inline functions, templates, vtables --
with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.

&lt;/dl&gt;


&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Issue Status &lt;/h3&gt;

In the following sections,
the &lt;b&gt;&lt;i&gt;class&lt;/i&gt;&lt;/b&gt; of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

&lt;table&gt;
&lt;tr&gt; &lt;td&gt; call &lt;/td&gt;
&lt;td&gt; Function call interface, i.e. call linkage &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; data &lt;/td&gt;
&lt;td&gt; Data layout &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; lib &lt;/td&gt;
&lt;td&gt; Runtime library support &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; lif &lt;/td&gt;
&lt;td&gt; Library interface, i.e. API &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; g &lt;/td&gt;
&lt;td&gt; Potential gABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; ps &lt;/td&gt;
&lt;td&gt; Potential psABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; source &lt;/td&gt;
&lt;td&gt; Source code conventions (i.e. API, not ABI) &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; May affect how program construction tools interact &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Object Layout Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-1 &lt;/td&gt;
&lt;td&gt; Vptr location &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where is the Vptr stored in an object (first or last are the usual answers).
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-2 &lt;/td&gt;
&lt;td&gt; Virtual base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-3 &lt;/td&gt;
&lt;td&gt; Multiple inheritance &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Define the class layout in the presence of multiple base classes.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990617 All]&lt;/font&gt;
At offset zero is the Vptr whenever there is one,
as well as the primary base class if any (see A-7).
Also at offset zero is any number of empty base classes,
as long as that does not place multiple subobjects of the same type at
the same offset.
If there are multiple empty base classes such that placing two of them
at offset zero would violate this constraint, the first is placed there.
(First means in declaration order.)

&lt;p&gt;
All other non-virtual base classes are laid out in declaration order at
the beginning of the class.
All other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

&lt;p&gt;
The above ignores issues of padding for alignment,
and possible reordering of class members to fit in padding areas.
See issue A-9.

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
There remains an issue concerning the selection of the primary base
class (see A-7), but we are otherwise in agreement.
We will attempt to close this on 1 July, modulo A-7.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-4 &lt;/td&gt;
&lt;td&gt; Empty base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where are empty base classes allocated?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-5 &lt;/td&gt;
&lt;td&gt; Empty parameters &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
When passing a parameter with an empty class type by value,
what is the convention?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990623 SGI]&lt;/font&gt;
We propose that no parameter slot be allocated to such parameters,
i.e. that no register be used,
and that no space in the parameter memory sequence be used.
This implies that the callee must allocate storage at a unique address
if the address is taken (which we expect to be rare).

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
In addition to the address-taken case,
care is required if the object has a non-trivial copy constructor.
HP observes that in (some?) such cases,
they perform the construction at the call site and pass the object by
reference.

&lt;p&gt;
&lt;font color=blue&gt;[990625 SGI -- Jim]&lt;/font&gt;
I understand that the Standard explicitly allows elimination of
even non-trivial copy construction in some cases.
Is this one of them?  Where should I look?
Also, of course, varargs processing for elided empty parameters would
need to be careful.

&lt;p&gt;
I have opened a new issue (C-7) for passing copy-constructed
parameters by reference.
Since doing so would turn an empty value parameter
into a non-empty reference parameter,
this issue can ignore such cases.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-6 &lt;/td&gt;
&lt;td&gt; RTTI (&lt;code&gt;type_info&lt;/code&gt;) .o representation &lt;/td&gt;
&lt;td&gt; data call ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Christophe]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-7 &lt;/td&gt;
&lt;td&gt; Vptr sharing with primary base class &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
It is in general possible to share the virtual pointer with a
polymorphic base class (the &lt;i&gt;primary&lt;/i&gt; base class).
Which base class do we use for this?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990617 All]&lt;/font&gt;
It will be shared with the first polymorphic non-virtual base class,
or if none, with the first nearly empty polymorphic virtual base class.
(See A-2 for the definition of &lt;i&gt;nearly empty&lt;/i&gt;.)

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
HP noted that Taligent chooses a base class with virtual bases before
one without as the primary base class),
probably to avoid additional &quot;this&quot; pointer adjustments.
SGI observed that such a rule would prevent users from controlling the
choice by their ordering of the base classes in the declaration.
The bias of the group remains the above resolution,
but HP will attempt to find the Taligent rationale before this is decided.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-8 &lt;/td&gt;
&lt;td&gt; (Virtual) base class alignment &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-9 &lt;/td&gt;
&lt;td&gt; Sorting fields as allowed by [class.mem]/12 &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-10 &lt;/td&gt;
&lt;td&gt; Class parameters in registers &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The C ABI specifies that small structs are passed in registers.
Does this apply to small non-POD C++ objects passed by value?
What about the copy constructor and &lt;code&gt;this&lt;/code&gt; pointer in that case?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-11 &lt;/td&gt;
&lt;td&gt; Representation of pointers to members &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Ian]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-12 &lt;/td&gt;
&lt;td&gt; Merging secondary vtables &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990610 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Sun]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-13 &lt;/td&gt;
&lt;td&gt; Parameter struct field promotion &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
It is possible to pass small classes either as memory images,
as is specified by the base ABI for C structs,
or as a sequence of parameters, one for each member.
Which should be done, and if the latter,
what are the rules for identifying &quot;small&quot; classes?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Virtual Function Handling Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-1 &lt;/td&gt;
&lt;td&gt; Adjustment of &quot;this&quot; pointer (e.g. thunks) &lt;/td&gt;
&lt;td&gt; data call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
There are several methods for adjusting the &lt;i&gt;this&lt;/i&gt; pointer
for a member function call,
including thunks or offsets located in the vtable.
We need to agree on the mechanism used,
and on the location of offsets, if any are needed.
To maximize performance on IA64,
a slightly unusual approach such as using secondary entry points
to perform the adjustment may actually prove interesting. 
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-2 &lt;/td&gt;
&lt;td&gt; Covariant return types &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
There are several methods for adjusting the 'this' pointer of the
returned value for member functions with covariant return types.
We need to decide how this is done.
Return thunks might be especially costly on IA64,
so a solution based on returning multiple pointers may prove more interesting.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990610 Matt]&lt;/font&gt;
One possibility is to have two Vtable entries,
which might point to different functions, different entrypoints,
or a real entrypoint and a thunk.
Another is to return two result pointers (base/derived),
and have the caller select the right one.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-3 &lt;/td&gt;
&lt;td&gt; Allowed caching of vtable contents &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The contents of the vtable can sometimes be modified,
but the concensus is that it is nonetheless always allowed to &quot;cache&quot; elements,
i.e. to retain them in registers and reuse them,
whenever it is really useful.
However, this may sometimes break &quot;beyond the standard&quot; code,
such as code loading a shared library that replaces a virtual function.
Can we all agree when caching is allowed? 
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990604 HP Christophe]&lt;/font&gt;
Mike (Ball) gave me what I believe is an excellent definition of  
when caching is allowed.  I'd like him to present it.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-4 &lt;/td&gt;
&lt;td&gt; Function descriptors in vtable &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
For a runtime architecture where the caller is expected to load the GP
of the callee (if it is in, or may be in, a different DSO), e.g. HP/UX,
what should vtable entries contain?
One possibility is to put a function address/GP pair in the vtable.
Another is to include only the address of a thunk which loads the GP
before doing the actual call.

&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Note that putting GP in the Vtable prevents putting it in shared memory.
See B-7.


&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-5 &lt;/td&gt;
&lt;td&gt; Where are vtables emitted? &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
In C++, there are various things with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.
&gt;<i>From the user's standpoint, this applies to inlines and templates.
</I>&gt;<i>From the implementation's perspective,
</I>it also applies to things like vtables and RTTI info.
(We call this &lt;i&gt;vague linkage&lt;/i&gt;.)
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624 Cygnus -- Jason]&lt;/font&gt;
There are several ways of dealing with vague linkage items:
&lt;ol&gt;
&lt;li&gt; Emit them everywhere and only use one.
&lt;li&gt; Use some heuristic to decide where to emit them.
&lt;li&gt; Use a database to decide where to emit them.
&lt;li&gt; Generate them at link time.
&lt;/ol&gt;

&lt;p&gt;
#3 and #4 are feasible for templates,
but I consider them too heavyweight to be used for other things.

&lt;p&gt;
The typical heuristic for #2 is &quot;with the first non-inline,
non-abstract virtual function in the class&quot;.
This works pretty well,
but fails for classes that have no such virtual function,
and for non-member inlines.
Worse, the heuristic may produce different results in different
translation units,
as a method could be defined inline after being declared non-inline
in the class body.
So we have to handle multiple copies in some cases anyway.

&lt;p&gt;
The way to handle this in standard ELF is weak symbols.
If all definitions are marked weak,
the linker will choose one
and the others will just sit there taking up space.

&lt;p&gt;
Christophe mentioned the other day that the HP compiler used the
typical heuristic above,
and handled the case of different results by encoding the
key function in the vtable name.
But this seems unnecessary when we can just choose one of multiple defns.

&lt;p&gt;
A better solution than weak symbols alone would be to set things up so
that the linker will discard the extra copies.
Various existing implementations of this are:

&lt;ol&gt;
&lt;p&gt;
&lt;li&gt;
The Microsoft PE/COFF defn includes support for COMDAT sections,
which key off of the first symbol defined.
One copy is chosen, others are discarded.
You can specify conditions to the linker
(must have same contents, must have same size).

&lt;p&gt;
&lt;li&gt;
The IBM XCOFF platform includes a garbage-collecting linker;
sections that are not referenced in a sweep from main are discarded.
In xlC, template instantiations are emitted in separate sections,
with encoded names;
at link time, one copy is renamed to the real mangled name,
and the others are discarded by garbage collection.
&lt;/ol&gt;

&lt;p&gt;
The GNU ELF toolchain does a variant of #1 here;
any sections with names beginning with &quot;.gnu.linkonce.&quot;
are treated as COMDAT sections.
It seems more sensible to me to key off of the section name
than the first symbol name as in PE.

&lt;p&gt;
The GNU linker recently added support for garbage collection,
and I've been thinking about changing our handling of vague
linkage to make use of it, but haven't.

&lt;p&gt;
I propose that the ia64 base ABI be extended to
provide for either COMDAT sections or garbage collection,
and that we use that support for vague linkage.

&lt;p&gt;
I further propose that we not use heuristics to
cut down the number of copies ahead of time;
they usually work fine, but can cause problems in some situations,
such as when not all of the class's members are in the same symbol space.
Does the ia64 ABI provide for controlling which symbols
are exported from a shared library?

&lt;p&gt;
A side issue: What do we want to do with
dynamically-initialized variables?
The same thing, or use COMMON?
I propose COMMON.

&lt;p&gt;
See also G-3, for vague linkage of inlined routines and their static variables.

&lt;p&gt;
&lt;font color=blue&gt;[990624 SGI summarizing others]&lt;/font&gt;
HP uses COMDAT for many cases, keying from the symbol names.
HP also uses some heuristics.
HP observes that IA-64 objects will already be large.
&gt;<i>From the base ABI discussions,
</I>any use of WEAK or COMMON symbols will need to take care not to depend
on vendor-specific treatment.

&lt;p&gt;
Defining a COMDAT mechanism doesn't preclude using heuristics to avoid
some copies up front.
A COMDAT mechanism should also specify how to get rid of associated
sections like debugging info, unless the identical mechanism works.

&lt;p&gt;
&lt;font color=blue&gt;[990629 HP -- Christophe]&lt;/font&gt;
First, the &quot;usual&quot; heuristic
(which is usual because it dates back to Cfront)
is to emit vtables in the translation unit that contains  
the definition of the first non inline, non pure virtual function.  
That is, for:
&lt;pre&gt;&lt;code&gt;
        struct X {
                void a();
                virtual void f() { return; }
                virtual void g() = 0;
                virtual void h();
                virtual void i();
        };
&lt;/code&gt;&lt;/pre&gt;
the vtable is emitted only in the TU that contains the definition of h().

&lt;p&gt;
This breaks and becomes non-portable if:
&lt;ul&gt;
&lt;li&gt;There is no such thing. In that case,
    you generally emit duplicate versions of vtables
&lt;li&gt;There is a &quot;change of mind&quot;,
    such as having the above class followed by:
    &lt;code&gt;&lt;p&gt;
    &lt;dd&gt;inline void X::h() { f(); }
    &lt;/code&gt;

&lt;p&gt;
Now, the COMDAT issue is as follows:
a COMDAT section is, in some cases, slightly more difficult to handle
(at least, that's the impression Jason gave me).
For statics with runtime initialization,  
what you can do is reserve COMMON space ('easier'),
then initialize that space at runtime.
As I said, the problem is if two compilers disagree on whether this
is a runtime or a compile time initialization, such as in :
&lt;pre&gt;&lt;code&gt;
	int f() { return 1; }
	int x = f();	// Static (COMDAT) or Dynamic (COMMON) initialization?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
So I personally recommend that we put everything in COMDAT.


&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-6 &lt;/td&gt;
&lt;td&gt; Virtual function table layout &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
What is the layout of the Vtable?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624]&lt;/font&gt;
Issue split from A-1.


&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-7 &lt;/td&gt;
&lt;td&gt; Vtables in shared memory &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Is it possible to put the Vtable in shared memory?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Note that putting GP in the Vtable prevents putting it in shared memory.
This interacts with B-4.

&lt;p&gt;
&lt;font color=blue&gt;[990624 HP -- Cary]&lt;/font&gt;
For a C++ object to be placed into shared memory,
its vtable pointer must be valid in all processes
that are sharing that object.

&lt;ol&gt;
&lt;p&gt;
&lt;li&gt;
If the vtable can be placed in text, that would be fine,
but the vtable contains function pointers (or descriptors)
that require runtime relocation, so it must be in data.

&lt;p&gt;
&lt;li&gt;
We can place the vtables in shared memory,
but only if the function pointers/descriptors are valid in all processes.
The entry point addresses, which refer to shared text, should be shareable,
but the gp values may not be identical for all processes.
(RTTI pointers are also an issue,
and could be solved by putting the RTTI information in shared memory as well.)

&lt;p&gt;
&lt;li&gt;
We can place the vtables in private memory,
provided they are at the same address in all processes.
&lt;/ol&gt;

&lt;p&gt;
One way or another,
we need a way of ensuring that a pointer from shared 
memory to private memory is valid in all processes,
which means that we will need a means to ensure that certain shared
library data segments can get mapped at the same address in all
processes that load those certain libraries.

&lt;p&gt;
My wild idea a few years ago was to put the vtables in shared memory
(by allocating and building them at load time, as Taligent did),
and store a shared library index in place of the gp value
in each function descriptor.
Each process would have its own table of gp values,
indexed by this shared library index,
but the index space would be managed system-wide.
The C++ runtime library would have been responsible for allocating
a new index for each unique C++ shared library loaded on the system,
then storing the process-local copy of the gp pointer in the 
appropriate slot of the table.

&lt;p&gt;
&lt;font color=blue&gt;[990628 SGI -- Jim]&lt;/font&gt;
Note a further problem with vtables in shared memory (Cary's point 2).
If a virtual function comes from another DSO,
it may be pre-empted differently in different programs.
Hence, the function pointer itself is a problem even if the GP isn't.



&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; B-8 &lt;/td&gt;
&lt;td&gt; dynamic_cast &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990628 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
What information to we put in the vtable to enable (a) dynamic_cast
from pointer-to-base to pointer-to-derived (including detection of
ambiguous base classes) and (b) dynamic_cast to void*?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Object Construction/Destruction Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-1 &lt;/td&gt;
&lt;td&gt; Interaction with .init/.fini &lt;/td&gt;
&lt;td&gt; lif ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Static objects with dynamic constructors must be constructed at
intialization time.
This is done via the executable object initialization functions that
are identified (in ELF) by the DT_INIT and DT_INITARRAY dynamic tags.
How should the compiler identify the constructors to be called in this way?
One traditional mechanism is to put calls in a .init section.
Another, used by HP, is to put function addresses in a .initarray section.
&lt;p&gt;
The dual question arises for static object destructors.
Again, the extant mechanisms include putting calls in a .fini section,
or putting function addresses in a .finiarray section.
&lt;p&gt;
Finally, which mechanism (DT_INIT or DT_INITARRAY, or the FINI versions)
should be used in linked objects?
The gABI, and the IA-64 psABI, will support both,
with DT_INIT being executed before the DT_INITARRAY elements.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-2 &lt;/td&gt;
&lt;td&gt; Order of ctors/dtors w.r.t. link &lt;/td&gt;
&lt;td&gt; lif ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Given that the compiler has identified constructor/destructor calls for
static objects in each relocatable object, in what order should the
static linker combine them in the linked executable object?
(The initialization order determines the finalization order,
as its opposite.)
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990610 All]&lt;/font&gt;
Meeting concensus is that the desirable order is right to left on the
link command line, i.e. last listed relocatable object is initialized
first.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-3 &lt;/td&gt;
&lt;td&gt; Order of ctors/dtors w.r.t. DSOs &lt;/td&gt;
&lt;td&gt; ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Given the constructor/destructor calls for each executable object
comprising a program, what is the order of execution between objects?
For constructors, there is not much question:
unless we choose some explicit means of control,
file-scope objects will be initialized by the DT_INIT/DT_INITARRAY
functions in the order determined by the base ABI order rules,
and local objects will be initialized in the order their containing
scopes are entered.
&lt;p&gt;
For destructors, the Standard requires opposite-order destruction,
which implies a runtime structure to keep track of the order.
Furthermore, the potential for dynamic unloading of a DSO
(e.g. by dlclose)
requires a mechanism for early destruction of a subset.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-4 &lt;/td&gt;
&lt;td&gt; Calling vfuncs in ctors/dtors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Michael Lam]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-5 &lt;/td&gt;
&lt;td&gt; Calling virtual destructors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Michael Lam]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-6 &lt;/td&gt;
&lt;td&gt; Extra parameters to ctors/dtors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Cygnus &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Michael Lam]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-7 &lt;/td&gt;
&lt;td&gt; Passing value parameters by reference &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; All &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
It may be desirable in some cases where a type has a non-trivial
copy constructor to pass value parameters of that type by performing
the copy at the call site and passing a reference.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; C-8 &lt;/td&gt;
&lt;td&gt; Returning classes with non-trival copy constructors &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; All &lt;/td&gt;
&lt;td&gt; 990625 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
How do we return classes with non-trivial copy constructors?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Exception Handling Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-1 &lt;/td&gt;
&lt;td&gt; Language-specific data area format &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[SGI]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-2 &lt;/td&gt;
&lt;td&gt; Unwind personality routines &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[SGI]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-3 &lt;/td&gt;
&lt;td&gt; Unwind process clarification &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[SGI]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-4 &lt;/td&gt;
&lt;td&gt; Unwind routines nested? &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[SGI]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-5 &lt;/td&gt;
&lt;td&gt; Interaction with other languages (e.g. Java) &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The IA64 exceptions handling framework is largely language independent.
What is the behaviour of a C++ runtime receiving, for instance,
an exception thrown from Java?
Does it call terminate()?
Does it allow the exception to pass through C++ code with destructors
if there is no catch clause?
Does it allow the exception to be caught in a catch(...) provided this
catch(...) ends with a rethrow?
Does it allow even more?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-6 &lt;/td&gt;
&lt;td&gt; Allow resumption in other languages? &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The exception handling framework requires the interaction of the
runtime of all the languages &quot;on the stack&quot; during exception processing.
Some of these languages may have very different exception handling semantics.
What are the constraints we impose on the C++ exception handling runtime
to preserve the relative language neutrality of the EH framework?
Example: do we allow a handler to cleanup and resume at the point
where the exception was thrown?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-7 &lt;/td&gt;
&lt;td&gt; Interaction with signals or asynch events &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The Standard says that the behavior of anything other than
&quot;pure C code&quot; (POF) is implementation defined,
and warns (in a note) against using EH in a signal handler.
We should define what is supported,
possibly explicitly stating that signal handler code must be a POF.
We could allow any feature but exception handling to be used.
We could allow some EH routines to be called
(for instance, &lt;code&gt;uncaught_exception()&lt;/code&gt;).
Or we could allow even an exception to be thrown,
if it does not exit the handler.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; D-8 &lt;/td&gt;
&lt;td&gt; Interaction with threads packages &lt;/td&gt;
&lt;td&gt; lib ps &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
What happens when an exception is not caught in the thread where raised?
What does uncaught_exception() return if another thread is currently
processing an exception?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Template Instantiation Model Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;


&lt;tr&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;th&gt; E &lt;/th&gt;
&lt;th colspan=6&gt; Template Instantiation Model &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; E-1 &lt;/td&gt;
&lt;td&gt; When does instantiation occur? &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
There are two principal models for instantiation.
The &lt;i&gt;early instantiation&lt;/i&gt; (or Borland) model performs all
instantiation at compile time,
potentially resulting in extra copies which are removed at link time.
The &lt;i&gt;pre-link instantiation&lt;/i&gt; model identifies the required
instantiations prior to linking and instantiates them via a special
compile step.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; E-2 &lt;/td&gt;
&lt;td&gt; Separate compilation model &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[SGI]
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; E-3 &lt;/td&gt;
&lt;td&gt; Template repository &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Independent of the template instantiation model,
we need to make sure that whatever template persistent storage is used
by one vendor does not interact negatively with other vendors' mechanisms.
Issues:
  (1) Avoiding conflict on the name of any repository.
  (2) If .o files are used,
	describe how this information is to be preserved, ignored, etc.
  (3) Evaluate if tools such as make, ld, ar, or others, can
	break because .o files get written at unexpected times.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Name Mangling Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; F-1 &lt;/td&gt;
&lt;td&gt; Mangling convention &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
What rules shall be used for mangling names,
i.e. for encoding the information other than the source-level object
name necessary to resolve overloading?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; F-2 &lt;/td&gt;
&lt;td&gt; Mangled name size &lt;/td&gt;
&lt;td&gt; call g &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Typical name mangling schemes to date typically begin to produce very
long names.  SGI routinely encounters multi-kilobyte names,
and increasing usage of namespaces and templates will make them worse.
This has a negative impact on object file size, and on linker speed.
&lt;p&gt;
SGI has considered solutions to this problem including modified string
tables and/or symbol tables to eliminate redundancy.
Cygnus, HP, and Sun have also considered or implemented approaches
which at least mitigate it.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; F-3 &lt;/td&gt;
&lt;td&gt; Distinguish template instantiation and specialization
&lt;/td&gt;
&lt;td&gt; call g &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
In order to allow detection of conflicting template instantiation
and specialization (in different translation units),
should we name them differently?
If we do so in an easily recognizable way,
the linker could check for conflicts and report the ODR violation.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Miscellaneous Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; G-1 &lt;/td&gt;
&lt;td&gt; Basic command line options &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Can we agree on basic command line options (compiler and linker)
for fundamental functionality,
possibly allowing portable makefiles?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; G-2 &lt;/td&gt;
&lt;td&gt; Detection of ODR violations &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
[Sun]
(See also F-3.)
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; G-3 &lt;/td&gt;
&lt;td&gt; Inlined routine linkage &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; Sun &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Inline routines with external linkage require a method of handling
vague linkage (see B-5 for definition) for the out-of-line instance,
as well as for any static data they contain.
The latter includes string constants per [7.1.2]/4.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624 Cygnus -- Jason]&lt;/font&gt;
How should we handle local static variables in inlines?
G++ currently avoids this issue by suppressing
inlining of functions with local statics.
If we don't want to do that,
we'll need to specify a mangling for the statics,
and handle multiple copies like we do above.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; G-4 &lt;/td&gt;
&lt;td&gt; Dynamic init of local static objects and multithreading &lt;/td&gt;
&lt;td&gt; call &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SCO &lt;/td&gt;
&lt;td&gt; 990607 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The Standard requires that local static objects with dynamic
constructors be initialized exactly once, the first time the containing
scope is entered.
Multi-threading renders the simple check of a flag before
initialization inadequate to prevent multiple initialization.
Should the ABI require locking for this purpose,
and if so, what are the necessary interfaces?
In addition to the locking of the initialization,
special exception handling treatment is required to deal with an
exception during construction.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990607 SCO -- Jonathan]&lt;/font&gt;
The standard is mute on multiple threads of control in general, so 
there is no requirement in the language to support what I'm talking
about. But as a practical matter compilers have to do it (Watcom gave
a paper on their approach during the standardization process, if I
remember).  This example using UI/SVR4 threads will usually show
whether a compiler does it or not: 

&lt;pre&gt;&lt;code&gt;
thr5.C:
// static local initialization and threads

#include &lt;stdlib.h&gt;
#define EXIT(a) exit(a)
#define THR_EXIT() thr_exit(0)

#include &lt;thread.h&gt;

int init_count = 0;
int start_count = 0;

int init()
{
  
        ::thr_yield();
        return ++init_count;
}

void* start(void* s)
{
  
        start_count++;
        static int i = init();
        if (i != 1) EXIT(5);
        THR_EXIT();
        return 0;
}
                
int main()
{
  
        thread_t t1, t2;
        if (::thr_create(0, 0, start, 0, 0L, &amp;t1) != 0) EXIT(1);
        if (::thr_create(0, 0, start, 0, 0L, &amp;t2) != 0) EXIT(2);
        if (::thr_join(t1, 0, 0) != 0) EXIT(3);
        if (::thr_join(t2, 0, 0) != 0) EXIT(4);
        if (start_count != 2)
                EXIT(6);
        if (init_count != 1)
                EXIT(7);
        THR_EXIT();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
When compiled with CC -Kthread thr5.C on UnixWare 7, for instance,
it passes by returning 0.  When compiled with CC -mt thr5.C on
Solaris/x86 C++ 4.2 (sorry don't have the latest version!), it
fails by returning 5.


&lt;p&gt;
&lt;font color=blue&gt;[990607 Sun -- Mike Ball]&lt;/font&gt;
As far as I can tell, the language says that the automatic blocking 
issue isn't a valid approach.  It says what has to happen, and
it isn't that.

&lt;p&gt;
If you look at the entire statement you find that it reads:
&lt;quote&gt;
&quot;Otherwise such an object is initialized the first time control passes
through its declaration; such an object is considered initialized upon
the completion of its initialization.
If the initialization exits by throwing an exception,
the initialization is not complete,
so it will be tried again the next time control enters the declaration.
If control re-enters the declaration (recursively)
while the object is being initialized,
the behavior is undefined.&quot;
&lt;/quote&gt;

&lt;p&gt;
The word &quot;recursively&quot; is normative,
so eliminates that sentence from consideration.

&lt;p&gt;
One can, of course, make any extension to the language,
but in this case I think the extension invalidates some otherwise valid code.

&lt;p&gt;
The sentence I'm referring to is that the object is considered
initialized upon the completion of its initialization.
This is explicit, and the reason for it is covered in the following sentence,
which discusses an initialization that terminates with an exception.
A person catching such an exception has the right to try again
without danger that the static variable will be initialized in the meantime.

&lt;p&gt;
I don't see anything at all to justify semantics that say,
&quot;after initialization is started, Any other threads of control are
blocked until that thread completes the initialization,
unless, of course, it executes by an exception,
in which case the other thread can do the initialization before the
exception handler gets a chance to try again, except....&quot;
 Take an attempt to define the semantics as far as you like.

&lt;p&gt;
The problem is that there is no way for the compiler writer to know
what the programmer really wanted to do.
I can (and will at some other date, if necessary)
come up with scenarios justifying a variety of mutual exclusion policies,
including none.

&lt;p&gt;
The solution is to let the programmer write the mutual exclusion, the
same as we do for every other potential race condition.
It's a real mess, and, I claim, an unwise one to put in as an extension.

&lt;p&gt;
&lt;font color=blue&gt;[990608 HP -- Christophe]&lt;/font&gt;
The semantics currently implemented in the HP aC++ compiler is as follows:
&lt;ul&gt;
&lt;li&gt; No two thread can enter a static initialization at the same time
&lt;li&gt; Threads are blocked until immediately after the static  
    initialization either succeeds or fails with an exception.
&lt;/ul&gt;

&lt;p&gt;
There are details of our implementation that I disagree with, but in  
general, the semantics seem clear and sane, not as convoluted as you  
seemed to imply. In particular, it correctly covers the case where  
the static initialization fails with an exception. Any thread at that  
point can attempt the initialization.

&lt;p&gt;
&lt;font color=blue&gt;[990608 SCO -- Jonathan]&lt;/font&gt;
Here's what the SCO UnixWare 7 C++ compiler does for IA-32,
from a (slightly sanitized) design document.
 It meets Jim's goal of having no overhead for non-threaded programs
and minimal overhead for threaded programs unless
actual contention occurs (infrequent),
and meets Mike's goal of handling exceptions in the initialization correctly
(although it doesn't guarantee that the thread getting the exception is
the one that gets next crack at initializing the static).
 It's also worth noting that dynamic initialization of local variables
(static or otherwise) is very common in C++,
since that's what most object constructions involve,
so I don't think this case is as rare as Jim does.


&lt;p&gt;
[...] This is in local static variables with dynamic initialization,
where the compiler generates out a static one-time flag to guard the
initialization.
Two threads could read the flag as zero before either of them set it,
resulting in multiple initializations.

&lt;p&gt;
[...] Accordingly, when compilation is done with -Kthread on,
a code sequence will be generated to lock this initialization.  
[...] the basic idea is to have one guard saying whether the
initialization is done (so that multiple initializations do not occur)
and have another guard saying whether initialization is in progress
(so that a second thread doesn't access what it thinks is
an initialized value before the first thread has finished the
initialization).  [...]

&lt;p&gt;
When compiled with -Kthread, the generated code for a dynamic
initialization of a local static variable will look like the
following. guard is a local static boolean, initialized to zero,
generated by the [middle pass of the compiler]. 
Two bits of it are used: the low-order 'done bit'
and the next-low-order 'busy bit'.

&lt;pre&gt;&lt;code&gt;
.again:
        movl    $guard,%eax
        testl   $1,(%eax)       // test the done bit
        jnz     .done           // if set, variable is initialized,
done
        lock; btsl  $1,(%eax)   // test and set the busy bit
        jc      .busy
        &lt; init code &gt;           // not busy, do the initialization
        movl    $guard,%eax
        movl    $3,(%eax)       // set the done bit
        jmp     .done
.busy:
        pushl   %eax            // call RTS routine to wait, passing address
        call1   __static_init_wait      // of guard to monitor
        testl   %eax,%eax       // 1 means exception occurred in init code,
        popl    %ecx
        jnz     .again                  // start the whole thing over
.done                                   // 0 means wait finished
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
The above code will work for position-independent code as well.

The complication due to exceptions is:
what happens if the initialization code throws an exception?
The [compiler] EH tables will have set up a special region and flag in
their region table to detect this situation,
along with a pointer to the guard variable.
Because the initialization never completed,
when the RTS sees that it is cleaning up from such a region,
it will reset the guard variable back to both zeroes.
This will free up a busy-waiting thread, if any,
or will reset everything for the next thread that calls the function.

&lt;p&gt;
The idea of the __static_init_wait() RTS routine is to monitor the
value of guard bits passed in, by looping on this decision table:
&lt;pre&gt;&lt;code&gt;
    done    busy
    0       0       return 1 in %eax        (EH wipe-out)
    1       1       return 0 in %eax        (no longer busy)
    0       1       continue to wait        (still busy)
    1       0       internal error, shouldn't happen
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;
As for how the wait is done [... not relevant for ABI,
although currently we're using thr_yield(),
which may or may not be right for this context].

&lt;p&gt;
&lt;font color=blue&gt;[990608 SGI -- Hans]&lt;/font&gt;
I'd like to make some claims about function scope static constructor
calls in multithreaded environments.
I personally can't recall ever having used such a construct,
which somewhat substantiates my claims,
but also implies some lack of certainty.
I'd be interested in hearing any arguments to the contrary.

&lt;p&gt;
I believe that these arguments imply that this problem is not important
enough to warrant added ABI complexity or overhead for sequential code.

&lt;p&gt;
Consider the following skeletal example:

&lt;p&gt;&lt;code&gt;
f(int x) { static foo a(...); ... }
&lt;/code&gt;

&lt;ol&gt;
&lt;p&gt;
&lt;li&gt;
If the constructor argument doesn't depend on the function parameter,
and the code behaves reasonably, it should be possible to rewrite this as

&lt;p&gt;&lt;code&gt;
static foo a(...);
&lt;br&gt;
f(int x) { ... }
&lt;/code&gt;

&lt;p&gt;
&lt;li&gt;
If I read the standard correctly (and that's a big disclaimer),
the compiler is entitled to perform the above transformation under
conditions that are usually true,
but hard for the compiler to deduce.
Thus code that relies on the initialization occurring during the
execution of f is usually broken.

&lt;p&gt;
&lt;li&gt;
Thus the foo constructor cannot rely on its caller holding any locks.
It must explicitly acquire any locks it needs.

&lt;p&gt;
&lt;li&gt;
It is far preferable to write the transformed form with a file scope
static variable to start with.
The initial form risks deadlock,
since f may be called with locks held which the constructor
can't assume are held.
If it needs one of those locks it will need to reacquire it.
With default mutex semantics that results in deadlock with itself.
(If locks may be reentered,
it may fail in a more subtle manner since the foo constructor may
acquire a monitor lock whose monitor invariant doesn't hold.)

&lt;p&gt;
&lt;li&gt;
File scope static constructor calls aren't a problem and require no locking,
since they are executed in a single thread before main is called or
before dlopen returns.
(Forking a thread in a static constructor should probably be disallowed.
Threads may not have been fully initialized, among other issues.)

&lt;p&gt;
&lt;li&gt;
Static function scope constructor calls which depend on function
arguments are likely to involve a race condition anyway,
if multiple instances of the function can be invoked concurrently.
Any of the calls might determine the constructor parameters.
Thus these aren't very interesting either.
And if they are really needed, they can be replaced with a file scope
static constructor call plus an assignment.

&lt;/ol&gt;



&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Library Interface Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; H-1 &lt;/td&gt;
&lt;td&gt; Runtime library DSO name &lt;/td&gt;
&lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990616 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Determine the name of the common C++ runtime library DSO,
e.g. &lt;code&gt;libC.so&lt;/code&gt;.
If there are to be vendor-specific support libraries which must coexist
in programs from mixed sources, identify naming convention for them.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; H-2 &lt;/td&gt;
&lt;td&gt; Runtime library API &lt;/td&gt;
&lt;td&gt; lif &lt;/td&gt;
&lt;td&gt; open &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990616 &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Define the required entrypoints in the common C++ runtime library DSO,
and their prototypes.
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
Please send corrections to &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">dehnert at sgi.com</A>&gt;Jim Dehnert&lt;/a&gt;.


&lt;/BODY&gt;
&lt;/HTML&gt;
-------------- next part --------------
&lt;HTML&gt;

&lt;HEAD&gt;
&lt;title&gt;C++ ABI Closed Issues&lt;/title&gt;

&lt;link rel=stylesheet href=small-table.css type=&quot;text/css&quot;&gt;
&lt;link rel=stylesheet href=code.css type=&quot;text/css&quot;&gt;

&lt;hr&gt;

&lt;font size=6&gt;&lt;i&gt;&lt;b&gt;
&lt;p&gt;
C++ ABI Closed Issues
&lt;/b&gt;&lt;/i&gt;&lt;/font&gt;

&lt;font size=-1&gt;
&lt;p&gt;
&lt;i&gt;Revised 25 June 1999&lt;/i&gt;

&lt;/center&gt;

&lt;/HEAD&gt;

&lt;BODY&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; Issue Status &lt;/h3&gt;

In the following sections,
the &lt;b&gt;&lt;i&gt;class&lt;/i&gt;&lt;/b&gt; of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

&lt;table&gt;
&lt;tr&gt; &lt;td&gt; call &lt;/td&gt;
&lt;td&gt; Function call interface, i.e. call linkage &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; data &lt;/td&gt;
&lt;td&gt; Data layout &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; lib &lt;/td&gt;
&lt;td&gt; Runtime library support &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; lif &lt;/td&gt;
&lt;td&gt; Library interface, i.e. API &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; g &lt;/td&gt;
&lt;td&gt; Potential gABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; ps &lt;/td&gt;
&lt;td&gt; Potential psABI impact &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; source &lt;/td&gt;
&lt;td&gt; Source code conventions (i.e. API, not ABI) &lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; tools &lt;/td&gt;
&lt;td&gt; May affect how program construction tools interact &lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; A.  Object Layout Issues &lt;/h3&gt;

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-1 &lt;/td&gt;
&lt;td&gt; Vptr location &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where is the Vptr stored in an object (first or last are the usual answers).
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990610 All]&lt;/font&gt;
Given the absence of addressing modes with displacements on IA-64,
the consensus is to answer this question with &quot;first.&quot;

&lt;p&gt;
&lt;font color=blue&gt;[990617 All]&lt;/font&gt;
Given a Vptr and only non-polymorphic bases,
which (Vptr or base) goes at offset 0?
&lt;ul&gt;
&lt;li&gt; HP: Vptr at end, but IA-64 is different because no load displacement
&lt;li&gt; Sun: Vptr at 0 probably preferred
&lt;li&gt; g++: Vptr at end today
&lt;/ul&gt;
&lt;p&gt;
Tentative decision:  Vptr always goes at beginning.

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Accepted tentative decision.
Rename, close this issue, and open separate issue (B-6) for Vtable layout.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-2 &lt;/td&gt;
&lt;td&gt; Virtual base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990610 Matt]&lt;/font&gt;
With regard to how data member accesses are handled,
the choices are to store either a pointer or an offset in the Vtable.
The concensus seems to be to prefer an offset.

&lt;p&gt;
&lt;font color=blue&gt;[990617 All]&lt;/font&gt;
Any number of empty virtual base subobjects (rare) will be placed at
offset zero.
If there are no non-virtual polymorphic bases,
the first virtual base subobject with a Vpointer will be placed at
offset zero.
Finally, all other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Define an empty object as one with no non-static, non-empty data members,
no virtual functions,
no virtual base classes,
and no non-empty non-virtual base classes.
Define a nearly empty object as one which contains only a Vptr.
The above resolution is accepted, restated as follows:

&lt;p&gt;
Any number of empty virtual base subobjects
(rare, because they cannot have virtual functions or bases themselves)
will be placed at offset zero, subject to the conflict rules in A-3
(i.e. this cannot result in two objects of the same type at the same
address).
If there are no non-virtual polymorphic base subobjects,
the first nearly empty virtual base subobject will be placed at offset zero.
Any virtual base subobjects not thus placed at offset zero will be
allocated at the end of the class,
in left-to-right, depth-first declaration order.

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-4 &lt;/td&gt;
&lt;td&gt; Empty base classes &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; SGI &lt;/td&gt;
&lt;td&gt; 990520 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
Where are empty base classes allocated?
(An empty base class is one with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Closed as a duplicate of A-3.

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-8 &lt;/td&gt;
&lt;td&gt; (Virtual) base class alignment &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
(An alternative for virtual bases:
allow the virtual base to move in the complete object.)
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990623 SGI]&lt;/font&gt;
We propose that the alignment of a class be the maximum alignment of
its virtual and non-virtual base classes,
non-static data members, and Vptr if any.

&lt;p&gt;
&lt;font color=blue&gt;[990624 All]&lt;/font&gt;
Above proposal accepted.
(SGI observation:
the size of the class is rounded up to a multiple of this alignment,
per the underlying psABI rules.)

&lt;p&gt;
&lt;table border=on cellpadding=3&gt;

&lt;tr&gt;
&lt;th&gt; # &lt;/th&gt;
&lt;th&gt; Issue &lt;/th&gt; &lt;th&gt; Class &lt;/th&gt; &lt;th&gt; Status &lt;/th&gt;
&lt;th&gt; Source &lt;/th&gt; &lt;th&gt; Opened &lt;/th&gt; &lt;th&gt; Closed &lt;/th&gt;
&lt;/tr&gt;

&lt;tr&gt; &lt;td&gt; A-9 &lt;/td&gt;
&lt;td&gt; Sorting fields as allowed by [class.mem]/12 &lt;/td&gt;
&lt;td&gt; data &lt;/td&gt;
&lt;td&gt; closed &lt;/td&gt;
&lt;td&gt; HP &lt;/td&gt;
&lt;td&gt; 990603 &lt;/td&gt;
&lt;td&gt; 990624 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt; &lt;td colspan=7&gt;
&lt;b&gt;Summary&lt;/b&gt;:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
&lt;/td&gt; &lt;/tr&gt;

&lt;/table&gt;

&lt;p&gt;
&lt;font color=blue&gt;[990610 all]&lt;/font&gt;
Some participants want to avoid attempts to reorder members differently
than the underlying C struct ABI rules.
Others think there may be benefit in reordering later access sections
to fill holes in earlier ones, or even in base classes.

&lt;p&gt;
&lt;font color=blue&gt;[990617 all]&lt;/font&gt;
There are several potential reordering questions, more or less independent:
&lt;ol&gt;
&lt;li&gt; Do we reorder whole access regions relative to one another?
&lt;li&gt; Do we attempt to fill padding in earlier access regions with
	initial members from later regions?
&lt;li&gt; Do we fill the tail padding of non-POD base classes with members from
	the current class?
&lt;li&gt; Do we attempt to fill interior padding of non-POD base classes with later
	members?
&lt;/ol&gt;

&lt;p&gt;
There is no apparent support for (1),
since no simple heuristic has been identified with obvious benefits.
There is interest in (2), based on a simple heuristic which might
sometimes help and will never hurt.
However, it is not clear that it will help much,
and Sun objects on grounds that they prefer to match C struct layout.
Unless someone is interested enough to implement and run experiments,
this will be hard to agree upon.
G++ has implemented (3) as an option,
based on specific user complaints.
It clearly helps HP's example of a base class containing a word and flag,
with a derived class adding more flags.
Idea (4) has more problems, including some non-intuitive (to users) layouts,
and possibly complicating the selection of bitwise copy in the compiler.

&lt;p&gt;
&lt;font color=blue&gt;[990624 all]&lt;/font&gt;
We will not do (1), (2), or (4).  We will do (3).
Specifically, allocation will be in modified declaration order as follows:
&lt;ol&gt;
&lt;li&gt; Vptr if any, and the primary base class per A-7.
&lt;li&gt; Any empty base classes allocated at offset zero per A-3.
&lt;li&gt; Any remaining non-virtual base classes.
&lt;li&gt; Any non-static data members.
&lt;li&gt; Any remaining virtual base classes.
&lt;/ol&gt;
Each subobject allocated is placed at the next available position that
satisfies its alignment constraints, as in the underlying psABI.
This is interpreted with the following special cases:
&lt;ol&gt;
&lt;li&gt; The &quot;next available position&quot; after a class subobject
	(base class or data member) with tail padding is at the
	beginning of the tail padding, not after it.
&lt;li&gt; Empty classes are considered to have alignment and size 1,
	consisting solely of one byte of tail padding.
&lt;li&gt; Placement on top of the tail padding of an empty class must avoid
	placing multiple subobjects of the same type at the same
	address.
&lt;/ol&gt;
After allocation is complete,
the size is rounded up to a multiple of alignment (with tail padding).

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; B.  Virtual Function Handling Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; C.  Object Construction/Destruction Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; D.  Exception Handling Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; E.  Template Instantiation Model Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; F.  Name Mangling Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; G.  Miscellaneous Issues &lt;/h3&gt;

&lt;p&gt; &lt;hr&gt; &lt;p&gt;
&lt;h3&gt; H.  Library Interface Issues &lt;/h3&gt;

&lt;p&gt;
&lt;hr&gt;

&lt;p&gt;
Please send corrections to &lt;a href=mailto:<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">dehnert at sgi.com</A>&gt;Jim Dehnert&lt;/a&gt;.

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000137.html">Placement of vtables, inlines and such
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#138">[ date ]</a>
              <a href="thread.html#138">[ thread ]</a>
              <a href="subject.html#138">[ subject ]</a>
              <a href="author.html#138">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">More information about the cxx-abi-dev
mailing list</a><br>
</body></html>
