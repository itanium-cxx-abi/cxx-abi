From dehnert at sgi.com  Tue Jun  1 05:47:33 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Mon, 31 May 1999 22:47:33 -0700
Subject: SGI C++ ABI -- Initial meeting
Message-ID: <375373F5.637D2F9F@sgi.com>

Let's try to get this effort off the ground, with an initial
meeting on 3 June (Thursday) from 11:00 - 1:00.  We will arrange
a phone bridge and let you all know how to call it, and will set
up a conference room at SGI for anyone who would like to appear
physically (which might not be a bad idea the first time to see
one another's faces once).  Please let me know if you plan to come,
so I can make arrangements, including providing directions.

I'll attach our current issues list, in HTML and PDF, your choice.
After some initial discussion of objectives and procedures, I'll
have someone talk about alternatives for object layout.  If you
have issues and proposals in this area (or any other), please send
them to the list.

See you Thursday,
Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990531/eddd0224/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: issues-C++.pdf
Type: application/pdf
Size: 10531 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990531/eddd0224/attachment.pdf>

From dehnert at sgi.com  Tue Jun  1 05:53:14 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Mon, 31 May 1999 22:53:14 -0700
Subject: C++ ABI Participant info
Message-ID: <3753754A.43BDDA85@sgi.com>

Attached is the current information I have on participants.
Please send me corrections, additions, or whatever...

Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990531/5e20cb61/attachment.html>

From iancarm at cygnus.com  Tue Jun  1 15:28:16 1999
From: iancarm at cygnus.com (Ian Carmichael)
Date: Tue, 01 Jun 1999 15:28:16 +0000
Subject: [Fwd: [Fwd: C++ ABI Participant info]]
Message-ID: <3753FC10.71A972CB@cygnus.com>

We might want help Jim round out his list.  

How do you want to manage communication from within Cygnus.  Do you want to
filter everything through one or both of you two guys?

At any rate, his list is definitely incomplete.  A couple of glaring holes
...

1.  Object construction/destruction
	- parameters passed to c/dtors
	- handling of vtables during object construction

2.  Pointer to member function representation and use

Any other glaring holes?  

I guess it's also the case that some base ABI issues don't necessarily
carry (e.g. MS calling convention for member functions is not the same as
normal functions).

Ian

-------- Original Message --------
Received: from pneumatic-tube.sgi.com (pneumatic-tube.sgi.com
[204.94.214.22])by runyon.cygnus.com (8.8.7-cygnus/8.8.7) with ESMTP id
WAA17096;Mon, 31 May 1999 22:49:51 -0700 (PDT)
Received: from relay1.corp.sgi.com (spindle.corp.sgi.com [198.29.75.13]) by
pneumatic-tube.sgi.com (980309.SGI.8.8.8-aspam-6.2/980310.SGI-aspam) via
ESMTP id WAA330206; Mon, 31 May 1999 22:49:50 -0700 (PDT)mail_from
(owner-cxx-abi-outgoing at corp.sgi.com)
Received: (from majordom at localhost) by relay1.corp.sgi.com
(980427.SGI.8.8.8/970903.SGI.AUTOCF) id WAA43629 for cxx-abi-outgoing; Mon,
31 May 1999 22:49:48 -0700 (PDT)
Received: from baalbek.engr.sgi.com (baalbek.engr.sgi.com [192.26.72.107])
by relay1.corp.sgi.com (980427.SGI.8.8.8/970903.SGI.AUTOCF) via ESMTP id
WAA79134 for <cxx-abi at relay2.corp.sgi.com>; Mon, 31 May 1999 22:49:47 -0700
(PDT)
Received: from sgi.com (sgigate.sgi.com [198.29.75.75]) by
baalbek.engr.sgi.com (980427.SGI.8.8.8/980728.SGI.AUTOCF) via ESMTP id
WAA29962 for <cxx-abi at postofc.corp.sgi.com>; Mon, 31 May 1999 22:49:46
-0700 (PDT)
Message-ID: <3753754A.43BDDA85 at sgi.com>
Date: Mon, 31 May 1999 22:53:14 -0700
From: Jim Dehnert <dehnert at sgi.com>
Organization: Silicon Graphics, Inc.
X-Mailer: Mozilla 4.51 [en]C-DIAL  (WinNT; I)
X-Accept-Language: de,fr,no
MIME-Version: 1.0
To: cxx-abi at corp.sgi.com
Subject: C++ ABI Participant info
Sender: owner-cxx-abi at corp.sgi.com
Precedence: bulk
Reply-To: Jim Dehnert <dehnert at sgi.com>
Content-Type:
multipart/mixed;boundary="------------E754A023EB5D349C95848AB5"
X-Mozilla-Status: 8001
X-Mozilla-Status2: 00000000
X-UIDL: 1a23cce667759367c8330926aef6346c

Attached is the current information I have on participants.
Please send me corrections, additions, or whatever...

Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990601/67169d98/attachment.html>

From dehnert at baalbek.engr.sgi.com  Wed Jun  2 00:45:07 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Jun 1999 17:45:07 -0700 (PDT)
Subject: SGI C++ ABI -- Initial meeting
Message-ID: <199906020045.RAA32551@baalbek.engr.sgi.com>

The initial meeting is set for 11-1 on Thursday, 3 June.

We have an Intel phone bridge for the meeting.  Call (916)356-9200.
The RS # is 7-33255, and the passcode is 773-9583.
Thanks to Sunil for setting this up.

Subject to further refinement, I expect the agenda Thursday to be:

 1) Discussion of objectives.
 2) Procedural issues:  meetings, intellectual property, etc.
 3) Identify ABI issues to be raised.
 4) Matt Austern will summarize the object layout issues.

The meeting will be in the Maui conference room, SGI building 10.
>From the north, take Amphitheatre Pkwy. east and cross Shoreline
at the second light.  Go nearly to the end of the block -- building 10
is the next to last on the left, not counting the buildings at the end.
>From the south, take Shoreline Blvd. east, turn right at the red
sculpture, and follow the directions above.

Please let me know by mid-day tomorrow if you're planning to attend in
the flesh, so we can have food available.  (I know about Michael.)


> From michael.ball at eng.sun.com  Tue Jun  1 08:35:44 1999
> 
> I think I'd like to come in the flesh for an initial meeting.
> Also, there are two hyperlinks from your issues list.  Did you intend
> to make them unavailable, or did that just happen?

It was intentional -- sorry about the confusion.  Those were rough
internal descriptions, and we'll probably provide something cleaner
later.


> From reza.monajjemi at eng.sun.com  Tue Jun  1 09:49:55 1999
>
> What color are these C++ ABI discussions.  Are they Orange?

The intent is that they be white in general.  If we need orange
discussions, we'll split them off.

> Are there any multi-way agreements required for these discussions?
> My understanding is that the C++ ABI group will decide these
> issues.  Right?

I'm presuming that, with Intel's participation, we can handle any
orange side discussions with no more agreements than we have now for
the IA-64 psABI.  Is that reasonable, Sunil?

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Jun  3 01:18:37 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 2 Jun 1999 18:18:37 -0700 (PDT)
Subject: IMPORTANT -- meeting location change
Message-ID: <199906030118.SAA01985@baalbek.engr.sgi.com>

The meeting tomorrow has moved.  It will be in the Sapphire conference
room in SGI building 20.  That building is the first one on the right
side of Shoreline Blvd. on the east side of 101, just past a traffic
light -- drive past it and turn right into the driveway.

I'm expecting 3 Sun and 3 HP people in the flesh (with SGI people),
and others on the phone.  See you all then.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From jason at cygnus.com  Thu Jun  3 02:37:04 1999
From: jason at cygnus.com (Jason Merrill)
Date: 02 Jun 1999 19:37:04 -0700
Subject: IMPORTANT -- meeting location change
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Wed, 2 Jun 1999 18:18:37 -0700 (PDT)"
References: <199906030118.SAA01985@baalbek.engr.sgi.com>
Message-ID: <u9g14anh67.fsf@yorick.cygnus.com>

I'll plan on showing up in person, too.

Jason



From dehnert at sgi.com  Wed Jun  2 20:12:17 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 02 Jun 1999 21:12:17 +0100
Subject: Summary document
Message-ID: <37559021.B033FBD8@sgi.com>

Attached (HTML and PDF) is the summary document, with meeting info,
participant info, agenda, and issue status.  Think about any other
"preliminary" agenda items we should discuss, and about issues that
aren't on our initial list.  Also, please email me contact information
missing from the table.

HP:  Your new reflector is bouncing messages...
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990602/4b3b00f8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: summary.pdf
Type: application/pdf
Size: 27310 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990602/4b3b00f8/attachment.pdf>

From ddd at cup.hp.com  Thu Jun  3 17:29:20 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 3 Jun 1999 10:29:20 -0700
Subject: Summary document
Message-ID: <199906031729.KAA13121@cllmail.cup.hp.com>

Hi Jim,


I have a few questions regarding the proposed issues list.

Classification:
Could you please detail what the gABI and psABI are?


A5: Empty parameters
What does that mean? That's not a term used in the standard. I guess  
it is either empty parameter list (K&R style), default arguments  
(but I don't see what the problem would be here) or passing empty  
classes (again, I don't see exactly what the problem could be).


I also would like to add a few issues to your list:

A7: Primary base class optimization / Selection of primary base class
A8: Alignment constraints on bases / virtual bases
A9: Sorting of class fields as allowed by [class.mem]/12
A10: Structure field promotion / passing structs as registers

B3: Optimizing for unchanged vptr using a predicate bit
B4: What do vtable entries point to (function entry vs. function  
descriptor)
B5: Where are vtables emitted ("key function")

C2: Order of construction/destruction wrt link command
C3: Order of construction/destruction wrt shared libraries

D5: Interoperability with other languages (Java in particular)
D5-bis: Allowing resumption?
D6: Interaction with signals or asynchronous events

E3: Templates repository
E4: Template separation model (maybe that's what you mean with E2)


And, since our goal is to make customers happy, why not also try to  
agree on a set of common command line options (for historical  
reasons, we could say that you need a different driver for those, or  
a special switch to turn on a "compatible" mode)


Best Regards
Christophe de Dinechin



From dehnert at sgi.com  Fri Jun  4 06:40:10 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 03 Jun 1999 23:40:10 -0700
Subject: C++ ABI Summary -- 3 June meeting notes
Message-ID: <375774CA.5284B431@sgi.com>

Attached is an updated summary page, in HTML and PDF, as usual.
Changes include:

- Updated participant info
- More detail on objectives, based somewhat on our discussion.
- A list of action items from the meeting.
- Additional issues from email and meeting.
- Sketchy notes on procedure from the meeting.

I have a bunch of requests to help us move this effort along:

- Check the action item list and pursue any that belong to you.
  Nothing is listed for IBM, but if you have ABI-related
  documentation that you're willing to share, please do so.

- Check the issue list.  Look at the "class" field and let me know
  if there are missing impacts or mistakes (could be due to either
  cut-and-paste or ignorance).  Make sure that I've included
  any that you brought up (or that you remember anyone else
  bringing up).  Also, I took notes on the issues, but not on who
  raised them -- if I got sources wrong, and you care, let me know.

- There are at least a couple of issues that discussion suggested
  are not real on grounds that they address undefined behaviors
  (B-3 and D-7, at least).  As a non-expert, I will wait to close
  them until someone puts up a clear explanation of the grounds
  for doing so.  Please do...

- Take a look at the prioritization discussion under Objectives
  and comment.  If the classification seems reasonable, I'll take
  a shot at prioritizing the issues based on it.

- Next week we'll dive into the object layout issues.  Matt will
  describe alternatives, and I hope suggest preferences, for the
  first half dozen.  It is my intent to maintain another document
  tracking the discussion on the individual issues, for which I
  need information in writing (HTML best, text fine, FrameMaker,
  Word, PDF probably OK -- if I figure out how to embed them).
  Also, a written description is the best way to get people to
  consider and react to an issue.  So I'd like people to start
  signing up to do at least simple write-ups of the issues.  It
  is very desirable to keep a backlog of well-documented issues
  to discuss, so the sooner the better.  Send me your
  reservations...

- In anticipation of communication about orange info:  If you need
  to send something, but can't produce password-protected PDF, you
  can send it to me or probably Sunil Saxena at Intel and we can
  do it.  To send it to us, PGP encryption works.  My key is:

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.2

mQBtAzTiZwgAAAEDAK4H8RFhhJk/4yLQ6iKSWWueGcgEFGEr/LcnnSUdvyrZkVG7
ln5oAhGbfO+adH8TGRMtVq7OrRBSkNx9JkmKnNrrZ9kxXrqZY3B4hzvMtiZEw1Pv
qtk3LiwJ2diWHlMZXQAFE7QdSmltIERlaG5lcnQgPGRlaG5lcnRAc2dpLmNvbT6J
AHUDBRA09QoqlQ82p+GzYC0BAZYRAwCxFd3mnpxAlxsIMovqxNbHv65HNKzdaKsk
NGuUVriNAw7x/0IVv25pwkOxeAF4bfMWd/qhQIt7ZmKYKiAKf85rLmZoCQ5phCzR
DI6FuDqfuQv1eF57SQpe2hhgq24KJzM=
=iLIv
-----END PGP PUBLIC KEY BLOCK-----

  Sunil's is:

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGP for Personal Privacy 5.0

mQGiBDbghzQRBAD7of7KzVhPF0mXe7bp3N7neoBenXj4eNL4NRZA9ScnnQpaF7Bi
C022jYtmWa+6K4Wbdt0CyK2IkU3wWuCTA7SzLjGzwBoyjIClT4MKS06uveOrNfyS
eeVZKHyBX3pWMbZoxCbSW4i3rt+HI9GzVIyVACXk0p0tUmaiY+Vbn11vwwCg/8VD
sBhvhcgRCDIhB/yDtasTHKsEALLvgAnALsjlYR2PMi15jYmfVfkBTB1zd1sNQJi6
9RVGozdBGApOUl3I9nr54mTq2cTan1NNZoSzwqiCuTABj8Ax5pJ6OxR893i5bOwH
TbprGtUAhXgvZ1i3mXG4FGVYtpU/jRxdLlnWfaQBtILIBeasUCmn64N9QV3rHbUP
dgfGA/0fCToRpR4qZx5My5B40HCkDEn4ZbLni3kFQGL+7liycoCuuNAq1PAxhxQU
udAxFUjfVlBdU5dC0DP9jkiVsS7UGCEtBMRCwmSFLcKlMqRXXAmDjzKTQK7SOScV
88Ky4N34qs3ObeeD0zeeG08sVgCpGOHkKGdECj/mzEl1wfjE57QlU3VuaWwgU2F4
ZW5hIDxTdW5pbC5TYXhlbmFASW50ZWwuQ29tPokASwQQEQIACwUCNuCHNAQLAwIB
AAoJEIuepmkX0KAaVeMAmgL/8gI40xGvjNbR1OodFe2b8zjlAKDcZdBxFhqvY5y3
RCWR3ByPq9Z8mLkCDQQ24Ic0EAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlL
OCDaAadWoxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N
286Z4VeSWc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/
RgBYK+X0iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2O
u1WMuF040zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqV
DNmWn6vQClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAgf/RpoeQh8Q
0qR2E3ZyfdzOpndPfXeFr14JYfqDy4dZjfqVgOYDxk3SsqQbvIYu4Eg+T5a1Ay0r
EtlhN8B7vlqI8tv6Hel3Fop0/l+0G//oOR2sKZICEKhczwPn3YmfK6kPqGswJCQw
mXhaApM7QLI7n+XGCkziTWiO+AFCYgUhE399sMQYe5VoELCqHvojNVGZ+i+5haCL
xjcUKe9RPomcTYcE1je3uSueQXr9GXIjm3xeuZIoMqdes1lq0H90Yrg9Ear7jeom
svGFA/qu9VKDyZ1AeOMQKQ6r+jT0XjcVXrdpccBBxpuxJ+/CJn+2/j+bc/NxklAn
6b2t+qVXOOpQo4kARgQYEQIABgUCNuCHNAAKCRCLnqZpF9CgGvHvAKDVvW/NAIRO
HKc7Hb3wuHIUv4TLugCg0+wkcTiFM1vaRY6fb9uUaaY200Q=
=WNlf
-----END PGP PUBLIC KEY BLOCK-----

  Others that have PGP keys might want to share them.  I think we
  may want to discuss exception handling sooner rather than later
  because of the potential impact on the base ABI, so Priti's
  action item to get the n-way NDA in place is important.

- By the way, since I'm not intimately familiar with the Standard,
  I probably have used ad-hoc terminology where there is common
  terminology available.  Please let me know, and I'll fix it.

- Does anyone know how to shrink the font inside HTML tables
  (for a whole table, or a whole document, without a <font>
  tag in each cell)?  If so, I'd love to hear from you.  (And
  if you don't want me to do it, say so, but I'd still like to
  know how.)

For all the minor corrections and bits of info requested above,
if they don't need general discussion, feel free to just send them
to me for incorportation rather than inundating the reflector.

Thanks to all for your participation!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990603/e96b9ea8/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: summary-990603.pdf
Type: application/pdf
Size: 29239 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990603/e96b9ea8/attachment.pdf>

From dehnert at sgi.com  Fri Jun  4 06:40:10 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 03 Jun 1999 23:40:10 -0700
Subject: C++ ABI Summary -- 3 June meeting notes
Message-ID: <199906040641.XAA06909@baalbek.engr.sgi.com>

Attached is an updated summary page in HTML.  I'll send PDF separately.
Changes include:

- Updated participant info
- More detail on objectives, based somewhat on our discussion.
- A list of action items from the meeting.
- Additional issues from email and meeting.
- Sketchy notes on procedure from the meeting.

I have a bunch of requests to help us move this effort along:

- Check the action item list and pursue any that belong to you.
  Nothing is listed for IBM, but if you have ABI-related
  documentation that you're willing to share, please do so.

- Check the issue list.  Look at the "class" field and let me know
  if there are missing impacts or mistakes (could be due to either
  cut-and-paste or ignorance).  Make sure that I've included
  any that you brought up (or that you remember anyone else
  bringing up).  Also, I took notes on the issues, but not on who
  raised them -- if I got sources wrong, and you care, let me know.

- There are at least a couple of issues that discussion suggested
  are not real on grounds that they address undefined behaviors
  (B-3 and D-7, at least).  As a non-expert, I will wait to close
  them until someone puts up a clear explanation of the grounds
  for doing so.  Please do...

- Take a look at the prioritization discussion under Objectives
  and comment.  If the classification seems reasonable, I'll take
  a shot at prioritizing the issues based on it.

- Next week we'll dive into the object layout issues.  Matt will
  describe alternatives, and I hope suggest preferences, for the
  first half dozen.  It is my intent to maintain another document
  tracking the discussion on the individual issues, for which I
  need information in writing (HTML best, text fine, FrameMaker,
  Word, PDF probably OK -- if I figure out how to embed them).
  Also, a written description is the best way to get people to
  consider and react to an issue.  So I'd like people to start
  signing up to do at least simple write-ups of the issues.  It
  is very desirable to keep a backlog of well-documented issues
  to discuss, so the sooner the better.  Send me your
  reservations...

- In anticipation of communication about orange info:  If you need
  to send something, but can't produce password-protected PDF, you
  can send it to me or probably Sunil Saxena at Intel and we can
  do it.  To send it to us, PGP encryption works.  My key is:

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: 2.6.2

mQBtAzTiZwgAAAEDAK4H8RFhhJk/4yLQ6iKSWWueGcgEFGEr/LcnnSUdvyrZkVG7
ln5oAhGbfO+adH8TGRMtVq7OrRBSkNx9JkmKnNrrZ9kxXrqZY3B4hzvMtiZEw1Pv
qtk3LiwJ2diWHlMZXQAFE7QdSmltIERlaG5lcnQgPGRlaG5lcnRAc2dpLmNvbT6J
AHUDBRA09QoqlQ82p+GzYC0BAZYRAwCxFd3mnpxAlxsIMovqxNbHv65HNKzdaKsk
NGuUVriNAw7x/0IVv25pwkOxeAF4bfMWd/qhQIt7ZmKYKiAKf85rLmZoCQ5phCzR
DI6FuDqfuQv1eF57SQpe2hhgq24KJzM=
=iLIv
-----END PGP PUBLIC KEY BLOCK-----

  Sunil's is:

-----BEGIN PGP PUBLIC KEY BLOCK-----
Version: PGP for Personal Privacy 5.0

mQGiBDbghzQRBAD7of7KzVhPF0mXe7bp3N7neoBenXj4eNL4NRZA9ScnnQpaF7Bi
C022jYtmWa+6K4Wbdt0CyK2IkU3wWuCTA7SzLjGzwBoyjIClT4MKS06uveOrNfyS
eeVZKHyBX3pWMbZoxCbSW4i3rt+HI9GzVIyVACXk0p0tUmaiY+Vbn11vwwCg/8VD
sBhvhcgRCDIhB/yDtasTHKsEALLvgAnALsjlYR2PMi15jYmfVfkBTB1zd1sNQJi6
9RVGozdBGApOUl3I9nr54mTq2cTan1NNZoSzwqiCuTABj8Ax5pJ6OxR893i5bOwH
TbprGtUAhXgvZ1i3mXG4FGVYtpU/jRxdLlnWfaQBtILIBeasUCmn64N9QV3rHbUP
dgfGA/0fCToRpR4qZx5My5B40HCkDEn4ZbLni3kFQGL+7liycoCuuNAq1PAxhxQU
udAxFUjfVlBdU5dC0DP9jkiVsS7UGCEtBMRCwmSFLcKlMqRXXAmDjzKTQK7SOScV
88Ky4N34qs3ObeeD0zeeG08sVgCpGOHkKGdECj/mzEl1wfjE57QlU3VuaWwgU2F4
ZW5hIDxTdW5pbC5TYXhlbmFASW50ZWwuQ29tPokASwQQEQIACwUCNuCHNAQLAwIB
AAoJEIuepmkX0KAaVeMAmgL/8gI40xGvjNbR1OodFe2b8zjlAKDcZdBxFhqvY5y3
RCWR3ByPq9Z8mLkCDQQ24Ic0EAgA9kJXtwh/CBdyorrWqULzBej5UxE5T7bxbrlL
OCDaAadWoxTpj0BV89AHxstDqZSt90xkhkn4DIO9ZekX1KHTUPj1WV/cdlJPPT2N
286Z4VeSWc39uK50T8X8dryDxUcwYc58yWb/Ffm7/ZFexwGq01uejaClcjrUGvC/
RgBYK+X0iP1YTknbzSC0neSRBzZrM2w4DUUdD3yIsxx8Wy2O9vPJI8BD8KVbGI2O
u1WMuF040zT9fBdXQ6MdGGzeMyEstSr/POGxKUAYEY18hKcKctaGxAMZyAcpesqV
DNmWn6vQClCbAkbTCD1mpF1Bn5x8vYlLIhkmuquiXsNV6TILOwACAgf/RpoeQh8Q
0qR2E3ZyfdzOpndPfXeFr14JYfqDy4dZjfqVgOYDxk3SsqQbvIYu4Eg+T5a1Ay0r
EtlhN8B7vlqI8tv6Hel3Fop0/l+0G//oOR2sKZICEKhczwPn3YmfK6kPqGswJCQw
mXhaApM7QLI7n+XGCkziTWiO+AFCYgUhE399sMQYe5VoELCqHvojNVGZ+i+5haCL
xjcUKe9RPomcTYcE1je3uSueQXr9GXIjm3xeuZIoMqdes1lq0H90Yrg9Ear7jeom
svGFA/qu9VKDyZ1AeOMQKQ6r+jT0XjcVXrdpccBBxpuxJ+/CJn+2/j+bc/NxklAn
6b2t+qVXOOpQo4kARgQYEQIABgUCNuCHNAAKCRCLnqZpF9CgGvHvAKDVvW/NAIRO
HKc7Hb3wuHIUv4TLugCg0+wkcTiFM1vaRY6fb9uUaaY200Q=
=WNlf
-----END PGP PUBLIC KEY BLOCK-----

  Others that have PGP keys might want to share them.  I think we
  may want to discuss exception handling sooner rather than later
  because of the potential impact on the base ABI, so Priti's
  action item to get the n-way NDA in place is important.

- By the way, since I'm not intimately familiar with the Standard,
  I probably have used ad-hoc terminology where there is common
  terminology available.  Please let me know, and I'll fix it.

- Does anyone know how to shrink the font inside HTML tables
  (for a whole table, or a whole document, without a <font>
  tag in each cell)?  If so, I'd love to hear from you.  (And
  if you don't want me to do it, say so, but I'd still like to
  know how.)

For all the minor corrections and bits of info requested above,
if they don't need general discussion, feel free to just send them
to me for incorportation rather than inundating the reflector.

Thanks to all for your participation!
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990603/d7ab8e17/attachment.html>

From dehnert at sgi.com  Fri Jun  4 06:45:58 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 3 Jun 1999 23:45:58 -0700 (PDT)
Subject: C++ ABI Summary -- 3 June meeting notes (PDF)
Message-ID: <199906040645.XAA06846@baalbek.engr.sgi.com>

Here's the PDF version.

If you got two sets of this stuff, I apologize.  It looked like our
mailer bounced the first one for being too long.
-------------- next part --------------
A non-text attachment was scrubbed...
Name: summary-990603.pdf
Type: application/pdf
Size: 29239 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990603/4279e47f/attachment.pdf>

From jls at sco.com  Mon Jun  7 19:16:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Mon, 7 Jun 1999 15:16 EDT
Subject: thread-safe local static variable initialization
Message-ID: <199906071922.PAA24226@kauai.newjersey.sco.com>

Another issue to add to the C++ ABI "Miscellaneous" list is local static 
variables with dynamic initialization expressions, when multiple threads 
are possible.  The first thread through has to block other threads from
accessing the variable until initialization is complete.  For some 
compilers at least, the generated code tests flags and calls a runtime 
support routine that waits on the flags changing state.  Thus, this can 
be an ABI issue.

(I mentioned this during last week's meeting, and Mike Ball said
something to the effect that this was already fully described by
the language.  But given that the language says nothing about
multithreading to begin with, I'm not sure what he meant.)

Jonathan Schilling		SCO, Inc.		jls at sco.com



From michael.ball at eng.sun.com  Mon Jun  7 21:36:05 1999
From: michael.ball at eng.sun.com (Mike Ball)
Date: Mon, 07 Jun 1999 14:36:05 -0700 (PDT)
Subject: thread-safe local static variable initialization
Message-ID: <0FCZ000JS7XLHZ@ha-sims.eng.sun.com>


>Another issue to add to the C++ ABI "Miscellaneous" list is local static 
>variables with dynamic initialization expressions, when multiple threads 
>are possible.  The first thread through has to block other threads from
>accessing the variable until initialization is complete.  For some 
>compilers at least, the generated code tests flags and calls a runtime 
>support routine that waits on the flags changing state.  Thus, this can 
>be an ABI issue.
>
>(I mentioned this during last week's meeting, and Mike Ball said
>something to the effect that this was already fully described by
>the language.  But given that the language says nothing about
>multithreading to begin with, I'm not sure what he meant.)

As far as I can tell, the language says that the automatic blocking
issue isn't a valid approach.  It says what has to happen, and
it isn't that.

-Mike-




From dehnert at baalbek.engr.sgi.com  Mon Jun  7 22:52:36 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Jun 1999 15:52:36 -0700 (PDT)
Subject: thread-safe local static variable initialization
Message-ID: <199906072252.PAA13406@baalbek.engr.sgi.com>

> As far as I can tell, the language says that the automatic blocking
> issue isn't a valid approach.  It says what has to happen, and
> it isn't that.

Are you referring to the statement in 6.7 that "If control re-enters
the declaration (recursively) while the object is being initialized,
the behavior is undefined?"  Or is there more somewhere?  This would
seem to imply that automatic blocking isn't required, but not that it's
not valid.

(This is curiosity, not a position.)

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From jls at sco.com  Mon Jun  7 23:54:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Mon, 7 Jun 1999 19:54 EDT
Subject: thread-safe local static variable initialization
Message-ID: <199906080022.UAA25267@kauai.newjersey.sco.com>

> From: Jim Dehnert <dehnert at baalbek.engr.sgi.com>
> 
> > [Mike Ball said]
> > As far as I can tell, the language says that the automatic blocking
> > issue isn't a valid approach.  It says what has to happen, and
> > it isn't that.
> 
> Are you referring to the statement in 6.7 that "If control re-enters
> the declaration (recursively) while the object is being initialized,
> the behavior is undefined?"  

No, 6.7 /4 is referring to a single-threaded program where the static
local variable initialization expression calls the function containing
the static local.

The standard is mute on multiple threads of control in general, so 
there is no requirement in the language to support what I'm talking
about. But as a practical matter compilers have to do it (Watcom gave
a paper on their approach during the standardization process, if I
remember).  This example using UI/SVR4 threads will usually show whether 
a compiler does it or not: 

thr5.C:
// static local initialization and threads

#include <stdlib.h>
#define EXIT(a) exit(a)
#define THR_EXIT() thr_exit(0)

#include <thread.h>

int init_count = 0;
int start_count = 0;

int init()
{
	::thr_yield();
	return ++init_count;
}

void* start(void* s)
{
	start_count++;
	static int i = init();
	if (i != 1) EXIT(5);
	THR_EXIT();
	return 0;
}
		
int main()
{
	thread_t t1, t2;
	if (::thr_create(0, 0, start, 0, 0L, &t1) != 0) EXIT(1);
	if (::thr_create(0, 0, start, 0, 0L, &t2) != 0) EXIT(2);
	if (::thr_join(t1, 0, 0) != 0) EXIT(3);
	if (::thr_join(t2, 0, 0) != 0) EXIT(4);
	if (start_count != 2)
		EXIT(6);
	if (init_count != 1)
		EXIT(7);
	THR_EXIT();
}

When compiled with CC -Kthread thr5.C on UnixWare 7, for instance,
it passes by returning 0.  When compiled with CC -mt thr5.C on
Solaris/x86 C++ 4.2 (sorry don't have the latest version!), it
fails by returning 5.

If there's a way of supporting this without affecting the ABI,
I'll be happy to be enlightened :)

Jonathan Schilling		SCO, Inc.		jls at sco.com



From michael.ball at eng.sun.com  Tue Jun  8 02:19:42 1999
From: michael.ball at eng.sun.com (Michael Ball)
Date: Mon, 07 Jun 1999 19:19:42 -0700 (PDT)
Subject: thread-safe local static variable initialization
In-Reply-To: Your message with ID <199906072248.PAA25511@cllmail.cup.hp.com>
Message-ID: <Roam.SIMC.2.0.6.928808382.25807.ball@smmpk17.eng>

> Mike Ball wrote:
> > >(I mentioned this during last week's meeting, and Mike Ball said
> > >something to the effect that this was already fully described by
> > >the language.  But given that the language says nothing about
> > >multithreading to begin with, I'm not sure what he meant.)
> >
> > As far as I can tell, the language says that the automatic blocking 
> > issue isn't a valid approach.  It says what has to happen, and
> > it isn't that.
> 
> The language says it's undefined if control re-enters the  
> declaration recursively. It does not say much about threads. I think  
> you can read the standard as saying it's unnecessary, but not  
> incorrect.

If you look at the entire statement you find that it reads

"Otherwise such an object is initialized the first time control passes through its declaration; such an object is considered initialized upon the completion of its
initialization. If the initialization exits by throwing an exception, the 
initialization is not complete, so it will be tried again the next time control 
enters the declaration. If control re-enters the declaration (recursively)
while the object is being initialized, the behavior is undefined."

The word "recursively" is normative, so eliminates that sentence from consideration.

One can, of course, make any extension to the language, but in this case I
think the extension invalidates some otherwise valid code.

The sentence I'm referring to is that the object is considered initialized upon the
completion of its initialization.  This is explicit, and the reason for it is
covered in the following sentence, which discusses an initialization that
terminates with an exception.   A person catching such an exception has the
right to try again without danger that the static variable will be initialized
in the meantime.

I don't see anything at all to justify semantics that say "After initialization is
started, Any other threads of control are blocked until that thread completes 
the initialization, unless, of course, it executes by an exception, in which case 
the other thread can do the initialization before the exception handler gets a 
chance to try again, except...."  Take an attempt to define the semantics as
far as you like.

The problem is that there is no way for the compiler writer to know what the
programmer really wanted to do.  I can (and will at some other date, if necessary)
come up with scenarios justifying a variety of mutual exclusion policies, including
none.

The solution is to let the programmer write the mutual exclusion, the same as
we do for every other potential race condition.

-Mike Ball-

It's a real mess, and, I claim, an unwise one to put in as an extension




From dehnert at baalbek.engr.sgi.com  Tue Jun  8 06:47:25 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Jun 1999 23:47:25 -0700 (PDT)
Subject: thread-safe local static variable initialization
Message-ID: <199906080647.XAA15197@baalbek.engr.sgi.com>

Thanks for the clarification.  I understand now, and have added the
issue as G-4.  However, I share Mike's scepticism about tackling the
problem, for reasons I'll explain below.

> From: jls at sco.com (Jonathan Schilling)
> Date: Mon, 7 Jun 1999 19:54 EDT
> 
> The standard is mute on multiple threads of control in general, so 
> there is no requirement in the language to support what I'm talking
> about. But as a practical matter compilers have to do it (Watcom gave
> a paper on their approach during the standardization process, if I
> remember).

It's not obvious to me that compilers have to do it.  As Mike points
out, it is permissible to leave the responsibility to the users.  And,
I'm inclined to believe that's the right solution.  What it would take
to change my mind would be a solution which addressed the following
concerns:

First, it should not cause noticible cost in non-multithreaded
programs.

Second, it should not cause unnecessary cost in multithreaded programs.
This requires more elaboration.  Even in multithreaded programs, I
would guess that most relevant initializations would not really be
exposed to multiple simultaneous executions, and a careful user could
avoid locking.  Further, in many of the remaining cases, I would expect
a careful user to be able to use a single lock for a collection of
object initializations, giving the per-object locking I would expect
from an automatic approach higher overhead than necessary.

Of course, the argument might be made that doing this automatically
simplifies the life of the multithreading programmer, but I suspect
that's less useful than it appears.  This particular case (explicit
dynamic initialization of local static variables) is a relatively minor
example of a whole class of program behaviors subject to the same
issues, where most of them are strictly user code cases that the
compiler has no chance of identifying, let alone solving.  So the user
is going to have to be aware of these issues and their solutions
anyway, and leaving this example to him doesn't seem onerous.


However, it's not very effective to discuss the problem in the
abstract.  If someone has a specific proposal for solving the problem,
submit it, and we can discuss concrete characteristics instead of
speculations.


-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From sassan at cup.hp.com  Tue Jun  8 15:54:13 1999
From: sassan at cup.hp.com (Sassan Hazeghi)
Date: Tue, 8 Jun 1999 08:54:13 -0700 (PDT)
Subject: thread-safe local static variable initialization
In-Reply-To: <199906080647.XAA15197@baalbek.engr.sgi.com>
References: <199906080647.XAA15197@baalbek.engr.sgi.com>
Message-ID: <199906081554.IAA02726@hpcll539.cup.hp.com>

Jim: One issue that library providers face, though, is whether they
need to provide a thread-safe in addition to the higher performance
and possibly thread-unsafe version of their library.  I.e. it may
still be helpful to provide a consistent model for library vendors,
possibly at some initialization-time performance overhead, if it
resolves the dilemma (without taxing the application performance
beyond initialization.)

Sassan.

Jim Dehnert writes:
 > Thanks for the clarification.  I understand now, and have added the
 > issue as G-4.  However, I share Mike's scepticism about tackling the
 > problem, for reasons I'll explain below.
 > 
 > > From: jls at sco.com (Jonathan Schilling)
 > > Date: Mon, 7 Jun 1999 19:54 EDT
 > > 
 > > The standard is mute on multiple threads of control in general, so 
 > > there is no requirement in the language to support what I'm talking
 > > about. But as a practical matter compilers have to do it (Watcom gave
 > > a paper on their approach during the standardization process, if I
 > > remember).
 > 
 > It's not obvious to me that compilers have to do it.  As Mike points
 > out, it is permissible to leave the responsibility to the users.  And,
 > I'm inclined to believe that's the right solution.  What it would take
 > to change my mind would be a solution which addressed the following
 > concerns:
 > 
 > First, it should not cause noticible cost in non-multithreaded
 > programs.
 > 
 > Second, it should not cause unnecessary cost in multithreaded programs.
 > This requires more elaboration.  Even in multithreaded programs, I
 > would guess that most relevant initializations would not really be
 > exposed to multiple simultaneous executions, and a careful user could
 > avoid locking.  Further, in many of the remaining cases, I would expect
 > a careful user to be able to use a single lock for a collection of
 > object initializations, giving the per-object locking I would expect
 > from an automatic approach higher overhead than necessary.
 > 
 > Of course, the argument might be made that doing this automatically
 > simplifies the life of the multithreading programmer, but I suspect
 > that's less useful than it appears.  This particular case (explicit
 > dynamic initialization of local static variables) is a relatively minor
 > example of a whole class of program behaviors subject to the same
 > issues, where most of them are strictly user code cases that the
 > compiler has no chance of identifying, let alone solving.  So the user
 > is going to have to be aware of these issues and their solutions
 > anyway, and leaving this example to him doesn't seem onerous.
 > 
 > 
 > However, it's not very effective to discuss the problem in the
 > abstract.  If someone has a specific proposal for solving the problem,
 > submit it, and we can discuss concrete characteristics instead of
 > speculations.
 > 
 > 
 > -	    Jim Dehnert		dehnert at sgi.com
 > 				(650)933-4272



From ddd at cup.hp.com  Tue Jun  8 17:24:03 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 8 Jun 1999 10:24:03 -0700
Subject: thread-safe local static variable initialization
In-Reply-To: Your message with ID <199906072248.PAA25511@cllmail.cup.hp.com>
Message-ID: <199906081724.KAA04507@cllmail.cup.hp.com>

Mike,.


>From your explanation, I understand that you consider protecting  
static initializations unnecessary. Initially, I thought you could  
read the standard that way. Now, I believe you can only if you accept  
that threaded and non-threaded code behaves completely differently.  
Consider:

	void f() {
		static int i = 0;
		static int j = i++;
		cout << i << j;
	}

Since the int ++ operator cannot throw an exception, the standard  
mandates that the output be 1 and 0 for all calls of f() in any  
non-threaded code.

You cannot ensure that in a threaded case without locking the  
initialization of j (the initialization of i can occur outside of f).  
That's because "[the] an object is considered initialized upon the  
completion of its initialization". While i++ is executing, another  
thread can therefore enter the static initialization. In the end, for  
a threaded program using f(), i and j can be anything (they could  
even be non consistent, that is 27 and 13).

Of course, you can say that having threads in the first place brings  
you in Undefined Land, but I'd prefer the above code to be  
consistent between threaded and non-threaded cases. It seems hard to  
require users to lock the above code.


The semantics currently implemented in the HP aC++ compiler is as follows:
- No two thread can enter a static initialization at the same time
- Threads are blocked until immediately after the static  
initialization either succeeds or fails with an exception.

There are details of our implementation that I disagree with, but in  
general, the semantics seem clear and sane, not as convoluted as you  
seemed to imply. In particular, it correctly covers the case where  
the static initialization fails with an exception. Any thread at that  
point can attempt the initialization.

> One can, of course, make any extension to the language, but in  
this case I
> think the extension invalidates some otherwise valid code.

If that's the case, this would make it a serious problem worth  
bringing to the committee. I could not find a case, though, that does  
not involve recursion (undefined) or setjmp/longjmp (I'm not sure it  
is undefined unless any automatic object requires destruction  
[lib.support.runtime]/4... maybe we could have a problem here)


Thank you in advance for your comments.
Christophe



From ddd at cup.hp.com  Tue Jun  8 18:26:11 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 8 Jun 1999 11:26:11 -0700
Subject: thread-safe local static variable initialization
Message-ID: <199906081826.LAA07818@cllmail.cup.hp.com>

Jim,


> It's not obvious to me that compilers have to do it.  As Mike points 
> out, it is permissible to leave the responsibility to the users.  And, 
> I'm inclined to believe that's the right solution.  What it would take 
> to change my mind would be a solution which addressed the following 
> concerns:

I sent another message explaining why I think compilers _should_ do  
it, even if they don't _have_ to.


> First, it should not cause noticible cost in non-multithreaded
> programs.

Our implementatino has some cost at initialization time (the cost of  
locking). However, the process also sets a static boolean flag, that  
is then tested. Also note that there is an initialization cost  
anyway because you need to register the object for destruction.

After that, the cost is that of checking a flag, whether in threaded  
or non-threaded mode.


> Second, it should not cause unnecessary cost in multithreaded programs. 
> This requires more elaboration.  Even in multithreaded programs, I 
> would guess that most relevant initializations would not really be 
> exposed to multiple simultaneous executions, and a careful user could 
> avoid locking.  Further, in many of the remaining cases, I would expect 
> a careful user to be able to use a single lock for a collection of 
> object initializations, giving the per-object locking I would expect 
> from an automatic approach higher overhead than necessary.

There is a cost in multithreaded programs, because we some threads  
may be blocked while attempting a static initialization that is  
completing in another thread. The cost after initialization is  
limited to a single flag check, though. And I think this cost is  
minor.


> However, it's not very effective to discuss the problem in the
> abstract.  If someone has a specific proposal for solving the problem, 
> submit it, and we can discuss concrete characteristics instead of
> speculations.

Maybe we can present what HP aC++ does. Any other compiler has a  
similar mechanism?


Regards
Christophe



From jls at sco.com  Tue Jun  8 18:59:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Tue, 8 Jun 1999 14:59 EDT
Subject: thread-safe local static variable dynamic initialization
Message-ID: <199906081909.PAA13751@kauai.newjersey.sco.com>

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> > However, it's not very effective to discuss the problem in the
> > abstract.  If someone has a specific proposal for solving the problem, 
> > submit it, and we can discuss concrete characteristics instead of
> > speculations.
> 
> Maybe we can present what HP aC++ does. Any other compiler has a  
> similar mechanism?

Here's what the SCO UnixWare 7 C++ compiler does for IA-32, from a (slightly
sanitized) design document.  It meets Jim's goal of having no overhead
for non-threaded programs and minimal overhead for threaded programs unless
actual contention occurs (infrequent), and meets Mike's goal of handling
exceptions in the initialization correctly (although it doesn't guarantee
that the thread getting the exception is the one that gets next crack
at initializing the static).  It's also worth noting that dynamic
initialization of local variables (static or otherwise) is very 
common in C++, since that's what most object constructions involve,
so I don't think this case is as rare as Jim does.

Jonathan Schilling		SCO, Inc.		jls at sco.com


   [...] This is in local static variables with dynamic
   initialization, where the compiler generates out a static one-time
   flag to guard the initialization. Two threads could read the flag as
   zero before either of them set it, resulting in multiple
   initializations.
   
   [...] Accordingly, when compilation is done with -Kthread on, a code
   sequence will be generated to lock this initialization.  
   [...] the basic idea is to have one guard saying
   whether the initialization is done (so that multiple initializations
   do not occur) and have another guard saying whether initialization is
   in progress (so that a second thread doesn't access what it thinks is
   an initialized value before the first thread has finished the
   initialization).  [...]
   
   When compiled with -Kthread, the generated code for a dynamic
   initialization of a local static variable will look like the
   following. guard is a local static boolean, initialized to zero,
   generated by the [middle pass of the compiler]. 
   Two bits of it are used: the low-order 'done bit'
   and the next-low-order 'busy bit'.
   
.again:
        movl    $guard,%eax
        testl   $1,(%eax)       // test the done bit
        jnz     .done           // if set, variable is initialized, done
        lock; btsl  $1,(%eax)   // test and set the busy bit
        jc      .busy
        < init code >           // not busy, do the initialization
        movl    $guard,%eax
        movl    $3,(%eax)       // set the done bit
        jmp     .done
.busy:
        pushl   %eax            // call RTS routine to wait, passing address
        call1   __static_init_wait      // of guard to monitor
        testl   %eax,%eax       // 1 means exception occurred in init code,
        popl    %ecx
        jnz     .again                  // start the whole thing over
.done                                   // 0 means wait finished

   The above code will work for position-independent code as well.
   
   The complication due to exceptions is: what happens if the
   initialization code throws an exception? The [compiler] EH tables will have
   set up a special region and flag in their region table to detect this
   situation, along with a pointer to the guard variable. Because the
   initialization never completed, when the RTS sees that it is cleaning
   up from such a region, it will reset the guard variable back to both
   zeroes. This will free up a busy-waiting thread, if any, or will reset
   everything for the next thread that calls the function.
   
   The idea of the __static_init_wait() RTS routine is to monitor the
   value of guard bits passed in, by looping on this decision table:
   
        done    busy
        0       0       return 1 in %eax        (EH wipe-out)
        1       1       return 0 in %eax        (no longer busy)
        0       1       continue to wait        (still busy)
        1       0       internal error, shouldn't happen

   As for how the wait is done [... not relevant for ABI, although currently
   we're using thr_yield(), which may or may not be right for this context].




From dehnert at baalbek.engr.sgi.com  Tue Jun  8 19:41:07 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 8 Jun 1999 12:41:07 -0700 (PDT)
Subject: thread-safe local static variable initialization
References: <199906080647.XAA15197@baalbek.engr.sgi.com>
Message-ID: <199906081941.MAA16346@baalbek.engr.sgi.com>

> From sassan at cup.hp.com  Tue Jun  8 08:54:33 1999
> 
> Jim: One issue that library providers face, though, is whether they
> need to provide a thread-safe in addition to the higher performance
> and possibly thread-unsafe version of their library.

Of course.  In that regard, of course, they are just like any user
trying to write thread-safe code.

> I.e. it may
> still be helpful to provide a consistent model for library vendors,
> possibly at some initialization-time performance overhead, if it
> resolves the dilemma (without taxing the application performance
> beyond initialization.)

It might.  One of my points was that this is a big if.  There's much
more involved in the problem than dynamic initialization of local
statics.  But rather than argue about the concept, let's wait for a
proposal and discuss that.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From jls at sco.com  Tue Jun  8 20:56:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Tue, 8 Jun 1999 16:56 EDT
Subject: C++ standard library ABI
Message-ID: <199906082057.QAA00145@kauai.newjersey.sco.com>

During the meeting last week, there was some discussion about 
how hard it might be to specify a C++ standard library ABI,
and some opinions ventured that such a goal might be out of reach.

I presume the problem here is that even if all object layouts etc.
are specified by an ABI, differences in source-level implementation
of the standard library from one system to another will result in
incompatible class representations between library caller and
library implementation (i.e., the RRBC problem in another guise).

But what then is the ABI supposed to accomplish?  Is it that I can take 
my application executables and dynamic libraries from one system to
another (for any given source level of the application), and it
will work ... until my application calls the standard library?
That's not very realistic.

If I can't even move the executable representing this (dynamically-linked) 
program:

#include <string>
#include <iostream.h>

using namespace std;

int main() {
	string s = "hello std lib";
	cout << s << endl;
}

from one C++-ABI-conforming system to another, what will we have
accomplished?

Hopefully I have misunderstood something along the way....

Jonathan Schilling		SCO, Inc.		jls at sco.com



From jls at sco.com  Wed Jun  9 14:39:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Wed, 9 Jun 1999 10:39 EDT
Subject: extern inline
Message-ID: <199906091443.KAA03512@kauai.newjersey.sco.com>

I believe extern inline should be added to the issues list.  Typical 
implementations rely on ABI-level actions such as using COMDAT sections
(which aren't in the IA-64 base ABI) or weak definitions or reusing
the template instantiation mechanism.  How to handle local statics
within extern inlines is also an ABI-level detail.

(I think this is different from the G-3 "Inlined routine linkage"
item already on the list.)

Jonathan Schilling		SCO, Inc.		jls at sco.com




From dehnert at sgi.com  Wed Jun  9 21:00:15 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 09 Jun 1999 14:00:15 -0700
Subject: C++ ABI Summary
Message-ID: <375ED5DF.65F128E5@sgi.com>

Attached is an updated issue summary, with phone information for tomorrow.
The meeting is in the same place, and will run from 10-12 instead of 11-1.

The agenda is to begin discussion of object layout issues, starting with
a presentation by Matt Austern.  Please send any documentation to the group
as early as possible...
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990609/3d7034a1/attachment.html>

From cary at cup.hp.com  Thu Jun 10 00:58:32 1999
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 9 Jun 1999 17:58:32 -0700
Subject: [C++ ABI] HP's object layout
Message-ID: <199906100056.RAA19024@cllmail.cup.hp.com>

Attached are two HTML files that describe HP's object and vtable layout. 
We intend to modify this somewhat for IA-64, but this is our starting 
point. (The third attachment, vtables1.txt, is referenced by 
vtables.html.)

Cary Coutant
408-447-5759
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990609/bb8e649b/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990609/bb8e649b/attachment-0001.html>
-------------- next part --------------
An embedded and charset-unspecified text was scrubbed...
Name: vtables1.txt
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990609/bb8e649b/attachment.txt>

From dehnert at baalbek.engr.sgi.com  Thu Jun 10 01:06:50 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 9 Jun 1999 18:06:50 -0700 (PDT)
Subject: IMPORTANT -- phone change
Message-ID: <199906100106.SAA02736@baalbek.engr.sgi.com>

Due to a time mix-up, the number in the summary I sent earlier has
changed.  The phone contact info for tomorrow is:

> Sorry!  Then we will have a new bridge for tomorrow, 6/10
> from 10-12:30P:
> 
> BR (916) 356-9200
> RS       7-35593
> PC       295-6596

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From jls at sco.com  Thu Jun 10 09:52:00 1999
From: jls at sco.com (Jonathan Schilling)
Date: Thu, 10 Jun 1999 05:52 EDT
Subject: C++ standard library ABI
Message-ID: <199906101004.GAA05895@kauai.newjersey.sco.com>

Christophe suggested that the way around the C++ standard library ABI
problem is to move the C++ runtime support library (which includes the
standard library, as well as compiled code support routines) along with
the binaries for the application, when moving from one system to another.

This would mean that multiple C++ RTS libraries might be present on a
system at once (I guess you could refer to them as one "native" and 
zero or more "foreign" libraries).

I think that if we have the C++ RTS travel with the C++ generated code, 
this might allow us to duck a lot of complicated areas - for instance there's 
no need to specify in the ABI exactly what EH tables look like.  The same 
for some other things like array new/delete, ctor/dtor registration, etc.  
Interfaces between compiled code and the RTS in general don't have to be 
specified, but rather just compiled code -> compiled code interfaces 
(the basic object model stuff) and some RTS -> RTS interfaces (e.g. memory
management from multiple systems has to coexist together) and some
RTS -> OS interfaces (e.g. iostreams has to work on top of libc, rather
than depending on anything within it).

I think you could see this as a quasi-OO setup:  generated code has "objects"
which carry with them "methods" in the RTS.  Some objects would be fully
specified in the ABI, while the rest can be overridden in any particular 
implementation.

Jonathan Schilling		SCO, Inc.		jls at sco.com



From michael.ball at eng.sun.com  Thu Jun 10 15:29:19 1999
From: michael.ball at eng.sun.com (Mike Ball)
Date: Thu, 10 Jun 1999 08:29:19 -0700 (PDT)
Subject: C++ ABI Summary
Message-ID: <0FD400CMZB8YFQ@ha-sims.eng.sun.com>


>Subject: C++ ABI Summary
>To: cxx-abi at corp.sgi.com
>MIME-version: 1.0
>X-Accept-Language: de,fr,no
>
>Attached is an updated issue summary, with phone information for tomorrow.
>The meeting is in the same place, and will run from 10-12 instead of 11-1.
>
>The agenda is to begin discussion of object layout issues, starting with
>a presentation by Matt Austern.  Please send any documentation to the group
>as early as possible...

Unfortunately, the document I was planning to send is "in transition"
and won't be presentable until at least next week.  The person in charge
has promised me it will be read then.

-Mike Ball-




From ddd at cup.hp.com  Thu Jun 10 16:43:30 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 10 Jun 1999 09:43:30 -0700
Subject: C++ standard library ABI
Message-ID: <199906101643.JAA20056@cllmail.cup.hp.com>

My suggestion was actually to separate the 'ABI' from the 'API'.  
That is: try to agree on the support library (all the functions  
beginning with __, typically), but not necessarily on the standard  
library, iostream, and so on. So you could reuse the support library,  
but you would need, say, the "RogueWave" library if you want to run  
code that included it, and the "Sun" library if you want to run code  
that included it.

For various reasons, EH format needs not be identical between  
compilers, but a few other things in EH processing need to if we want  
to pass exceptions around. We can discuss that also.

Regards
Christophe.

> Christophe suggested that the way around the C++ standard library ABI 
> problem is to move the C++ runtime support library (which includes the 
> standard library, as well as compiled code support routines) along with 
> the binaries for the application, when moving from one system to  
another.
>
> This would mean that multiple C++ RTS libraries might be present on a 
> system at once (I guess you could refer to them as one "native" and  
> zero or more "foreign" libraries).
>
> I think that if we have the C++ RTS travel with the C++ generated  
code,
> this might allow us to duck a lot of complicated areas - for  
instance there's
> no need to specify in the ABI exactly what EH tables look like.   
The same
> for some other things like array new/delete, ctor/dtor  
registration, etc.
> Interfaces between compiled code and the RTS in general don't have  
to be
> specified, but rather just compiled code -> compiled code interfaces  
> (the basic object model stuff) and some RTS -> RTS interfaces  
(e.g. memory
> management from multiple systems has to coexist together) and some 
> RTS -> OS interfaces (e.g. iostreams has to work on top of libc, rather 
> than depending on anything within it).
>
> I think you could see this as a quasi-OO setup:  generated code  
has "objects"
> which carry with them "methods" in the RTS.  Some objects would be  
fully
> specified in the ABI, while the rest can be overridden in any  
particular
> implementation.
>
> Jonathan Schilling		SCO, Inc.		jls at sco.com
>
>



From boehm at hoh.engr.sgi.com  Thu Jun 10 22:54:23 1999
From: boehm at hoh.engr.sgi.com (Hans Boehm)
Date: Thu, 10 Jun 1999 15:54:23 -0700
Subject: thread-safe local static variable initialization
In-Reply-To: Mike Ball <michael.ball@eng.sun.com>
        "Re: C++ ABI Summary" (Jun 10,  8:29am)
References: <0FD400CMZB8YFQ@ha-sims.eng.sun.com>
Message-ID: <9906101554.ZM3948@hoh.engr.sgi.com>

I'd like to make some claims about function scope static constructor calls in
multithreaded environments.  I personally can't recall ever having used
such a construct, which somewhat substantiates my claims, but also implies
some lack of certainty.  I'd be interested in hearing any arguments to the
contrary.

I believe that these arguments imply that this problem is not important
enough to warrant added ABI complexity or overhead for sequential code.

Consider the following skeletal example:

f(int x) { static foo a(...); ... }

1) If the constructor argument doesn't depend on the function parameter,
and the code behaves reasonably, it should be possible to rewrite this as

static foo a(...);

f(int x) { ... }

2) If I read the standard correctly (and that's a big disclaimer), the compiler
is entitled to perform the above transformation under conditions that are
usually true, but hard for the compiler to deduce.  Thus code that relies on
the initialization occurring during the execution of f is usually broken.

3) Thus the foo constructor cannot rely on its caller holding any locks.
It must explicitly acquire any locks it needs.

4) It is far preferable to write the transformed form with a file scope
static variable to start with.  The initial form risks deadlock, since
f may be called with locks held which the constructor can't assume are held.
If it needs one of those locks it will need to reacquire it.  With default
mutex semantics that results in deadlock with itself.
(If locks may be reentered, it may fail in a more subtle manner since the
foo constructor may acquire a monitor lock whose monitor invariant doesn't
hold.)

5) File scope static constructor calls aren't a problem and require no locking,
since they are executed in a single thread before main is called or before
dlopen returns.  (Forking a thread in a static constructor should probably
be disallowed.  Threads may not have been fully initialized, among other
issues.)

6) Static function scope constructor calls which depend on function arguments
are likely to involve a race condition anyway, if multiple instances of
the function can be invoked concurrently.  Any of the calls might determine
the constructor parameters.  Thus these aren't very interesting either.
And if they are really needed, they can be replaced with a file scope static
constructor call plus an assignment.

-- 
Hans-J. Boehm
boehm at sgi.com



From dehnert at sgi.com  Fri Jun 11 06:18:41 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 10 Jun 1999 23:18:41 -0700
Subject: C++ ABI Summary and Open Issues
Message-ID: <3760AA41.36BC4A77@sgi.com>

Attached is the summary page, with minor updates, including a
couple of additions to the Action Item list.  Please check yours
and deal with them if you can.  (Cary, is the object layout stuff
you sent the expected Taligent material, or is more coming?)
Let me know of any errors or omissions.

Also attached is the beginning of an open issues page.  It lists
the same issues as the summary (so far), and should by next week
also include descriptions of each issue on the order of a
paragraph.  Most of the summaries now list only the party I
expect to provide a real summary.  Consider those action items,
too, and try to get them to me by early next week, so we can
deliver a complete list to everyone before the meeting.  I intend
to use this page to also track the significant relevant discussion
of the issues as we proceed.

I will add more material reflecting today's meeting to both pages
later.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990610/c4491769/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990610/c4491769/attachment-0001.html>

From thomson at ca.ibm.com  Fri Jun 11 18:22:43 1999
From: thomson at ca.ibm.com (thomson at ca.ibm.com)
Date: Fri, 11 Jun 1999 14:22:43 -0400
Subject: HP's object layout, clarification
Message-ID: <8525678D.00653194.00@D51MTA05.pok.ibm.com>

Cary, your object layout description makes this statement:

    The C++ language allows an empty base-class to share
    its location with its descendents ...
    ... but also imposes the following INequalities:

    (void*)&empty != (void*)&also_empty
    (void*)&(Empty2&)bug != (void*)&(AlsoEmpty&)bug

    I.e., for two subobjects to have the same address,
    one must be derived from the other

I see this asserted in section 10.0 of the spec for subobjects
"that have the same class type", but not for subobjects in general.
Do you have a supporting citation?


Brian Thomson
VisualAge C/C++ Chief Architect





From dehnert at baalbek.engr.sgi.com  Sat Jun 12 04:04:18 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 11 Jun 1999 21:04:18 -0700 (PDT)
Subject: C++ standard library ABI
Message-ID: <199906120404.VAA08831@baalbek.engr.sgi.com>

Jonathon and Christophe have made some thought-provoking comments about
the library implications of attempting to achieve ABI-conforming
portable code in some meaningful sense.  Since this discussion is no
doubt partially due to my minimal treatment in the Objectives section
of the summary page, let me try to clarify what my thinking has been on
the subject.  It is similar to that of Jonathon and Christophe.

To put it in context, the base ABI (nominally for C) contains several
parts which are all required for producing portable objects, but treat
distinct parts of the problem.  Chapter 3 deals with data layout,
procedure call interfaces, and other "Machine Interface" issues, i.e.
code sequences and data layouts that must match for objects to interact
successfully.  Most of the issues on our list so far fall in this
category, and very little is possible without agreement on them.

Chapters 4 and 5 deal with the representation of object files (ELF) and
the process of executing a program given that representation.  Some of
our issues touch on this category (.init/.fini issues, name mangling,
etc.).  It is usually straightforward to convert from one
representation to another, so not all such issues absolutely require
agreement.  But they're usually not hard to agree on -- easier than
writing conversion programs.

Chapter 6 defines a standard library API, in the sense of a set of
interfaces which may be found in the system libraries of any conforming
platform, typically including libc, libm, and similar basic facilities.
This is the area of concern when we start talking about the standard
library.  It is touched upon by the exception handling and
multithreading issues, but there's a great deal more that's not on the
issue list yet.

An ABI-conforming program, then, is one which uses the standard data
layouts and interface code, the standard object file formats, and
_only_ the Chapter 6 library interfaces.  If it uses additional external
calls, they must appear in DSOs supplied with the program.

What I believe to be a workable (and, I hope, achievable) approach is
to define as large a subset of the Standard Library as possible to be
in the platform libC.so (and possibly other DSOs), and then require that
the remaining parts be implemented by a compiler vendor in a "utility"
DSO that the user can deliver with his program, that doesn't use more
than the standard interface on a conforming platform, and that doesn't
clash with the standard interface or other vendors' utility DSOs.  Then,
if objects from multiple vendors' systems are combined, they may just
include all of the required utility DSOs with the host libC.so and
libc.so.

Now, it may seem that one could minimize the common interface in
libC.so, and push most of the functionality into the utility DSOs,
but that is not desirable, and probably not possible.  It is not
desirable because one of the benefits one obtains from
platform-specific system DSOs is platform-specific optimization.
It may not be possible because of things like iostreams -- mixing
different implementations in the same program is likely to be a
disaster.

So, here's what I suggest we do.  I would like someone to volunteer to
try to list the candidate common libC.so interfaces (presumably based
on a current implementation) sometime in the next month.  We can then
all take that as a basis for determining whether we need more material
or less in the base (likely both), and evaluating where the conformance
difficulties are going to be.  Does this sound reasonable?  Other
ideas?  A volunteer?

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From ddd at cup.hp.com  Mon Jun 14 22:17:03 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 14 Jun 1999 15:17:03 -0700
Subject: HP's object layout, clarification
Message-ID: <199906142217.PAA26264@cllmail.cup.hp.com>


Brian Thomson wrote:

> Cary, your object layout description makes this statement:
>
>     The C++ language allows an empty base-class to share
>     its location with its descendents ...
>     ... but also imposes the following INequalities:
>
>     (void*)&empty != (void*)&also_empty
>     (void*)&(Empty2&)bug != (void*)&(AlsoEmpty&)bug
>
>     I.e., for two subobjects to have the same address,
>     one must be derived from the other
>
> I see this asserted in section 10.0 of the spec for subobjects
> "that have the same class type", but not for subobjects in general. 
> Do you have a supporting citation?
>
I think this is 5.10. [expr.eq], which says:

	Pointer to objects or functions of the same type
	(after pointer conversion) can be compared for
	equality. Two pointers of the same type compare
	equal if and only if they are both null, both point
	to the same object or function, or both point one
	past the end of the same array.

Since (void *) is the same type, you can do the comparison.
'empty' and 'also_empty' are not the same object. Similarly, the  
(Empty2) subobject of 'bug' and the (AlsoEmpty) subobject are not the  
same object. In both cases, this means that the equality above  
cannot be true.

What were described as possible equalities are when the objects are  
actually the same. Probably the wording above is not perfect (but,  
remember, this used to be an internal document). Rather than
	for two subobjects to have the same address,
	one must be derived from the other
you could have:
	for two pointers to compare equal,
	they must actually point to the same object.
(which implies the other, but the converse is not true)


Best regards
Christophe de Dinechin.



From jason at cygnus.com  Tue Jun 15 01:51:44 1999
From: jason at cygnus.com (Jason Merrill)
Date: 14 Jun 1999 18:51:44 -0700
Subject: HP's object layout, clarification
In-Reply-To: Christophe de Dinechin's message of "Mon, 14 Jun 1999 15:17:03 -0700"
References: <199906142217.PAA26264@cllmail.cup.hp.com>
Message-ID: <u93dzuxmbz.fsf@yorick.cygnus.com>

Your reasoning would also suggest that compilers can't have base and
derived classes at the same address, since they are not the "same object".
When you're dealing with void*, the idea of what object a void pointer
points to is a bit vague.

I think it's pretty clear that the committee's intent was to allow empty
bases to overlap except when they are of the same type.  Perhaps the
language in the standard could be clarified a bit.

Jason



From ddd at cup.hp.com  Tue Jun 15 17:54:50 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 15 Jun 1999 10:54:50 -0700
Subject: HP's object layout, clarification
In-Reply-To: Christophe de Dinechin's message of "Mon, 14 Jun 1999 15:17:03 -0700"
Message-ID: <199906151754.KAA28894@cllmail.cup.hp.com>

From: Jason Merrill <jason at cygnus.com>
>
> Your reasoning would also suggest that compilers can't have base and 
> derived classes at the same address, since they are not the "same  
object".
> When you're dealing with void*, the idea of what object a void pointer 
> points to is a bit vague.

First of all, I'm not a "Standard Guru", and I may be dead wrong on  
this. Which would be good news, because it would mean we have no bug  
:-)

However, I think you can legitimately claim that a pointer to a base  
and a pointer to a derived class, after conversion, point to the  
same object. The exact wording in [expr.eq] does not say that  
pointers compare equal if the objects they point to are the same, but  
that pointers can compare _after conversion_, and that then they  
compare equal if they point to the same object.

Casting a pointer to the derived or base class, when this is valid  
(unambiguous), indeed returns a pointer to the same subobject. The  
cast to (void *) in the examples given may have hidden this fact. We,  
internally, all read a cast to (void *) as meaning "the address  
corresponding to", which is why this cast was used in the first  
place.

There is also a note in [class.derived]/5, that reads:

	[ (...) A base class subobject may be of zero size
	(clause 9); however, two subobjects that
	have the same class type and that belong
	to the same most derived object must not
	be allocated at the same address (5.10). ]

which means that the address must not be the same, even if you would  
think that this would be unambiguous just because the size of the  
object is zero. I think this covers:

	struct A {};
	struct B: A {};
	struct C: A, B {};

The A in B and A in C subojbects must not be allocated at the same  
address, even though the zero size would make things like (A*)(C*)ptr  
unambiguous if they were allocated at the same address. This is only  
a note (non normative), so to me. To me, it just recalls a  
consequence of some other normative text, in that case, [expr.eq],  
which is explicitly referred to as the reason why you allocate these  
objects at the same address.

>
> I think it's pretty clear that the committee's intent was to allow  
empty
> bases to overlap except when they are of the same type.  Perhaps the 
> language in the standard could be clarified a bit.

My reading (but I may be wrong) is that empty base classes can  
overlap as long as they represent a single object, but that two  
subobjects in a given object that are not part of the same branch of  
a class hierarchy always need to be given a different address, even  
if they are zero size (and even if they have the same class.)

I have no personal preference on the subject, as long as everybody  
agrees on the correct solution. Do we want some clarification on this  
from c++core?


Regards
Christophe



From jason at cygnus.com  Tue Jun 15 18:21:14 1999
From: jason at cygnus.com (Jason Merrill)
Date: 15 Jun 1999 11:21:14 -0700
Subject: HP's object layout, clarification
In-Reply-To: Christophe de Dinechin's message of "Tue, 15 Jun 1999 10:54:50 -0700"
References: <199906151754.KAA28894@cllmail.cup.hp.com>
Message-ID: <u9hfo9wcit.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > However, I think you can legitimately claim that a pointer to a base  
 > and a pointer to a derived class, after conversion, point to the  
 > same object.

If you convert them to the common type before converting to void*, yes.
Otherwise it's the same situation as with parallel bases.  I believe that
the intent of 5.10 was to talk about comparing using the same
pointer-to-class type, and that comparing via a pointer-to-void or some
other unrelated type should have different rules.

 > I have no personal preference on the subject, as long as everybody  
 > agrees on the correct solution. Do we want some clarification on this  
 > from c++core?

I suppose so.  I've sent off a note.

Jason



From dehnert at sgi.com  Wed Jun 16 07:58:08 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 00:58:08 -0700
Subject: C++ ABI Summary
Message-ID: <37675910.41C6@sgi.com>

Attached is a somewhat updated summary page -- I hope to
update it further before the meeting Thursday.  Note that
the meeting is a different room -- about 2 rooms closer to
the front door, with yellow outer walls.

Welcome to two new participants:  Daveed Vandevoorde from
Edison Design Group, and Colin McPhail from Edison Portable
Compilers.

Please take a look at the action items, and deal with them
if you can.  Also, please check your contact information,
and send me corrections or missing information.

Also, I will send the open issues list shortly.  I haven't
gotten issue summaries from anyone.  Please try to get me
the ones you are listed for -- they needn't be long, or if
in rare cases they are, I'll settle for a brief summary now
and an update next week.

I have taken to sending these pages just in the HTML form,
because it's slightly easier and much smaller.  If anyone
really prefers PDF, let me know and I'll go back to sending
both.

Jim
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/16017e5d/attachment.html>

From dehnert at sgi.com  Wed Jun 16 08:01:41 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 01:01:41 -0700
Subject: C++ ABI Open Issues
Message-ID: <376759E4.3F54@sgi.com>

Attached is the open issues list...
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/7702cb42/attachment.html>

From austern at isolde.engr.sgi.com  Wed Jun 16 22:02:56 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 16 Jun 1999 15:02:56 -0700
Subject: Empty base optimization, sharing vptrs
Message-ID: <9906161502.ZM30768@isolde.engr.sgi.com>

I'm trying to work out exactly when we're allowed to allocate zero
space for an empty base object, and when we're allowed to share a vptr
between a full object and a base class subobject.  Here are my
assumptions.  I'd appreciate it if people could point out places where
my assumptions are overly aggressive.

The major assumption I'm making about class layout is that we're accessing
virtual bases through an offset in the vtable rather than through a pointer
in the class itself, so the only hidden member in an object is its vptr.

NONPOLYMORPHIC BASES

We may allocate any number of empty base subobjects at the same location
(the beginning of the complete object) except when, because of repeated
inheritance, we'd have multiple subobjects of the same type allocated in
the same place.

NON-VIRTUAL POLYMORPHIC BASES

The first immediate base subobject (not necessarily the leftmost
immediate base, since we're allowed to reorder base classes) may share
its vptr with the complete object.  We may allocate any number of
non-virtual polymorphic base subobjects at offset zero, provided that
all but one are empty except for their vptrs and that none of these
base classes have any non-virtual base classes in common themselves.
(It's OK if they do have virtual bases in common.)

VIRTUAL BASES

We may allocate any number of empty virtual base subobjects at offset 0,
and they will share the complete object's vptr.  Non-empty virtual base
subobjects get allocated at the end of the complete object.

There's one case where a base class B can be treated as empty (except
for a vptr) even if it has data members: the case when all of the data
members are inherited from virtual bases.



(Oh, another point.  I don't have a proof, but my guess is that
finding an optimal space-minimizing solution to the class layout
problem is equivalent to the travelling salesman problem.  I'm not
going to try.  What I'm going to present tomorrow is a heuristic
that I think should usually do better than just declaration order.)


			--Matt



From michael.ball at eng.sun.com  Wed Jun 16 22:30:09 1999
From: michael.ball at eng.sun.com (Michael Ball)
Date: Wed, 16 Jun 1999 15:30:09 -0700 (PDT)
Subject: Empty base optimization, sharing vptrs
Message-ID: <0FDF00I26YFGHM@ha-sims.eng.sun.com>

>The major assumption I'm making about class layout is that we're accessing
>virtual bases through an offset in the vtable rather than through a pointer
>in the class itself, so the only hidden member in an object is its vptr.
>
>NONPOLYMORPHIC BASES

I am assuming by this that you mean that the base class itself is
non-polymorphic.  That is, it has no virtual functions and no virtual
bases.

>
>We may allocate any number of empty base subobjects at the same location
>(the beginning of the complete object) except when, because of repeated
>inheritance, we'd have multiple subobjects of the same type allocated in
>the same place.

Check

>
>NON-VIRTUAL POLYMORPHIC BASES
>
>The first immediate base subobject (not necessarily the leftmost
>immediate base, since we're allowed to reorder base classes) may share
>its vptr with the complete object.  We may allocate any number of
>non-virtual polymorphic base subobjects at offset zero, provided that
>all but one are empty except for their vptrs and that none of these
>base classes have any non-virtual base classes in common themselves.
>(It's OK if they do have virtual bases in common.)

I don't see how you can allocate more than one immediate polymorphic
bases at offset 0, they will in general require different vtables since
they will have different virtual functions.  If by empty you also
imply that they have no virtual functions of their own, then OK, they
can be ignored and only their bases matter.  Normally I would think
that empty implied only a lack of data members.

>
>VIRTUAL BASES
>
>We may allocate any number of empty virtual base subobjects at offset 0,
>and they will share the complete object's vptr.  Non-empty virtual base
>subobjects get allocated at the end of the complete object.

This again assumes that they have no virtual functions of their own.
Why is this even an interesting case?  No data is common, no virtual
functions in a virtual base class is extremely uncommon, since they
are then essentially useless.  There are rare cases when the
class contains only static members, but I haven't seen many of them.

>(Oh, another point.  I don't have a proof, but my guess is that
>finding an optimal space-minimizing solution to the class layout
>problem is equivalent to the travelling salesman problem.  I'm not
>going to try.  What I'm going to present tomorrow is a heuristic
>that I think should usually do better than just declaration order.)

I would need to see real numbers on real programs before I am convinced
that such algorithms are other than bugs waiting to happen.

-Mike-




From austern at isolde.engr.sgi.com  Wed Jun 16 22:43:25 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 16 Jun 1999 15:43:25 -0700
Subject: Empty base optimization, sharing vptrs
In-Reply-To: Michael Ball <michael.ball@eng.sun.com>
        "Re: Empty base optimization, sharing vptrs" (Jun 16,  3:30pm)
References: <0FDF00I26YFGHM@ha-sims.eng.sun.com>
Message-ID: <9906161543.ZM31016@isolde.engr.sgi.com>

On Jun 16,  3:30pm, Michael Ball wrote:

> I don't see how you can allocate more than one immediate polymorphic
> bases at offset 0, they will in general require different vtables since
> they will have different virtual functions.  If by empty you also
> imply that they have no virtual functions of their own, then OK, they
> can be ignored and only their bases matter.  Normally I would think
> that empty implied only a lack of data members.

Oops, yes.  You're quite right; only one empty-except-for-the-vptr
base class at offset 0, and that's true whether it's a non-virtual
base class with virtual functions, or a virtual base class.

Another goof I just noticed: if it's a virtual but nonpolymorphic
base class then we can't put it at offset 0, because the derived
class has a vptr at offset 0 and the base class doesn't.

> >(Oh, another point.  I don't have a proof, but my guess is that
> >finding an optimal space-minimizing solution to the class layout
> >problem is equivalent to the travelling salesman problem.  I'm not
> >going to try.  What I'm going to present tomorrow is a heuristic
> >that I think should usually do better than just declaration order.)
>
> I would need to see real numbers on real programs before I am convinced
> that such algorithms are other than bugs waiting to happen.

I don't know whether this sort of reordering is a good idea.  Part of this
exercise is to see if we can come up with a simple enough heuristic so that
it's even worth running tests.

			--Matt





From ddd at cup.hp.com  Wed Jun 16 23:57:40 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 16 Jun 1999 16:57:40 -0700
Subject: Empty base optimization, sharing vptrs
Message-ID: <199906162357.QAA13486@cllmail.cup.hp.com>

From: "Matt Austern" <austern at isolde.engr.sgi.com>

> NONPOLYMORPHIC BASES
>
> We may allocate any number of empty base subobjects at the same  
location
> (the beginning of the complete object) except when, because of repeated 
> inheritance, we'd have multiple subobjects of the same type  
allocated in
> the same place.

You probably have noticed that I currently don't read the standard  
that way. But I also acknowledge that this is quite a reasonable way  
of implementing things. Jason was supposed to send a message to  
c++core regarding this issue. I did not receive this message, but  
this might be a problem with our mail setup. Was the message sent?

> (Oh, another point.  I don't have a proof, but my guess is that
> finding an optimal space-minimizing solution to the class layout
> problem is equivalent to the travelling salesman problem.  I'm not 
> going to try.

Ah ah, but that's the kind of optimization that could be useful to  
make people buy IA64-class machines :-)


Christophe



From dehnert at baalbek.engr.sgi.com  Thu Jun 17 00:26:38 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 17:26:38 -0700 (PDT)
Subject: Empty base optimization, sharing vptrs
Message-ID: <199906170026.RAA20858@baalbek.engr.sgi.com>

> > NONPOLYMORPHIC BASES
> >
> > We may allocate any number of empty base subobjects at the same  
> location
> > (the beginning of the complete object) except when, because of repeated 
> > inheritance, we'd have multiple subobjects of the same type  
> allocated in
> > the same place.
> 
> You probably have noticed that I currently don't read the standard  
> that way. But I also acknowledge that this is quite a reasonable way  
> of implementing things. Jason was supposed to send a message to  
> c++core regarding this issue. I did not receive this message, but  
> this might be a problem with our mail setup. Was the message sent?

SGI hasn't gotten it either.  I added an action item for Jason.
He now has an opportunity to be the first person to finish one :-).

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From daveed at edg.com  Thu Jun 17 01:27:57 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 16 Jun 1999 18:27:57 -0700
Subject: Empty base optimization, sharing vptrs
References: <199906170026.RAA20858@baalbek.engr.sgi.com>
Message-ID: <37684F1D.9F7B94BC@edg.com>

Jim Dehnert wrote:
[...]
> > You probably have noticed that I currently don't read the standard
> > that way. But I also acknowledge that this is quite a reasonable way
> > of implementing things. Jason was supposed to send a message to
> > c++core regarding this issue. I did not receive this message, but
> > this might be a problem with our mail setup. Was the message sent?
> 
> SGI hasn't gotten it either.  I added an action item for Jason.
> He now has an opportunity to be the first person to finish one :-).

I did get the message. It is c++std-core-8101.
Responses: c++std-core-8102 ... c++std-core-8106.

(You can retrieve the messages by sending e-mail to 
c++std-ping at research.att.com.)

	Daveed



From dehnert at sgi.com  Wed Jun 16 19:19:03 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 20:19:03 +0100
Subject: C++ ABI: Summary and Issues List
Message-ID: <3767F8A7.1AC2B103@sgi.com>

Attached is an updated summary and open issues document.
The former includes the meeting info -- I'll see you there.

I have requested the C++ reflector's messages related to
Jason's action item, and will close it if the issue is
resolved.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/1867b348/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/1867b348/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: code.css
Type: text/css
Size: 323 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/1867b348/attachment.css>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: small-table.css
Type: text/css
Size: 238 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/1867b348/attachment-0001.css>

From dehnert at baalbek.engr.sgi.com  Thu Jun 17 03:17:33 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 20:17:33 -0700 (PDT)
Subject: C++ ABI: Summary and Issues List
Message-ID: <199906170317.UAA22926@baalbek.engr.sgi.com>

(I apologize if you get this twice.  The first attempt produced
a Majordomo abort, and I don't know who received it.)

Attached is an updated summary and open issues document.
The former includes the meeting info -- I'll see you there.

I have requested the C++ reflector's messages related to
Jason's action item, and will close it if the issue is
resolved.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/c076c62d/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/c076c62d/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: code.css
Type: text/css
Size: 323 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/c076c62d/attachment.css>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: small-table.css
Type: text/css
Size: 238 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990616/c076c62d/attachment-0001.css>

From dehnert at baalbek.engr.sgi.com  Thu Jun 17 03:42:59 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 16 Jun 1999 20:42:59 -0700 (PDT)
Subject: Sharing base pointers: c++core discussion
Message-ID: <199906170342.UAA23024@baalbek.engr.sgi.com>

For those of you who didn't get it, here's the C++ core discussion
of the issue Jason raised last week:

=================================================================

From: Jason Merrill <jason at cygnus.com>
Date: Tue, 15 Jun 1999 11:20:34 -0700
Message-Id: <199906151820.LAA24561 at yorick.cygnus.com>

To: C++ core language mailing list
Message c++std-core-8101

  5.10 - Equality operators [expr.eq]

  -1- ... Pointers to objects or functions of the same type (after pointer
   conversions) can be compared for equality. Two pointers of the same type
   compare equal if and only if they are both null, both point to the same
   object or function, or both point one past the end of the same array.

When you consider comparing pointers to void, this seems to suggest that no
two objects can have the same address, depending on your interpretation of
"point to the same object."  This would cripple the empty base
optimization.

Seems to me that these rules should only apply to pointers to the type of
the object being pointed to, and that comparing via void* or other
unrelated type should be more flexible.

Jason
=================================================================

From: "William M. Miller" <wmm at fastdial.net>
Date: Tue, 15 Jun 1999 14:30:32 -0400
References: <199906151820.LAA24561 at yorick.cygnus.com>

To: C++ core language mailing list
Message c++std-core-8102

Yet one more problem for this wording.  I'll add a note to
issue 73.  (The problems already described there are the "object
that happens to be one past the end of an array" and the
"different objects sharing the same space sequentially" issues.)

-- Mike Miller
-- 
William M. Miller, wmm at setech.com, wmm at fastdial.net
Software Emancipation Technology, Inc.,    +1 (781) 359-3335
15 Third Ave., Burlington MA 01803    FAX: +1 (781) 359-3399
        http://www.setech.com
=================================================================

From: Nathan Myers <ncm at best.com>
Date: Tue, 15 Jun 1999 11:38:45 -0700 (PDT)

To: C++ core language mailing list
Message c++std-core-8103

Jason Merrill, in Message c++std-core-8101, wrote:
> ... 
> Seems to me that these rules should only apply to pointers to the type of
> the object being pointed to, and that comparing via void* or other
> unrelated type should be more flexible.

Of course, pointers-to-void don't point at objects.

Nathan Myers
ncm at cantrip.org
=================================================================

From: Greg Comeau <comeau at panix.com>
Date: Tue, 15 Jun 1999 14:52:01 -0400 (EDT)

To: C++ core language mailing list
Message c++std-core-8104

> Of course, pointers-to-void don't point at objects.

They do, but you normally wouldn't call them 'pointers to objects' per se.

- Greg
=================================================================

From: Jason Merrill <jason at cygnus.com>
Date: 15 Jun 1999 12:23:18 -0700
Message-ID: <u97lp5w9nd.fsf at yorick.cygnus.com>

To: C++ core language mailing list
Message c++std-core-8105

...

Perhaps not; [basic.compound] refers to 'pointers to void or objects or
functions'.  But in that case, [expr.eq] does not allow you to compare
them; it only allows comparing pointers to objects and functions.

Jason
=================================================================

From: Nathan Myers <ncm at best.com>
Date: Tue, 15 Jun 1999 13:55:39 -0700 (PDT)
Message-Id: <199906152055.NAA25668 at shell7.ba.best.com>

To: C++ core language mailing list
Message c++std-core-8106

...

No, it leaves the result of comparison between null pointers undefined.
They can be compared, but the result isn't specified for that case.
That may be a problem.  Fortunately, we have some existing practice
to fall back on.

Nathan Myers
ncm at cantrip.org

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at isolde.engr.sgi.com  Thu Jun 17 03:53:20 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 16 Jun 1999 20:53:20 -0700
Subject: Empty base optimization, sharing vptrs
In-Reply-To: dehnert@baalbek (Jim Dehnert)
        "Re: Empty base optimization, sharing vptrs" (Jun 16,  5:26pm)
References: <199906170026.RAA20858@baalbek.engr.sgi.com>
Message-ID: <9906162053.ZM20899@isolde.engr.sgi.com>

On Jun 16,  5:26pm, Jim Dehnert wrote:

> > You probably have noticed that I currently don't read the standard
> > that way. But I also acknowledge that this is quite a reasonable way
> > of implementing things. Jason was supposed to send a message to
> > c++core regarding this issue. I did not receive this message, but
> > this might be a problem with our mail setup. Was the message sent?
>
> SGI hasn't gotten it either.  I added an action item for Jason.
> He now has an opportunity to be the first person to finish one :-).

Jason did send the message, and there has been a discussion about this
issue on c++std-core.  Jason's message was c++std-core-8101.

My take on the discussion is that everyone agrees there is a defect in
the standard, because it can reasonably be interpreted both ways, and that
the standard needs to be clarified.  Several people expressed support for
the interpretation under which this proposed layout rule is legal.  My
guess (perhaps Mike and Jason could comment, since they've both seen the
discussion too) is that's how this issue will eventually be resolve.

			--Matt







From jason at cygnus.com  Thu Jun 17 04:02:51 1999
From: jason at cygnus.com (Jason Merrill)
Date: 16 Jun 1999 21:02:51 -0700
Subject: Empty base optimization, sharing vptrs
In-Reply-To: "Matt Austern"'s message of "Wed, 16 Jun 1999 15:43:25 -0700"
References: <0FDF00I26YFGHM@ha-sims.eng.sun.com> <9906161543.ZM31016@isolde.engr.sgi.com>
Message-ID: <u97lp3v5hw.fsf@yorick.cygnus.com>

>>>>> Matt Austern <austern at isolde.engr.sgi.com> writes:

 > Another goof I just noticed: if it's a virtual but nonpolymorphic
 > base class then we can't put it at offset 0, because the derived
 > class has a vptr at offset 0 and the base class doesn't.

If it's empty and nonpolymorphic, then it doesn't matter where we put it
because its address will never be used for anything.

Jason



From jason at cygnus.com  Thu Jun 17 04:03:37 1999
From: jason at cygnus.com (Jason Merrill)
Date: 16 Jun 1999 21:03:37 -0700
Subject: Empty base optimization, sharing vptrs
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Wed, 16 Jun 1999 17:26:38 -0700 (PDT)"
References: <199906170026.RAA20858@baalbek.engr.sgi.com>
Message-ID: <u94sk7v5gm.fsf@yorick.cygnus.com>

I suspect a problem with the core reflector; I haven't gotten a copy of my
mail either, but I did get the two responses.

Jason



From ddd at cup.hp.com  Thu Jun 17 16:37:23 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 17 Jun 1999 09:37:23 -0700
Subject: Empty base optimization, sharing vptrs
In-Reply-To: dehnert@baalbek (Jim Dehnert)       "Re: Empty base optimization, sharing vptrs" (Jun 16,  5:26pm)
Message-ID: <199906171637.JAA18922@cllmail.cup.hp.com>

From: "Matt Austern" <austern at isolde.engr.sgi.com>
> My take on the discussion is that everyone agrees there is a defect in 
> the standard, because it can reasonably be interpreted both ways,  
and that
> the standard needs to be clarified.  Several people expressed  
support for
> the interpretation under which this proposed layout rule is legal.  My 
> guess (perhaps Mike and Jason could comment, since they've both  
seen the
> discussion too) is that's how this issue will eventually be resolve. 

Even though I don't read the standard that way today, I still would  
favor this resolution, because it just seems to make sense.
Thank you for forwarding the messages, I will investigate why I  
don't receive them.

Christophe



From dehnert at baalbek.engr.sgi.com  Thu Jun 17 21:29:17 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 17 Jun 1999 14:29:17 -0700 (PDT)
Subject: Phone number...
Message-ID: <199906172129.OAA25518@baalbek.engr.sgi.com>

> I couldn't get in for the June 17th meeting, since I didn't have a correct
> reservation number

I'm sorry if I didn't make this clear.  The telephone bridge we're using
now has no reservation numbers or passcodes (and hence no real security).
So all you need is the phone number.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at isolde.engr.sgi.com  Fri Jun 18 17:12:14 1999
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Fri, 18 Jun 1999 10:12:14 -0700
Subject: Interleaving members
Message-ID: <9906181012.ZM38707@isolde.engr.sgi.com>

I asked on the reflector: yes, given the class
  struct X {
  public:
    int a, b;
  public:
    int c, d;
  };
it is legal to have the layout A C B D.  This was intentional; we
aren't just exploiting a loophole in the wording.  Interestingly,
Bjarne says that this was also true (and equally intentional) in
the ARM.

I still don't know of any implementation that actually does this.

			--Matt



From michael.ball at eng.sun.com  Fri Jun 18 17:32:15 1999
From: michael.ball at eng.sun.com (Michael Ball)
Date: Fri, 18 Jun 1999 10:32:15 -0700 (PDT)
Subject: Interleaving members
Message-ID: <0FDJ008OJ9YXCI@ha-sims.eng.sun.com>


>I asked on the reflector: yes, given the class
>  struct X {
>  public:
>    int a, b;
>  public:
>    int c, d;
>  };
>it is legal to have the layout A C B D.  This was intentional; we
>aren't just exploiting a loophole in the wording.  Interestingly,
>Bjarne says that this was also true (and equally intentional) in
>the ARM.
>
>I still don't know of any implementation that actually does this.

In our case it's because we (Sun) consider it highly desirable to use the
C ABI whenever we can, and the obvious mapping onto a C struct is
considered valuable.

There is no strict technical reason for that.  Rather, it's a stronly
held quasi-religious view.  We would have to promise significant gains
to go against it.

In fact, there seems to be little to be gained, for two reasons.

1.  There are very few structs or classes with both public and private
    data elements.  New classes aren't designed that way because it's widely
    considered bad style.  Most that do exist are there because they have
    migrated from C code, and many still refer to the public parts from
    C routines. 
    
2.  With the single exception of classes with lots of bitfields, there just
    isn't that much padding to squeeze out.  People who care seem to
    follow the usual C rules about ordering by descending size.
    
This conclusion is the result of looking at lots of code.  Still, there may 
be a counter example out there.

-Mike-
    




From dehnert at sgi.com  Wed Jun 23 16:18:28 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 23 Jun 1999 17:18:28 +0100
Subject: C++ ABI Summary
Message-ID: <377108D4.CCD0BD8D@sgi.com>

Attached is an updated summary page and issues list for tomorrow.
Notice in particular that Matt and I have added proposed
resolutions, based on discussions so far, to many of the A issues.
Please go through the list and identify any problems you notice.

I'm expecting that Christophe will be ready to discuss the
virtual function issues tomorrow.  John Wilkinson is also ready
to talk about exception handling:  Priti and Sunil -- is that
OK?

In general, if your name (or your company's) is on an action
item (or an issue summary), please try to get it done (or
summarized).  Going forward, progress is going to depend on
some work being done by all of us outside of the meetings.

-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990623/e673a8f1/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990623/e673a8f1/attachment-0001.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: code.css
Type: text/css
Size: 323 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990623/e673a8f1/attachment.css>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: small-table.css
Type: text/css
Size: 238 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990623/e673a8f1/attachment-0001.css>

From ddd at cup.hp.com  Thu Jun 24 00:31:27 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 23 Jun 1999 17:31:27 -0700
Subject: Virtual function calls
Message-ID: <199906240031.RAA04882@cllmail.cup.hp.com>

Folks,


Here is a summary of the virtual function call mechanism.


OPEN ISSUES THAT BELONG TO THIS DISCUSSION (Coming later)

1/ Keeping all of a class in a single load module. The vtable  
contains the target address and one copy of the target GP. This  
implies that it is not in text, and that it is generated by dld.

2/ Detailed layout of the virtual table

3/ How can we share class offsets?




1/ Scope and "State of the Art"

The following proposal applies only to calls to virtual functions  
when a this pointer adjustment is required from a base class to a  
derived class. Essentially, this means multiple inheritance, and the  
existence of two or more virtual table pointers (vptr) in the  
complete object. The multiple vptrs are required so that the layout  
of all bases is unchanged in the complete object. There will be one  
additional vptr for each base class which already required a vptr,  
but cannot be placed in the whole object so that it shares its vptr  
with the whole object. Note: when the vptr is shared, the base class  
is said to be the "primary base class", and there is only one such  
class.

For the primary base class, no pointer adjustment is needed. For all  
other bases, a pointer to the whole object is not a pointer to the  
base class, so whenever a pointer to the base class is needed,  
adjustment will occur.

In particular, when calling a virtual function, one does not know in  
advance in which class the function was actually defined. Depending  
on the actual class of the object pointed to, pointer adjustment may  
be needed or not, and the pointer adjustment value may vary from  
class to class. The existing solution is to have the vtable point not  
to the function itself, but to a "thunk" which does pointer  
adjustment when needed, and then jumps to the actual function.  
Another possibility is to have an offset in the vtable, which is used  
by the called function. However, more often than not, this implies  
adding zero.

Virtual bases make things slightly more complicated. In that case,  
the data layout is such that there is only one instance of the  
virtual base in the whole object. Therefore, the offset from a this  
pointer to a same virtual base may change along the inheritance tree.  
This is solved by placing an offset in the virtual table, which is  
used to adjust the this pointer to the virtual base.


2/ Proposal and Rationale

My proposal is to replace thunks with offsets, with two additional tricks:
- Give a virtual function two entry points, so as to bypass the  
adjustment when it's known to be zero
- Moving the adjustment at call-site, where it can be scheduled more  
easily, using a "reasonable" value, so that the adjustment is  
bypassed even more often.

The thunks are believed to cost more on IA64 than they would on  
other platforms. The reason is that they are small islands of code  
spread throughout the code, where you cannot guarantee any cache  
locality. Since they immediately follow an indirect branch, chances  
are we will always encounter both a branch misprediction and a  
I-cache miss in a row.

On the other hand, a virtual function call starts by reading the  
virtual function address. Reading the offset immediately thereafter  
should almost never cause a D-cache miss (cache locality should be  
good). More often than not, no adjustment is needed, or the  
adjustment will be done at call site correctly. In the worst case  
scenario, we perform two adjustments, one static at call site, and  
one dynamic in the callee, but this case should be really infrequent.


3/ New Calling Convention

The new calling convention requires that the 'this' pointer on entry  
points to the class for which the virtual function is just defined.  
That is, for A::f(), the pointer is an A* when the main entry of the  
function is reached. If the actual pointer is not an A*, then an  
adjusting entry point is used, which immediately precedes the  
function.

In the following, we will assume the following examples:
	struct A { virtual void f(); };
	struct B { virtual void g(); };
	struct C: A, B { }
	struct D : C { virtual void f(); virtual void g(); }
	struct E: Other, C { virtual void f(); virtual void g(); }
	struct F: D, E { virtual void f(); }
	void call_Cf(C *c) { c->f(); }
	void call_Cg(C *c) { c->g(); }
	void call_Df(D* d) { d->f(); }
	void call_Dg(D* d) { d->g(); }
	void call_Ef(E* e) { e->f(); }
	void call_Eg(E* e) { e->g(); }
	void call_Ff(F *ff) { ff->f(); }
	void call_Fg(F *ff) { ff->g(); }		// Invalid:  
ambiguous

a) Call site:
The caller performs adjustment to match the class of the last  
overrider of the given function.

+ call_Cf will assume that the pointer needs to be cast to an A*,  
since C::f is actually A::f. Since A is the primary base class, no  
adjustment is done at call site.

+ call_Cg is similar, but assumes that the actual type is a B*, and  
performs the adjustment, since B is not the primary base class.

+ call_Df and call_Dg will assume that the pointer needs to be cast  
to a D*, which is where D::f is defined. No adjustment is performed  
at call site.


b) Callee

+ A::f and B::g are defined in classes where there is a single vptr.  
They don't define a secondary entry point. Because of call-site  
conventions, they expect to always be called with the correct type.

+ D::f is defined in a class where there is more than one vptr, so  
it needs a secondary entry point and an entry 'convert_to_D' in the  
vtable. That's because it can be potentially called with either an A*  
or a B*. There are two vtables, one for A in D, one for B in D. The  
D::f entry in A in D points to the non-adjusting entry point, since A  
shares its vptr.

+ D::g requires a secondary entry point, that will read the same  
offset 'convert_to_D' from the vtable.

+ E also will require a 'convert_to_E' entry in the vtable, but this  
time, the vtable for A in C will have to point to an adjusting entry  
point, since A no longer shares the vptr with E (assuming Other has  
a vptr). This vtable is also the vtable of C in E.


c) Offsets in the vtable
Offsets have to be placed in the vtable at a position which does not  
conflict with any offset in the inheritance tree.

convert_to_D and convert_to_E are likely to be at the same offset in  
the vtable. This is not a problem, even if D and E are used in the  
same class, such as F, because this is the same offset in different  
vtables.

- call_Fg is invalid, because it is ambiguous.

- A notation such as ((E*) ff)->g() can be used to disambiguate, but  
in that case, we don't use the same vtable (either the E in F or D  
in F vtable). The E in F vtable uses that offset as 'convert_to_E',  
whereas the D in F vtable uses that offset as 'convert_to_D'.

- Similarly, call_Cf called with an F object will actually be called  
with the E in F or D in F, which disambiguates which C is actually  
used. The actual C* passed will have been adjusted by the caller  
unambiguously, or the call will be invalid.

- For functions overriden in F, an entry 'convert_to_F' is created  
anyway. This entry will not overlap with either convert_to_E or  
convert_to_D.


The fact that an offset is reserved does not mean that it is  
actually used. A vtable need to contain the offset only if it refers  
to a function that will use it. An offset of 0 is not needed, since  
the function pointer will point to the non-adjusting entry point in  
that case.


4/ Cases where adjustment is performed

+ For call_Cf: No adjustment is done at call site. No adjustment is  
done at callee site if the dynamic type is C,  or D, or D in F (that  
is, F casted to an E).

+ For call_Cg: Adjustment to B* is done at call-site. No further  
adjustment is needed if the dynamic type is C, D, or D in F. On the  
other hand, a second adjustment may happen for an E or E in F,  
because C is not their primary base.

In other words, adjustment is made only when necessary, and at a  
place where it is better scheduled than with thunks. The only bad  
case is double adjustment for call_Cg called with an E*. This case  
can probably be considered rare enough, compared to calls such as  
call_Cg called with a C*, where we now actually do the adjustment at  
the call-site.


4/ Comparing the code trails

Currently, the sequence for a virtual function call in a shared  
library will look as follows. I'm assuming +DD64, there would be some  
additional addp4 in +DD32. The trail below is the dynamic execution  
sequence. In bold and between #if/#endif, the affected code.

	// Compute the address of the vptr in the object, from the  
this pointer
	// Optional, since vptroffset is often 0. This also adjusts  
to the class
	// of the final overrider
	addi		Rthis=vptroffset_of_final_overrider,Rthis
	;;
	// Load the vptr in a register
	ld8		Rvptr=[Rthis]
	;;
	// Add the offset to get to the function descriptor pointer  
in the vtable
	// Never zero, this instruction is always generated
	addi		Rfndescr=fndescroffset,Rvptr
	;;
	// (Assuming inlined stub) Load the function address and new GP
	ld8		Rfnaddr=[Rfndescr],8
	;;
	// Load the new GP
	ld8		GP=[Rfndescr]
	mov		BRn=Rfnaddr
	;;
	// Perform the actual branch to the target

	// For prediction to occur correctly on McKinley,
	// at least 5 cycles between the mov to BR above and the use
	// of the BR. Up to 16 bundles...
	// This is very unlikely to be possible in most actual code, so...
	// ... Branch misprediction almost always
	// ... followed by I-Cache miss almost always if jumping to  
a thunk
	br.call	B0=BRn

#if OLD_ADJUST
thunk_A::f_from_a_B:
	// If the 'adjustment_from_B_to_A is the 'adjustment_to_A' above,
	// then in the new case, the vtable directly points to A::f
	addi		Rthis,adjustment_from_B_to_A

	// In most cases, we can probably generate a PC-relative  
branch here
	// It is unclear whether we would correctly predict that branch
	// (since it is assumed that we arrive here immediately following
	// a misprediction at call site)
	br		A::f
#endif // OLD_ADJUST

 // This occurs less often than OLD_ADJUST
// (it does not happen when call-site adjustment is correct)
#if NEW_ADJUST
adjusting_entry_A::f
	// Can't be executed in less than 3 cycles?
	addi		Rvptr=class_adjustment_offset,Rvptr
	;;
	// This loads data which is close to the fn descriptor,
	// so it's likely to be in the D-cache
	ld8		Rvptr=[Rvptr]
	;;
	add		Rthis=Rthis,Rvptr
#endif

A::f:
	alloc	...


Christophe



From daveed at edg.com  Thu Jun 24 01:22:20 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 23 Jun 1999 18:22:20 -0700
Subject: Covariant polymorphic returns and when sharing B-D V-pointers
References: <199906240031.RAA04882@cllmail.cup.hp.com>
Message-ID: <3771884C.F2E5C689@edg.com>

Here is a note explaining some subtleties (and possible solutions) in
combining V-pointer sharing and covariant polymorphic returns.
I still owe a note about the handling of nasty dynamic_cast cases
(hopefully later tonight).

	Daveed


A Hairy Example
---------------
Covariant polymorphic returns consists in having a virtual overrider function 
override the type it returns with a type that is derived from all of the return 
types declared for the overridden (virtual) functions. The complication that 
this brings is that the static return types of the caller and callee can no 
longer be determined at compile-time.

The following valid C++ code illustrates this: 

        // Return types: 
        struct S {}; 
        struct T {}; 
        struct U: S, virtual T { virtual ~U(); }; 

        // Covariant classes: 
        struct A { 
           virtual S& f(); 
        }; 

        struct B { 
           virtual T& f(); 
        }; 

        struct D: A, B { 
           virtual U& f(); // Covariant with both A::f and B::f 
        }; 

        void g(A *p) { 
           S &r = p->f(); // OK 
           // U &r2 = p->f();  // Would be illegal 
        } 

        void g(B *p) { 
           T &r = p->f(); 
        }; 

        void g(D *p) { 
           U &r1 = p->f(); // OK 
           S &r2 = p->f(); // OK 
           T &r3 = p->f(); // OK 
        }

Consider the call in g(B*) above ("T &r = p->f();"): the callee could very well 
end up being D::f and thus it is fair to say that (a) the caller does not know 
the static type declared for the callee, and (b) the callee does not know which 
type will be expected by the caller. Note also that the dynamic type of the 
returned object may be different from either of these types (i.e., D::f might 
return an object that is further derived from U).


Solution for the Single Inheritance case 
----------------------------------------
The first component of a solution to the above problem is to seek a common point 
of reference for the caller and the callee. In particular, both can look back along
the derivation chain to find which base the original, non-overriding virtual function
introduced as a return type. In the case of single inheritance, the callee can ensure
that the returned address points to that original base, and the caller can perform
the inverse transformation (if needed). 

Here is an example: 

        // Return types: 
        struct T {}; 
        struct U: T { virtual ~U(); }; 

        // Covariant classes: 
        struct B { 
           virtual T& f(); // Original base is T 
        }; 

        struct D: B { 
           virtual U& f(); // Covariant return; definition of f 
                           // will implicitly adjust to original 
                           // base subobject of type T. 
        }; 

        void g(B *p) { 
           T &r = p->f(); // OK, caller needs no adjustment 
        }; 

        void g(D *p) { 
           U &r1 = p->f(); // OK, adjust from T to U since callee
                           // is really returning the original base 
                           // type T. 
           T &r3 = p->f(); // OK, no adjustment needed. 
        }

Unfortunately, this doesn't always work for virtual bases because it is not possible
to cast from a non-polymorphic virtual base to a derived type (since the base is not
polymorphic, there is no vtable to find the location of enclosing derivations. The
proposed solution in that case is for the callee to also return the adjustment from
the original base to the first enclosing virtual derivation in a second return register
(assuming the calling conventions allow for at least two return registers).
If the caller determines that a deeper derivation must be cast to, it can do so
since the returned adjustment provides access to a virtual table. The following
example illustrates such an intricate situation: 

        // Return types: 
        struct VB {}; 
        struct VD: virtual VB {}; 
        struct VX: virtual VD {}; 

        // Covariant classes: 
        struct B { 
           virtual VB* f(); // Unaware of derivations; hence returns a VB* only. 
        }; 

        struct D: B { 
           virtual VD* f() { 
              return new VX; // Returns a VB* and the offset to the VD* subobject. 
           } 
        }; 

        struct X: D { 
           virtual VX* f() { 
              return new VX; // Returns a VB* and the offset to the VD* subobject. 
           }                 // Adjustment to VX* is done on caller (or thunk) side. 
        }; 

        void f1(B *p) { 
           VB *r = p->f(); // No problem, a VB* is what you get. 
        } 

        void f2(D *p) { 
           VB *r1 = p->f(); // No problem either. 
           VD *r2 = p->f(); // A VB* is received in first return register; 
        }                   // add the second register to find the VD*. 

        void f3(X *p) { 
           VB *r1 = p->f(); // No problem either. 
           VD *r2 = p->f(); // A VB* is received in the first return register; 
                            // add the second register to find the VD*. 
           VX *r3 = p->f(); // A VB* is received in the first return register; 
                            // add the second register and we're now pointing 
                            // to a vtable pointer in the VD subobject. Hence 
                            // a simplified "dynamic_cast"-like operation can 
        }                   // determine the VX*

This general approach still leaves some options open: 

  . The adjustment to VD* or VX* above could be done by the caller directly, or in
    a thunk that would be dispatched from an added vtable slot. I would suggest to
    not introduce thunks unless needed for multiple inheritance cases (see later).
  . The second return value (the adjustment) is only needed if the original primary
    virtual base does not have a vtable pointer. However, even if there is a virtual
    table it could be used. I would suggest to create the second return value only
    when absolutely needed. This avoids the sometimes unnecessary cost on the callee
    side. 


Multiple Inheritance 
--------------------
Reconsider the introductory example. Since there are now multiple derivation
branches, we can start with the single inheritance convention where the "original
base" is meant to be "the original leftmost base" (i.e., along the primary derivation
path). This leaves the case where a base along a secondary derivation path is
returned: 

        // Return types: 
        struct S {}; 
        struct T {}; 
        struct U: S, virtual T { virtual ~U(); }; 

        // Covariant classes: 
        struct A { 
           virtual S& f(); 
        }; 

        struct B { 
           virtual T& f(); 
        }; 

        struct D: A, B { 
           virtual U& f(); // Covariant with both A::f and B::f 
        };

        void g(A *p) { 
           S &r = p->f(); // Enabled with mechanism above 
        } 

        void g(B *p) { 
           T &r = p->f(); // Still a problem! May return an S&. 
        };

        void g(D *p) { 
           U &r1 = p->f(); // Enabled 
           S &r2 = p->f(); // Enabled 
           T &r3 = p->f(); // Enabled: add second return value to get a U&, 
        }                  // then cast to T& (through vtable info).

Note that "leftmost original base" means "the type returned by the leftmost
non-overridden virtual function", and not the "leftmost base" of the returned type.
I.e., if A::f were to return T, then T would be the type pointed to by the physical
return value of D::f.

For secondary derivation paths, we are saved by the fact that those virtual calls are
dispatched through a secondary---and therefore different---virtual table. Hence, in
such cases the secondary vtable slot can be made to point to a stub/thunk that adapts
the return value: 

        void g(B *p) { 
           T &r = p->f(); 
           // Secondary vtable entry for D::B::f point to stub. 
           // This stub calls D::f which returns an S&, adjusts 
           // it to a U&, and then back to T&. 
        };

The double adjustment may be collapsed into a single constant adjustment if there are
no virtual bases involved. Otherwise it may be required to use the second return
value and/or the virtual base offset stored in the returned object vtable. In this
particular example, we get: 

        S->U: ret_ptr -= sizeof(void*) 
        U->T: ret_ptr += (*(ptrdiff_t**)ret_ptr)[-1]

<end of note>



From jason at cygnus.com  Thu Jun 24 11:36:42 1999
From: jason at cygnus.com (Jason Merrill)
Date: 24 Jun 1999 04:36:42 -0700
Subject: Placement of vtables, inlines and such
Message-ID: <u9aetpkeyd.fsf@yorick.cygnus.com>

In C++, there are various things with external linkage that can be defined
in multiple translation units, while the ODR requires that the program
behave as if there were only a single definition.  From the user's
standpoint, this applies to inlines and templates.  From the
implementation's perspective, it also applies to things like vtables and
RTTI info.  There are several ways of dealing with such "vague linkage"
items:

1) Emit them everywhere and only use one.
2) Use some heuristic to decide where to emit them.
3) Use a database to decide where to emit them.
4) Generate them at link time.

#3 and #4 are feasible for templates, but I consider them too heavyweight
to be used for other things.

The typical heuristic for #2 is "with the first non-inline, non-abstract
virtual function in the class".  This works pretty well, but fails for
classes that have no such virtual function, and for non-member inlines.
Worse, the heuristic may produce different results in different translation
units, as a method could be defined inline after being declared non-inline
in the class body.  So we have to handle multiple copies in some cases
anyway.

The way to handle this in standard ELF is weak symbols.  If all definitions
are marked weak, the linker will choose one and the others will just sit
there taking up space.

Christophe mentioned the other day that the HP compiler used the typical
heuristic above, and handled the case of different results by encoding the
key function in the vtable name.  But this seems unnecessary when we can
just choose one of multiple defns.

A better solution than weak symbols alone would be to set things up so that
the linker will discard the extra copies.  Various existing implementations
of this are:

1) The Microsoft PE/COFF defn includes support for COMDAT sections, which
   key off of the first symbol defined.  One copy is chosen, others are
   discarded.  You can specify conditions to the linker (must have same
   contents, must have same size)
2) The IBM XCOFF platform includes a garbage-collecting linker; sections
   that are not referenced in a sweep from main are discarded.  In xlC,
   template instantiations are emitted in separate sections, with encoded
   names; at link time, one copy is renamed to the real mangled name, and
   the others are discarded by garbage collection.

The GNU ELF toolchain does a variant of #1 here; any sections with names
beginning with ".gnu.linkonce." are treated as COMDAT sections.  It seems
more sensible to me to key off of the section name than the first symbol
name as in PE.

The GNU linker recently added support for garbage collection, and I've been
thinking about changing our handling of vague linkage to make use of it,
but haven't.

I propose that the ia64 base ABI be extended to provide for either COMDAT
sections or garbage collection, and that we use that support for vague
linkage.

I further propose that we not use heuristics to cut down the number of
copies ahead of time; they usually work fine, but can cause problems in
some situations, such as when not all of the class's members are in the
same symbol space.  Does the ia64 ABI provide for controlling which symbols
are exported from a shared library?

A side issue: What do we want to do with dynamically-initialized variables?
The same thing, or use COMMON?  I propose COMMON.

A side issue is how to handle local static variables in inlines.  G++
currently avoids this issue by suppressing inlining of functions with
local statics, if we don't want to do that, we'll need to specify a
mangling for the statics, and handle multiple copies like we do above.

Jason



From ddd at cup.hp.com  Fri Jun 25 00:14:39 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 24 Jun 1999 17:14:39 -0700
Subject: Placement of vtables, inlines and such
Message-ID: <199906250014.RAA03552@cllmail.cup.hp.com>

From: Jason Merrill <jason at cygnus.com>
>
> Christophe mentioned the other day that the HP compiler used the  
typical
> heuristic above, and handled the case of different results by  
encoding the
> key function in the vtable name.  But this seems unnecessary when  
we can
> just choose one of multiple defns.

I think that the name of the vtable has to either contain the name  
of the class or the (mangled) name of the key function. If there is a  
key function, it does not harm to use that as the name (except that  
it makes for a slightly longer symbol), and it sometimes catches some  
broken makefiles that fail to recompile some .o file when a .h file  
they include changed :-). I don't know if catching a problem  
"sometimes" is better than "never", or if it is actually worse...

Also, HP uses COMDATs for the actual emission of the vtable,  
out-of-line copies of inline functions, some cases of template  
instantiations, etc. Our COMDAT key is the name alone. I don't think  
we can have the linker check size or whatever. Note that it's hard to  
believe that the content of a COMDAT section for code emitted by two  
different compilers would have anything in common :-)

> I propose that the ia64 base ABI be extended to provide for either  
COMDAT
> sections or garbage collection, and that we use that support for vague 
> linkage.

It looks to me like garbage collection requires one extra operation,  
namely selecting the "blessed" symbol that will not be discarded,  
right? Isn't that some other form of COMDATing? In other words, isn't  
garbage collection just an additional optimization which may be  
placed on top of COMDATs?


> I further propose that we not use heuristics to cut down the number of 
> copies ahead of time; they usually work fine, but can cause problems in 
> some situations, such as when not all of the class's members are in the 
> same symbol space.  Does the ia64 ABI provide for controlling  
which symbols
> are exported from a shared library?

As you said, "they usually work fine". In particular, without them,  
you end up emitting the same vtables again and again, which is a  
waste of time, disk space, etc. Just as a reminder, IA64 .o files are  
not exactly small. Regarding the symbol spaces, did I misunderstand,  
or are you talking about having some pathological case like (using  
Microsoft's notations :-)

	#if INCLUDED_FROM_FILE_1
	__declspec(export)
	#endif
	inline void foo() { ... }

That's just a bad idea. There may be other cases I did not think of,  
but currently, I don't see this as a real issue.

>
> A side issue: What do we want to do with dynamically-initialized  
variables?
> The same thing, or use COMMON?  I propose COMMON.

The problem is that some compiler may be smarter at inlining that  
another, and figure out that it actually can initialize it  
statically. In that case, it cannot go into COMMON (or you force that  
smart compiler to not do that optimization for binary compatibility  
reasons...). For instance:

	inline int f() { return 1; }
	static int i = f();

What is the problem with COMMON?


> A side issue is how to handle local static variables in inlines.  G++ 
> currently avoids this issue by suppressing inlining of functions with 
> local statics, if we don't want to do that, we'll need to specify a 
> mangling for the statics, and handle multiple copies like we do above. 

Side issue of side issue: you are also supposed to name string  
constants, because they are supposed to have the same address in  
different inline functions ([7.1.2]/4 :-)


Christophe



From jason at cygnus.com  Fri Jun 25 05:28:03 1999
From: jason at cygnus.com (Jason Merrill)
Date: 24 Jun 1999 22:28:03 -0700
Subject: Placement of vtables, inlines and such
In-Reply-To: Christophe de Dinechin's message of "Thu, 24 Jun 1999 17:14:39 -0700"
References: <199906250014.RAA03552@cllmail.cup.hp.com>
Message-ID: <u9so7gj1cs.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > I think that the name of the vtable has to either contain the name  
 > of the class or the (mangled) name of the key function. If there is a  
 > key function, it does not harm to use that as the name (except that  
 > it makes for a slightly longer symbol), and it sometimes catches some  
 > broken makefiles that fail to recompile some .o file when a .h file  
 > they include changed :-). I don't know if catching a problem  
 > "sometimes" is better than "never", or if it is actually worse...

Worse, I think.  The heuristic can give different results in different
translation units for well-formed code.

 > Also, HP uses COMDATs for the actual emission of the vtable,  
 > out-of-line copies of inline functions, some cases of template  
 > instantiations, etc. Our COMDAT key is the name alone. I don't think  
 > we can have the linker check size or whatever. Note that it's hard to  
 > believe that the content of a COMDAT section for code emitted by two  
 > different compilers would have anything in common :-)

No, the size check is primarily interesting for vtables.

 >> I propose that the ia64 base ABI be extended to provide for either
 >> COMDAT sections or garbage collection, and that we use that support for
 >> vague linkage.

 > It looks to me like garbage collection requires one extra operation,  
 > namely selecting the "blessed" symbol that will not be discarded,  
 > right? Isn't that some other form of COMDATing? In other words, isn't  
 > garbage collection just an additional optimization which may be  
 > placed on top of COMDATs?

No.  gc works by sweeping from main, finding all the referenced symbols;
any sections that haven't provided any symbols are discarded.  If we use
weak symbols for vtables and put them in separate sections, gc will keep at
most one copy, as needed.  There is no notion of a special symbol.

gc is a more general solution, as it also can discard normal code that
isn't actually needed.  It also allows us to discard all copies in cases
where that is appropriate, such as when we can get the vtable from one of
our shared libs.  But COMDAT is simpler to implement, and has fewer
implications for the broader ABI.

 >> I further propose that we not use heuristics to cut down the number of
 >> copies ahead of time; they usually work fine, but can cause problems in
 >> some situations, such as when not all of the class's members are in the
 >> same symbol space.  Does the ia64 ABI provide for controlling which
 >> symbols are exported from a shared library?

 > As you said, "they usually work fine". In particular, without them,  
 > you end up emitting the same vtables again and again, which is a  
 > waste of time, disk space, etc. Just as a reminder, IA64 .o files are  
 > not exactly small.

True enough.

 > Regarding the symbol spaces, did I misunderstand, or are you talking
 > about having some pathological case like (using Microsoft's notations
 > :-)

 > 	#if INCLUDED_FROM_FILE_1
 > 	__declspec(export)
 > 	#endif
 > 	inline void foo() { ... }

 > That's just a bad idea. There may be other cases I did not think of,  
 > but currently, I don't see this as a real issue.

Not exactly.  The idea is not that the function needs to be explicitly
imported, but that it is simply unavailable.  A customer of ours defines a
proxy class where the main functionality is in one shared object which does
not export the functions; the functionality of the class is only made
available through virtual function calls.  Our use of the heuristic caused
us to give an undefined symbol for a client's call to one of the class'
inline functions.

It may be that we don't want to support this practice, but it is something
to think about.

 >> A side issue: What do we want to do with dynamically-initialized
 >> variables?  The same thing, or use COMMON?  I propose COMMON.

 > The problem is that some compiler may be smarter at inlining that  
 > another, and figure out that it actually can initialize it  
 > statically. In that case, it cannot go into COMMON (or you force that  
 > smart compiler to not do that optimization for binary compatibility  
 > reasons...). For instance:

 > 	inline int f() { return 1; }
 > 	static int i = f();

 > What is the problem with COMMON?

Do you mean "with COMDAT" here?  There's no problem; it doesn't really
matter which you use.  If one implementation uses COMMON, and another uses
COMDAT, they will be combined by the linker (I think; does a weak symbol
take precedence over COMMON?)

This does bring up another issue; handling initialization.  g++ handles
initialization of a weak/COMDAT object by emitting a sentry along with it,
which gets set when the object has been initialized.

BTW, note that this really only applies to template static data members;
that's the only case where you would find a dynamically initialized
variable with comdat linkage.

 >> A side issue is how to handle local static variables in inlines.  G++ 
 >> currently avoids this issue by suppressing inlining of functions with 
 >> local statics.  If we don't want to do that, we'll need to specify a 
 >> mangling for the statics, and handle multiple copies like we do above. 

 > Side issue of side issue: you are also supposed to name string  
 > constants, because they are supposed to have the same address in  
 > different inline functions ([7.1.2]/4 :-)

Aha.  I guess there's no point in trying to avoid dealing with local
statics then.

Jason



From daveed at edg.com  Fri Jun 25 06:04:38 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 24 Jun 1999 23:04:38 -0700
Subject: Placement of vtables, inlines and such
References: <199906250014.RAA03552@cllmail.cup.hp.com> <u9so7gj1cs.fsf@yorick.cygnus.com>
Message-ID: <37731BF6.82DC3EFA@edg.com>

Jason Merrill wrote:
[...]
> No.  gc works by sweeping from main, finding all the referenced symbols;
> any sections that haven't provided any symbols are discarded.  If we use
> weak symbols for vtables and put them in separate sections, gc will keep at
> most one copy, as needed.  There is no notion of a special symbol.

How does this work in shared libraries? Is GC done at load time?

> gc is a more general solution, as it also can discard normal code that
> isn't actually needed.  It also allows us to discard all copies in cases
> where that is appropriate, such as when we can get the vtable from one of
> our shared libs. 

I guess that means the answer to the above is "yes"?

[...]
> This does bring up another issue; handling initialization.  g++ handles
> initialization of a weak/COMDAT object by emitting a sentry along with it,
> which gets set when the object has been initialized.

Do you thread-protect it? (just curious)

[...]
> Aha.  I guess there's no point in trying to avoid dealing with local
> statics then.

I'm afraid so. An idiom to protect against initialization order
dependencies is:
	inline X& x() {
		static X lx;
		return lx;
	}

(and use x() instead of a global x everywhere.)

I've seen increased usage of this and it would be nice if it could be
inlined.

	Daveed



From jason at cygnus.com  Fri Jun 25 06:14:52 1999
From: jason at cygnus.com (Jason Merrill)
Date: 24 Jun 1999 23:14:52 -0700
Subject: Placement of vtables, inlines and such
In-Reply-To: Daveed Vandevoorde's message of "Thu, 24 Jun 1999 23:04:38 -0700"
References: <199906250014.RAA03552@cllmail.cup.hp.com> <u9so7gj1cs.fsf@yorick.cygnus.com> <37731BF6.82DC3EFA@edg.com>
Message-ID: <u9bte4iz6r.fsf@yorick.cygnus.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 > Jason Merrill wrote:
 >> No.  gc works by sweeping from main, finding all the referenced symbols;
 >> any sections that haven't provided any symbols are discarded.  If we use
 >> weak symbols for vtables and put them in separate sections, gc will keep at
 >> most one copy, as needed.  There is no notion of a special symbol.

 > How does this work in shared libraries? Is GC done at load time?

As I understand it, yes.

 >> This does bring up another issue; handling initialization.  g++ handles
 >> initialization of a weak/COMDAT object by emitting a sentry along with it,
 >> which gets set when the object has been initialized.

 > Do you thread-protect it? (just curious)

Nope.  We don't currently do anything to thread-protect initializers.

Jason



From ddd at cup.hp.com  Fri Jun 25 17:26:59 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 25 Jun 1999 10:26:59 -0700
Subject: A customer opinion on thread protection of static initialization
Message-ID: <199906251727.KAA10656@cllmail.cup.hp.com>

We received a message, a couple of days ago, discussing a bug in our  
static initialization scheme with shared libraries. Here is an  
interesting snippet.

| (BTW, don't take this as a criticism of aCC.  In fact, aCC  
generally does a
| very good job on this front.  For example, it's one of the few  
applications I
| know of that generates thread-safe code to guard local static  
initializers.
| That's one reason I'm surprised it has the limitation being  
discussed here.)

I did not make this up :-)
Christophe



From dehnert at sgi.com  Fri Jun 25 21:08:53 1999
From: dehnert at sgi.com (Jim Dehnert)
Date: Fri, 25 Jun 1999 22:08:53 +0100
Subject: C++ ABI Summary
Message-ID: <3773EFE5.CEBD0041@sgi.com>

I have updated the documents to reflect the meeting, including
moving closed issues to a new document.  Please check them over,
especially A-9, where I attempted a precise write-up, and of
course might have gotten it wrong.

I will later attempt to incorporate some of the email discussion
that has been going on.
-- 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990625/d4773338/attachment.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990625/d4773338/attachment-0001.html>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/19990625/d4773338/attachment-0002.html>

From jason at cygnus.com  Sat Jun 26 07:26:40 1999
From: jason at cygnus.com (Jason Merrill)
Date: 26 Jun 1999 00:26:40 -0700
Subject: C++ ABI Summary
In-Reply-To: Jim Dehnert's message of "Fri, 25 Jun 1999 22:08:53 +0100"
References: <3773EFE5.CEBD0041@sgi.com>
Message-ID: <u9pv2jh173.fsf@yorick.cygnus.com>

BTW, I'll be on vacation next week.  Let me know what happens at the
meeting.

Jason



From dehnert at baalbek.engr.sgi.com  Tue Jun 29 06:15:07 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 28 Jun 1999 23:15:07 -0700 (PDT)
Subject: Placement of vtables, inlines and such
Message-ID: <199906290615.XAA61829@baalbek.engr.sgi.com>

A variety of questions and observations on this thread...

> From: Jason Merrill <jason at cygnus.com>
> Date: 24 Jun 1999 04:36:42 -0700
> 
> 1) Emit them everywhere and only use one.
> 2) Use some heuristic to decide where to emit them.
> 3) Use a database to decide where to emit them.
> 4) Generate them at link time.
> 
> #3 and #4 are feasible for templates, but I consider them too heavyweight
> to be used for other things.

Does that remain true if you're already using them for templates?
> 
> The way to handle this in standard ELF is weak symbols.  If all definitions
> are marked weak, the linker will choose one and the others will just sit
> there taking up space.

It has become apparent in the base IA-64 ABI discussions that weak
symbols are problematic.  Different vendors treat them differently,
both in terms of whether they cause archive objects to be extracted,
and in terms of how they are handled in DSOs (some vendors treat them
like normal globals once linked, some also defer to non-weak at
runtime.)

> Christophe mentioned the other day that the HP compiler used the typical
> heuristic above, and handled the case of different results by encoding the
> key function in the vtable name.  But this seems unnecessary when we can
> just choose one of multiple defns.

It would be helpful to me if someone would describe the "typical
heuristic" (or any heuristic being used).

> The GNU ELF toolchain does a variant of #1 here; any sections with names
> beginning with ".gnu.linkonce." are treated as COMDAT sections.  It seems
> more sensible to me to key off of the section name than the first symbol
> name as in PE.

Keying off section names is evil.  If we're going to use (the
equivalent of) COMDAT sections, let's mark them with a section header
flag.

> I further propose that we not use heuristics to cut down the number of
> copies ahead of time; they usually work fine, but can cause problems in
> some situations, such as when not all of the class's members are in the
> same symbol space.

What do you mean by the same symbol space?

> Does the ia64 ABI provide for controlling which symbols
> are exported from a shared library?

Yes.  We have changed the gABI to add an export class to the symbol
record (in st_other).  The compiler (or linker) may mark a symbol
PROTECTED, preventing preemption, or HIDDEN, preventing export.
(The latter is converted to LOCAL binding at link time.)

> A side issue: What do we want to do with dynamically-initialized variables?
> The same thing, or use COMMON?  I propose COMMON.

COMMON is another problem, due to different treatment across DSOs by
different vendors.  But I don't really know what you're suggesting
here.  What is the issue with dynamically-initialized variables?  There
should still be a unique definition, shouldn't there?  (Except in cases
which have nothing to do with the dynamic definition, like statics in
inlines, classes, etc.)  So COMMON doesn't seem to help.  Furthermore,
if you were to optimize an initialization that were partially static,
you can't use COMMON, which doesn't have iniital values.
> 
> Jason


> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> From: Jason Merrill <jason at cygnus.com>
>
> I don't know if catching a problem  
> "sometimes" is better than "never", or if it is actually worse...

Usually better, I'd say...

> It looks to me like garbage collection requires one extra operation,  
> namely selecting the "blessed" symbol that will not be discarded,  
> right? Isn't that some other form of COMDATing? In other words, isn't  
> garbage collection just an additional optimization which may be  
> placed on top of COMDATs?
> 
> 
> > I further propose that we not use heuristics to cut down the number of 
> > copies ahead of time; they usually work fine, but can cause problems in 
> > some situations, such as when not all of the class's members are in the 
> > same symbol space.
> 
> As you said, "they usually work fine".

Again, could I please have an explanation of what the heuristics being
discussed are, and what "usually" means?

> The problem is that some compiler may be smarter at inlining that  
> another, and figure out that it actually can initialize it  
> statically. In that case, it cannot go into COMMON (or you force that  
> smart compiler to not do that optimization for binary compatibility  
> reasons...). For instance:
> 
> 	inline int f() { return 1; }
> 	static int i = f();

We would certainly inline this one...

> Christophe


> From: Jason Merrill <jason at cygnus.com>
> 
>  If one implementation uses COMMON, and another uses
> COMDAT, they will be combined by the linker (I think; does a weak symbol
> take precedence over COMMON?)

Depends on the vendor, and on whether they are in the same DSO.  Yecch.
> 
> Jason


> From: Daveed Vandevoorde <daveed at edg.com>
> 
> Jason Merrill wrote:
> [...]
> > No.  gc works by sweeping from main, finding all the referenced symbols;
> > any sections that haven't provided any symbols are discarded.  If we use
> > weak symbols for vtables and put them in separate sections, gc will keep at
> > most one copy, as needed.  There is no notion of a special symbol.
> 
> How does this work in shared libraries? Is GC done at load time?
> 
> > gc is a more general solution, as it also can discard normal code that
> > isn't actually needed.  It also allows us to discard all copies in cases
> > where that is appropriate, such as when we can get the vtable from one of
> > our shared libs. 
> 
> I guess that means the answer to the above is "yes"?

I don't think you can do GC at load time.  However, at that point, the
extra copies should disappear by virtue of preemption, if you've done
it all with exported global symbols.

> 	Daveed

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Jun 29 06:24:23 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 28 Jun 1999 23:24:23 -0700 (PDT)
Subject: Placement of vtables, inlines and such
Message-ID: <199906290624.XAA60970@baalbek.engr.sgi.com>

Another observation regarding the heuristic vs. COMDAT choice...
Modulo not knowing what the heuristics in question are, it seems to me
that, if the ABI specifies COMDAT processing it will always work with
nothing further, and if it's safe an implementation could still elide
(some of) the unnecessary copies (which probably requires ABI
identification of the required copy), but wouldn't need to.

Also, along with the COMDAT choice, we would also want to make sure
there was a mechanism available to also eliminate duplicate copies of
associated information like debug sections.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Jun 29 07:50:20 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 29 Jun 1999 00:50:20 -0700 (PDT)
Subject: Issue summaries
Message-ID: <199906290750.AAA61808@baalbek.engr.sgi.com>

Could I please get summaries of the following issues:

Christophe: A-6

Ian: A-11

Mike Ball: A-12, C-4, C-5, C-6, G-2

John W.: E-2

Priti:  How's the release of the Intel exception model description coming?
Since this potentially affects the unwind table contents, I think it's
important not to delay discussing it too long.

Daveed:  Are you looking at the dynamic_cast/inaccessible base description?

-		Jim Dehnert  x3-4272



From daveed at edg.com  Tue Jun 29 14:50:55 1999
From: daveed at edg.com (Daveed Vandevoorde)
Date: Tue, 29 Jun 1999 07:50:55 -0700
Subject: Issue summaries
References: <199906290750.AAA61808@baalbek.engr.sgi.com>
Message-ID: <3778DD4F.624E9256@edg.com>

Jim Dehnert wrote:
[...]
> Daveed:  Are you looking at the dynamic_cast/inaccessible base description?

I intend to, though I still haven't written up anything.

	Daveed



From ddd at cup.hp.com  Tue Jun 29 18:06:03 1999
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 29 Jun 1999 11:06:03 -0700
Subject: Placement of vtables, inlines and such
Message-ID: <199906291806.LAA02847@cllmail.cup.hp.com>

From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)

> Another observation regarding the heuristic vs. COMDAT choice...
> Modulo not knowing what the heuristics in question are, it seems to me 
> that, if the ABI specifies COMDAT processing it will always work with 
> nothing further, and if it's safe an implementation could still elide 
> (some of) the unnecessary copies (which probably requires ABI
> identification of the required copy), but wouldn't need to.
>
> Also, along with the COMDAT choice, we would also want to make sure 
> there was a mechanism available to also eliminate duplicate copies of 
> associated information like debug sections.

First, the "usual" heuristic (which is usual because it dates back  
to Cfront) is to emit vtables in the translation unit that contains  
the definition of the first non inline, non pure virtual function.  
That is, for:

	struct X {
		void a();
		virtual void f() { return; }
		virtual void g() = 0;
		virtual void h();
		virtual void i();
	};

the vtable is emitted only in the TU that contains the definition of h().

This breaks and becomes non-portable if:
- There is no such thing. In that case, you generally emit duplicate  
versions of vtables
- There is a "change of mind", such as having the above class followed by:

	inline void X::h() { f(); }



Now, the COMDAT issue is as follows: a COMDAT section is, in some  
cases, slightly more difficult to handle (at least, that's the  
impression Jason gave me). For statics with runtime initialization,  
what you can do is reserve COMMON space ('easier'), then initialize  
that space at runtime. As I said, the problem is if two compilers  
disagree on whether this is a runtime or a compile time  
initialization, such as in :

	inline int f() { return 1; }
	int x = f();			// Static (COMDAT) or  
Dynamic (COMMON) initialization?

So I personally recommend that we put everything in COMDAT.

Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Tue Jun 29 20:22:02 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 29 Jun 1999 13:22:02 -0700 (PDT)
Subject: Placement of vtables, inlines and such
Message-ID: <199906292022.NAA62972@baalbek.engr.sgi.com>

Thanks for the explanations, Christophe.

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> Now, the COMDAT issue is as follows: a COMDAT section is, in some  
> cases, slightly more difficult to handle (at least, that's the  
> impression Jason gave me). For statics with runtime initialization,  
> what you can do is reserve COMMON space ('easier'), then initialize  
> that space at runtime. As I said, the problem is if two compilers  
> disagree on whether this is a runtime or a compile time  
> initialization, such as in :
> 
> 	inline int f() { return 1; }
> 	int x = f();			// Static (COMDAT) or  
> Dynamic (COMMON) initialization?
> 
> So I personally recommend that we put everything in COMDAT.

I may be slow, but I think I'm finally understanding :-).
I was looking for too much.  I gather now that the "COMMON" solution
isn't really a different solution, it's just the observation that, if
there is no static initialization, COMMON serves the same purpose as
COMDAT.  Correct?  In that case, as Christophe proposes, COMDAT by
itself is clearly adequate (and COMMON by itself is not, unless we
require dynamic initialization, which seems objectionable).

Given a COMDAT-based ABI, for objects without any static initialization,
one could emit a COMMON symbol instead or an "empty" COMDAT, and either
would be suitable.  There are a couple of reasons one might prefer
COMMON:

  - If there are enough with only dynamic (or no) initialization to be
    of concern, a COMMON symbol is much lighter-weight in the object
    than a section, especially if the object is large.

  - If one were concerned about different compilers making different
    initialization decisions (e.g. due to inlining), one would
    presumably define the COMMON symbol as being preempted by the
    COMDAT symbol (which I envision as just a normal GLOBAL symbol with
    a flag).

The second point touches on Christophe's earlier concern about
compilers and inlining.  It will partially solve the problem -- given
objects from one compiler which does all the initialization
dynamically, and another which does some or all of it statically, the
COMDAT from the latter will preempt the COMMON from the former, and
whichever dynamic initializer is actually chosen will work.

However, if both compilers initialize some of the data statically, but
not the same part, they will both produce COMDAT sections, but
different ones, and it becomes important that the initializer chosen
match the COMDAT instance chosen.  One solution would be to associate
the initializer with the COMDAT.  Another would be to mark which parts
of the COMDAT contain valid initialization and have the linker merge
the non-overlapping parts.  In any case, we should worry about this
if we decide to use COMDAT.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jun 30 07:07:15 1999
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Jun 1999 00:07:15 -0700 (PDT)
Subject: Issue summaries and status
Message-ID: <199906300707.AAA64874@baalbek.engr.sgi.com>

Attached are the current summary, open, and closed lists.  Note that
I've incorporated some of the edited email into the open issues list.
Let me know if I've screwed anything up...

-------------- next part --------------
<HTML>

<HEAD>
<title>C++ ABI Summary</title>

<link rel=stylesheet href=small-table.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Summary
</b></i></font>

<p>
<i>Revised 28 June 1999</i>

</center>

</HEAD>

<BODY>

<p>
See also the full
<a href=cxx-open.html>Open</a> and
<a href=cxx-closed.html>Closed</a> issues lists.

<p>
<hr>

<p>
<h4>Meetings</h4>

<p>
<table align=center border=on cellpadding=3>

<tr class=small>
<th colspan=2> When </th>
<th> Where </th>
<th> Phone </th>
</tr>

<tr class=small>
<td> 24 June </td> <td> 10:00-12:00 PDT </td>
<td align=left colspan=2> completed </td>
</tr>

<tr class=small>
<td> 1 July </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 8 July </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 15 July </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 22 July </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 29 July </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 5 August </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 12 August </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

<tr class=small>
<td> 19 August </td>
<td> 10:00-12:00 PDT </td>
<td> SGI Sapphire 20L </td>
<td> 650-933-7976 </td>
</tr>

</table>

<p>
Note:  When calling the SGI telephone bridges,
the first caller continues to ring until the second party joins.
To get rid of it, you can call from a second phone,
and I believe you can hang it up right away.

<p>
<hr>

<p>
<h4>Participants</h4>

<p>
<table border=on cellpadding=3>

<tr class=small>
<th> Company </th>
<th> Name </th>
<th> Telephone </th>
<th> Fax </th>
<th> Email </th>
</tr>

<tr class=tiny>
<th rowspan=1> </th>
<td colspan=3> overall reflector </td>
<td> <a href=mailto:cxx-abi at postofc.corp.sgi.com>cxx-abi at corp.sgi.com</a> </td>
</tr>

<tr class=tiny>
<th rowspan=6> SGI </th>
<td> Jim Dehnert </td>
<td> (650) 933-4272 </td>
<td> (650) 932-4272 </td>
<td> <a href=mailto:dehnert at sgi.com> dehnert at sgi.com </a></td>
</tr>
<tr class=tiny>
<td> Matt Austern </td>
<td> (650) 933-4196 </td>
<td> (650) 932-4196 </td>
<td> <a href=mailto:austern at engr.sgi.com> austern at engr.sgi.com </a></td>
</tr>
<tr class=tiny>
<td> Hans Boehm </td>
<td> (650) 933-7144 </td>
<td> (650) 932-7144 </td>
<td> <a href=mailto:boehm at engr.sgi.com> boehm at engr.sgi.com </a></td>
</tr>
<tr class=tiny>
<td> Shin-Ming Liu </td>
<td> (650) 933-4287 </td>
<td> (650) 932-4287 </td>
<td> <a href=mailto:shin at engr.sgi.com> shin at engr.sgi.com </a></td>
</tr>
<tr class=tiny>
<td> John Wilkinson </td>
<td> (650) 933-4298 </td>
<td> (650) 932-4298 </td>
<td> <a href=mailto:jfw at engr.sgi.com> jfw at engr.sgi.com </a></td>
</tr>
<tr class=tiny>
<td colspan=3> reflector </td>
<td> <a href=mailto:cxx-abi-sgi at engr.sgi.com>
cxx-abi-sgi at engr.sgi.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=4> Cygnus </th>
<td> Jason Merrill </td>
<td> (408) 542-9665 </td>
<td> (408) 542-9765 </td>
<td> <a href=mailto:jason at cygnus.com> jason at cygnus.com </a></td>
</tr>
<tr class=tiny>
<td> Ian Carmichael </td>
<td> (416) 482-3946 </td>
<td> (416) 482-6299 </td>
<td> <a href=mailto:iancarm at cygnus.com> iancarm at cygnus.com </a></td>
</tr>
<tr class=tiny>
<td> Ulrich Drepper </td>
<td> (408) 765-4699 </td>
<td> ? </td>
<td> <a href=mailto:drepper at cygnus.com> drepper at cygnus.com </a></td>
</tr>
<tr class=tiny>
<td colspan=3> reflector </td>
<td> <a href=mailto:c++abi at cygnus.com> c++abi at cygnus.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=1> EDG </th>
<td> Daveed Vandevoorde </td>
<td> ? </td>
<td> ? </td>
<td> <a href=mailto:daveed at edg.com> daveed at edg.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=1> EPC </th>
<td> Colin McPhail </td>
<td> +44 (131) 225-6262 </td>
<td> +44 (131) 225-6644 </td>
<td> <a href=mailto:colin at epc.co.uk> colin at epc.co.uk </a></td>
</tr>

<tr class=tiny>
<th rowspan=4> Hewlett- Packard </th>
<td> Cary Coutant </td>
<td> (408) 447-5759 </td>
<td> ? </td>
<td> <a href=mailto:cary at cup.hp.com> cary at cup.hp.com </a></td>
</tr>
<tr class=tiny>
<td> Christophe de Dinechin </td>
<td> (408) 447-5491 </td>
<td> ? </td>
<td> <a href=mailto:ddd at cup.hp.com> ddd at cup.hp.com </a></td>
</tr>
<tr class=tiny>
<td> Sassan Hazeghi </td>
<td> (408) 447-5007 </td>
<td> ? </td>
<td> <a href=mailto:sassan at cup.hp.com> sassan at cup.hp.com </a></td>
</tr>
<tr class=tiny>
<td colspan=3> reflector </td>
<td> <a href=mailto:cxx-abi-hp at cllmail.cup.hp.com>
cxx-abi-hp at cllmail.cup.hp.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=3> IBM </th>
<td> Mark Mendell </td>
<td> (416) 448-3485 </td>
<td> (416) 448-4414 </td>
<td> <a href=mailto:mendell at ca.ibm.com> mendell at ca.ibm.com </a></td>
</tr>
<tr class=tiny>
<td> Allan H. Kielstra </td>
<td> (416) 448-3558 </td>
<td> (416) 448-4414 </td>
<td> <a href=mailto:kielstra at ca.ibm.com> kielstra at ca.ibm.com </a></td>
</tr>
<tr class=tiny>
<td colspan=3> reflector </td>
<td> <a href=mailto:CxxABI-ADTC-CAN at ca.ibm.com>
CxxABI-ADTC-CAN at ca.ibm.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=4> Intel </th>
<td> Sunil Saxena </td>
<td> (408) 765-5272 </td>
<td> (408) 653-8511 </td>
<td> <a href=mailto:Sunil.Saxena at Intel.com> Sunil.Saxena at Intel.com </a></td>
</tr>
<tr class=tiny>
<td> Suresh Rao </td>
<td> (408) 765-5416 </td>
<td> (408) 765-5165 </td>
<td> <a href=mailto:Suresh.K.Rao at Intel.com>
Suresh.K.Rao at Intel.com </a></td>
</tr>
<tr class=tiny>
<td> Priti Shrivastav </td>
<td> (408) 765-4699 </td>
<td> (408) 765-5165 </td>
<td> <a href=mailto:Priti.Shrivastav at Intel.com>
Priti.Shrivastav at Intel.com </a></td>
</tr>
<tr class=tiny>
<td colspan=3> reflector </td>
<td> <a href=mailto:cxx-abi at unix-os.sc.intel.com>
cxx-abi at unix-os.sc.intel.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=1> SCO </th>
<td> Jonathan Schilling </td>
<td> (908) 790-2364 </td>
<td> (908) 790-2426 </td>
<td> <a href=mailto:jls at sco.com> jls at sco.com </a></td>
</tr>

<tr class=tiny>
<th rowspan=4> Sun </th>
<td> George Vasick </td>
<td> (650) 786-5123 </td>
<td> (650) 786-9551 </td>
<td> <a href=mailto:george.vasick at eng.sun.com>
george.vasick at eng.sun.com <a></td>
</tr>
<tr class=tiny>
<td> Michael Lam </td>
<td> (650) 786-3492 </td>
<td> (650) 786-9551 </td>
<td> <a href=mailto:michael.lam at eng.sun.com> michael.lam at eng.sun.com </a></td>
</tr>
<tr class=tiny>
<td> Michael Ball </td>
<td> (650) 786-9109 </td>
<td> (650) 786-9551 </td>
<td> <a href=mailto:michael.ball at eng.sun.com> michael.ball at eng.sun.com </a></td>
</tr>
<tr class=tiny>
<td> Reza Monajjemi </td>
<td> (650) 786-6175 </td>
<td> ? </td>
<td> <a href=mailto:reza.monajjemi at eng.sun.com>
     reza.monajjemi at eng.sun.com </a></td>
</tr>

</table>

<p>
<hr>

<p>
<h4> Objectives </h4>

<ul>
<p>
<li>
Interoperable C++ compilation on IA-64:
we want users to be able to build relocatable objects with
different compilers and link them together,
and if possible even to ship common DSOs.
This objective implies agreement on:
    <ul>    
    <li> Data representation
    <li> Object file representation
    <li> Library API
    </ul>

<p>
<li>
ISO Standard C++:
highest priority is functionality and performance of standard-compliant code.
It should not be sacrificed for the benefit of language extensions or
legacy implementations (though considering them as tie-breakers is fine).

<p>
<li>
Some areas will be easier to agree on than others.
Our priorities should be based on achieving as much
interoperability as possible if we can't attain perfection.
That is, it is better to end up with a few restrictions being required
for interoperable code, than to have no interoperability at all.
This suggests priorities as follows:
    <ol>
    <li> Items requiring base ABI changes that might affect other
	languages, and will therefore become impossible soon.
	Examples include exception handling / stack unwind,
	or ELF changes (not extensions).
    <li> Core features where differences will prevent virtually any
	C++ object code from porting.
	Examples include data layout and calling conventions.
    <li> Limited usage features,
	where users can achieve portability by avoiding the feature.
	An example might be multi-threading.
    <li> Peripheral features,
	where the requirements on users to achieve
	portability are clear and easy to implement.
	An example is non-explicit inlining,
	where compilers would presumably allow it to just be suppressed.
    <li> Tool interfaces, which affect how users build code,
	rather than what they build.
	An example is the compilation command line.
    </ol>

<p>
<li>
Mechanisms/methods which allow coexistence of incompatible
implementations may be suitable in some cases.
For instance, packaging vendor-specific compiler support runtimes
in DSOs occupying distinct namespaces might allow multiple such DSOs to
be loaded for mixed objects and avoid requiring that all vendors have
the same support runtimes.

</ul>

<p>
<hr>

<p>
<h4> Action Item Status </h4>

<p>
<table border=on cellpadding=3>

<tr class=small>
<th> # </th>
<th> Action </th>
<th> Who </th>
<th> Status </th>
<th> Opened </th>
<th> Closed </th>
</tr>

<tr class=small> <td> 1 </td>
<td> Distribute Sun C++ ABI </td>
<td> Mike Ball </td>
<td> open </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> 2 </td>
<td> Distribute Sun C++ ABI Rationale </td>
<td> Mike Ball </td>
<td> open </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> 3 </td>
<td> Distribute Taligent C++ ABI </td>
<td> Cary Coutant </td>
<td> open </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> 4 </td>
<td> Expedite IA-64 RT Arch doc release </td>
<td> Cary Coutant </td>
<td> open </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> 5 </td>
<td> Set up n-way NDA for eligible members </td>
<td> Priti Shrivastav </td>
<td> open </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> 6 </td>
<td> Organize/summarize object layout issues and alternatives </td>
<td> Matt Austern </td>
<td> closed </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> 7 </td>
<td> Write-up of Vtable issues,
     including Vtable layout, Vfunc call protocol
</td>
<td> Christophe de Dinechin </td>
<td> open </td>
<td> 990610 </td>
<td> </td>
</tr>

<tr class=small> <td> 8 </td>
<td> Write-up of object layout strawman </td>
<td> Matt Austern </td>
<td> closed </td>
<td> 990610 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> 9 </td>
<td> Check with c++-core about empty base placement </td>
<td> Jason Merrill </td>
<td> open </td>
<td> 990610 </td>
<td> 990618 </td>
</tr>

<tr class=small> <td> 10 </td>
<td> Describe dynamic cast / inaccessible base issue </td>
<td> Daveed Vandevoorde </td>
<td> open </td>
<td> 990617 </td>
<td> </td>
</tr>

<tr class=small> <td> 11 </td>
<td> Summarize ctor/dtor issues </td>
<td> Michael Lam </td>
<td> open </td>
<td> 990617 </td>
<td> </td>
</tr>

<tr class=small> <td> 12 </td>
<td> Describe Intel exception model </td>
<td> Priti Shrivastav </td>
<td> open </td>
<td> 990624 </td>
<td> </td>
</tr>


</table>

<p>
<hr>

<p>
<h4> Issue Status </h4>

In the following table,
the <b><i>class</i></b> column attempts to classify the issue on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr class=small> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr class=small> <td> data </td>
<td> Data layout </td>
</tr>

<tr class=small> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr class=small> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr class=small> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr class=small> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr class=small> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr class=small> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p>
<hr width=50%>

<p>
<table border=on cellpadding=3>

<tr class=small>
<th> # </th>
<th> Issue </th>
<th> Class </th>
<th> Status </th>
<th> Source </th>
<th> Opened </th>
<th> Closed </th>
</tr>

<tr class=small> </tr>
<tr class=small> <th> A </th>
<th colspan=6> <a href=issues-C++-layout.html> Object Layout </a> </th>
</tr>

<tr class=small> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> A-3 </td>
<td> Multiple inheritance </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> A-5 </td>
<td> Empty parameters </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> A-6 </td>
<td> RTTI (<code>type_info</code>) .o representation </td>
<td> data call ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> A-7 </td>
<td> Vptr sharing with primary base class </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> A-9 </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>

<tr class=small> <td> A-10 </td>
<td> Class parameters in registers </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> A-11 </td>
<td> Representation of pointers to members </td>
<td> data </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> A-12 </td>
<td> Merging secondary vtables </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990610 </td>
<td> </td>
</tr>

<tr class=small> <td> A-13 </td>
<td> Parameter struct field promotion </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> </tr>
<tr class=small> <th> B </th>
<th colspan=6> <a href=issues-C++-layout.html#vfunc>
Virtual Function Handling </a> </th>
</tr>

<tr class=small> <td> B-1 </td>
<td> Adjustment of "this" pointer (e.g. thunks) </td>
<td> data call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> B-2 </td>
<td> Covariant return types </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> B-3 </td>
<td> Allowed caching of vtable contents </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> B-4 </td>
<td> Function descriptors in vtable </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> B-5 </td>
<td> Where are vtables emitted? </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> B-6 </td>
<td> Virtual function table layout </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> B-7 </td>
<td> Vtables in shared memory </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990624 </td>
<td> </td>
</tr>

<tr class=small> <td> B-8 </td>
<td> dynamic_cast </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990628 </td>
<td> </td>
</tr>


<tr class=small> </tr>
<tr class=small> <th> C </th>
<th colspan=6> Object Construction/Destruction </th>
</tr>

<tr class=small> <td> C-1 </td>
<td> Interaction with .init/.fini </td>
<td> lif ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> C-2 </td>
<td> Order of ctors/dtors w.r.t. link </td>
<td> lif ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> C-3 </td>
<td> Order of ctors/dtors w.r.t. DSOs </td>
<td> ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> C-4 </td>
<td> Calling vfuncs in ctors/dtors </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> C-5 </td>
<td> Calling virtual destructors </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> C-6 </td>
<td> Extra parameters to ctors/dtors </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> C-7 </td>
<td> Passing value parameters by reference </td>
<td> call </td>
<td> open </td>
<td> All </td>
<td> 990625 </td>
<td> </td>
</tr>

<tr class=small> <td> C-8 </td>
<td> Returning classes with non-trival copy constructors </td>
<td> call </td>
<td> open </td>
<td> All </td>
<td> 990625 </td>
<td> </td>
</tr>


<tr class=small> </tr>
<tr class=small> <th> D </th>
<th colspan=6> Exception Handling </th>
</tr>

<tr class=small> <td> D-1 </td>
<td> Language-specific data area format </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> D-2 </td>
<td> Unwind personality routines </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> D-3 </td>
<td> Unwind process clarification </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> D-4 </td>
<td> Unwind routines nested? </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> D-5 </td>
<td> Interaction with other languages (e.g. Java) </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> D-6 </td>
<td> Allow resumption in other languages? </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> D-7 </td>
<td> Interaction with signals or asynch events </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> D-8 </td>
<td> Interaction with threads packages </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990603 </td>
<td> </td>
</tr>


<tr class=small> </tr>
<tr class=small> <th> E </th>
<th colspan=6> Template Instantiation Model </th>
</tr>

<tr class=small> <td> E-1 </td>
<td> When does instantiation occur? </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> E-2 </td>
<td> Separate compilation model </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> E-3 </td>
<td> Template repository </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>


<tr class=small> </tr>
<tr class=small> <th> F </th>
<th colspan=6> Name Mangling </th>
</tr>

<tr class=small> <td> F-1 </td>
<td> Mangling convention </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> F-2 </td>
<td> Mangled name size </td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>

<tr class=small> <td> F-3 </td>
<td> Distinguish template instantiation and specialization
</td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>


<tr class=small> </tr>
<tr class=small> <th> G </th>
<th colspan=6> Miscellaneous </th>
</tr>

<tr class=small> <td> G-1 </td>
<td> Basic command line options </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> G-2 </td>
<td> Detection of 1-def rule violations </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> G-3 </td>
<td> Inlined routine linkage </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>

<tr class=small> <td> G-4 </td>
<td> Dynamic init of local static objects and multithreading </td>
<td> call </td>
<td> open </td>
<td> SCO </td>
<td> 990607 </td>
<td> </td>
</tr>

<tr class=small> </tr>
<tr class=small> <th> H </th>
<th colspan=6> Runtime Library Interface </th>
</tr>

<tr class=small> <td> H-1 </td>
<td> Runtime library DSO name </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>

<tr class=small> <td> H-1 </td>
<td> Runtime library API </td>
<td> lif </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>


</table>

<p>
<hr>

<p>
<h4>Notes from 3 June 1999 </h4>

<ul>
<p>
<li> Introductions

<p>
<li> Objectives: see above

<p>
<li> Procedure

  <ul>
  <li> Meetings:  10-12 Thursdays at SGI for the near term.
  <li> Intel NDA:  Generally unnecessary.  Priti will set up n-way
       for eligible members for cases where needed.  Cary expects RT
       architecture/software conventions document to be released in the
       next month or two, removing most of the issues.
  <li> Communication:  Use of reflector encouraged for discussion.
       NDA communication will be handled with password-protected PDF
       once Intel sets up n-way.
  <li> Available documents:  Parties with existing, relevant documents
       (includes Sun, HP) will send them to group.
  <li> Intellectual property:  Participants don't expect problems with
       release of any of their IP.  Microsoft has extensive patents in
       the area, but they are excessively broad (covering obvious ideas
       and prior art), so expectation is that they are not a problem.
       Nonetheless, we should be aware of them.
  </ul>

<p>
<li> Issue Identification:  new issues reflected in status table.

</ul>

<p>
<h4>Notes from 10 June 1999 </h4>

<p>
Matt Austern presented an initial assessment of the object layout issues.
He categorized them as trivial
(requiring agreement, but without significant performance implications)
or significant.  The trivial issues are:

<ol>
<p>
<li> (A-1) Where is the Vptr stored in an object?
Given the absence of addressing modes with displacements on IA-64,
the consensus is at the beginning of the object.

<p>
<li> (A-9) What is the order of members in an object?
Discussion of the possibilities for reordering between access
specifications suggests that we might find significance here.

<p>
<li> (A-4) Empty base class optimization:
when can an empty base class be stored at the same offset as another member?

<p>
<li> (A-1) What is the order of the Vtable?

<p>
<li> (B-5) What is the external name of a global Vtable?

<p>
<li> (B-5) Where is a global Vtable emitted?

</ol>

<p>
The significant issues are:

<ol>
<p>
<li> (A-3) How are virtual functions handled given multiple inheritance?
That is, where is the "this" pointer adjusted?

<p>
<li> (A-2) How are virtual functions handled given virtual base types?

<p>
<li> (B-2) How are virtual functions with covariant return types handled?
That is, where is the result pointer adjusted?

<p>
<li> (A-6) How does RTTI interact with exceptions?

</ol>

<p>
<h4>Notes from 17 June 1999 </h4>

<p>
<b> Issues A-1, A-2, A-9</b> (Matt):
See the open issues list.

<p>
<b> Actions</b>:
Christophe will write a Vtable layout definition strawman,
including a description of covariant returns,
and more generally the virtual function protocol.
Daveed will write up the issue with dynamic casts and inaccessible bases.

<p>
Michael Lam will write summaries for the ctor/dtor issues for next week.

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert at sgi.com>Jim Dehnert</a>.


</BODY>
</HTML>
-------------- next part --------------
<HTML>

<HEAD>
<title>C++ ABI Open Issues</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Open Issues
</b></i></font>

<font size=-1>
<p>
<i>Revised 28 June 1999</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[990625]</font>
Closed A-1, A-2, A-4, A-8, A-9.
Additions to A-3, A-5, A-7, B-4, B-5, B-7, G-3, G-4.
New issues B-6, B-7, B-8, C-7, C-8.

<p>
<font color=blue>[990616]</font>
Added HP summaries.
Added sketchy notes from 990610 discussions (A and B issues).
A-10 was intended by HP as something different than I described,
so it was renamed, and a new issue A-13 opened as an SGI issue.
HP did not submit A-12, so relabeled as Sun's (is that right?).
Added library interface issues, H-1 and H-2.


<p> <hr> <p>
<h3> Definitions </h3>

<p>
The issues below make use of the following definitions:

<dl>

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)

<p>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class, the objects of which contain only a Vptr.

<p>
<dt> <i>vague linkage</i> </dt>
<dd>
The treatment of entities --
e.g. inline functions, templates, vtables --
with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.

</dl>


<p> <hr> <p>
<h3> Issue Status </h3>

In the following sections,
the <b><i>class</i></b> of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr> <td> data </td>
<td> Data layout </td>
</tr>

<tr> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p> <hr> <p>
<h3> Object Layout Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where is the Vptr stored in an object (first or last are the usual answers).
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
</td> </tr>

</table>

<p>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-3 </td>
<td> Multiple inheritance </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the class layout in the presence of multiple base classes.
</td> </tr>

</table>

<p>
<font color=blue>[990617 All]</font>
At offset zero is the Vptr whenever there is one,
as well as the primary base class if any (see A-7).
Also at offset zero is any number of empty base classes,
as long as that does not place multiple subobjects of the same type at
the same offset.
If there are multiple empty base classes such that placing two of them
at offset zero would violate this constraint, the first is placed there.
(First means in declaration order.)

<p>
All other non-virtual base classes are laid out in declaration order at
the beginning of the class.
All other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

<p>
The above ignores issues of padding for alignment,
and possible reordering of class members to fit in padding areas.
See issue A-9.

<p>
<font color=blue>[990624 All]</font>
There remains an issue concerning the selection of the primary base
class (see A-7), but we are otherwise in agreement.
We will attempt to close this on 1 July, modulo A-7.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are empty base classes allocated?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-5 </td>
<td> Empty parameters </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When passing a parameter with an empty class type by value,
what is the convention?
</td> </tr>

</table>

<p>
<font color=blue>[990623 SGI]</font>
We propose that no parameter slot be allocated to such parameters,
i.e. that no register be used,
and that no space in the parameter memory sequence be used.
This implies that the callee must allocate storage at a unique address
if the address is taken (which we expect to be rare).

<p>
<font color=blue>[990624 All]</font>
In addition to the address-taken case,
care is required if the object has a non-trivial copy constructor.
HP observes that in (some?) such cases,
they perform the construction at the call site and pass the object by
reference.

<p>
<font color=blue>[990625 SGI -- Jim]</font>
I understand that the Standard explicitly allows elimination of
even non-trivial copy construction in some cases.
Is this one of them?  Where should I look?
Also, of course, varargs processing for elided empty parameters would
need to be careful.

<p>
I have opened a new issue (C-7) for passing copy-constructed
parameters by reference.
Since doing so would turn an empty value parameter
into a non-empty reference parameter,
this issue can ignore such cases.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-6 </td>
<td> RTTI (<code>type_info</code>) .o representation </td>
<td> data call ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Christophe]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-7 </td>
<td> Vptr sharing with primary base class </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is in general possible to share the virtual pointer with a
polymorphic base class (the <i>primary</i> base class).
Which base class do we use for this?
</td> </tr>

</table>

<p>
<font color=blue>[990617 All]</font>
It will be shared with the first polymorphic non-virtual base class,
or if none, with the first nearly empty polymorphic virtual base class.
(See A-2 for the definition of <i>nearly empty</i>.)

<p>
<font color=blue>[990624 All]</font>
HP noted that Taligent chooses a base class with virtual bases before
one without as the primary base class),
probably to avoid additional "this" pointer adjustments.
SGI observed that such a rule would prevent users from controlling the
choice by their ordering of the base classes in the declaration.
The bias of the group remains the above resolution,
but HP will attempt to find the Taligent rationale before this is decided.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-9 </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-10 </td>
<td> Class parameters in registers </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The C ABI specifies that small structs are passed in registers.
Does this apply to small non-POD C++ objects passed by value?
What about the copy constructor and <code>this</code> pointer in that case?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-11 </td>
<td> Representation of pointers to members </td>
<td> data </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Ian]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-12 </td>
<td> Merging secondary vtables </td>
<td> data </td>
<td> open </td>
<td> Sun </td>
<td> 990610 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Sun]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-13 </td>
<td> Parameter struct field promotion </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is possible to pass small classes either as memory images,
as is specified by the base ABI for C structs,
or as a sequence of parameters, one for each member.
Which should be done, and if the latter,
what are the rules for identifying "small" classes?
</td> </tr>

</table>

<p> <hr> <p>
<h3> Virtual Function Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-1 </td>
<td> Adjustment of "this" pointer (e.g. thunks) </td>
<td> data call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the <i>this</i> pointer
for a member function call,
including thunks or offsets located in the vtable.
We need to agree on the mechanism used,
and on the location of offsets, if any are needed.
To maximize performance on IA64,
a slightly unusual approach such as using secondary entry points
to perform the adjustment may actually prove interesting. 
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-2 </td>
<td> Covariant return types </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the 'this' pointer of the
returned value for member functions with covariant return types.
We need to decide how this is done.
Return thunks might be especially costly on IA64,
so a solution based on returning multiple pointers may prove more interesting.
</td> </tr>

</table>

<p>
<font color=blue>[990610 Matt]</font>
One possibility is to have two Vtable entries,
which might point to different functions, different entrypoints,
or a real entrypoint and a thunk.
Another is to return two result pointers (base/derived),
and have the caller select the right one.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-3 </td>
<td> Allowed caching of vtable contents </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The contents of the vtable can sometimes be modified,
but the concensus is that it is nonetheless always allowed to "cache" elements,
i.e. to retain them in registers and reuse them,
whenever it is really useful.
However, this may sometimes break "beyond the standard" code,
such as code loading a shared library that replaces a virtual function.
Can we all agree when caching is allowed? 
</td> </tr>

</table>

<p>
<font color=blue>[990604 HP Christophe]</font>
Mike (Ball) gave me what I believe is an excellent definition of  
when caching is allowed.  I'd like him to present it.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-4 </td>
<td> Function descriptors in vtable </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
For a runtime architecture where the caller is expected to load the GP
of the callee (if it is in, or may be in, a different DSO), e.g. HP/UX,
what should vtable entries contain?
One possibility is to put a function address/GP pair in the vtable.
Another is to include only the address of a thunk which loads the GP
before doing the actual call.

</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Note that putting GP in the Vtable prevents putting it in shared memory.
See B-7.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-5 </td>
<td> Where are vtables emitted? </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In C++, there are various things with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.
>From the user's standpoint, this applies to inlines and templates.
>From the implementation's perspective,
it also applies to things like vtables and RTTI info.
(We call this <i>vague linkage</i>.)
</td> </tr>

</table>

<p>
<font color=blue>[990624 Cygnus -- Jason]</font>
There are several ways of dealing with vague linkage items:
<ol>
<li> Emit them everywhere and only use one.
<li> Use some heuristic to decide where to emit them.
<li> Use a database to decide where to emit them.
<li> Generate them at link time.
</ol>

<p>
#3 and #4 are feasible for templates,
but I consider them too heavyweight to be used for other things.

<p>
The typical heuristic for #2 is "with the first non-inline,
non-abstract virtual function in the class".
This works pretty well,
but fails for classes that have no such virtual function,
and for non-member inlines.
Worse, the heuristic may produce different results in different
translation units,
as a method could be defined inline after being declared non-inline
in the class body.
So we have to handle multiple copies in some cases anyway.

<p>
The way to handle this in standard ELF is weak symbols.
If all definitions are marked weak,
the linker will choose one
and the others will just sit there taking up space.

<p>
Christophe mentioned the other day that the HP compiler used the
typical heuristic above,
and handled the case of different results by encoding the
key function in the vtable name.
But this seems unnecessary when we can just choose one of multiple defns.

<p>
A better solution than weak symbols alone would be to set things up so
that the linker will discard the extra copies.
Various existing implementations of this are:

<ol>
<p>
<li>
The Microsoft PE/COFF defn includes support for COMDAT sections,
which key off of the first symbol defined.
One copy is chosen, others are discarded.
You can specify conditions to the linker
(must have same contents, must have same size).

<p>
<li>
The IBM XCOFF platform includes a garbage-collecting linker;
sections that are not referenced in a sweep from main are discarded.
In xlC, template instantiations are emitted in separate sections,
with encoded names;
at link time, one copy is renamed to the real mangled name,
and the others are discarded by garbage collection.
</ol>

<p>
The GNU ELF toolchain does a variant of #1 here;
any sections with names beginning with ".gnu.linkonce."
are treated as COMDAT sections.
It seems more sensible to me to key off of the section name
than the first symbol name as in PE.

<p>
The GNU linker recently added support for garbage collection,
and I've been thinking about changing our handling of vague
linkage to make use of it, but haven't.

<p>
I propose that the ia64 base ABI be extended to
provide for either COMDAT sections or garbage collection,
and that we use that support for vague linkage.

<p>
I further propose that we not use heuristics to
cut down the number of copies ahead of time;
they usually work fine, but can cause problems in some situations,
such as when not all of the class's members are in the same symbol space.
Does the ia64 ABI provide for controlling which symbols
are exported from a shared library?

<p>
A side issue: What do we want to do with
dynamically-initialized variables?
The same thing, or use COMMON?
I propose COMMON.

<p>
See also G-3, for vague linkage of inlined routines and their static variables.

<p>
<font color=blue>[990624 SGI summarizing others]</font>
HP uses COMDAT for many cases, keying from the symbol names.
HP also uses some heuristics.
HP observes that IA-64 objects will already be large.
>From the base ABI discussions,
any use of WEAK or COMMON symbols will need to take care not to depend
on vendor-specific treatment.

<p>
Defining a COMDAT mechanism doesn't preclude using heuristics to avoid
some copies up front.
A COMDAT mechanism should also specify how to get rid of associated
sections like debugging info, unless the identical mechanism works.

<p>
<font color=blue>[990629 HP -- Christophe]</font>
First, the "usual" heuristic
(which is usual because it dates back to Cfront)
is to emit vtables in the translation unit that contains  
the definition of the first non inline, non pure virtual function.  
That is, for:
<pre><code>
        struct X {
                void a();
                virtual void f() { return; }
                virtual void g() = 0;
                virtual void h();
                virtual void i();
        };
</code></pre>
the vtable is emitted only in the TU that contains the definition of h().

<p>
This breaks and becomes non-portable if:
<ul>
<li>There is no such thing. In that case,
    you generally emit duplicate versions of vtables
<li>There is a "change of mind",
    such as having the above class followed by:
    <code><p>
    <dd>inline void X::h() { f(); }
    </code>

<p>
Now, the COMDAT issue is as follows:
a COMDAT section is, in some cases, slightly more difficult to handle
(at least, that's the impression Jason gave me).
For statics with runtime initialization,  
what you can do is reserve COMMON space ('easier'),
then initialize that space at runtime.
As I said, the problem is if two compilers disagree on whether this
is a runtime or a compile time initialization, such as in :
<pre><code>
	int f() { return 1; }
	int x = f();	// Static (COMDAT) or Dynamic (COMMON) initialization?
</code></pre>

<p>
So I personally recommend that we put everything in COMDAT.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-6 </td>
<td> Virtual function table layout </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the layout of the Vtable?
</td> </tr>

</table>

<p>
<font color=blue>[990624]</font>
Issue split from A-1.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-7 </td>
<td> Vtables in shared memory </td>
<td> data </td>
<td> open </td>
<td> HP </td>
<td> 990624 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Is it possible to put the Vtable in shared memory?
</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Note that putting GP in the Vtable prevents putting it in shared memory.
This interacts with B-4.

<p>
<font color=blue>[990624 HP -- Cary]</font>
For a C++ object to be placed into shared memory,
its vtable pointer must be valid in all processes
that are sharing that object.

<ol>
<p>
<li>
If the vtable can be placed in text, that would be fine,
but the vtable contains function pointers (or descriptors)
that require runtime relocation, so it must be in data.

<p>
<li>
We can place the vtables in shared memory,
but only if the function pointers/descriptors are valid in all processes.
The entry point addresses, which refer to shared text, should be shareable,
but the gp values may not be identical for all processes.
(RTTI pointers are also an issue,
and could be solved by putting the RTTI information in shared memory as well.)

<p>
<li>
We can place the vtables in private memory,
provided they are at the same address in all processes.
</ol>

<p>
One way or another,
we need a way of ensuring that a pointer from shared 
memory to private memory is valid in all processes,
which means that we will need a means to ensure that certain shared
library data segments can get mapped at the same address in all
processes that load those certain libraries.

<p>
My wild idea a few years ago was to put the vtables in shared memory
(by allocating and building them at load time, as Taligent did),
and store a shared library index in place of the gp value
in each function descriptor.
Each process would have its own table of gp values,
indexed by this shared library index,
but the index space would be managed system-wide.
The C++ runtime library would have been responsible for allocating
a new index for each unique C++ shared library loaded on the system,
then storing the process-local copy of the gp pointer in the 
appropriate slot of the table.

<p>
<font color=blue>[990628 SGI -- Jim]</font>
Note a further problem with vtables in shared memory (Cary's point 2).
If a virtual function comes from another DSO,
it may be pre-empted differently in different programs.
Hence, the function pointer itself is a problem even if the GP isn't.



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-8 </td>
<td> dynamic_cast </td>
<td> data </td>
<td> open </td>
<td> SGI </td>
<td> 990628 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What information to we put in the vtable to enable (a) dynamic_cast
from pointer-to-base to pointer-to-derived (including detection of
ambiguous base classes) and (b) dynamic_cast to void*?
</td> </tr>

</table>

<p> <hr> <p>
<h3> Object Construction/Destruction Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-1 </td>
<td> Interaction with .init/.fini </td>
<td> lif ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Static objects with dynamic constructors must be constructed at
intialization time.
This is done via the executable object initialization functions that
are identified (in ELF) by the DT_INIT and DT_INITARRAY dynamic tags.
How should the compiler identify the constructors to be called in this way?
One traditional mechanism is to put calls in a .init section.
Another, used by HP, is to put function addresses in a .initarray section.
<p>
The dual question arises for static object destructors.
Again, the extant mechanisms include putting calls in a .fini section,
or putting function addresses in a .finiarray section.
<p>
Finally, which mechanism (DT_INIT or DT_INITARRAY, or the FINI versions)
should be used in linked objects?
The gABI, and the IA-64 psABI, will support both,
with DT_INIT being executed before the DT_INITARRAY elements.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-2 </td>
<td> Order of ctors/dtors w.r.t. link </td>
<td> lif ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given that the compiler has identified constructor/destructor calls for
static objects in each relocatable object, in what order should the
static linker combine them in the linked executable object?
(The initialization order determines the finalization order,
as its opposite.)
</td> </tr>

</table>

<p>
<font color=blue>[990610 All]</font>
Meeting concensus is that the desirable order is right to left on the
link command line, i.e. last listed relocatable object is initialized
first.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-3 </td>
<td> Order of ctors/dtors w.r.t. DSOs </td>
<td> ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given the constructor/destructor calls for each executable object
comprising a program, what is the order of execution between objects?
For constructors, there is not much question:
unless we choose some explicit means of control,
file-scope objects will be initialized by the DT_INIT/DT_INITARRAY
functions in the order determined by the base ABI order rules,
and local objects will be initialized in the order their containing
scopes are entered.
<p>
For destructors, the Standard requires opposite-order destruction,
which implies a runtime structure to keep track of the order.
Furthermore, the potential for dynamic unloading of a DSO
(e.g. by dlclose)
requires a mechanism for early destruction of a subset.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-4 </td>
<td> Calling vfuncs in ctors/dtors </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Michael Lam]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-5 </td>
<td> Calling virtual destructors </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Michael Lam]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-6 </td>
<td> Extra parameters to ctors/dtors </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Michael Lam]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-7 </td>
<td> Passing value parameters by reference </td>
<td> call </td>
<td> open </td>
<td> All </td>
<td> 990624 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It may be desirable in some cases where a type has a non-trivial
copy constructor to pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-8 </td>
<td> Returning classes with non-trival copy constructors </td>
<td> call </td>
<td> open </td>
<td> All </td>
<td> 990625 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How do we return classes with non-trivial copy constructors?
</td> </tr>

</table>

<p> <hr> <p>
<h3> Exception Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-1 </td>
<td> Language-specific data area format </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-2 </td>
<td> Unwind personality routines </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-3 </td>
<td> Unwind process clarification </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-4 </td>
<td> Unwind routines nested? </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-5 </td>
<td> Interaction with other languages (e.g. Java) </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA64 exceptions handling framework is largely language independent.
What is the behaviour of a C++ runtime receiving, for instance,
an exception thrown from Java?
Does it call terminate()?
Does it allow the exception to pass through C++ code with destructors
if there is no catch clause?
Does it allow the exception to be caught in a catch(...) provided this
catch(...) ends with a rethrow?
Does it allow even more?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-6 </td>
<td> Allow resumption in other languages? </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The exception handling framework requires the interaction of the
runtime of all the languages "on the stack" during exception processing.
Some of these languages may have very different exception handling semantics.
What are the constraints we impose on the C++ exception handling runtime
to preserve the relative language neutrality of the EH framework?
Example: do we allow a handler to cleanup and resume at the point
where the exception was thrown?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-7 </td>
<td> Interaction with signals or asynch events </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard says that the behavior of anything other than
"pure C code" (POF) is implementation defined,
and warns (in a note) against using EH in a signal handler.
We should define what is supported,
possibly explicitly stating that signal handler code must be a POF.
We could allow any feature but exception handling to be used.
We could allow some EH routines to be called
(for instance, <code>uncaught_exception()</code>).
Or we could allow even an exception to be thrown,
if it does not exit the handler.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> D-8 </td>
<td> Interaction with threads packages </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What happens when an exception is not caught in the thread where raised?
What does uncaught_exception() return if another thread is currently
processing an exception?
</td> </tr>

</table>

<p> <hr> <p>
<h3> Template Instantiation Model Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>


<tr> </tr>
<tr> <th> E </th>
<th colspan=6> Template Instantiation Model </th>
</tr>

<tr> <td> E-1 </td>
<td> When does instantiation occur? </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are two principal models for instantiation.
The <i>early instantiation</i> (or Borland) model performs all
instantiation at compile time,
potentially resulting in extra copies which are removed at link time.
The <i>pre-link instantiation</i> model identifies the required
instantiations prior to linking and instantiates them via a special
compile step.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> E-2 </td>
<td> Separate compilation model </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> E-3 </td>
<td> Template repository </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Independent of the template instantiation model,
we need to make sure that whatever template persistent storage is used
by one vendor does not interact negatively with other vendors' mechanisms.
Issues:
  (1) Avoiding conflict on the name of any repository.
  (2) If .o files are used,
	describe how this information is to be preserved, ignored, etc.
  (3) Evaluate if tools such as make, ld, ar, or others, can
	break because .o files get written at unexpected times.
</td> </tr>

</table>

<p> <hr> <p>
<h3> Name Mangling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> F-1 </td>
<td> Mangling convention </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What rules shall be used for mangling names,
i.e. for encoding the information other than the source-level object
name necessary to resolve overloading?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> F-2 </td>
<td> Mangled name size </td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Typical name mangling schemes to date typically begin to produce very
long names.  SGI routinely encounters multi-kilobyte names,
and increasing usage of namespaces and templates will make them worse.
This has a negative impact on object file size, and on linker speed.
<p>
SGI has considered solutions to this problem including modified string
tables and/or symbol tables to eliminate redundancy.
Cygnus, HP, and Sun have also considered or implemented approaches
which at least mitigate it.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> F-3 </td>
<td> Distinguish template instantiation and specialization
</td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In order to allow detection of conflicting template instantiation
and specialization (in different translation units),
should we name them differently?
If we do so in an easily recognizable way,
the linker could check for conflicts and report the ODR violation.
</td> </tr>

</table>

<p> <hr> <p>
<h3> Miscellaneous Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> G-1 </td>
<td> Basic command line options </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Can we agree on basic command line options (compiler and linker)
for fundamental functionality,
possibly allowing portable makefiles?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> G-2 </td>
<td> Detection of ODR violations </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Sun]
(See also F-3.)
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> G-3 </td>
<td> Inlined routine linkage </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Inline routines with external linkage require a method of handling
vague linkage (see B-5 for definition) for the out-of-line instance,
as well as for any static data they contain.
The latter includes string constants per [7.1.2]/4.
</td> </tr>

</table>

<p>
<font color=blue>[990624 Cygnus -- Jason]</font>
How should we handle local static variables in inlines?
G++ currently avoids this issue by suppressing
inlining of functions with local statics.
If we don't want to do that,
we'll need to specify a mangling for the statics,
and handle multiple copies like we do above.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> G-4 </td>
<td> Dynamic init of local static objects and multithreading </td>
<td> call </td>
<td> open </td>
<td> SCO </td>
<td> 990607 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard requires that local static objects with dynamic
constructors be initialized exactly once, the first time the containing
scope is entered.
Multi-threading renders the simple check of a flag before
initialization inadequate to prevent multiple initialization.
Should the ABI require locking for this purpose,
and if so, what are the necessary interfaces?
In addition to the locking of the initialization,
special exception handling treatment is required to deal with an
exception during construction.
</td> </tr>

</table>

<p>
<font color=blue>[990607 SCO -- Jonathan]</font>
The standard is mute on multiple threads of control in general, so 
there is no requirement in the language to support what I'm talking
about. But as a practical matter compilers have to do it (Watcom gave
a paper on their approach during the standardization process, if I
remember).  This example using UI/SVR4 threads will usually show
whether a compiler does it or not: 

<pre><code>
thr5.C:
// static local initialization and threads

#include <stdlib.h>
#define EXIT(a) exit(a)
#define THR_EXIT() thr_exit(0)

#include <thread.h>

int init_count = 0;
int start_count = 0;

int init()
{
  
        ::thr_yield();
        return ++init_count;
}

void* start(void* s)
{
  
        start_count++;
        static int i = init();
        if (i != 1) EXIT(5);
        THR_EXIT();
        return 0;
}
                
int main()
{
  
        thread_t t1, t2;
        if (::thr_create(0, 0, start, 0, 0L, &t1) != 0) EXIT(1);
        if (::thr_create(0, 0, start, 0, 0L, &t2) != 0) EXIT(2);
        if (::thr_join(t1, 0, 0) != 0) EXIT(3);
        if (::thr_join(t2, 0, 0) != 0) EXIT(4);
        if (start_count != 2)
                EXIT(6);
        if (init_count != 1)
                EXIT(7);
        THR_EXIT();
}
</code></pre>

<p>
When compiled with CC -Kthread thr5.C on UnixWare 7, for instance,
it passes by returning 0.  When compiled with CC -mt thr5.C on
Solaris/x86 C++ 4.2 (sorry don't have the latest version!), it
fails by returning 5.


<p>
<font color=blue>[990607 Sun -- Mike Ball]</font>
As far as I can tell, the language says that the automatic blocking 
issue isn't a valid approach.  It says what has to happen, and
it isn't that.

<p>
If you look at the entire statement you find that it reads:
<quote>
"Otherwise such an object is initialized the first time control passes
through its declaration; such an object is considered initialized upon
the completion of its initialization.
If the initialization exits by throwing an exception,
the initialization is not complete,
so it will be tried again the next time control enters the declaration.
If control re-enters the declaration (recursively)
while the object is being initialized,
the behavior is undefined."
</quote>

<p>
The word "recursively" is normative,
so eliminates that sentence from consideration.

<p>
One can, of course, make any extension to the language,
but in this case I think the extension invalidates some otherwise valid code.

<p>
The sentence I'm referring to is that the object is considered
initialized upon the completion of its initialization.
This is explicit, and the reason for it is covered in the following sentence,
which discusses an initialization that terminates with an exception.
A person catching such an exception has the right to try again
without danger that the static variable will be initialized in the meantime.

<p>
I don't see anything at all to justify semantics that say,
"after initialization is started, Any other threads of control are
blocked until that thread completes the initialization,
unless, of course, it executes by an exception,
in which case the other thread can do the initialization before the
exception handler gets a chance to try again, except...."
 Take an attempt to define the semantics as far as you like.

<p>
The problem is that there is no way for the compiler writer to know
what the programmer really wanted to do.
I can (and will at some other date, if necessary)
come up with scenarios justifying a variety of mutual exclusion policies,
including none.

<p>
The solution is to let the programmer write the mutual exclusion, the
same as we do for every other potential race condition.
It's a real mess, and, I claim, an unwise one to put in as an extension.

<p>
<font color=blue>[990608 HP -- Christophe]</font>
The semantics currently implemented in the HP aC++ compiler is as follows:
<ul>
<li> No two thread can enter a static initialization at the same time
<li> Threads are blocked until immediately after the static  
    initialization either succeeds or fails with an exception.
</ul>

<p>
There are details of our implementation that I disagree with, but in  
general, the semantics seem clear and sane, not as convoluted as you  
seemed to imply. In particular, it correctly covers the case where  
the static initialization fails with an exception. Any thread at that  
point can attempt the initialization.

<p>
<font color=blue>[990608 SCO -- Jonathan]</font>
Here's what the SCO UnixWare 7 C++ compiler does for IA-32,
from a (slightly sanitized) design document.
 It meets Jim's goal of having no overhead for non-threaded programs
and minimal overhead for threaded programs unless
actual contention occurs (infrequent),
and meets Mike's goal of handling exceptions in the initialization correctly
(although it doesn't guarantee that the thread getting the exception is
the one that gets next crack at initializing the static).
 It's also worth noting that dynamic initialization of local variables
(static or otherwise) is very common in C++,
since that's what most object constructions involve,
so I don't think this case is as rare as Jim does.


<p>
[...] This is in local static variables with dynamic initialization,
where the compiler generates out a static one-time flag to guard the
initialization.
Two threads could read the flag as zero before either of them set it,
resulting in multiple initializations.

<p>
[...] Accordingly, when compilation is done with -Kthread on,
a code sequence will be generated to lock this initialization.  
[...] the basic idea is to have one guard saying whether the
initialization is done (so that multiple initializations do not occur)
and have another guard saying whether initialization is in progress
(so that a second thread doesn't access what it thinks is
an initialized value before the first thread has finished the
initialization).  [...]

<p>
When compiled with -Kthread, the generated code for a dynamic
initialization of a local static variable will look like the
following. guard is a local static boolean, initialized to zero,
generated by the [middle pass of the compiler]. 
Two bits of it are used: the low-order 'done bit'
and the next-low-order 'busy bit'.

<pre><code>
.again:
        movl    $guard,%eax
        testl   $1,(%eax)       // test the done bit
        jnz     .done           // if set, variable is initialized,
done
        lock; btsl  $1,(%eax)   // test and set the busy bit
        jc      .busy
        < init code >           // not busy, do the initialization
        movl    $guard,%eax
        movl    $3,(%eax)       // set the done bit
        jmp     .done
.busy:
        pushl   %eax            // call RTS routine to wait, passing address
        call1   __static_init_wait      // of guard to monitor
        testl   %eax,%eax       // 1 means exception occurred in init code,
        popl    %ecx
        jnz     .again                  // start the whole thing over
.done                                   // 0 means wait finished
</code></pre>

<p>
The above code will work for position-independent code as well.

The complication due to exceptions is:
what happens if the initialization code throws an exception?
The [compiler] EH tables will have set up a special region and flag in
their region table to detect this situation,
along with a pointer to the guard variable.
Because the initialization never completed,
when the RTS sees that it is cleaning up from such a region,
it will reset the guard variable back to both zeroes.
This will free up a busy-waiting thread, if any,
or will reset everything for the next thread that calls the function.

<p>
The idea of the __static_init_wait() RTS routine is to monitor the
value of guard bits passed in, by looping on this decision table:
<pre><code>
    done    busy
    0       0       return 1 in %eax        (EH wipe-out)
    1       1       return 0 in %eax        (no longer busy)
    0       1       continue to wait        (still busy)
    1       0       internal error, shouldn't happen
</code></pre>

<p>
As for how the wait is done [... not relevant for ABI,
although currently we're using thr_yield(),
which may or may not be right for this context].

<p>
<font color=blue>[990608 SGI -- Hans]</font>
I'd like to make some claims about function scope static constructor
calls in multithreaded environments.
I personally can't recall ever having used such a construct,
which somewhat substantiates my claims,
but also implies some lack of certainty.
I'd be interested in hearing any arguments to the contrary.

<p>
I believe that these arguments imply that this problem is not important
enough to warrant added ABI complexity or overhead for sequential code.

<p>
Consider the following skeletal example:

<p><code>
f(int x) { static foo a(...); ... }
</code>

<ol>
<p>
<li>
If the constructor argument doesn't depend on the function parameter,
and the code behaves reasonably, it should be possible to rewrite this as

<p><code>
static foo a(...);
<br>
f(int x) { ... }
</code>

<p>
<li>
If I read the standard correctly (and that's a big disclaimer),
the compiler is entitled to perform the above transformation under
conditions that are usually true,
but hard for the compiler to deduce.
Thus code that relies on the initialization occurring during the
execution of f is usually broken.

<p>
<li>
Thus the foo constructor cannot rely on its caller holding any locks.
It must explicitly acquire any locks it needs.

<p>
<li>
It is far preferable to write the transformed form with a file scope
static variable to start with.
The initial form risks deadlock,
since f may be called with locks held which the constructor
can't assume are held.
If it needs one of those locks it will need to reacquire it.
With default mutex semantics that results in deadlock with itself.
(If locks may be reentered,
it may fail in a more subtle manner since the foo constructor may
acquire a monitor lock whose monitor invariant doesn't hold.)

<p>
<li>
File scope static constructor calls aren't a problem and require no locking,
since they are executed in a single thread before main is called or
before dlopen returns.
(Forking a thread in a static constructor should probably be disallowed.
Threads may not have been fully initialized, among other issues.)

<p>
<li>
Static function scope constructor calls which depend on function
arguments are likely to involve a race condition anyway,
if multiple instances of the function can be invoked concurrently.
Any of the calls might determine the constructor parameters.
Thus these aren't very interesting either.
And if they are really needed, they can be replaced with a file scope
static constructor call plus an assignment.

</ol>



<p> <hr> <p>
<h3> Library Interface Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> H-1 </td>
<td> Runtime library DSO name </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Determine the name of the common C++ runtime library DSO,
e.g. <code>libC.so</code>.
If there are to be vendor-specific support libraries which must coexist
in programs from mixed sources, identify naming convention for them.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> H-2 </td>
<td> Runtime library API </td>
<td> lif </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the required entrypoints in the common C++ runtime library DSO,
and their prototypes.
</td> </tr>

</table>

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert at sgi.com>Jim Dehnert</a>.


</BODY>
</HTML>
-------------- next part --------------
<HTML>

<HEAD>
<title>C++ ABI Closed Issues</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Closed Issues
</b></i></font>

<font size=-1>
<p>
<i>Revised 25 June 1999</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Issue Status </h3>

In the following sections,
the <b><i>class</i></b> of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr> <td> data </td>
<td> Data layout </td>
</tr>

<tr> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p> <hr> <p>
<h3> A.  Object Layout Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where is the Vptr stored in an object (first or last are the usual answers).
</td> </tr>

</table>

<p>
<font color=blue>[990610 All]</font>
Given the absence of addressing modes with displacements on IA-64,
the consensus is to answer this question with "first."

<p>
<font color=blue>[990617 All]</font>
Given a Vptr and only non-polymorphic bases,
which (Vptr or base) goes at offset 0?
<ul>
<li> HP: Vptr at end, but IA-64 is different because no load displacement
<li> Sun: Vptr at 0 probably preferred
<li> g++: Vptr at end today
</ul>
<p>
Tentative decision:  Vptr always goes at beginning.

<p>
<font color=blue>[990624 All]</font>
Accepted tentative decision.
Rename, close this issue, and open separate issue (B-6) for Vtable layout.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
</td> </tr>

</table>

<p>
<font color=blue>[990610 Matt]</font>
With regard to how data member accesses are handled,
the choices are to store either a pointer or an offset in the Vtable.
The concensus seems to be to prefer an offset.

<p>
<font color=blue>[990617 All]</font>
Any number of empty virtual base subobjects (rare) will be placed at
offset zero.
If there are no non-virtual polymorphic bases,
the first virtual base subobject with a Vpointer will be placed at
offset zero.
Finally, all other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

<p>
<font color=blue>[990624 All]</font>
Define an empty object as one with no non-static, non-empty data members,
no virtual functions,
no virtual base classes,
and no non-empty non-virtual base classes.
Define a nearly empty object as one which contains only a Vptr.
The above resolution is accepted, restated as follows:

<p>
Any number of empty virtual base subobjects
(rare, because they cannot have virtual functions or bases themselves)
will be placed at offset zero, subject to the conflict rules in A-3
(i.e. this cannot result in two objects of the same type at the same
address).
If there are no non-virtual polymorphic base subobjects,
the first nearly empty virtual base subobject will be placed at offset zero.
Any virtual base subobjects not thus placed at offset zero will be
allocated at the end of the class,
in left-to-right, depth-first declaration order.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are empty base classes allocated?
(An empty base class is one with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)
</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Closed as a duplicate of A-3.

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
(An alternative for virtual bases:
allow the virtual base to move in the complete object.)
</td> </tr>

</table>

<p>
<font color=blue>[990623 SGI]</font>
We propose that the alignment of a class be the maximum alignment of
its virtual and non-virtual base classes,
non-static data members, and Vptr if any.

<p>
<font color=blue>[990624 All]</font>
Above proposal accepted.
(SGI observation:
the size of the class is rounded up to a multiple of this alignment,
per the underlying psABI rules.)

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-9 </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
</td> </tr>

</table>

<p>
<font color=blue>[990610 all]</font>
Some participants want to avoid attempts to reorder members differently
than the underlying C struct ABI rules.
Others think there may be benefit in reordering later access sections
to fill holes in earlier ones, or even in base classes.

<p>
<font color=blue>[990617 all]</font>
There are several potential reordering questions, more or less independent:
<ol>
<li> Do we reorder whole access regions relative to one another?
<li> Do we attempt to fill padding in earlier access regions with
	initial members from later regions?
<li> Do we fill the tail padding of non-POD base classes with members from
	the current class?
<li> Do we attempt to fill interior padding of non-POD base classes with later
	members?
</ol>

<p>
There is no apparent support for (1),
since no simple heuristic has been identified with obvious benefits.
There is interest in (2), based on a simple heuristic which might
sometimes help and will never hurt.
However, it is not clear that it will help much,
and Sun objects on grounds that they prefer to match C struct layout.
Unless someone is interested enough to implement and run experiments,
this will be hard to agree upon.
G++ has implemented (3) as an option,
based on specific user complaints.
It clearly helps HP's example of a base class containing a word and flag,
with a derived class adding more flags.
Idea (4) has more problems, including some non-intuitive (to users) layouts,
and possibly complicating the selection of bitwise copy in the compiler.

<p>
<font color=blue>[990624 all]</font>
We will not do (1), (2), or (4).  We will do (3).
Specifically, allocation will be in modified declaration order as follows:
<ol>
<li> Vptr if any, and the primary base class per A-7.
<li> Any empty base classes allocated at offset zero per A-3.
<li> Any remaining non-virtual base classes.
<li> Any non-static data members.
<li> Any remaining virtual base classes.
</ol>
Each subobject allocated is placed at the next available position that
satisfies its alignment constraints, as in the underlying psABI.
This is interpreted with the following special cases:
<ol>
<li> The "next available position" after a class subobject
	(base class or data member) with tail padding is at the
	beginning of the tail padding, not after it.
<li> Empty classes are considered to have alignment and size 1,
	consisting solely of one byte of tail padding.
<li> Placement on top of the tail padding of an empty class must avoid
	placing multiple subobjects of the same type at the same
	address.
</ol>
After allocation is complete,
the size is rounded up to a multiple of alignment (with tail padding).

<p> <hr> <p>
<h3> B.  Virtual Function Handling Issues </h3>

<p> <hr> <p>
<h3> C.  Object Construction/Destruction Issues </h3>

<p> <hr> <p>
<h3> D.  Exception Handling Issues </h3>

<p> <hr> <p>
<h3> E.  Template Instantiation Model Issues </h3>

<p> <hr> <p>
<h3> F.  Name Mangling Issues </h3>

<p> <hr> <p>
<h3> G.  Miscellaneous Issues </h3>

<p> <hr> <p>
<h3> H.  Library Interface Issues </h3>

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert at sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>

