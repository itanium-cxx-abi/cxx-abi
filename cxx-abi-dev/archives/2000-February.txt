From dehnert at baalbek.engr.sgi.com  Tue Feb  1 03:15:03 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 31 Jan 2000 19:15:03 -0800 (PST)
Subject: Vcall/vbase offset clarification
References: <200001252056.MAA66540@baalbek.engr.sgi.com>
Message-ID: <200002010315.TAA84577@baalbek.engr.sgi.com>

> From mitchell at codesourcery.com  Tue Jan 25 13:26:12 2000
> 
> Consider:
> 
>   struct A { void f();}
>   struct B : public virtual A {};
> 
> Now, imagine `B' is used as a virtual base.  For example:
> 
>   struct C : public virtual B { virtual void f(); };
>   B* b = new C;
>   b->f();
> 
> The description says:
> 
>   o First, we convert to the most derived class in which `f' was
>     overridden.  That's `A'.  We know statically what offset
>     to adjust `b' by to get an `A*'.
> 
>   o We pass this value to the function found in the vtable for `A'.
> 
>   o That function will first perform the constant adjustment from 
>     `A' to `B'.  
> 
>   o Now, using the vcall offset found in the vtable for `B', the `B'
>     will be adjusted to a `C', and `C::f' will be called.
> 
> I'm not quite sure *why* we do it this way.  Why not just have the
> C-as-A vtable contain a function which adjusts the `A*' directly to a
> `C*'?  I guess we decided we wanted to avoid having to use thunks --
> the current scheme allows the cascading entry point approach.  Was
> that the reason?

Sort of.  I'll explain my (fuzzy) understanding, and let the others
correct me :-).

The real objective is not to completely avoid thunks -- this one could
use either a thunk or a fall-through entry.  But it allows exactly one
thunk/alternate entry, which can therefore always be emitted with the
"original" function and pick up the adjustment via 'this'.  I probably
can't explain why (due to NDA), but placing this alternate entry
immediately before the normal entry will likely have noticible
performance benefit on IA-64.

Incidently, I don't know that we've written it down anywhere, but we
should probably specify that the alternate entry _must_ be emitted with
a virtual function, so other units don't need to consider doing so.
Is this true, everyone?

Hope this helps,
Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb  1 08:50:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Feb 2000 00:50:07 -0800 (PST)
Subject: Stack unwind ABI
Message-ID: <200002010850.AAA85738@baalbek.engr.sgi.com>

The C++ ABI group has pretty much completed a draft of a more
precise stack unwind ABI, based on the Intel/HP architecture in
the psABI document, but specifying the interfaces and functionality
more completely.

It is available on our web site at:

	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.html
or
	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.pdf

I'm sure further details will come to light as implementations progress,
but it's time for the base ABI group to look at it for adoption.

Note that we're also waiting for base ABI consideration of the COMDAT
proposal, and feedback on the preferred mechanism for ordering
constructors, submitted a couple of months ago (or more).  Sunil,
it's time for a meeting!

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb  1 09:01:48 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Feb 2000 01:01:48 -0800 (PST)
Subject: Updated status -- new issues
Message-ID: <200002010901.BAA84261@baalbek.engr.sgi.com>

I've attempted to capture much of the recent email about RTTI and
constructors as new issues, A-22-24 and C-11-12.  Some but not all
of the mail is included in the open issues document.  The HTML pages
on the web site have been updated, and will be a bit more tomorrow
with the rest of the meeting results.  If you've been half following
the email exchange, look at it again and think about the questions --
we'll probably discuss it on Thursday.

I'll include the following in the document when I get them:

  Daveed -- updated mangling proposal
  Coleen -- construction vtable writeup

I also have an old action item for Christophe -- a virtual destructor
proposal.  I suspect that is issue C-5, already resolved.  True?

Jim

-		Jim Dehnert  x3-4272



From sidwell at codesourcery.com  Tue Feb  1 10:59:22 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Tue, 01 Feb 2000 10:59:22 +0000
Subject: rtti data structures (again)
References: <388F02EF.A80C7B0E@codesourcery.com> <u9n1pp1w0m.fsf@yorick.cygnus.com> <3893052F.E3AB18F5@codesourcery.com> <u9emb01t2n.fsf@yorick.cygnus.com>
Message-ID: <3896BC8A.67010927@codesourcery.com>

Jason Merrill wrote:

>  >> We also decided that the flags should move from __class_type_info into
>  >> __vmi_class_type_info, and that the polymorphic flag should be removed.
> 
>  > I think this moving of the flags is a mistake. If I understood correctly,
>  > they indicated information about direct and indirect bases (whether there
>  > was virtuality anywhere in the heirarchy for instance). Such information
>  > can speed up dynamic cast. When walking the inheritance graph, we can
>  > take some early outs, if we know there are no multiple sub object types
>  > within the complete graph. With the flags in every class's type_info, it
>  > becomes easier to get hold of that info. With it only for vmi classes,
>  > we have to remember `unknown' when presented with a complete object of
>  > si type, and fill the information in when/if we find a vmi base.
> 
> So what you're saying is if we try to dynamic_cast from A* to B*, where B
> has a unique A subobject and the A* does not actually point to part of a B,
> if we know that B has no multiple subobjects we can check the passed
> offset, see that it doesn't match, and return failure.  Without that
> information, we would have to recurse up the single-inheritance chain until
> we either reach the A or a class with multiple or virtual bases.
No, the base_offset hint covers this case already. If A is a unique public
base of B base_offset will tell us where it is. If A is a non-unique public
base of B base_offset will tell us (and we search B to find one). If A is
not a public base, base_offset will tell us (and we don't search B).

What I'm talking about is that in a cast from A* to B*, if we know the
complete type has no multiple subobjects, then as soon as we find a B base
we can stop looking. We have to remember the flags from the complete object.
Should the flags only be in vmi type_info's then we also have to remember
that we don't know the subobject status when the complete object is an si.
We fill the flags in when/if we meet a vmi base. This is a minor problem
though, and is bookkeeping.

> I think I'd rather pay that small performance hit than add a word to the
> type_info for each class.  Matt, would this affect locales?
Yes, I suspect the performance hit is minor.

>  > Another case is in a potential cross-cast case, which I had in the
>  > previous email.  Suppose we've found the target base, which we know is
>  > unique, but not found the source base (because we early outed,
>  > maybe). To be a valid cross-cast both the source and target base objects
>  > must be public in the complete object. If we know the complete heirarchy
>  > has no non-public bases, there's no need to search for the source base
>  > in this case.
> 
> But cross-casts only come up in the context of classes with multiple bases,
> so it wouldn't make sense to look for this in single inheritance classes
> anyway.
Consider the following,

struct A {};
struct B {};
struct C : public A, public B {};
struct D : public C {};

consider cross cast from an A subobject to a B subobject. suppose we locate
the B subobject. We know C contains no multiple sub objects, 'cos of it's
vmi flags, therefore as soon as we find the target object we can stop searching.
This could mean we don't trip over the A subobject we started from. Hence
at the end of the search, when we're holding the D complete object we know
that B is an unambiguous public base of D, but we have no idea about A.
For the dynamic cast to be valid, either the A subobject must be a base
of the B target object (which it isn't), or the A subobject must be a public
base of the complete D object. Notice, it is insufficient for it to be a public
base of the common vmi object which contains both A and B. Thus, without the
flags in a single inheritance object, we have to go up the base chain till
we find a vmi object to discover whether any bases are private.

Actually it occurs to me that even this case can be dealt with during the
search for B. We find B and know we've not located the A we started from. So
we continue searching (or early succeed as we know there are no private bases,
at that point because of the vmi flags we've just seen). This is better.

I withdraw my objections about the flags only being in vmi classes.

nathan

-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From dehnert at baalbek.engr.sgi.com  Tue Feb  1 20:44:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Feb 2000 12:44:07 -0800 (PST)
Subject: Virtual function calls
Message-ID: <200002012044.MAA86195@baalbek.engr.sgi.com>

I've made this change.

Jim

> This is a nit.
> 
> I don't think:
> 
>   The caller adjusts the 'this' argument to point to the class which
>   last overrode the function being called. The result provides both the
>   'this' argument and the vtable pointer for finding the function we
>   want.
> 
> is very clear...
> 
> I think its easiest to use terms straight out of the standard:
> 
>   The caller adjusts the `this' argument to point to the class
>   that contains the unique final overrider (as defined in
>   [class.virtual]) for the function being called.  The result provides
>   both the 'this' argument and the vtable pointer for finding the
>   function we want.
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Feb  2 07:12:37 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Feb 2000 23:12:37 -0800 (PST)
Subject: emitting vtables (was rtti data layout notes)
Message-ID: <200002020712.XAA88216@baalbek.engr.sgi.com>

One more response from the meeting:

> Date: Mon, 24 Jan 2000 10:17:28 +0000
> From: Nathan Sidwell <sidwell at codesourcery.com>
> 
> 2) place of emission of vtables.
> The vtables for the type_info derrived classes must be in the runtime.
> Other translation units must not emit vtables. Rationale: the runtime
> will expect certain implementation defined virtual member functions
> for these classes. A foreign translation unit must not override the
> runtime's vtable.

The perspective from the meeting was why not?  That is, if the class
has a virtual function, either (a) the user deriving from it needs to
override the vfunc for some reason and should be able to, or (b) the
user shouldn't override it because it's not appropriate, and is
responsible for avoiding the problem.  This stuff is in the
implementation name space, so it shouldn't be happening by accident.
Let the user beware if he trespasses...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From sidwell at codesourcery.com  Wed Feb  2 10:21:55 2000
From: sidwell at codesourcery.com (Nathan Sidwell)
Date: Wed, 02 Feb 2000 10:21:55 +0000
Subject: emitting vtables (was rtti data layout notes)
References: <200002020712.XAA88216@baalbek.engr.sgi.com>
Message-ID: <38980543.345FFE7@codesourcery.com>

Jim Dehnert wrote:
> 
> One more response from the meeting:
> 
> > Date: Mon, 24 Jan 2000 10:17:28 +0000
> > From: Nathan Sidwell <sidwell at codesourcery.com>
> >
> > 2) place of emission of vtables.
> > The vtables for the type_info derrived classes must be in the runtime.
> > Other translation units must not emit vtables. Rationale: the runtime
> > will expect certain implementation defined virtual member functions
> > for these classes. A foreign translation unit must not override the
> > runtime's vtable.
> 
> The perspective from the meeting was why not?  That is, if the class
> has a virtual function, either (a) the user deriving from it needs to
> override the vfunc for some reason and should be able to, or (b) the
> user shouldn't override it because it's not appropriate, and is
> responsible for avoiding the problem.  This stuff is in the
> implementation name space, so it shouldn't be happening by accident.
> Let the user beware if he trespasses...
Oops, I've been careless with terminology. My apologies.

I didn't mean the case of a user deriving from (say) __fundamental_type_info,
which as you say might be dangerous -- the ABI only defines the data
layout for __fundamental_type_info and leaves unspecified any additional
virtual member functions the implementation may add.

I was worried that a translation unit emitting the __class_type_info
definition for `struct Foo' (for example), might have the freedom
of also emitting the vtable for __class_type_info. Naturally that
would be a disaster, as there's no knowledge of the runtime support
internals that the translation unit happens to be linked with. 

I now see that closed issue B-5 (sort of) covers this. What is left
unspecified is that implementations must assume that __class_type_info
has at least one non-inline virtual function. As it stands at the moment,
compiler implementation A is free to have a runtime support definition
of __class_type_info with no non-inline virtual member functions.
Therefore, when that compiler emits the __class_type_info object for
`struct Foo', it must emit the vtable for its definition of __class_type_info.
Of course, that translation unit might be linked with the other modules and
the runtime of implementation B, which has a different definition of
__class_type_info.

I suspect that all implementations will end up having such a virtual
function, but it would be prudent to say so.

nathan

-- 
Dr Nathan Sidwell :: sidwell at codesourcery.com
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From cary at cup.hp.com  Wed Feb  2 18:41:52 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 2 Feb 2000 10:41:52 -0800
Subject: Unwind table location
Message-ID: <200002021841.KAA13057@adlmail.cup.hp.com>

>As I understand it, on ia64 (as on hppa) there is no guarantee that the
>text and data segments will be at a fixed offset from each other, so it is
>not feasible to use GP-relative offsets to refer to code locations.

Correct.

>I'm
>guessing that .rdata is allocated with .data.  Or to be more general, that
>all sections with the CODE attribute are allocated in one group, and those
>with the DATA attribute are in another, such that self-relative references
>work within a group but not between them.  Is this accurate?

No. The grouping is intended to be based on the writable attribute: all 
read-only sections are grouped in the text segment, and all writable 
sections are grouped in the data segment.

It is correct that self-relative references will work only within a 
segment, and not between segments.

>Therefore, the EH info that refers to absolute code locations (i.e. the
>start and end of the procedure fragment) must be in a CODE section.

It doesn't have to, but that's a good place for it. It's always best to 
maximize the amount of shareable data in the program, so I've tried to 
put as much as possible in read-only data, including all unwind and 
exception handling info.

You can, however, refer to absolute code locations from a data section, 
but the pointers would carry dynamic relocations, slowing down the load 
time. You can also use LTVs (link-time virtual addresses), which would 
not carry dynamic relocations, provided the Unwind/EH library has 
sufficient information to perform the relocation on the fly, but then you 
could move the data back to read-only memory.

>The LSDA starts with a pointer to the beginning of the landing pad;
>conceivably this could be made relative to the fragment start, allowing the
>LSDA to go into data, but I see no reason to prefer that.

We've intended to make references from the Unwind/EH info to code 
locations using either 

1. Segment-relative offsets (as the unwind table entries are already 
defined); or

2. Fragment-relative offsets where the compiler can determine the offset 
statically (without the aid of a relocation) and where the Unwind/EH 
library can identify the base address of the fragment from context. (Here 
I'm making an assumption about what you mean by "fragment.")

>In the case of non-contiguous text segments (such as for embedded systems,
>as Jim suggested yesterday), it seems to makes sense to have separate
>tables for each.  A system that requires something like this could define
>its own means of accessing the different tables, though we still need to
>define how that works for the normal case.

Yes. In this case, we would treat each text segment (each including its 
own unwind/EH tables) as a separate load module from the point of view of 
the unwind library. In an embedded system where there is no dynamic 
loader, one could provide a dlmodinfo equivalent that consults static 
tables prepared by the linker.

-cary



From dehnert at baalbek.engr.sgi.com  Thu Feb  3 03:15:36 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 2 Feb 2000 19:15:36 -0800 (PST)
Subject: Agenda for 3 February
Message-ID: <200002030315.TAA72860@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Exception handling.

  B) Mangling.

  C) Data layout.

So, take a look at the material associated with these issues:

  1) D-11:  I've written up the pthreads entries.
     Is this what we want?

  2) D-12:  Unwind table location.  See the exchange with Cary (HP)
     in the open issues document.

  3) F-*:  Mangling.  Do you have an update, Daveed?

  4) A-22:  Eliminate reference type RTTI?

  5) A-23:  Resolve structure of class RTTI.

  6) A-24:  Incomplete type RTTI.

  7) A-21:  Placement new array cookies.  Discuss the options if
     there's time

Issues that are active and awaiting proposals:

  a) C-4:  Coleen will write up construction vtables so we can
     verify.  Wait.

Jim

-		Jim Dehnert  x3-4272



From daveed at edg.com  Thu Feb  3 16:04:32 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 03 Feb 2000 08:04:32 -0800
Subject: Agenda for 3 February
References: <200002030315.TAA72860@baalbek.engr.sgi.com>
Message-ID: <3899A710.D74EC595@edg.com>

Jim Dehnert wrote:
[...]
>   3) F-*:  Mangling.  Do you have an update, Daveed?

Nope, I'm afraid I forgot to work on that this week :-/

	Daveed



From jason at cygnus.com  Thu Feb  3 17:27:15 2000
From: jason at cygnus.com (Jason Merrill)
Date: 03 Feb 2000 09:27:15 -0800
Subject: Vcall/vbase offset clarification
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Mon, 31 Jan 2000 19:15:03 -0800 (PST)"
References: <200001252056.MAA66540@baalbek.engr.sgi.com> <200002010315.TAA84577@baalbek.engr.sgi.com>
Message-ID: <u9bt5yxklo.fsf@yorick.cygnus.com>

 >> I'm not quite sure *why* we do it this way.  Why not just have the
 >> C-as-A vtable contain a function which adjusts the `A*' directly to a
 >> `C*'?  I guess we decided we wanted to avoid having to use thunks --
 >> the current scheme allows the cascading entry point approach.  Was
 >> that the reason?

Yes.  This way, all the thunks can be emitted at the beginning of the
function, so we can use a pc-relative branch or just fall through.  The
performance is much better as a result.

Jason



From jason at cygnus.com  Thu Feb  3 18:04:24 2000
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 3 Feb 2000 10:04:24 -0800
Subject: ABI phone number?
Message-ID: <200002031804.KAA31624@yorick.cygnus.com>

I just called the number listed for this week, and got some other meeting.
Does anyone reading email now know the right number?

Jason



From daveed at edg.com  Thu Feb  3 18:13:15 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 03 Feb 2000 10:13:15 -0800
Subject: ABI phone number?
References: <200002031804.KAA31624@yorick.cygnus.com>
Message-ID: <3899C53B.7BF33894@edg.com>

It is (650) 933-7969, but there seem to be problems with their
phone switch.  I suspect the number was mapped twice.  I'd suggest
just trying again.

	Daveed

Jason Merrill wrote:
> 
> I just called the number listed for this week, and got some other meeting.
> Does anyone reading email now know the right number?
> 
> Jason



From dehnert at baalbek.engr.sgi.com  Fri Feb  4 00:26:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 3 Feb 2000 16:26:05 -0800 (PST)
Subject: RTTI updates
Message-ID: <200002040026.QAA93105@baalbek.engr.sgi.com>

I've updated the abi-layout.html page to reflect this morning's decisions
about RTTI issues A-22 and A-23.  Removing the reference type RTTI is
straightforward, but the class type restructuring is a bit different than
what I expected going in (could just be my confusion).

I moved the flags from __class_type_info to __vmi_class_type_info,
discovering that they don't need to share space with the offset field
in the __base_class_info records, but rather with the base class count.
This is actually simpler, but check how I specified that and comment if
you have better ideas.

But, the __base_class_info has its own flags (virtual and public)
which can reasonably share a doubleword, as we were discussing for the
other flags this morning.  So I specified that -- see what you think.
Note that I put the flags in the low byte rather than the high byte.
That is because the offset is signed, and it is likely that
implementations will sign-extend (signed doubleword>>8), but not
(doubleword & 0x00ffffffffffffffll).  If you have other ideas, please
suggest them.

The HTML is updated, not the PDF yet.

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Fri Feb  4 10:09:13 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 4 Feb 2000 11:09:13 +0100
Subject: Vcall/vbase offset clarification
In-Reply-To: <200002010315.TAA84577@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200001252056.MAA66540@baalbek.engr.sgi.com> <200002010315.TAA84577@baalbek.engr.sgi.com>
Message-ID: <200002041009.LAA23682@pandora>

> > From mitchell at codesourcery.com  Tue Jan 25 13:26:12 2000
> >   struct A { void f();}
> >   struct B : public virtual A {};
[...]
> >   o First, we convert to the most derived class in which `f' was
> >     overridden.  That's `A'.  We know statically what offset
> >     to adjust `b' by to get an `A*'.

Maybe you didn't mean it that way, but: How do we know statically the
offset needed to adjust a B* to an A*? Wouldn't we have to look in the
vtable at run time to fetch the vbase offset?

> >   o We pass this value to the function found in the vtable for `A'.
> > 
> >   o That function will first perform the constant adjustment from 
> >     `A' to `B'.  

Or perhaps that shouldn't have been virtual inheritance in the B
bases?

Regards,
Martin



From nathan at acm.org  Fri Feb  4 10:08:37 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Fri, 04 Feb 2000 10:08:37 +0000
Subject: RTTI updates
References: <200002040026.QAA93105@baalbek.engr.sgi.com>
Message-ID: <389AA525.CA6F4E1F@acm.org>

Jim Dehnert wrote:
[rtti updates]

Thanks for the update, it all looks good.

Some pedant points.
* (7b) The description of __si_type_info still does not say the base must
be public and at offset zero.
* (7c) The description of __class_type_info still says `containing (directly
or indirectly)', Jason's mail indicates the intention is `containing directly'
* (7c) The vmi_flags should probably indicate they refer to direct and indirect
bases.

And a more significant one.
* (7c) I see the diamond shaped flag has been added, what about the non-diamond
shaped multiple sub-object? That too is important for dynamic cast and base
class catching.

For instance, in dynamic cast, when we locate an instance of the target class
the following cases can be considered
1) The complete class has no multiple sub-objects. There cannot be another
instance of the target class in the heirarchy, so we're done.
2) The complete class is diamond-shaped, but has no non-diamond shaped multiple
base object. There will be no other instance of the target class, but the target
may be reachable via another path. That other path could be publicly accessible,
so if we've found a private access to the target keep looking, otherwise we're
done.
3) The complete class has non-diamond shaped multiple base object, but is not
diamond shaped. There may be other instances of the target class, which could
ambiguate the dynamic cast. The other instances cannot share base objects. If the
src sub object is within the located target, this is unambiguous, so we're done.
Otherwise keep looking.
4) The complete class has non-diamond shaped multiple base object, and is
diamond shaped too. There may be other instances of the target class, which
could share base objects. Keep looking.

Similar cases arise in catch matching on casting derived to base.

Without the non-diamond shaped multiple subobject flag, both dynamic cast
and catch matching must take paths 3 or 4, which are more work and I'd hazard
less common.

Maybe there was insufficient time to discus this at the meeting. Just want to
make sure it's not forgotten.

nathan
-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From mendell at ca.ibm.com  Fri Feb  4 17:19:12 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Fri, 4 Feb 2000 12:19:12 -0500
Subject: Bitfields of greater than field size
Message-ID: <8725687B.005EE227.00@d53mta05h.boulder.ibm.com>



I have been told that the standard allows:

struct foo {
     long xx : 128;
};

This is a field that takes up 128 bits of space, but only really uses
sizeof(long) * 8 bits.
We have to agree on where the padding goes.  I couldn't find it in the data
layout spec.
Our compiler puts it after the 'real' bits.

Mark





From loewis at informatik.hu-berlin.de  Fri Feb  4 17:46:25 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 4 Feb 2000 18:46:25 +0100
Subject: Bitfields of greater than field size
In-Reply-To: <8725687B.005EE227.00@d53mta05h.boulder.ibm.com>
	(mendell@ca.ibm.com)
References: <8725687B.005EE227.00@d53mta05h.boulder.ibm.com>
Message-ID: <200002041746.SAA10539@pandora>

> I have been told that the standard allows:
> 
> struct foo {
>      long xx : 128;
> };

> This is a field that takes up 128 bits of space, but only really
> uses sizeof(long) * 8 bits.  We have to agree on where the padding
> goes.  I couldn't find it in the data layout spec.
> Our compiler puts it after the 'real' bits.

Isn't that already specified by the base API (gABI, psABI)? (not that
I have access to the base API...)

Regards,
Martin



From mendell at ca.ibm.com  Fri Feb  4 19:35:32 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Fri, 4 Feb 2000 14:35:32 -0500
Subject: Bitfields of greater than field size
Message-ID: <8725687B.006B9691.00@d53mta04h.boulder.ibm.com>




I doubt it, since it isn't legal C code.

Mark


> I have been told that the standard allows:
>
> struct foo {
>      long xx : 128;
> };

> This is a field that takes up 128 bits of space, but only really
> uses sizeof(long) * 8 bits.  We have to agree on where the padding
> goes.  I couldn't find it in the data layout spec.
> Our compiler puts it after the 'real' bits.

Isn't that already specified by the base API (gABI, psABI)? (not that
I have access to the base API...)

Regards,
Martin





From dehnert at baalbek.engr.sgi.com  Fri Feb  4 21:27:18 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 4 Feb 2000 13:27:18 -0800 (PST)
Subject: Bitfields of greater than field size
References: <8725687B.005EE227.00@d53mta05h.boulder.ibm.com>
Message-ID: <200002042127.NAA96074@baalbek.engr.sgi.com>

> To: mendell at ca.ibm.com
> Subject: Re: Bitfields of greater than field size
> Reply-To: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> > I have been told that the standard allows:
> > 
> > struct foo {
> >      long xx : 128;
> > };
> 
> > This is a field that takes up 128 bits of space, but only really
> > uses sizeof(long) * 8 bits.  We have to agree on where the padding
> > goes.  I couldn't find it in the data layout spec.
> > Our compiler puts it after the 'real' bits.
> 
> Isn't that already specified by the base API (gABI, psABI)? (not that
> I have access to the base API...)

I've never seen this in an ABI.  I just verified that this is
explicitly forbidden by the C 2000 draft standard, which would explain
its absence in C ABIs.  I also verified that it is explicitly allowed
by the C++ standard, with the excess being treated as inaccessible
padding, making it a valid concern of our C++ ABI.  I'll open an issue.
Would someone care to write up a careful discussion of the issues?
It seems to me that the situation that makes it interesting is the
following:

	struct s {
	  short s1;
	  int i: 64;
	  short s2;
	}

In this case, I don't want the accessible part of i at the beginning or
the end -- I want it in the middle.  Doing otherwise gives me either a
badly aligned i, or wasted space.

I think one could express this by the following rule:

	Place the accessible part of the bitfield object as if
	it were a non-bitfield member of the declared type, i.e.
	at the next available offset of the appropriate alignment.
	Allocate the full bitfield at the earliest available
	offset where it will include the accessible part.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Fri Feb  4 21:35:32 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 4 Feb 2000 22:35:32 +0100
Subject: Bitfields of greater than field size
In-Reply-To: <8725687B.006B9691.00@d53mta04h.boulder.ibm.com>
	(mendell@ca.ibm.com)
References: <8725687B.006B9691.00@d53mta04h.boulder.ibm.com>
Message-ID: <200002042135.WAA18363@pandora>

> I doubt it, since it isn't legal C code.

Oops, yes, I was confused.

Martin



From mendell at ca.ibm.com  Fri Feb  4 22:17:30 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Fri, 4 Feb 2000 17:17:30 -0500
Subject: Bitfields of greater than field size
Message-ID: <8725687B.007A752F.00@d53mta04h.boulder.ibm.com>



I disagree.  If the user wants the bitfield to be aligned in a certain
place, he
 has the tools to do so.  He can certainly pick a different size bitfield.
I think that this should be aligned as if it is the same size as the type,
and then
the extra bits put somewhere.  Putting them afterwards is probably simpler
than before, or splitting it in the middle.

Mark



dehnert at baalbek.engr.sgi.com (Jim Dehnert) on 02/04/2000 04:27:18 PM

Please respond to dehnert at sgi.com

To:   Mark Mendell/Toronto/IBM at IBMCA, Martin von Loewis
      <loewis at informatik.hu-berlin.de>
cc:   cxx-abi at corp.sgi.com
Subject:  Re: Bitfields of greater than field size




> To: mendell at ca.ibm.com
> Subject: Re: Bitfields of greater than field size
> Reply-To: Martin von Loewis <loewis at informatik.hu-berlin.de>
>
> > I have been told that the standard allows:
> >
> > struct foo {
> >      long xx : 128;
> > };
>
> > This is a field that takes up 128 bits of space, but only really
> > uses sizeof(long) * 8 bits.  We have to agree on where the padding
> > goes.  I couldn't find it in the data layout spec.
> > Our compiler puts it after the 'real' bits.
>
> Isn't that already specified by the base API (gABI, psABI)? (not that
> I have access to the base API...)

I've never seen this in an ABI.  I just verified that this is
explicitly forbidden by the C 2000 draft standard, which would explain
its absence in C ABIs.  I also verified that it is explicitly allowed
by the C++ standard, with the excess being treated as inaccessible
padding, making it a valid concern of our C++ ABI.  I'll open an issue.
Would someone care to write up a careful discussion of the issues?
It seems to me that the situation that makes it interesting is the
following:

     struct s {
       short s1;
       int i: 64;
       short s2;
     }

In this case, I don't want the accessible part of i at the beginning or
the end -- I want it in the middle.  Doing otherwise gives me either a
badly aligned i, or wasted space.

I think one could express this by the following rule:

     Place the accessible part of the bitfield object as if
     it were a non-bitfield member of the declared type, i.e.
     at the next available offset of the appropriate alignment.
     Allocate the full bitfield at the earliest available
     offset where it will include the accessible part.

Jim

-        Jim Dehnert          dehnert at sgi.com
                    (650)933-4272






From dehnert at baalbek.engr.sgi.com  Fri Feb  4 22:28:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 4 Feb 2000 14:28:35 -0800 (PST)
Subject: Vcall/vbase offset clarification
References: <200001252056.MAA66540@baalbek.engr.sgi.com>
    <200002010315.TAA84577@baalbek.engr.sgi.com>
Message-ID: <200002042228.OAA96694@baalbek.engr.sgi.com>

> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> To: mark at codesourcery.com
> 
> > > From mitchell at codesourcery.com  Tue Jan 25 13:26:12 2000
> > >   struct A { void f();}
> > >   struct B : public virtual A {};
> [...]
> > >   o First, we convert to the most derived class in which `f' was
> > >     overridden.  That's `A'.  We know statically what offset
> > >     to adjust `b' by to get an `A*'.
> 
> Maybe you didn't mean it that way, but: How do we know statically the
> offset needed to adjust a B* to an A*? Wouldn't we have to look in the
> vtable at run time to fetch the vbase offset?
> 
> > >   o We pass this value to the function found in the vtable for `A'.
> > > 
> > >   o That function will first perform the constant adjustment from 
> > >     `A' to `B'.  
> 
> Or perhaps that shouldn't have been virtual inheritance in the B
> bases?

I think the right statement is 'we know statically how to adjust "b" to
get an "A*".  If A is a non-virtual base, we know the offset
statically.  If it is a virtual base, we know statically where to fetch
the vbase offset in the vtable.'

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Feb  4 22:48:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 4 Feb 2000 14:48:24 -0800 (PST)
Subject: A-23 RTTI class structures (was RTTI updates)
References: <200002040026.QAA93105@baalbek.engr.sgi.com>
Message-ID: <200002042248.OAA96608@baalbek.engr.sgi.com>

I've fixed all of Nathan's concerns except that of indicating whether
the vmi_flags refer to direct and indirect bases.  That one's because I
wasn't sure of the right answer.  It seems useful to include both
direct and indirect properties except for:

 1) has non-virtual bases (would anyone ever care about indirect ones?)
 2) maybe publicly inherited bases (same reason)

Opinions on these (and the others)?

I also made the fix for his more significant concern.  I had left out
the multiple inheritance flag because of the exchange with Jason at the
meeting indicating agreement that it wasn't necessary.  But one or both
of us may have misunderstood what we were discussing.  Does anyone have
a problem with including it?

> From nathan at acm.org  Fri Feb  4 02:12:00 2000
> 
> Some pedant points.
> * (7b) The description of __si_type_info still does not say the base must
> be public and at offset zero.
> * (7c) The description of __class_type_info still says `containing (directly
> or indirectly)', Jason's mail indicates the intention is `containing directly'
> * (7c) The vmi_flags should probably indicate they refer to direct and
> indirect bases.
> 
> And a more significant one.
> * (7c) I see the diamond shaped flag has been added, what about the non-diamond
> shaped multiple sub-object? That too is important for dynamic cast and base
> class catching.
> 
> For instance, in dynamic cast, when we locate an instance of the target class
> the following cases can be considered
> 1) The complete class has no multiple sub-objects. There cannot be another
> instance of the target class in the heirarchy, so we're done.
> 2) The complete class is diamond-shaped, but has no non-diamond shaped multiple
> base object. There will be no other instance of the target class, but the target
> may be reachable via another path. That other path could be publicly accessible,
> so if we've found a private access to the target keep looking, otherwise we're
> done.
> 3) The complete class has non-diamond shaped multiple base object, but is not
> diamond shaped. There may be other instances of the target class, which could
> ambiguate the dynamic cast. The other instances cannot share base objects. If the
> src sub object is within the located target, this is unambiguous, so we're done.
> Otherwise keep looking.
> 4) The complete class has non-diamond shaped multiple base object, and is
> diamond shaped too. There may be other instances of the target class, which
> could share base objects. Keep looking.
> 
> Similar cases arise in catch matching on casting derived to base.
> 
> Without the non-diamond shaped multiple subobject flag, both dynamic cast
> and catch matching must take paths 3 or 4, which are more work and I'd hazard
> less common.
> 
> Maybe there was insufficient time to discus this at the meeting. Just want to
> make sure it's not forgotten.
> 
> nathan
> -- 
> Dr Nathan Sidwell :: Computer Science Department :: Bristol University
> Never hand someone a gun unless you are sure where they will point it
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Feb  5 00:56:51 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 4 Feb 2000 16:56:51 -0800 (PST)
Subject: A-25 Bitfields of greater than field size
Message-ID: <200002050056.QAA95188@baalbek.engr.sgi.com>

> I disagree.  If the user wants the bitfield to be aligned in a certain
> place, he has the tools to do so.  He can certainly pick a different
> size bitfield.  I think that this should be aligned as if it is the
> same size as the type, and then the extra bits put somewhere.  Putting
> them afterwards is probably simpler than before, or splitting it in
> the middle.

I see your point, but I draw the opposite conclusion.  If the user
wants a specific layout, he can use separate padding fields.  This
structure tells me that he wants a specific amount of space, total, and
doesn't care where the real data is.  I conclude that the compiler
should come as close to the requested space as is possible given the
natural alignment constraints.

(I must admit, though, that my other conclusion is that such a user
quite likely doesn't know what he's doing.  Does anyone know what the
rationale for this feature was?)

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From cary at cup.hp.com  Mon Feb  7 19:11:54 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Mon, 7 Feb 2000 11:11:54 -0800
Subject: A-25 Bitfields of greater than field size
Message-ID: <200002071910.LAA04282@adlmail.cup.hp.com>

>(I must admit, though, that my other conclusion is that such a user
>quite likely doesn't know what he's doing.  Does anyone know what the
>rationale for this feature was?)

The only possible rationale I can imagine is to get a degree of 
independence from the machine-specific data representations. Perhaps the 
programmer is trying to create a structure whose external representation 
is the same on another machine, where int might be 64 bits. If that's the 
case, I'd think it's important to allocate 64 bits on a 64-bit boundary, 
and position the 32-bit int at the LSB end of the allocation (i.e., 
padding on the left).

That said, I'll admit that that's still a pretty lame rationale.

-cary



From dehnert at baalbek.engr.sgi.com  Mon Feb  7 20:13:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Feb 2000 12:13:07 -0800 (PST)
Subject: Status page updates
Message-ID: <200002072013.MAA02831@baalbek.engr.sgi.com>

The web pages have been updated to reflect Thursday's meeting...

Jim
-		Jim Dehnert  x3-4272



From ddd at cup.hp.com  Mon Feb  7 22:59:43 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 07 Feb 2000 22:59:43 +0000
Subject: Updated mangling specs
References: <388F8D40.6FB44DD5@edg.com>
Message-ID: <389F4E5F.E5112313@cup.hp.com>

Daveed,


One issue that is not covered by your initial proposal is the mangling of static
data inside functions. In particular:

- Mangling of static data in inline functions or templates
- Mangling of strings constants in inline functions


Also, to allow cross-.o file inlining, you need to extend that to any function
(not only those explicitly marked inline.) Strictly speaking, this is outside
the ABI, but unless there are strong reasons not to, I'd advocate mangling any
static data, regardless of whether the function is tagged inline or not.


Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Wed Feb  9 00:24:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 8 Feb 2000 16:24:06 -0800 (PST)
Subject: Agenda for Thursday 2/10
Message-ID: <200002090024.QAA07862@baalbek.engr.sgi.com>

Following is an updated agenda for Thursday.  I will be out of town,
so Matt and/or John will run the meeting.  Please check the red text in
the abi-layout document (recently changed information) and let me know
if there are any issues -- this is relevant to A-23 below, too.

The status pages are updated and on the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Mangling.

  B) Data layout.

  C) Exception handling.

So, take a look at the material associated with these issues:

  1) F-*:  Mangling.  Do you have an update, Daveed?

  2) A-23:  Resolve structure of class RTTI.
     This is probably ready to close now.

  3) A-24:  Incomplete type RTTI.  Do we use a dummy COMMON pointer?
     Where do we put it in the structure, if so?  Should we ask the
     base ABI for a "unique address" symbol capability?

  4) Choose a namespace for the RTTI definitions -- std:: or abi::.

  5) A-21:  New array cookies.  When are they allocated?

  6) A-25:  Excess-width bitfields.

  7) D-12:  Unwind table location.

Issues that are active and awaiting proposals:

  a) C-4:  Coleen will write up construction vtables so we can
     verify.  Wait.  But it would be nice to tackle this if we get a
     proposal (priority 5.5 above).  Hint, hint...

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Feb  9 02:12:53 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 8 Feb 2000 18:12:53 -0800 (PST)
Subject: D-12 Unwind table location
References: <200001282350.PAA24742@adlmail.cup.hp.com>
Message-ID: <200002090212.SAA08837@baalbek.engr.sgi.com>

I'd like to continue working through the table location issues, as
we've started in email and at the last meeting.  But first, I think
my concern has been misinterpreted, so I'd like to clarify that.

---

I don't have an immediate objection to the locations identified for
the tables by HP, except possibly sharing Jason's question about
whether another type table location would better allow sharing it
among multiple text segments.  I would guess that we'll end up
agreeing to put the tables where HP does (except, again, possibly
the type table) for IA-64.

However, I also believe in maximizing flexibility and generality,
at least when it's nearly free, and particularly when there are
anticipatable uses for it.  Now, I can anticipate two departures
from HP's assumptions that are relevant here:

  - Multiple text segments.  This is common in the embedded world,
    where the reasons for them often also prevent their being adjacent
    in the address, and probably also sometimes prevent the inclusion
    of extraneous data with each text segment.

  - LSDA somewhere besides the associated .text segment.  See the
    above, or imagine a language/implementation that decides to put a
    lot of runtime-relocated data in it.

These possibilities, even though I don't anticipate them for IA-64
mainstream C++, lead me to ask the question:  Can we provide the
flexibility to support them at little or no cost to our own needs?

---

With this in mind, what are the requirements?  We have four structures
of interest:

 1) The original entry to the complex is via an IP value, i.e. an
    address in .text (probably).  The unwind library, which is part of
    the implementation and therefore can be coordinated with other
    system components like ld.so, needs to map this IP value to the
    associated .text segment start address and to its associated
    .unwind segment address and size, which it uses to find an unwind
    table entry.

    So, we need under-the-covers maps from IP -> .text -> .unwind .

 2) The unwind table entry identifies a text fragment, using
    offsets relative to the .text segment, which it should know from
    step (1).  It also identifies an unwind info record, currently as
    an offset relative to the .text segment.  This still happens in the
    unwind library.

    So, we add an under-the-covers map from .unwind -> .unwind_info .

 3) The unwind info table contains unwind descriptor references
    relative to the text fragment, handled in the unwind library,
    and the LSDA, handled by the personality routine.  The latter
    includes:

    ** LPStart, an offset currently relative to its own location,
    which requires that unwind info be in the associated text segment.

    ** TTBase, an offset currently relative to its own location,
    which requires that the type table be in the unwind info segment.

    Other references to call sites and landing pads, as offsets
    relative to the address calculated from LPStart.

 4) The type table contains RTTI references, relative to GP for the
    current text fragment, handled by the personality routine.
    
    ** This requires that the RTTI be in the data segment containing
    GP, and prevents address-only RTTI comparisons, since it does not
    support preemption.

The potentially problematic references are those with (**), which make
assumptions about the locations of tables AND are handled by the
personality routine above-the-covers.  (The under-the-covers mappings
can use unspecified collaboration between the system and unwind
library.)

The unwind info references could be "fixed" by making them relative to
segment addresses identified by the unwind library (more
under-the-covers mappings) and passed to the personality routine, e.g.
via routines like _Unwind_GetIP.

The type table requirement that RTTI be in the segment with GP could be
fixed in the same way; the inability to deal with address-only
comparisons cannot.

Finally, although the under-the-covers mappings need not be our
official concern, I note that the relevant information is known to the
static linker (except perhaps .unwind_info location), and providing an
explicit way to pass it from linker to unwind library might simplify
the latter and make it more portable.

Anyway, I hope this clarifies things somewhat.  It leads me to believe
that pursuing this can produce simple elimination of the current
restrictions.

Comments?

Jim


-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Thu Feb 10 18:31:37 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 10 Feb 2000 19:31:37 +0100
Subject: Static locals (Was: Updated mangling specs)
In-Reply-To: <389F4E5F.E5112313@cup.hp.com> (message from Christophe de
	Dinechin on Mon, 07 Feb 2000 22:59:43 +0000)
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com>
Message-ID: <200002101831.TAA21378@pandora>

> - Mangling of static data in inline functions or templates
> - Mangling of strings constants in inline functions

In relation to issue G-3, we then also need to specify how
initialisation of static data happens. The standard says that
initialization of those data can fail (with an exception), in which
case it must be "re-tried" the next time the same block is entered.

To achieve this, g++ adds an implicit variable, which indicates
whether the static has been initialized. We need to specify

- the type of that variable
- the meaning of its possible values
- the mangling of that variable

If compilers want thread-aware initialization of such a variable, a
simple two-state value does not suffice, as there are at least three
possible states:
- variable is uninitialized
- initialization is in progress (so other threads should block when
  the reach the variable declaration)
- variable is fully initialized

Whether or not thread-safe initialization is part of the ABI or an
extension is another issue, IMHO; if it was, the mechanism would need
to be specified (along with the mangling for the mutexes and so on).

However, I think the ABI should support the three-state approach in
any case: this will also allow to detect recursive entering of
initializations (which has undefined behaviour).

Regards,
Martin



From jls at sco.com  Thu Feb 10 19:22:00 2000
From: jls at sco.com (Jonathan Schilling)
Date: Thu, 10 Feb 2000 14:22 EST
Subject: Static locals (Was: Updated mangling specs)
Message-ID: <200002101926.OAA22971@kauai.newjersey.sco.com>

> From owner-cxx-abi at corp.sgi.com Thu Feb 10 13:41:26 2000
> 
> [...] If compilers want thread-aware initialization of such a variable, a
> simple two-state value does not suffice, as there are at least three
> possible states:
> - variable is uninitialized
> - initialization is in progress (so other threads should block when
>   the reach the variable declaration)
> - variable is fully initialized
> 
> Whether or not thread-safe initialization is part of the ABI or an
> extension is another issue, IMHO; if it was, the mechanism would need
> to be specified (along with the mangling for the mutexes and so on).
> 
> However, I think the ABI should support the three-state approach in
> any case: this will also allow to detect recursive entering of
> initializations (which has undefined behaviour).

Thread-safe initialization is issue G-4 on the open issues list.

It's not clear from what you wrote whether your comments are in response
to the discussion in that issue or not.  I still think this is something 
the ABI should cover.

Jonathan Schilling		SCO, Inc.		jls at sco.com



From loewis at informatik.hu-berlin.de  Thu Feb 10 20:12:36 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 10 Feb 2000 21:12:36 +0100
Subject: Static locals (Was: Updated mangling specs)
In-Reply-To: <200002101926.OAA22971@kauai.newjersey.sco.com> (jls@sco.com)
References: <200002101926.OAA22971@kauai.newjersey.sco.com>
Message-ID: <200002102012.VAA24924@pandora>

> Thread-safe initialization is issue G-4 on the open issues list.

Ah, thanks.

> It's not clear from what you wrote whether your comments are in
> response to the discussion in that issue or not.  I still think this
> is something the ABI should cover.

I was proposing to break the problem into pieces. One piece that is
certainly needed is the guard; and in particular its mangling. In my
view, that is an issue that can be more easily agreed-upon.

I was also proposing a resolution to that issue, namely, to make the
guard three-state.

I also agree that the ABI should cover thread-safe initialisation, but
I did not want to pick up that discussion right now.

Regards,
Martin



From jason at cygnus.com  Thu Feb 10 17:36:15 2000
From: jason at cygnus.com (Jason Merrill)
Date: 10 Feb 2000 09:36:15 -0800
Subject: Updated mangling specs
In-Reply-To: Christophe de Dinechin's message of "Mon, 07 Feb 2000 22:59:43 +0000"
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com>
Message-ID: <u9ln4t2c4w.fsf@casey.cygnus.com>

Christophe de Dinechin <ddd at cup.hp.com> writes:

> One issue that is not covered by your initial proposal is the
> mangling of static data inside functions. In particular:
> 
> - Mangling of static data in inline functions or templates
> - Mangling of strings constants in inline functions

True, though we decided last week that these can be handled by simply
adding a sequence number to the name of the function.  gcc also
includes the name of the static variable; that's not necessary for
linking, but it is for demangling.

This also applies to local classes.

Daveed, want to make a specific proposal?

> Also, to allow cross-.o file inlining, you need to extend that to
> any function (not only those explicitly marked inline.) Strictly
> speaking, this is outside the ABI, but unless there are strong
> reasons not to, I'd advocate mangling any static data, regardless of
> whether the function is tagged inline or not.

We should mangle the static data for any function that may be inlined;
which functions those are depends on the compiler.

Jason



From jason at cygnus.com  Thu Feb 10 17:49:25 2000
From: jason at cygnus.com (Jason Merrill)
Date: 10 Feb 2000 09:49:25 -0800
Subject: A-23 RTTI class structures (was RTTI updates)
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Fri, 4 Feb 2000 14:48:24 -0800 (PST)"
References: <200002040026.QAA93105@baalbek.engr.sgi.com> <200002042248.OAA96608@baalbek.engr.sgi.com>
Message-ID: <u9itzx2biy.fsf@casey.cygnus.com>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

> I've fixed all of Nathan's concerns except that of indicating whether
> the vmi_flags refer to direct and indirect bases.  That one's because I
> wasn't sure of the right answer.  It seems useful to include both
> direct and indirect properties except for:
> 
>  1) has non-virtual bases (would anyone ever care about indirect ones?)
>  2) maybe publicly inherited bases (same reason)
> 
> Opinions on these (and the others)?

You mean duplicate the flags, once for direct and once for indirect?
That seems useless to me; I agree with Nathan that the flags refer to
both direct and indirect bases.

> I also made the fix for his more significant concern.  I had left out
> the multiple inheritance flag because of the exchange with Jason at the
> meeting indicating agreement that it wasn't necessary.  But one or both
> of us may have misunderstood what we were discussing.  Does anyone have
> a problem with including it?

Nope, makes sense to me.

I'm still not sure what 'has {non-,}virtual base' are good for,
though.  The only reason that we care about the difference between
virtual and non-virtual bases is because of the potential for diamond
shapes, right?

Jason



From jason at cygnus.com  Thu Feb 10 20:35:42 2000
From: jason at cygnus.com (Jason Merrill)
Date: 10 Feb 2000 12:35:42 -0800
Subject: Vcall/vbase offset clarification
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Fri, 4 Feb 2000 14:28:35 -0800 (PST)"
References: <200001252056.MAA66540@baalbek.engr.sgi.com> <200002010315.TAA84577@baalbek.engr.sgi.com> <200002042228.OAA96694@baalbek.engr.sgi.com>
Message-ID: <u9hffg23tt.fsf@yorick.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 >> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
 >> To: mark at codesourcery.com
 >> 
 >> > > From mitchell at codesourcery.com  Tue Jan 25 13:26:12 2000
 >> > >   struct A { void f();}
 >> > >   struct B : public virtual A {};
 >> [...]
 >> > >   o First, we convert to the most derived class in which `f' was
 >> > >     overridden.  That's `A'.  We know statically what offset
 >> > >     to adjust `b' by to get an `A*'.
 >> 
 >> Maybe you didn't mean it that way, but: How do we know statically the
 >> offset needed to adjust a B* to an A*? Wouldn't we have to look in the
 >> vtable at run time to fetch the vbase offset?
 >> 
 >> > >   o We pass this value to the function found in the vtable for `A'.
 >> > > 
 >> > >   o That function will first perform the constant adjustment from 
 >> > >     `A' to `B'.  
 >> 
 >> Or perhaps that shouldn't have been virtual inheritance in the B
 >> bases?

 > I think the right statement is 'we know statically how to adjust "b" to
 > get an "A*".  If A is a non-virtual base, we know the offset
 > statically.  If it is a virtual base, we know statically where to fetch
 > the vbase offset in the vtable.'

No, I'm with Martin on this.  We're trying to adjust from A* to C*; the
adjustment from B* to A* is not useful.

Jason



From jason at cygnus.com  Thu Feb 10 20:43:55 2000
From: jason at cygnus.com (Jason Merrill)
Date: 10 Feb 2000 12:43:55 -0800
Subject: A-25 Bitfields of greater than field size
In-Reply-To: Cary Coutant's message of "Mon, 7 Feb 2000 11:11:54 -0800"
References: <200002071910.LAA04282@adlmail.cup.hp.com>
Message-ID: <u9emak23g4.fsf@yorick.cygnus.com>

It seems to me that

struct A {
  ...
  signed char c: 32;
  ...
};

should be treated like

struct A {
  ...
  int i: 32;
  ...
};

except that only the low 8 bits are significant.  This should be true
whether or not there is actually a 32-bit type on the target.

Jason



From austern at isolde.engr.sgi.com  Fri Feb 11 00:22:03 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Thu, 10 Feb 2000 16:22:03 -0800
Subject: Notes from 10 Feb meeting
Message-ID: <10002101622.ZM144811@isolde.engr.sgi.com>

                      Notes from 10 Feb meeting

                              NEW ISSUES

>From HP:
HP will be supporting an ilp32 model as well as as an lp64 model.
The ABI only discusses an lp64 model.  Do we want to support ilp32
in any way?  What will we have to do to support (a) compatibility
between different vendors' ipl32 compilers (b) compatibility between
ilp32 and lp64.  HP has suggested, for example, modifying the mangling
scheme so that long long in ipl32 is mangled the same way as long in
lp64.  Is this enough to ensure ipl32/lp64 link compatibility, or
would we need to make many other changes as well?

>From Cygnus:
Users have access to types' mangled names via the standard type_info
class.  Users may sometimes want to get demangled names.  Should
we provide an entry point for calling a demangler?  This might be
a standalone function, perhaps with an interface like that of EDG's
demangle(), or it might be some kind of type_info extension.  If we
do this, should we attempt to specify exactly what demangled names
look like, or should we explicitly leave it unspecified and warn users
not to depend on the exact format?

                             ACTION ITEMS

Christophe - Find out whether the base ABI nails down the sizes of all
basic floating point types.  (Is long double always required to be 80
bits?)  If not, we may have some issues here.

Christophe - Write up a proposal for using incomplete_type_info
rather than using the comdat proxy method.  (See A24 discussion
below.)

Matt - Write up detailed wording for Issue A21 Proposal C.

Daveed - Update mangling document based on today's discussion.

Coleen - Finish construction vtable writeup.

                               MANGLING

We have agreed that local statics and local classes must be mangled.
We agreed that string literals should also be mangled even if linker
features might make it unnecessary.  The motivation is a desire to
support less capable linkers on other platforms.

For local statics and local classes, the mangled name consists of the
mangled function name, a sequence number, and the name of the local
class/varaible.  For string literals the mangled name consists only of
the mangled function name and the sequence number.

(There was concern that this might prevent merging of identical string
literals.  Jason believes it doesn't, that given a smart linker it
will just result in multiple names for the same string literal.)

Sequence numbers are assigned in lexical order within a function,
starting at 1.  The entities that receive sequence numbers are local
static variables, local classes, and string literals.  Other entities
(e.g. automatic variables) do not receive or affect sequence numbers.

Exception specification information must be part of the mangled name
of a function.

Special entities that need to receive mangled names, in addition to those
mentioned in Daveed's document:

 - Vtables (which should contain mangled name of complete type)
 - Construction vtables probably do not require mangled names, and
   table of vtables probably doesn't either.  Daveed will reserve
   prefixes for them just in case.
 - If we are using the comdat proxy method for class typeinfos,
   then both class typeinfo objects and the comdat proxies must be
   given mangled names.  We must ensure that the comdat proxy for
   an incomplete class is the same as the one for a complete class
   with the same name, and we must ensure that the typeinfo object
   for an incomplete class is different from that of any complete
   class.  (Either that, or make all typeinfo objects for incomplete
   classes static.)

Exported template may require other things to be mangled.  We don't
have a detailed analysis.

We discussed the idea of having a small dictionary of well known
names, so that mangled names could be shorter.  Jason was concerned
with readability of mangled names if we had too many things in this
dictionary, and Daveed was concerned that a large dictionary wouldn't
give enough of a space savings because an index would take too many
bits.  If we have such a dictionary it will have very few names in
it.  Some obvious candidates are
  std
  std::char_traits<char>
  std::allocator<char>
  std::basic_string<char, char_traits<char>, std::allocator<char> >


                        RTTI - A23 AND GENERAL

Minor corrections to RTTI discussion in data layout document:
In section 7c, which describes the vmi_flags, flag 0x01 is
documented incorrectly.  It says "class has non-diamond multiple
inheritance", which isn't quite right.  We're really talking
more about repeated inheritance: having multiple subobjects of
the same type.

Also in vmi_flags, Jason questions whether flags 0x04 and 0x08 are
necessary.  What do we really need "has virtual base(s)" and "has
non-virtual base(s)" for?  Jason has sent email to Nathan about
this.

Naming issue: we decided to put all of our type_info subclasses
in namespace abi, not namespace std.  This means, of course,
that they can't go in any of the standard headers.  Rather than
inventing multiple header names, we would like to put everything
(unwinding longjmp, type_info subclasses, etc.) into one quasi-
standard header.  We propose the name <ia64cxxabi>.  Everything
in that header will be in namespace abi.

Issue A23 can almost be closed.  The only thing we need to
resolve is whether to keep the two flags that Jason is unsure about.

                              RTTI - A24

The scheme we have been converging on: we extend __class_type_info
by putting in a new field, id_proxy_ptr, of type char*.  It points
to a one-byte comdat which serves only as a unique address.  (We
don't see a strong need to ask the base ABI group to mandate a
magic unique-address feature in the linker.  We may want to get input
from our linker people, though.)

A class's __class_type_info object and its comdat proxy both receive
mangled names.  We must make sure that the proxy's mangled name is the
same for all complete and incomplete declarations of a class, that the
mangled name of the __class_type_info object is the same for all
complete declarations of a class, and that the mangled name of the
__class_type_info object is different for incomplete declarations than
for complete declarations.  One way to achieve this is to make
__class_type_info objects for incomplete declarations static.

We add a new flag to __pointer_type_info; let's say bit 0x4.  If
this is set, it means we have a pointer to an incomplete type (or
pointer to pointer to incomplete type, etc.)

We compare two __class_type_infos for equality by pointer comparison
of the id_proxy_ptr fields.  We compare two __pointer_type_infos for
equality by looking at the addresses of the type_info objects,
*unless* the incomplete bit is set in at least one of them.  If the
incomplete bit is set, we have to compare the pointed-to types.  For
everything other than classes and pointers we can just use address
equality of the type_info objects themselves.

In response to Jason's 000129 question: we can't use gp-relative
references for type_info objects because we're only using comdat
proxies for __class_type_info, not for other kinds of type_info
objects.

In response to Nathan's 000130 question: this is the reason to
give the complete and incomplete __class_type_info objects different
mangled names.  That way a complete __class_type_info object in a
DSO won't be overridden by an incomplete __class_type_info object
in the executable.

At the very end of this meeting we got a suggestion from Christophe
for a complete different mechanism.  We agreed that we can't evaluate
it without a writeup.  The suggestion: abandon these comdat proxies
altogether.  Instead we have a new type_info class,
__incomplete_class_type_info.  Comparisons involving two
__class_type_info objects use address equality, comparisons involving
two __incomplete_class_type_info objects, or a __class_type_info and
an __incomplete_class_type_info, do string comparison on the name.  We
still would have an incomplete bit in the __pointer_type_info class,
which, again, we would use to determine whether two
__pointer_type_info objects with different addresses might
nevertheless represent the same pointer type.

                       ARRAY OPERATOR NEW - A21

We agreed that Proposal B, where ::operator new(size_t, void*) is
a special case with no cookie, is preferable to Proposal A, where
all versions of array new get cookies.

We also agreed to the variation where we don't reserve space for a
cookie if the type has no destructor.  We're calling it Proposal C.
We need a writeup, but we should be able to close this issue next
week.





From nathan at acm.org  Fri Feb 11 17:07:17 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Fri, 11 Feb 2000 17:07:17 +0000
Subject: A-23 RTTI class structures (was RTTI updates)
References: <200002040026.QAA93105@baalbek.engr.sgi.com> <200002042248.OAA96608@baalbek.engr.sgi.com> <u9itzx2biy.fsf@casey.cygnus.com>
Message-ID: <38A441C5.123730FF@acm.org>

Jason Merrill wrote:
> I'm still not sure what 'has {non-,}virtual base' are good for,
> though.  The only reason that we care about the difference between
> virtual and non-virtual bases is because of the potential for diamond
> shapes, right?
Yup, you're correct. Now that the flags are only in vmi classes,
the 'has {non-,}virtual base' flags give little/no help. (When they
were everywhere, they could prune the tree walk looking for the
original sub object given the src2dst hint, for some cases of dynamic
cast.)

Kill them.

nathan

-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From dehnert at baalbek.engr.sgi.com  Tue Feb 15 00:26:55 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 14 Feb 2000 16:26:55 -0800 (PST)
Subject: Updated mangling specs
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com>
Message-ID: <200002150026.QAA22312@baalbek.engr.sgi.com>

> From: Jason Merrill <jason at cygnus.com>
> 
> Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
> > One issue that is not covered by your initial proposal is the
> > mangling of static data inside functions. In particular:
> > 
> > - Mangling of static data in inline functions or templates
> > - Mangling of strings constants in inline functions
> 
> True, though we decided last week that these can be handled by simply
> adding a sequence number to the name of the function.

Of course, we will have to be very careful about the specification of
this so that everyone gets the same sequence number...  Maybe we should
include a little redundancy (the name as in gcc, a type prefix, etc.)
so that mistakes are clear?  But I guess that still won't produce link
errors...

> > Also, to allow cross-.o file inlining, you need to extend that to
> > any function (not only those explicitly marked inline.) Strictly
> > speaking, this is outside the ABI, but unless there are strong
> > reasons not to, I'd advocate mangling any static data, regardless of
> > whether the function is tagged inline or not.
> 
> We should mangle the static data for any function that may be inlined;
> which functions those are depends on the compiler.

I don't think that we can or should require that the static data
always have mangled symbols emitted -- that should be the responsibility
of an implementation that chooses to inline routines not declared
inline.  However, once the compiler chooses to emit them, it should use
the defined mangling for inline routines.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 15 00:31:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 14 Feb 2000 16:31:35 -0800 (PST)
Subject: A-23 RTTI class structures (was RTTI updates)
References: <200002040026.QAA93105@baalbek.engr.sgi.com>
    <200002042248.OAA96608@baalbek.engr.sgi.com>
    <u9itzx2biy.fsf@casey.cygnus.com>
Message-ID: <200002150031.QAA22020@baalbek.engr.sgi.com>

> From nathan at acm.org  Fri Feb 11 09:08:29 2000
> 
> Jason Merrill wrote:
> > I'm still not sure what 'has {non-,}virtual base' are good for,
> > though.  The only reason that we care about the difference between
> > virtual and non-virtual bases is because of the potential for diamond
> > shapes, right?
> Yup, you're correct. Now that the flags are only in vmi classes,
> the 'has {non-,}virtual base' flags give little/no help. (When they
> were everywhere, they could prune the tree walk looking for the
> original sub object given the src2dst hint, for some cases of dynamic
> cast.)
> 
> Kill them.

I've taken care of this...

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 15 00:35:29 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 14 Feb 2000 16:35:29 -0800 (PST)
Subject: A-23 RTTI class structures (was RTTI updates)
References: <200002040026.QAA93105@baalbek.engr.sgi.com>
    <200002042248.OAA96608@baalbek.engr.sgi.com>
Message-ID: <200002150035.QAA22826@baalbek.engr.sgi.com>

> From jason at casey.cygnus.com  Thu Feb 10 12:13:57 2000
> 
> dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
> 
> > I've fixed all of Nathan's concerns except that of indicating whether
> > the vmi_flags refer to direct and indirect bases.  That one's because I
> > wasn't sure of the right answer.  It seems useful to include both
> > direct and indirect properties except for:
> > 
> >  1) has non-virtual bases (would anyone ever care about indirect ones?)
> >  2) maybe publicly inherited bases (same reason)
> > 
> > Opinions on these (and the others)?
> 
> You mean duplicate the flags, once for direct and once for indirect?

No, actually I meant that some of them might refer only to direct
bases, on grounds that indirect bases were irrelevant.  But I'm fine
with the following...

> That seems useless to me; I agree with Nathan that the flags refer to
> both direct and indirect bases.

I've added the following comment after the flags:

	All of these flags refer to both direct and indirect bases.

I assume this takes care of it.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 15 00:44:42 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 14 Feb 2000 16:44:42 -0800 (PST)
Subject: A-25 Bitfields of greater than field size
References: <200002071910.LAA04282@adlmail.cup.hp.com>
Message-ID: <200002150044.QAA22572@baalbek.engr.sgi.com>

> From: Jason Merrill <jason at cygnus.com>
> Date: 10 Feb 2000 12:43:55 -0800
> 
> It seems to me that
> 
> struct A {
>   ...
>   signed char c: 32;
>   ...
> };
> 
> should be treated like
> 
> struct A {
>   ...
>   int i: 32;
>   ...
> };
> 
> except that only the low 8 bits are significant.  This should be true
> whether or not there is actually a 32-bit type on the target.

In fact, I had been thinking that IF the primary purpose of this feature
is to allow known layout of (something like) an enum type without
knowing how big the compiler will make it, then Jason is right.
Specifically, the allocation of the field _with_ padding should be
based on the largest type that could fit in the specified size.
Where the real data goes (if there's a choice) doesn't much matter
then.  Lowest address would work (and lead to a consistent offset
and/or address).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 15 07:28:20 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 14 Feb 2000 23:28:20 -0800 (PST)
Subject: A-23 and ABI header file
Message-ID: <200002150728.XAA20037@baalbek.engr.sgi.com>

>From Matt's meeting writeup:

> Naming issue: we decided to put all of our type_info subclasses
> in namespace abi, not namespace std.  This means, of course,
> that they can't go in any of the standard headers.  Rather than
> inventing multiple header names, we would like to put everything
> (unwinding longjmp, type_info subclasses, etc.) into one quasi-
> standard header.  We propose the name <ia64cxxabi>.  Everything
> in that header will be in namespace abi.

We previously decided on cxxabi.h for the header, in conjunction
with D-9 (longjmp).  Aside from the ".h", which I don't care about,
I prefer not including "ia64" because I have quixotic notions about the
possibility of this ABI spreading elsewhere, and don't think source
code ought to need to change in such cases.

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Tue Feb 15 16:49:58 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 15 Feb 2000 17:49:58 +0100
Subject: Notes from 10 Feb meeting
In-Reply-To: <10002101622.ZM144811@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <10002101622.ZM144811@isolde.engr.sgi.com>
Message-ID: <200002151649.RAA02290@pandora>

> Sequence numbers are assigned in lexical order within a function,
> starting at 1.  The entities that receive sequence numbers are local
> static variables, local classes, and string literals.  Other
> entities (e.g. automatic variables) do not receive or affect
> sequence numbers.

The C99 standard defines an implicit variable inside of each function:

  static const char __func__[]="function-name";

Even though this is not part of standard C++, it is likely that C++
compilers will support this if the 'corresponding' C compiler supports
it. If so, it might be useful to support it in the ABI.

Proposal: The sequence number of __func__ is 0.

Of course, there is always discussion what the value of __func__ is in
C++ context; I think this does not necessarily need to be defined by
the ABI (or the question whether __func__ is defined at all - if it is
not used in a function, it does not matter).

Regards,
Martin



From austern at isolde.engr.sgi.com  Tue Feb 15 17:48:59 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Tue, 15 Feb 2000 09:48:59 -0800
Subject: A-25 Bitfields of greater than field size
In-Reply-To: dehnert@baalbek (Jim Dehnert)
        "Re: A-25 Bitfields of greater than field size" (Feb 14,  4:44pm)
References: <200002071910.LAA04282@adlmail.cup.hp.com> 
	<200002150044.QAA22572@baalbek.engr.sgi.com>
Message-ID: <10002150949.ZM172668@isolde.engr.sgi.com>

On Feb 14,  4:44pm, Jim Dehnert wrote:
> Subject: Re: A-25 Bitfields of greater than field size
> > From: Jason Merrill <jason at cygnus.com>
> > Date: 10 Feb 2000 12:43:55 -0800
> >
> > It seems to me that
> >
> > struct A {
> >   ...
> >   signed char c: 32;
> >   ...
> > };
> >
> > should be treated like
> >
> > struct A {
> >   ...
> >   int i: 32;
> >   ...
> > };
> >
> > except that only the low 8 bits are significant.  This should be true
> > whether or not there is actually a 32-bit type on the target.
>
> In fact, I had been thinking that IF the primary purpose of this feature
> is to allow known layout of (something like) an enum type without
> knowing how big the compiler will make it, then Jason is right.

Based on conversation with Mike Ball, I believe that the primary
purpose of the feature was that it was easier to allow it than
to forbid it.  I don't think it was intended for any specific
purpose, and I don't think users have any expectations.  We may
as well do whatever is easier for us.

			--Matt






From austern at isolde.engr.sgi.com  Tue Feb 15 18:43:52 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Tue, 15 Feb 2000 10:43:52 -0800
Subject: Writeup for A-21, proposal C
Message-ID: <10002151043.ZM172926@isolde.engr.sgi.com>

PROPOSAL C

Like proposal B, except that we don't save an element count
if the type T has no destructor.

Pseudocode for new(ARGS) T[n] under this proposal:

    if T has a trivial destructor (C++ standard, 12.4/3)
      padding = 0
    else if we're using ::operator new[](size_t, void*)
      padding = 0
    else
      padding = max(sizeof(size_t), alignof(T))

    p = operator new[](n * sizeof(T) + padding, ARGS)
    p1 = (T*) (p + padding)

    if padding > 0
      *((unsigned long*) p1 - 1) = n

    for i = [0, n)
      create a T, using the default constructor, at p1[i]

    return p1



From ddd at cup.hp.com  Tue Feb 15 21:38:17 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 15 Feb 2000 21:38:17 +0000
Subject: Notes from 10 Feb meeting
References: <10002101622.ZM144811@isolde.engr.sgi.com> <200002151649.RAA02290@pandora>
Message-ID: <38A9C749.494637A3@cup.hp.com>

Martin von Loewis wrote:
> 
> > Sequence numbers are assigned in lexical order within a function,
> > starting at 1.  The entities that receive sequence numbers are local
> > static variables, local classes, and string literals.  Other
> > entities (e.g. automatic variables) do not receive or affect
> > sequence numbers.
> 
> The C99 standard defines an implicit variable inside of each function:
> 
>   static const char __func__[]="function-name";
>

What about the "pretty_func" GNUism? Sequence number -1? :-)

Christophe



From ddd at cup.hp.com  Wed Feb 16 01:46:20 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 16 Feb 2000 01:46:20 +0000
Subject: D-12 Unwind table location
References: <200001282350.PAA24742@adlmail.cup.hp.com> <200002090212.SAA08837@baalbek.engr.sgi.com>
Message-ID: <38AA016C.1199C250@cup.hp.com>

Jim Dehnert wrote:
> 
> However, I also believe in maximizing flexibility and generality,
> at least when it's nearly free, and particularly when there are
> anticipatable uses for it.  Now, I can anticipate two departures
> from HP's assumptions that are relevant here:
> 
>   - Multiple text segments.  This is common in the embedded world,
>     where the reasons for them often also prevent their being adjacent
>     in the address, and probably also sometimes prevent the inclusion
>     of extraneous data with each text segment.

If you have multiple segments, then your local equivalent of 'dlmodinfo' must be
able to deal with the IP->.text segment. We do that today for multiple text
segments from different load modules, but there is no reason this could not work
for multiple load modules loaded at the same time. So I don't see an objection
here. dlmodinfo reads info from the ELF files, as long as there is an ELF
representation for multiple text segments and your dlmodinfo supports it, you
are fine.

I see the requirement of multiple .text segments as legitimate. We can support
it. On the other hand, I still do not understand what situation would require to
split .unwind from the .text for the corresponding procedure fragment. I am not
saying there is no case where it makes sense, just that if there is such a case,
I don't know it or I did not understand it.


>   - LSDA somewhere besides the associated .text segment.  See the
>     above, or imagine a language/implementation that decides to put a
>     lot of runtime-relocated data in it.

That's why we have a 'TTBase'. The type information contains runtime relocated
data in it. So we need to access it through extra indirections. But we don't pay
the price for any data for which we managed to avoid relocation (in particular
call-site and action tables).

 
> These possibilities, even though I don't anticipate them for IA-64
> mainstream C++, lead me to ask the question:  Can we provide the
> flexibility to support them at little or no cost to our own needs?

My position is that we do have the flexibility today. What you want to do can be
done within the existing framework. It is just slightly non-uniform: the LSDA is
in text. If you want to refer to data that requires relocation, you need a
pointer from that LSDA to your data, which is typically GP-relative.

> 
>  3) The unwind info table contains unwind descriptor references
>     relative to the text fragment, handled in the unwind library,
>     and the LSDA, handled by the personality routine.  The latter
>     includes:
> 
>     ** LPStart, an offset currently relative to its own location,
>     which requires that unwind info be in the associated text segment.

Correct. As I said, this makes this representation efficient both from a
run-time and load-time point of view. Since I don't see any use of splitting
.unwind from .text, I am not willing to pay an extra penalty
accessing/relocating LPStart for no purpose.

> 
>     ** TTBase, an offset currently relative to its own location,
>     which requires that the type table be in the unwind info segment.

What you describe is the projection of the current HP mechanims to our new
typeinfo. I acknoledged that this needs to be changed. In the HP case, TTbase
does not point to the typeinfo, but to structure containing (among others) a
pointer to the typeinfo. Even if the typeinfo are "COMDAT-ed' between load
modules, the structures are not (they are statics that exist only in the data
space associated to the .text, so they can be accessed GP-relative).

We can keep that, having just a pointer to a pointer to the typeinfo. Or we can
invent something smarter. In all cases, if we want to keep typeinfo pointer
comparison, TTBase cannot be GP-relative, I agree with that.


> 
>     Other references to call sites and landing pads, as offsets
>     relative to the address calculated from LPStart.
> 
>  4) The type table contains RTTI references, relative to GP for the
>     current text fragment, handled by the personality routine.
> 
>     ** This requires that the RTTI be in the data segment containing
>     GP, and prevents address-only RTTI comparisons, since it does not
>     support preemption.

See the comment on TTBase above. In today's HP implementation, this is not a
pointer to the RTTI info, but a pointer to a pointer to RTTI info. GP-relative
is fine in that case. We need to devise something else, just keeping in mind
that we want to reduce the number of relocations.

 
> The potentially problematic references are those with (**), which make
> assumptions about the locations of tables AND are handled by the
> personality routine above-the-covers.  (The under-the-covers mappings
> can use unspecified collaboration between the system and unwind
> library.)

> The unwind info references could be "fixed" by making them relative to
> segment addresses identified by the unwind library (more
> under-the-covers mappings) and passed to the personality routine, e.g.
> via routines like _Unwind_GetIP.

As I said, I believe there is no real reason to change the unwind info. Please
feel free to convince me otherwise :-)


> The type table requirement that RTTI be in the segment with GP could be
> fixed in the same way; the inability to deal with address-only
> comparisons cannot.

As I said, my proposal is pointer to pointer, the first pointer being
load-module private, GP-relative, the second one being the actual typeinfo
pointer, load-time relocated, pointing to the COMDAT-ed typeinfo.

There may be a better way to do that, but I could not figure it out.




Thanks for your comments
Christophe



From dehnert at baalbek.engr.sgi.com  Wed Feb 16 03:25:42 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 15 Feb 2000 19:25:42 -0800 (PST)
Subject: emitting vtables (was rtti data layout notes)
References: <200002020712.XAA88216@baalbek.engr.sgi.com>
Message-ID: <200002160325.TAA25908@baalbek.engr.sgi.com>

OK, I've added a comment about this to the ABI layout document --
please see if it looks OK, everyone.  But beyond that, do we assume
that all references to any function members of these classes are in the
library, and therefore inherently consistent, or do we need to define
the function member interface, too?

> From sidwell at codesourcery.com  Wed Feb  2 02:25:51 2000
> 
> Jim Dehnert wrote:
> > 
> > One more response from the meeting:
> > 
> > > Date: Mon, 24 Jan 2000 10:17:28 +0000
> > > From: Nathan Sidwell <sidwell at codesourcery.com>
> > >
> > > 2) place of emission of vtables.
> > > The vtables for the type_info derrived classes must be in the runtime.
> > > Other translation units must not emit vtables. Rationale: the runtime
> > > will expect certain implementation defined virtual member functions
> > > for these classes. A foreign translation unit must not override the
> > > runtime's vtable.
> > 
> > The perspective from the meeting was why not?  That is, if the class
> > has a virtual function, either (a) the user deriving from it needs to
> > override the vfunc for some reason and should be able to, or (b) the
> > user shouldn't override it because it's not appropriate, and is
> > responsible for avoiding the problem.  This stuff is in the
> > implementation name space, so it shouldn't be happening by accident.
> > Let the user beware if he trespasses...
> Oops, I've been careless with terminology. My apologies.
> 
> I didn't mean the case of a user deriving from (say) __fundamental_type_info,
> which as you say might be dangerous -- the ABI only defines the data
> layout for __fundamental_type_info and leaves unspecified any additional
> virtual member functions the implementation may add.
> 
> I was worried that a translation unit emitting the __class_type_info
> definition for `struct Foo' (for example), might have the freedom
> of also emitting the vtable for __class_type_info. Naturally that
> would be a disaster, as there's no knowledge of the runtime support
> internals that the translation unit happens to be linked with. 
> 
> I now see that closed issue B-5 (sort of) covers this. What is left
> unspecified is that implementations must assume that __class_type_info
> has at least one non-inline virtual function. As it stands at the moment,
> compiler implementation A is free to have a runtime support definition
> of __class_type_info with no non-inline virtual member functions.
> Therefore, when that compiler emits the __class_type_info object for
> `struct Foo', it must emit the vtable for its definition of __class_type_info.
> Of course, that translation unit might be linked with the other modules and
> the runtime of implementation B, which has a different definition of
> __class_type_info.
> 
> I suspect that all implementations will end up having such a virtual
> function, but it would be prudent to say so.
> 
> nathan
> 
> -- 
> Dr Nathan Sidwell :: sidwell at codesourcery.com
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Feb 16 04:08:58 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 15 Feb 2000 20:08:58 -0800 (PST)
Subject: Vcall/vbase offset clarification
References: <200001252056.MAA66540@baalbek.engr.sgi.com>
    <200002010315.TAA84577@baalbek.engr.sgi.com>
    <200002042228.OAA96694@baalbek.engr.sgi.com>
Message-ID: <200002160408.UAA26109@baalbek.engr.sgi.com>

OK, maybe I've got this now.  I fixed the section on "Virtual Function
Calling Convention" in the ABI layout document, with the changes in
red.  Can someone check that my changes are right?  Also, since I
don't find the words from Mark quoted below, is there somewhere else
that needs to be changed?

Jim

> From jason at cygnus.com  Thu Feb 10 12:36:03 2000
> 
> >>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>  >> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
>  >> To: mark at codesourcery.com
>  >> 
>  >> > > From mitchell at codesourcery.com  Tue Jan 25 13:26:12 2000
>  >> > >   struct A { void f();}
>  >> > >   struct B : public virtual A {};
>  >> [...]
>  >> > >   o First, we convert to the most derived class in which `f' was
>  >> > >     overridden.  That's `A'.  We know statically what offset
>  >> > >     to adjust `b' by to get an `A*'.
>  >> 
>  >> Maybe you didn't mean it that way, but: How do we know statically the
>  >> offset needed to adjust a B* to an A*? Wouldn't we have to look in the
>  >> vtable at run time to fetch the vbase offset?
>  >> 
>  >> > >   o We pass this value to the function found in the vtable for `A'.
>  >> > > 
>  >> > >   o That function will first perform the constant adjustment from 
>  >> > >     `A' to `B'.  
>  >> 
>  >> Or perhaps that shouldn't have been virtual inheritance in the B
>  >> bases?
> 
>  > I think the right statement is 'we know statically how to adjust "b" to
>  > get an "A*".  If A is a non-virtual base, we know the offset
>  > statically.  If it is a virtual base, we know statically where to fetch
>  > the vbase offset in the vtable.'
> 
> No, I'm with Martin on this.  We're trying to adjust from A* to C*; the
> adjustment from B* to A* is not useful.
> 
> Jason
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Feb 16 05:48:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 15 Feb 2000 21:48:05 -0800 (PST)
Subject: D-12 Unwind table location
References: <200001282350.PAA24742@adlmail.cup.hp.com>
    <200002090212.SAA08837@baalbek.engr.sgi.com>
Message-ID: <200002160548.VAA25083@baalbek.engr.sgi.com>

I'm afraid I still haven't made my position clear.  So I'll try once
more, briefly.  I want to have a definition that will _allow_ an
implementation to put the various unwind tables in arbitrary segments,
without changing their format (and therefore without modifying anything
in the compiler except the segment choice).

I am not suggesting that this ABI select any location other than that
proposed, and believe that the currently proposed choices are fine.
But if we can achieve the above objective at little or no cost, I think
it's a benefit, from the point of view of having a more widely
applicable model, and being able to use a compiler like gcc in a wide
variety of environments without unnecessary changes.  And I believe
that we can do this with little or no cost.

> From ddd at cup.hp.com  Tue Feb 15 17:46:23 2000
> 
> I see the requirement of multiple .text segments as legitimate. We can
> support it. On the other hand, I still do not understand what situation
> would require to split .unwind from the .text for the corresponding
> procedure fragment. I am not saying there is no case where it makes
> sense, just that if there is such a case, I don't know it or I did not
> understand it.

I don't think we need to understand the reason for a future requirement
in order to make allowances for it.  I wouldn't want to introduce
significant cost for it, but I don't believe there is one.

> My position is that we do have the flexibility today.  What you want
> to do can be done within the existing framework. It is just slightly
> non-uniform: the LSDA is in text.

No, your position is that we have the flexibility to do what you want
to do, and that you don't see a need for additional flexibility.  I
can't put LSDA in data with the current definition.  That's the
flexibility I want, as long as it's not expensive.

> >  3) The unwind info table contains unwind descriptor references
> >     relative to the text fragment, handled in the unwind library,
> >     and the LSDA, handled by the personality routine.  The latter
> >     includes:
> > 
> >     ** LPStart, an offset currently relative to its own location,
> >     which requires that unwind info be in the associated text segment.
> 
> Correct. As I said, this makes this representation efficient both from a
> run-time and load-time point of view. Since I don't see any use of splitting
> .unwind from .text, I am not willing to pay an extra penalty
> accessing/relocating LPStart for no purpose.

This is the key.  Where is the cost?  Suppose that the unwind table has
associated with it two segment pointers, for the unwind info table and
the text segment.  Then the unwind info pointers in the unwind table
can be relative to the first (not so important since that's under the
covers), and the LPStart pointers can be relative to the second).  If
the unwind library puts them in the exception object each time it
locates a new frame, then we have a small number of cache hits per
frame, all happening in parallel with other memory references that
often won't be hits.  I think that cost is somewhere between zero and
negligible.

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Feb 16 06:35:37 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 15 Feb 2000 22:35:37 -0800 (PST)
Subject: Status pages
Message-ID: <200002160635.WAA26686@baalbek.engr.sgi.com>

The status pages on the web site are updated (HTML).
I'll update the PDF tomorrow.

Jim
-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Wed Feb 16 09:11:33 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 16 Feb 2000 10:11:33 +0100
Subject: Notes from 10 Feb meeting
In-Reply-To: <38A9C749.494637A3@cup.hp.com> (message from Christophe de
	Dinechin on Tue, 15 Feb 2000 21:38:17 +0000)
References: <10002101622.ZM144811@isolde.engr.sgi.com> <200002151649.RAA02290@pandora> <38A9C749.494637A3@cup.hp.com>
Message-ID: <200002160911.KAA22103@pandora>

> What about the "pretty_func" GNUism? Sequence number -1? :-)

It's interesting you bring this up :-) I was indeed going to propose
that numbering for statics starts with 100, so that there are numbers
left for 'magic' things. I couldn't think of any, so I'm only
half-serious here.

Martin



From nathan at acm.org  Wed Feb 16 09:43:54 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Wed, 16 Feb 2000 09:43:54 +0000
Subject: emitting vtables (was rtti data layout notes)
References: <200002020712.XAA88216@baalbek.engr.sgi.com> <200002160325.TAA25908@baalbek.engr.sgi.com>
Message-ID: <38AA715A.1F4277FB@acm.org>

Jim Dehnert wrote:
> 
> OK, I've added a comment about this to the ABI layout document --
> please see if it looks OK, everyone.  
Looks good to me.

> But beyond that, do we assume
> that all references to any function members of these classes are in the
> library, and therefore inherently consistent, or do we need to define
> the function member interface, too?
No, we should not constrain the implementation in this way. The
entry points are abi::__dynamic_cast and <catch matcher> (which
might be implementation defined anyway, when the unwind stuff has settled).

nathan

-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From nathan at acm.org  Wed Feb 16 09:51:39 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Wed, 16 Feb 2000 09:51:39 +0000
Subject: `abi' namespace
Message-ID: <38AA732B.48005963@acm.org>

Hi,
`abi' is not in the implementation namespace. we should be using
`__abi' or `std::abi' or something.

[17.4.3.1] and [17.4.3.1.2] are relevant here, but other than symbols
inside `std', doesn't talk about implementation reserved namespaces, only
global symbols -- perhaps this is a defect. Anyway, I think the intent
is clear.

nathan
-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From austern at isolde.engr.sgi.com  Wed Feb 16 17:18:02 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 16 Feb 2000 09:18:02 -0800
Subject: `abi' namespace
In-Reply-To: Nathan Sidwell <nathan@acm.org>
        "`abi' namespace" (Feb 16,  9:51am)
References: <38AA732B.48005963@acm.org>
Message-ID: <10002160918.ZM158634@isolde.engr.sgi.com>

I think that's irrelevant.  We're not putting any of this in standard
headers.

If we're willing to put __ in our symbol names, we don't really need
a namespace of our own.

			--Matt


On Feb 16,  9:51am, Nathan Sidwell wrote:
> Subject: `abi' namespace
> Hi,
> `abi' is not in the implementation namespace. we should be using
> `__abi' or `std::abi' or something.
>
> [17.4.3.1] and [17.4.3.1.2] are relevant here, but other than symbols
> inside `std', doesn't talk about implementation reserved namespaces, only
> global symbols -- perhaps this is a defect. Anyway, I think the intent
> is clear.
>
> nathan
> --
> Dr Nathan Sidwell :: Computer Science Department :: Bristol University
> Never hand someone a gun unless you are sure where they will point it
> nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk
>-- End of excerpt from Nathan Sidwell





From loewis at informatik.hu-berlin.de  Wed Feb 16 19:08:36 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 16 Feb 2000 20:08:36 +0100
Subject: `abi' namespace
In-Reply-To: <10002160918.ZM158634@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <38AA732B.48005963@acm.org> <10002160918.ZM158634@isolde.engr.sgi.com>
Message-ID: <200002161908.UAA03691@pandora>

> I think that's irrelevant.  We're not putting any of this in standard
> headers.
> 
> If we're willing to put __ in our symbol names, we don't really need
> a namespace of our own.

The question is whether a user could ever construct out symbols by
declaring well-formed C++, and what the consequences of defining the
symbols in user code would be.

For example, if the user writes

#include <cstdio>
namespace abi {
  extern "C" void longjmp_unwind (jmp_buf env, int val){
   std::printf("Hello, world\n");
  }
}

using namespace abi;

int main()
{
  jmp_buf foo;
  longjmp_unwind(foo,0);
}

then he's got a well-formed C++ program, with a well-defined
meaning. Under our ABI, all kinds of things could happen - for
example, the code might be rejected because of a duplicate symbol.

In the specific case of longjmp_unwind, I don't fully understand
whether the plan is to expose this to the application developer, thus
extending the C++ API (rather than defining an ABI).

In the case of the RTTI types, the problem is more serious: Even if
there is no intention of exposing the interface to the programmer, the
programmer still might in conflicts when writing valid code.

So, I support Nathan's proposal of calling the namespace __abi: This
is a reserved name, and no well-formed C++ program should use that.
_ABI is possible alternativ with the same properties.

Even if the longjmp_unwind is user-callable, I'd prefer to leave the
decision to expose it to the implementation, so that compilers that
chose to offer pedantic C++ compliance still have the option of
providing ABI compliance as well.

Regards,
Martin



From ddd at cup.hp.com  Wed Feb 16 19:44:11 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 16 Feb 2000 19:44:11 +0000
Subject: D-12 Unwind table location
References: <200001282350.PAA24742@adlmail.cup.hp.com>
	    <200002090212.SAA08837@baalbek.engr.sgi.com> <200002160548.VAA25083@baalbek.engr.sgi.com>
Message-ID: <38AAFE0B.5F72638F@cup.hp.com>

Jim,


Jim Dehnert wrote:
> I'm afraid I still haven't made my position clear.  So I'll try once
> more, briefly.  I want to have a definition that will _allow_ an
> implementation to put the various unwind tables in arbitrary segments,
> without changing their format (and therefore without modifying anything
> in the compiler except the segment choice).

I did understand what you want. What I did not understand is why. This has a
non-zero cost (see below), and I don't see anything you can do with that that
you can't do with the current scheme.


> 
> > Correct. As I said, this makes this representation efficient both from a
> > run-time and load-time point of view. Since I don't see any use of splitting
> > .unwind from .text, I am not willing to pay an extra penalty
> > accessing/relocating LPStart for no purpose.
> 
> This is the key.  Where is the cost?  Suppose that the unwind table has
> associated with it two segment pointers, for the unwind info table and
> the text segment.  Then the unwind info pointers in the unwind table
> can be relative to the first (not so important since that's under the
> covers), and the LPStart pointers can be relative to the second).  If
> the unwind library puts them in the exception object each time it
> locates a new frame, then we have a small number of cache hits per
> frame, all happening in parallel with other memory references that
> often won't be hits.  I think that cost is somewhere between zero and
> negligible.
> 

The key problem I see is the following: to get the unwind address from the
function address, all you need today is a mechanism that, from the IP, gets the
text segment, which is fairly trivial. Then everything is relative to the text
segment.

However, two identical IP addresses may _not_ correspond to the same GP under
the current ABI (consider two instances of a same shared lib). In other words,
if you want to recover a GP from the IP, you need some magic. The magic we do
currently is that you go to the unwind info block, which contains unwind records
indicating where the GP was saved, and you recover it. That's the value that we
ultimately get from Unwind_GetGR(GP). The process that led to GP did not require
any dld support beyond the IP->text segment translation. Everything after that
is made of self-relative or text-relative offsets.

If the unwind info block is to be placed in a different segment, then you need a
_writable_ pointer to point to that segment (since the segment address is
allocated by the dynamic loader, whether text or data). So the unwind table (or
part of it) has to go to writable data, and become GP-relative. Then, some
really black magic has to occur to make sure that we can recover the initial GP
we need for unwinding. This black magic also needs to have debugger support,
etc, etc.

Also, this whole process becomes also a lot more fragile, since it starts at a
writable pointer, so a corruption of this pointer prevents any unwinding from
happening.

Last, but not least, I can't imagine going to our dld, linker, debugger, backend
and ABI folks and tell them: you need to change the location of the unwind info
block (or unwind table) without a very good reason. Remember that the location
of the unwind tables and unwind info block, and their format, are part of what
we call the C ABI, not the C++ ABI.


Regards
Christophe



From dehnert at sgi.com  Wed Feb 16 22:26:44 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 16 Feb 2000 16:26:44 -0600
Subject: [Fwd: HTML of construction vtables writeup]
Message-ID: <38AB2424.EDADFC4E@sgi.com>

Here's a construction vtable writeup from Coleen -- Thanks!
I'll include it in the document...

Jim

-------- Original Message --------
Subject: HTML of construction vtables writeup
Date: Wed, 16 Feb 2000 17:27:34 -0500
From: Coleen Phillimore <coleen at zko.dec.com>
Organization: Compaq C/C++ Development
To: Jim Dehnert <dehnert>
References: <200002160635.WAA26686 at baalbek.engr.sgi.com>


Jim,
I did the construction vtables writeup in html and it's attached here.
Let me know if you can't read it.  If you can, I can sent it out to the
whole group.

Thanks,
Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ctorvtbls.html
Type: application/octet-stream
Size: 9666 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000216/9fcd6372/attachment.obj>

From austern at isolde.engr.sgi.com  Thu Feb 17 01:04:53 2000
From: austern at isolde.engr.sgi.com (Matt Austern)
Date: Wed, 16 Feb 2000 17:04:53 -0800
Subject: `abi' namespace
In-Reply-To: Martin von Loewis <loewis@informatik.hu-berlin.de>
        "Re: `abi' namespace" (Feb 16,  8:08pm)
References: <38AA732B.48005963@acm.org> 
	<10002160918.ZM158634@isolde.engr.sgi.com> 
	<200002161908.UAA03691@pandora>
Message-ID: <10002161704.ZM169560@isolde.engr.sgi.com>

On Feb 16,  8:08pm, Martin von Loewis wrote:

> For example, if the user writes
>
> #include <cstdio>
> namespace abi {
>   extern "C" void longjmp_unwind (jmp_buf env, int val){
>    std::printf("Hello, world\n");
>   }
> }
>
> using namespace abi;
>
> int main()
> {
>   jmp_buf foo;
>   longjmp_unwind(foo,0);
> }
>
> then he's got a well-formed C++ program, with a well-defined
> meaning. Under our ABI, all kinds of things could happen - for
> example, the code might be rejected because of a duplicate symbol.

I see your point.  OK, how about this as a compromise: use C++'s
namespace aliasing feature.  Our <cxxabi> header would look something
like this:

  namespace __cxx_abi_version1 {

    void longjmp_unwind(jmp_buf, int);
    ...

  }

  namespace abi = __cxx_abi_version1;

So the mangled name of longjmp_unwind would use the long name
 __cxx_abi_version1, which could not appear in any well formed
user program.  Anyone who includes the <cxxabi> header, however,
could use the short alias "abi".

			--Matt



From dehnert at baalbek.engr.sgi.com  Thu Feb 17 02:48:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 16 Feb 2000 18:48:05 -0800 (PST)
Subject: Meeting agenda for 17 Feb 2000
Message-ID: <200002170248.SAA29184@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Mangling.

  B) Data layout.

  C) Exception handling.

So, take a look at the material associated with these issues:

  0) Action item review.

  1) F-*:  Mangling.  Do you have an update, Daveed?
     Can we identify just what's missing?

  2) Choose ABI namespace -- abi::, __abi::, or ?.

  3) A-23:  Structure of class RTTI.  This is probably ready to close now.

  4) A-24:  Incomplete type RTTI.  Do we have a writeup of alternative
     mechanism from Christophe?

  5) A-21:  New array cookies.  Is the current writeup acceptable?

  6) C-4:  Construction vtables.

  7) A-25:  Excess-width bitfields.

  8) D-12:  Unwind table location.

Issues that are active and awaiting proposals:

  a)  A-24:  Incomplete type RTTI (alternate proposal from Christophe).

  b)  F-*:  Mangling (updated proposal from Daveed).

Jim

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Thu Feb 17 02:11:33 2000
From: jason at cygnus.com (Jason Merrill)
Date: 16 Feb 2000 18:11:33 -0800
Subject: A-25 Bitfields of greater than field size
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Mon, 14 Feb 2000 16:44:42 -0800 (PST)"
References: <200002071910.LAA04282@adlmail.cup.hp.com> <200002150044.QAA22572@baalbek.engr.sgi.com>
Message-ID: <u93dqs7f3e.fsf@casey.cygnus.com>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

> > From: Jason Merrill <jason at cygnus.com>
> > Date: 10 Feb 2000 12:43:55 -0800
> > 
> > It seems to me that
> > 
> > struct A {
> >   ...
> >   signed char c: 32;
> >   ...
> > };
> > 
> > should be treated like
> > 
> > struct A {
> >   ...
> >   int i: 32;
> >   ...
> > };
> > 
> > except that only the low 8 bits are significant.  This should be true
> > whether or not there is actually a 32-bit type on the target.
> 
> In fact, I had been thinking that IF the primary purpose of this feature
> is to allow known layout of (something like) an enum type without
> knowing how big the compiler will make it, then Jason is right.
> Specifically, the allocation of the field _with_ padding should be
> based on the largest type that could fit in the specified size.
> Where the real data goes (if there's a choice) doesn't much matter
> then.  Lowest address would work (and lead to a consistent offset
> and/or address).

Note that by "low 8 bits" I meant "least significant 8 bits"; the
position would depend on the endianness of the target.

In other words, you should be able to load the larger type and
truncate it to the smaller type to get the right answer.

Jason



From loewis at informatik.hu-berlin.de  Thu Feb 17 11:06:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 17 Feb 2000 12:06:55 +0100
Subject: `abi' namespace
In-Reply-To: <10002161704.ZM169560@isolde.engr.sgi.com>
	(austern@isolde.engr.sgi.com)
References: <38AA732B.48005963@acm.org> 
	<10002160918.ZM158634@isolde.engr.sgi.com> 
	<200002161908.UAA03691@pandora> <10002161704.ZM169560@isolde.engr.sgi.com>
Message-ID: <200002171106.MAA07524@pandora>

> I see your point.  OK, how about this as a compromise: use C++'s
> namespace aliasing feature.

That looks like an excellent use of namespace aliasing.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Feb 17 11:10:08 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 17 Feb 2000 12:10:08 +0100
Subject: Meeting agenda for 17 Feb 2000
In-Reply-To: <200002170248.SAA29184@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200002170248.SAA29184@baalbek.engr.sgi.com>
Message-ID: <200002171110.MAA07628@pandora>

>   5) A-21:  New array cookies.  Is the current writeup acceptable?

(As usual,) I won't participate in the meeting. So I'd like to say
that your version C write-up looks perfect to me.

Regards,
Martin



From daveed at edg.com  Thu Feb 17 17:24:24 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 17 Feb 2000 09:24:24 -0800
Subject: Meeting agenda for 17 Feb 2000
References: <200002170248.SAA29184@baalbek.engr.sgi.com>
Message-ID: <38AC2EC8.F05C9B0@edg.com>

Attached is an updated mangling spec.  It starts with a "left to do" list.

I won't be able to attend today's meeting though.

	Daveed
-------------- next part --------------
Name mangling
=============

[ To do:
   . Revise examples.
   . Mangling of special entities: VT, VTT, typeinfo, "TID", helper variables
        to ensure one-time initialization and thread protection, ...
   . ILP-32 conventions?
   . Complete glossary of Sx abbreviations.
   . Escape mechanism for extended operator like __alignof?
   . Proof of nonambiguity
   . 80-bit vs. 128-bit long doubles?
]


Entities with C linkage and file scope variables are not mangled.


General structure
-----------------

    _Z<name><type>opt

<name> is one of:
   <unqualified-name>
      <length><function name>
      <length><function name>I<template-args>E
      <operator-name>
      <operator-name>I<template-args>E
      <special-name>
         (see below: ctors, vtables, ...)   
   <qualified-name>
      N<qual-1>...<qual-J><unqualified-name>E
   <local-name>
      (see below: scope encoding)

<type> is used to disambiguate overloaded functions, but also to
distinguish the various virtual tables associated with a given complete
class type.  For nontemplate functions, <type> lists the parameter types
only. For template functions, <type> lists the return type followed by
the parameter types.  <type> is omitted for variables and static data
members.


Operator encodings
------------------

Operators appear as function names, but also in nontype template argument
expressions.
   new           nw
   new[]         na
   delete        dl
   delete[]      da
   - (unary)     ng
   & (unary)     ad
   * (unary)     de
   ~             co
   +             pl
   -             mi
   *             ml
   /             dv
   %             rm
   &             an
   |             or
   ^             eo
   =             aS
   +=            pL
   -=            mI
   *=            mL
   /=            dV
   %=            rM
   &=            aN
   |=            oR
   ^=            eO
   <<            ls
   >>            rs
   <<=           lS
   >>=           rS
   ==            eq
   !=            ne
   <             lt
   >             gt
   <=            le
   >=            ge
   !             nt
   &&            aa
   ||            oo
   ++            pp
   --            mm
   ,             cm
   ->*           pm
   ->            pt
   ()            cl
   []            ix
   ?             qu
   (cast)        cv
   sizeof        sz

Unlike Cfront, unary and binary operators using the same symbol have
different encodings.  All operators are encoded using exactly two letters,
the first of which is lowercase.


Other special functions and entities
------------------------------------

   TV            virtual table
   TI            typeinfo structure
   C1            complete object constructor
   C2            base object constructor
   D0            deleting destructor
   D1            complete object destructor
   D2            base object destructor


Type encodings
--------------
Types are encoded as follows:

builtin types: (one letter)
   void                     v
   wchar_t                  w
   bool                     b
   char                     c
   signed char              a
   unsigned char            h
   short                    s
   unsigned short           t
   int                      i
   unsigned int             j
   long                     l
   unsigned long            m
   long long                x
   unsigned long long       y
   float                    f
   double                   d
   long double              e
   ellipsis                 z

classes & enums:
   <decimal length of unqualified name><unqualified-name>
   Class names can optionally be followed by the encoding of a template
   argument list (see below).

template params (including nontype and template template parameters):
   T<param num>_

other dependent names: (see below)
   N<qual 1>...<qual N><unqual name>E

template argument list: (see below)
   I<arg1>...<argN>E

function types:
   F<return type><param type 1>...<param type N>E

array types:
   A<dimension>_<element type encoding>

pointers, references:
   P<encoding pointed-to type>
   R<encoding pointed-to type>

pointer-to-member:
   M<class type encoding><member type encoding>

cv-qualifiers:
   K const
   V volatile
   r restrict


Scope encoding
--------------
A nonlocal scope is encoded as the qualifier of a qualified name: it can be
the top-level name qualification or it can appear inside <type> to denote
dependent types or bind specific names as arguments.  Qualified names are
encoded as:
   N<qual 1>...<qual N><unqual name>E
where each <qual K> is the encoding of a namespace name or a class name (with
the latter possibly including a template argument list).

Occasionally entities in local scopes must be mangled too (e..g., because
inlining or separate template compilation causes mutliple translation units
to need access to that entity).  Local entities that might be mangled are
numbered in lexical order starting with "1".  The numbered entities are:
   . local static variables
   . local classes
   . string literals

The local name encoding is then:
   Z<function-encoding-without-prefix>E<num>_<entity-name>
where <entity-name> is either the entity's unqualified name or "0" (zero) if
it is a string literal.

Example:
   namespace N {
      inline char* f(int i) {
         static char *p = "IA-64 C++ ABI";  // p = 1, "..." = 2
         {  struct X {                      // X = 3
               void g() {}
            };   }
         return p[i];
      }
   }

   "_ZZN1N1fEiE1_1p":  encoding of N::f:p (first local mangled entity)
   "_ZZN1N1fEiE2_0":  encoding of N::f:"IA-64 C++ ABI"
   "_ZNZN1N1fEiE3_1X1gE":  encoding of N::f:X::g()
                      (third local mangled entity used as a class-qualifier)

Template argument encoding
--------------------------
Template-ids are encoded by following the unqualified name with
	I<arguments>E
This is used for the <specialization> segment in particular, but also in the
<type> and <scope> segments.

Type arguments appear using their regular encoding.  For example, the
template class "A<char, float>" is encoded as "1AIcfE".  A slightly more
involved example might be a dependent function parameter type "A<T2>::X"
(T2 is the second template parameter) which is encoded as "N1AIT2_E1XE",
where the "N...E" construct is used to describe a qualified name.

Nontype arguments can be:
   a) a literal, e.g. "A<42L>": these are encoded as "L<type><num>E";
      negative integer <num> are preceded with "n"; false is "Lb0E";
      true is "Lb1E".  For example, "A<-42L>" becomes "1AILln42EE".
      If floating-point arguments are accepted as an extension, they
      should be encoded using a fixed-length lowercase hexadecimal
      string corresponding to the internal (IEEE) representation.
      For example: "Lfbff000000" is -1.0f.
   b) a reference to an entity with external linkage: encoded with
      "L<mangled name>E".  For example:
          void foo(char); // mangled as _Z3fooc
          template<void (&)(char)> struct CB;
          // CB<foo> is encoded with "2CBIL_Z3foocEE"
   c) an expression, e.g., "B<(J+1)/2>" is encoded with a prefix traversal
      of the operators involved, delimited by "X...E".  The operators are
      encoded using their two letter mangled names.  For example, "B<(J+1)/2>"
      becomes "1BI Xdv pl T1_ Li1E Li2E E E" (the blanks were inserted to
      visualize the decomposition).


Compression
-----------
The subsequence
   S<num>_
is used to repeat the num-th most recently encoded type, namespace or template
(in right-to-left order, starting at "1"), but only if "S<num>_" is strictly
shorter that the previous encoding.  A qualifier is less recent than what it
qualifies and a template name is is less recent than the template-id it might
be a part of.  For example:

   "_ZN1N1TIiiE2mfES4_IddE": Ret? N::T<int, int>::mf(N::T<double, double>)

since at the point where S4_ appears:
   "S1_" == int
   "S2_" == int
   "S3_" == N::T<int, int>
   "S4_" == N::T (template is less recent than template-id)
   "S5_" == N (qualifier is less recent than qualified entity)

In addition, the following catalog of abbreviations of the form "Sx" should
be used:
   St = ::std::
   Sb = ::std::basic_string
   Ss = ::std::basic_string<char, ::std::char_traits<char>,
                            ::std::allocator<char> >

The abbreviation St is always treated as a qualifier and therefore does not
need a N...E construct.  For example:
   "_ZSt5state": ::std::state
   "_ZStN3_In4wardE": ::std::_In::ward


Examples
--------

1) "f": The C function or variable "f" or a file scope variable "f".

2) "_Z1f": Ret? f();

3) "_Z1fi": Ret? f(int);

4) "_Z3foo3bar": Ret? foo(bar);

5) "_Zrm1X1X": Ret? operator%(X, X);

6) "_ZplR1XR1X": Ret? operator+(X&, X&);

7) "_ZlsRK1XS1_": Ret? operator(X const&, X const&);
       (Note: strlen("S1_")<strlen("RK1X"))

8) "_Z1fIiE": void f<int>();

9) "_Z1fIiEvi": void f<int>(/*nondependent*/int);
       (Note: the return type is always explicitly encoded for template
              functions taking parameters.)

10) "_Z5firstI3DuoEvS2_": void first<Duo>(/*nondependent*/Duo);
       (Note: "S1_" would refer to the "void" return type.)

11) "_Z5firstI3DuoEvT1_": void first<Duo>(/*T1=*/Duo);

12) "_ZN1N1fE": Ret? N::f();

13) "_ZN6System5Sound4beepE: Ret? System::Sound::beep();

14) "_ZN5Arena5levelE": Type? Arena::level;

15) "_ZN5StackIiiE5levelE": Type? Stack<int, int>::level

16) "_Z1fI1XEvPVN1AIT1_E1TE": void f<X>(A</*T1=*/X>::T volatile*);
                |         |
                |         `------> end dependent name encoding
                `----------------> start of dependent name A<T1>::T

17) "_ZngIL42iEEvN1AIXplT1_L2iEE1TE": void operator-</*int J=*/42>(A<J+2>::T);

18) "_Z4makeI7FactoryiET1_IT2_E":
                              /*T1=*/Factory</*T2=*/int> make<Factory, int>();
                                          // T1 == template template parameter


From ddd at cup.hp.com  Thu Feb 17 17:52:12 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 17 Feb 2000 17:52:12 +0000
Subject: `abi' namespace
References: <38AA732B.48005963@acm.org> 
		<10002160918.ZM158634@isolde.engr.sgi.com> 
		<200002161908.UAA03691@pandora> <10002161704.ZM169560@isolde.engr.sgi.com>
Message-ID: <38AC354C.4D0F3A89@cup.hp.com>

Matt Austern wrote:
> 
> I see your point.  OK, how about this as a compromise: use C++'s
> namespace aliasing feature.  Our <cxxabi> header would look something
> like this:
> 
>   namespace __cxx_abi_version1 {
> 
>     void longjmp_unwind(jmp_buf, int);
>     ...
> 
>   }
> 
>   namespace abi = __cxx_abi_version1;
> 
> So the mangled name of longjmp_unwind would use the long name
>  __cxx_abi_version1, which could not appear in any well formed
> user program.  Anyone who includes the <cxxabi> header, however,
> could use the short alias "abi".

Problem: isn't longjmp_unwind intended for use by C programs as well. In which
case the only option really is (modulo possibly typos):


	#define longjmp_unwind __cxx_abi_longjmp_unwind
	#ifdef __cplusplus
	extern "C" {
	#endif
	void longjmp_unwind (jmp_buf, int);
	#ifdef __cplusplus
	extern "C" {
	#endif

cpp rulez.


Regards
Christophe



From ddd at cup.hp.com  Thu Feb 17 18:01:43 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 17 Feb 2000 18:01:43 +0000
Subject: Meeting agenda for 17 Feb 2000
References: <200002170248.SAA29184@baalbek.engr.sgi.com>
Message-ID: <38AC3787.780F9BF8@cup.hp.com>

Jim Dehnert wrote:
> 
>   4) A-24:  Incomplete type RTTI.  Do we have a writeup of alternative
>      mechanism from Christophe?

No, sorry, I've been working on the EH code first. Which is really close now...

Christophe



From dehnert at baalbek.engr.sgi.com  Thu Feb 17 23:45:20 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 17 Feb 2000 15:45:20 -0800 (PST)
Subject: B-1 vtable layout
Message-ID: <200002172345.PAA31840@baalbek.engr.sgi.com>

Jason noticed an issue today that we want to raise for those who weren't
at the meeting, involving the layout of primary vtables.

Our chosen layout starts with the primary base class vtable layout (if
any), and adds additional vbase/vcall offsets to the beginning, and
additional vfunc pointers at the end.  It is then followed by the
secondary vtables, in inheritance graph order.

We have assumed, for instance in our decision not to propagate vbase
offsets from non-virtual bases, that the secondary vtables were directly
accessible at compile-time offsets from the primary vptr.  However, this
is not currently the case if we are dealing with a class that is the
primary base of a derived class.  The derived class's additional vfunc
pointers will be added between the base class vtable and its secondary
vtables for the base's base classes.  Therefore, non-overridden base
class member functions, at least, can't make assumptions about
secondary vtable offsets.

One can, of course, get to the secondary vtable via the secondary vptr
in the object, but that costs an additional load.

There is a "solution" that should work, but is a touch ugly.  That
would be to place the additional vfunc fields for the derived class
not immediately after the primary base vtable, but after all of its
non-virtual secondary vtables.  If we don't think this is worthwhile,
we should reconsider the decision about promoting vbase offsets.
(I still wouldn't choose to, but we should make the choice conscious
of the real implications.)

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Fri Feb 18 02:41:44 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 17 Feb 2000 18:41:44 -0800 (PST)
Subject: A-23: RTTI has-public-base flag
Message-ID: <200002180241.SAA32421@baalbek.engr.sgi.com>

Another issue from the meeting today:  we see no utility for the
__vmi_class_type_info flag indicating that there is a public base.
Is there one that anyone knows of?  If so, I presume that "direct or
indirect" is equivalent to direct only, since it's not public unless
the entire inheritance path is public?  The reference is:

    http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html#vmi

The web pages (HTML) are updated from today's meeting.  I will try
to incorporate Daveed's latest mangling writeup in the ABI layout
document before doing the PDF.

For those not at the meeting, note that the SGI people are moving next
Tuesday/Wednesday, so we won't be accessible and likely won't be able
to receive or respond to email prior to the meeting.

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Fri Feb 18 04:08:20 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 17 Feb 2000 20:08:20 -0800 (PST)
Subject: Web page updates
Message-ID: <200002180408.UAA15524@baalbek.engr.sgi.com>

The updates are completed from today's meeting, including adding Daveed's
mangling proposal to the Layout document.  Please look them over (the
Layout document in particular), and let me know about any mistakes.
-		Jim Dehnert  x3-4272



From nathan at acm.org  Fri Feb 18 10:42:24 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Fri, 18 Feb 2000 10:42:24 +0000
Subject: A-23: RTTI has-public-base flag
References: <200002180241.SAA32421@baalbek.engr.sgi.com>
Message-ID: <38AD2210.145AEB0A@acm.org>

Jim Dehnert wrote:
> 
> Another issue from the meeting today:  we see no utility for the
> __vmi_class_type_info flag indicating that there is a public base.
> Is there one that anyone knows of?  If so, I presume that "direct or
> indirect" is equivalent to direct only, since it's not public unless
> the entire inheritance path is public?  The reference is:
There are several reasons I suggested it. The semantics I meant
were `there is at least one direct or indirect public base' (symmetrical
definition of the non-public, virtual and non-virtual flags). In this
case the indirect paths are unimportant, because for one of those to
be public, a direct base must be too (just as for the non-virtual flag).

To tell whether the whole graph is public, we look for non-public being
zero.

1) Symmetry, we had virtual/non-virtual, so public/non-public. However
the virtual ones are now killed, so this reason goes away.

2) For dynamic cast and catching we're looking for public bases. Such
a flag would tell us not to bother iterating over the base class array.
This is possibly an unimportant optimization - maybe even a pessimizer by
throwing in another test.

I've no strong feeling about the public flag, but I'm nervous about
throwing it away before actually coding up the dcast and catch algorithms
with it in mind.

nathan

-- 
Dr Nathan Sidwell :: Computer Science Department :: Bristol University
Never hand someone a gun unless you are sure where they will point it
nathan at acm.org  http://www.cs.bris.ac.uk/~nathan/  nathan at cs.bris.ac.uk



From dehnert at baalbek.engr.sgi.com  Fri Feb 18 22:48:26 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 18 Feb 2000 14:48:26 -0800 (PST)
Subject: Updated mangling specs
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com>
    <200002150026.QAA22312@baalbek.engr.sgi.com>
Message-ID: <200002182248.OAA36000@baalbek.engr.sgi.com>

> From jason at casey.cygnus.com  Thu Feb 17 00:30:36 2000
> 
> dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
> 
> > > > Also, to allow cross-.o file inlining, you need to extend that to
> > > > any function (not only those explicitly marked inline.) Strictly
> > > > speaking, this is outside the ABI, but unless there are strong
> > > > reasons not to, I'd advocate mangling any static data, regardless of
> > > > whether the function is tagged inline or not.
> > > 
> > > We should mangle the static data for any function that may be inlined;
> > > which functions those are depends on the compiler.
> > 
> > I don't think that we can or should require that the static data
> > always have mangled symbols emitted -- that should be the responsibility
> > of an implementation that chooses to inline routines not declared
> > inline.  However, once the compiler chooses to emit them, it should use
> > the defined mangling for inline routines.
> 
> I'm not sure that we're disagreeing here.

Perhaps not.

> If the compiler decides to inline the function in one translation
> unit, and not in another, we still need to share statics between
> inline and out-of-line copies.  Either we can say that the compiler
> should recognize that the function might be inlined in another TU and
> mangle the locals accordingly, or we can say that we should always
> mangle locals.  The latter might be the only way to deal with inlining
> differences between implementations...if we care.

My concern is that I think ending up with all statics resulting in
external symbols would be bad in terms of bloat and link speed.  So,
I'm willing to sacrifice guaranteed inlining compatibility between
implementations except for routines declared inline.  However, as long
as we've defined the mangling for the cases declared inline,
implementations that follow it when they do inline (or based on a
compile option) would match and work together fine.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Feb 18 23:05:29 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 18 Feb 2000 15:05:29 -0800 (PST)
Subject: A-23: RTTI has-public-base flag
References: <200002180241.SAA32421@baalbek.engr.sgi.com>
Message-ID: <200002182305.PAA35392@baalbek.engr.sgi.com>

> From nathan at acm.org  Fri Feb 18 02:45:20 2000
> 
> Jim Dehnert wrote:
> > 
> > Another issue from the meeting today:  we see no utility for the
> > __vmi_class_type_info flag indicating that there is a public base.
> > Is there one that anyone knows of?  If so, I presume that "direct or
> > indirect" is equivalent to direct only, since it's not public unless
> > the entire inheritance path is public?  The reference is:
> There are several reasons I suggested it. The semantics I meant
> were `there is at least one direct or indirect public base' (symmetrical
> definition of the non-public, virtual and non-virtual flags). In this
> case the indirect paths are unimportant, because for one of those to
> be public, a direct base must be too (just as for the non-virtual flag).
> 
> To tell whether the whole graph is public, we look for non-public being
> zero.
> 
> 1) Symmetry, we had virtual/non-virtual, so public/non-public. However
> the virtual ones are now killed, so this reason goes away.
> 
> 2) For dynamic cast and catching we're looking for public bases. Such
> a flag would tell us not to bother iterating over the base class array.
> This is possibly an unimportant optimization - maybe even a pessimizer by
> throwing in another test.
> 
> I've no strong feeling about the public flag, but I'm nervous about
> throwing it away before actually coding up the dcast and catch algorithms
> with it in mind.

OK.  I've added an action item for you to validate its utility, and I
propose that we now close this issue with the flag left there, and look
at it again once you've done the implementation.  OK with everyone?

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Sat Feb 19 23:51:18 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 19 Feb 2000 15:51:18 -0800
Subject: Virtual function call stuff, again
Message-ID: <20000219155118D.mitchell@codesourcery.com>


Folks --

  The virtual function call specification language is a disaster.  A
random sample of one (me) show's that it's pretty much impossible for
anyone not actually been in all the meetings to implement. :-)

  The discussion in the `callee' section on "Virtual Function Calling
Convention" is very unclear.  For example, it's not explained which
classes are bases of which others.  Here's an attempted rewrite.
Let's see if it's what y'all meant.

  o Suppose a class `A' defines a virtual function `A::f'.  The 
    primary vtable for `A' contains a pointer to an entry point
    that performs no adjustment.

  o Suppose that a class `A' declares a virtual function `A::f', 
    and suppose that `A' is a base class in a hierarchy dominated 
    by another class `B'.  Suppose that the unique final overrider for
    `A::f' in `B' is `C::f'.  We must determine what entry point
    is used for `f' in the `A-in-B' secondary vtable.  Here is the
    algorithm:

    - Find any path from `B' to `C' in the inheritance graph for `B'.

    - If there is no virtual base along the path, then create
      an entry point which adjusts the `this' pointer from `A' to `C'.
      This value can be computed statically when the `A-in-B' vtable
      is created.  Then transfer control to the non-adjusting entry
      point for `C::f'.

    - If there is a virtual base along this path, let `V' be the
      virtual base nearest to `C' along the path.  (In fact, `V'
      will be `C' itself if `C' is a virtual base.)

      (Note that the choice of `V' is independent of the choice of path.
      If there was more than one path, then there must have been a
      virtual base along all of the paths, and there is a unique one
      closest to `C'.)

      Now, create an entry point which first performs the adjustment
      from `A' to `V'.  (This value can be computed statically, when
      the `A-in-B' vtable is created.)  Then, adjust the `this'
      pointer by the vcall offset stored in the secondary vtable for
      `V' (i.e., the `V-in-B' vtable).  (This adjustment will adjust
      the `this' pointer from `V' to `C'.)  Finally, transfer control
      to the non-adjusting entry point for `C::f'.

  Is that correct?  

  It seems like the scheme specified in the ABI is advantageous in a
situation where `C' is the same as `A', and `A' is the same as `V'.
(In other words, if `A' is a virtual base and `A::f' is not overriden
in `B'.)  Then, by emitting the vcall-adjusting entry point right
before the main entry point for `C::f', calling `f' requires only one
branch (to the entry point specified in the vtable), rather than two
(to a thunk, and then from the thunk to the main function).  Right?

  I still can't see why it is a win to use vcall offsets in the case
where `A' and `V' are not the same class.  You already have to do one
static adjustment in the entry point -- why not just adjust all the
way to `B' directly, without bothering to look up the vcall offset?
  
  Furthermore, the actual algorithm used to perform the adjustments
does not seem necessarily to be part of the ABI.  The layout of the
vtables is certainly part of the ABI.  But, if one compiler wants to
completely ignore the vcall offset entries in the vtables, and compute
the entire adjustment statically, shouldn't that be permitted by the
ABI, even though it might require one extra branch?  Surely that's
just a quality-of-implementation issue?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Sun Feb 20 00:46:25 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 19 Feb 2000 16:46:25 -0800
Subject: Virtual function call stuff, again
In-Reply-To: <20000219155118D.mitchell@codesourcery.com>
References: <20000219155118D.mitchell@codesourcery.com>
Message-ID: <20000219164625T.mitchell@codesourcery.com>

>>>>> "Mark" == Mark Mitchell <mark at codesourcery.com> writes:

    Mark>   Furthermore, the actual algorithm used to perform the
    Mark> adjustments does not seem necessarily to be part of the ABI.

Similarly, I don't think the ABI should specify that the caller
adjusts the `this' pointer to the class containing the unique final
overrider.  *Any* class containing a virtual function table entry for
this function will do, and an implementation should be allowed to such
a class, if it wants to.  (Picking another class is probably inferior,
since that method is certain to require a `this' adjustment, while
picking the class with the unique final overrider may not, but that's
a quality-of-implementation issue.)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Sun Feb 20 03:04:19 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 19 Feb 2000 19:04:19 -0800
Subject: Vtables
Message-ID: <20000219190419E.mitchell@codesourcery.com>


Folks --

  The ABI appears to specify that the secondary vtables immediately
follow the primary vtables for a class.  However, the order is
unclear:

7.The secondary vtables are last. They are laid out in the same order used for the bases themselves in the object. 

  That's not well-defined since two bases may lay at the same offset.
Let's just say `in the order given by a left-to-right depth-first walk
of the inheritance graph', assuming that there's not some deep reason
behind the current wording.

  Agreed?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Thu Feb 17 02:04:46 2000
From: jason at cygnus.com (Jason Merrill)
Date: 16 Feb 2000 18:04:46 -0800
Subject: Updated mangling specs
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Mon, 14 Feb 2000 16:26:55 -0800 (PST)"
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com> <200002150026.QAA22312@baalbek.engr.sgi.com>
Message-ID: <u966vo7fep.fsf@casey.cygnus.com>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

> > > Also, to allow cross-.o file inlining, you need to extend that to
> > > any function (not only those explicitly marked inline.) Strictly
> > > speaking, this is outside the ABI, but unless there are strong
> > > reasons not to, I'd advocate mangling any static data, regardless of
> > > whether the function is tagged inline or not.
> > 
> > We should mangle the static data for any function that may be inlined;
> > which functions those are depends on the compiler.
> 
> I don't think that we can or should require that the static data
> always have mangled symbols emitted -- that should be the responsibility
> of an implementation that chooses to inline routines not declared
> inline.  However, once the compiler chooses to emit them, it should use
> the defined mangling for inline routines.

I'm not sure that we're disagreeing here.

If the compiler decides to inline the function in one translation
unit, and not in another, we still need to share statics between
inline and out-of-line copies.  Either we can say that the compiler
should recognize that the function might be inlined in another TU and
mangle the locals accordingly, or we can say that we should always
mangle locals.  The latter might be the only way to deal with inlining
differences between implementations...if we care.

Jason



From dehnert at baalbek.engr.sgi.com  Sun Feb 20 07:51:57 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sat, 19 Feb 2000 23:51:57 -0800 (PST)
Subject: Vtables
Message-ID: <200002200751.XAA01703@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
>   The ABI appears to specify that the secondary vtables immediately
> follow the primary vtables for a class.  However, the order is
> unclear:
> 
> 7.The secondary vtables are last. They are laid out in the same
> order used for the bases themselves in the object. 
> 
>   That's not well-defined since two bases may lay at the same offset.
> Let's just say `in the order given by a left-to-right depth-first walk
> of the inheritance graph', assuming that there's not some deep reason
> behind the current wording.
> 
>   Agreed?

Yes.  What the language means is the order in which allocation occurs
in the algorithm, not in memory, which is what the document defines as
inheritance graph order.  I'll try to clarify this.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Sun Feb 20 09:37:04 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 20 Feb 2000 01:37:04 -0800
Subject: Vtables
In-Reply-To: <200002200751.XAA01703@baalbek.engr.sgi.com>
References: <200002200751.XAA01703@baalbek.engr.sgi.com>
Message-ID: <20000220013704E.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> Yes.  What the language means is the order in which
    Jim> allocation occurs in the algorithm, not in memory, which is
    Jim> what the document defines as inheritance graph order.  I'll
    Jim> try to clarify this.

Thanks!

BTW, "inheritance graph order" is also defined a little bit
inaccurately:

  When all base classes of a class, direct and indirect, are viewed as
  an ordered set, the order assumed that obtained by a depth-first,
  left-to-right walk of the inheritance graph.

Really, this should say something like "all subobjects of a class
(including the complete object) ..."  That's not really very good --
but the point is that there can of course be multiple instances of a
given class in the hierarchy.  

It's really hard to make all these words clear, but it's worth it to
do our best -- that's the best way to ensure the ABI can be
implemented by lots of different people.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From coleen at zko.dec.com  Mon Feb 21 14:19:32 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 21 Feb 2000 09:19:32 -0500
Subject: Vtables
References: <20000219190419E.mitchell@codesourcery.com>
Message-ID: <38B14974.1C1F7628@zko.dec.com>

Mark Mitchell wrote:
> 
> Folks --
> 
>   The ABI appears to specify that the secondary vtables immediately
> follow the primary vtables for a class.  However, the order is
> unclear:
> 
> 7.The secondary vtables are last. They are laid out in the same order used for the bases themselves in the object.
> 
>   That's not well-defined since two bases may lay at the same offset.
> Let's just say `in the order given by a left-to-right depth-first walk
> of the inheritance graph', assuming that there's not some deep reason
> behind the current wording.
> 
>   Agreed?

In the construction vtables section, I suggested the same ordering as #7
for nonvirtual bases at least, since there's a one-to-one relationship
between vptrs and vtables for a derived class.  If two bases are at the
same offset, they share the same vtable.

The trouble that I have with the left-to-right wording is that if you have
an nearly empty virtual base class that shares a vptr with a subobject
in the class, the vtable would be coincident with the shared subobject vtable,
and not allocated at the end of the vtable array (in it's left-to-right
position).  Just like in the base class layout algorithm itself.

Coleen

> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From mark at codesourcery.com  Mon Feb 21 17:06:41 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 21 Feb 2000 09:06:41 -0800
Subject: Vtables
In-Reply-To: <38B14974.1C1F7628@zko.dec.com>
References: <20000219190419E.mitchell@codesourcery.com>
	<38B14974.1C1F7628@zko.dec.com>
Message-ID: <20000221090641B.mitchell@codesourcery.com>

>>>>> "Coleen" == Coleen Phillimore <coleen at zko.dec.com> writes:

    Coleen> In the construction vtables section, I suggested the same
    Coleen> ordering as #7 for nonvirtual bases at least, since

What's #7?  I'm somehow not understanding what in the documents that's
a cross-reference to.

    Coleen> there's a one-to-one relationship between vptrs and
    Coleen> vtables for a derived class.  If two bases are at the same
    Coleen> offset, they share the same vtable.

True.

    Coleen> The trouble that I have with the left-to-right wording is
    Coleen> that if you have an nearly empty virtual base class that
    Coleen> shares a vptr with a subobject in the class, the vtable
    Coleen> would be coincident with the shared subobject vtable, and
    Coleen> not allocated at the end of the vtable array (in it's
    Coleen> left-to-right position).  Just like in the base class
    Coleen> layout algorithm itself.

I've just implemented the vtable combination stuff in GCC.  Here's how
it works:

  o Do a depth-first, left-to-right walk of the graph.  Never walk
    the same node twice.

  o As you visit each node, if it is not a primary base, and has
    a vptr, add its vtable.

I'm not sure if that's what you meant.  With this algorithm, the
primary vtable is automatically output first, and there are no extra
vtables output.

I don't really care what order we pick, but it needs to be clearly
specified.  It's also advantageous if these things can be computed
relatively independently of each other.  For example, the algorithm I
just outlined can be implemented if you have the inheritance graph,
and bits saying which things are primary bases, without knowing the
offsets of the various bases, how various things got to be primary,
etc.  That's nice in that changes to the ABI, or supporting other
similar ABIs, will be easy -- there aren't too many interdependencies.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Feb 21 17:58:41 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 21 Feb 2000 09:58:41 -0800
Subject: Pointers-to-members
Message-ID: <20000221095841K.mitchell@codesourcery.com>


The ABI document says that a NULL pointer-to-member function has 
`ptr == 0'.  It does, not, however say whether or not a NULL
pointer-to-member function also has `adj == 0'.

I believe that this should be specified as well so that code generated
to do comparison of pointers to members (of the same type) looks like:

  p1->ptr == p2->ptr && p1->adj == p2->adj

and not:

  p1->ptr == p2->ptr && (!p1->ptr || (p1->adj == p2->adj))

So, I would say:

  If the pointer-to-member is NULL, both fields are zero.  (Note:
  there are no non-NULL pointers-to-members for which the `ptr'
  field is non-zero.)

Does that sound right?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From coleen at zko.dec.com  Mon Feb 21 18:36:49 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 21 Feb 2000 13:36:49 -0500
Subject: Vtables
References: <20000219190419E.mitchell@codesourcery.com>
		<38B14974.1C1F7628@zko.dec.com> <20000221090641B.mitchell@codesourcery.com>
Message-ID: <38B185C1.A320B9EE@zko.dec.com>

Mark Mitchell wrote:
> 
> >>>>> "Coleen" == Coleen Phillimore <coleen at zko.dec.com> writes:
> 
>     Coleen> In the construction vtables section, I suggested the same
>     Coleen> ordering as #7 for nonvirtual bases at least, since
> 
> What's #7?  I'm somehow not understanding what in the documents that's
> a cross-reference to.

The 7 was from your original mail that referred to the statement you
were quoting about the order of secondary vtables in the ABI data layout
document (under "Virtual Table Order").

> 
>     Coleen> there's a one-to-one relationship between vptrs and
>     Coleen> vtables for a derived class.  If two bases are at the same
>     Coleen> offset, they share the same vtable.
> 
> True.
> 
>     Coleen> The trouble that I have with the left-to-right wording is
>     Coleen> that if you have an nearly empty virtual base class that
>     Coleen> shares a vptr with a subobject in the class, the vtable
>     Coleen> would be coincident with the shared subobject vtable, and
>     Coleen> not allocated at the end of the vtable array (in it's
>     Coleen> left-to-right position).  Just like in the base class
>     Coleen> layout algorithm itself.
> 
> I've just implemented the vtable combination stuff in GCC.  Here's how
> it works:

I'm about to implement this myself and this is probably the algorithm
I will use as well.  It seems to be the same as the algorithm for
laying out base classes, except that the non-shared virtual vtables
should be last.

The non-virtual set of vtables needs to be first in the "fixed" part of
the greater vtable (for construction vtables to work properly), and the
vtables for virtual parts later.

I agree we need more specification of the ordering, which is why I tried
to do so in the construction vtable section.  Can you look at that?  Do you
think that should be reworded as a walk of the base classes not their
offsets too?

Thanks,
Coleen

> 
>   o Do a depth-first, left-to-right walk of the graph.  Never walk
>     the same node twice.
> 
>   o As you visit each node, if it is not a primary base, and has
>     a vptr, add its vtable.
> 
> I'm not sure if that's what you meant.  With this algorithm, the
> primary vtable is automatically output first, and there are no extra
> vtables output.
> 
> I don't really care what order we pick, but it needs to be clearly
> specified.  It's also advantageous if these things can be computed
> relatively independently of each other.  For example, the algorithm I
> just outlined can be implemented if you have the inheritance graph,
> and bits saying which things are primary bases, without knowing the
> offsets of the various bases, how various things got to be primary,
> etc.  That's nice in that changes to the ABI, or supporting other
> similar ABIs, will be easy -- there aren't too many interdependencies.
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From mark at codesourcery.com  Mon Feb 21 19:03:31 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 21 Feb 2000 11:03:31 -0800
Subject: Vtables
In-Reply-To: <38B185C1.A320B9EE@zko.dec.com>
References: <38B14974.1C1F7628@zko.dec.com>
	<20000221090641B.mitchell@codesourcery.com>
	<38B185C1.A320B9EE@zko.dec.com>
Message-ID: <20000221110331N.mitchell@codesourcery.com>


  I'm about to implement this myself and this is probably the algorithm
  I will use as well.  It seems to be the same as the algorithm for
  laying out base classes, except that the non-shared virtual vtables
  should be last.

  The non-virtual set of vtables needs to be first in the "fixed" part of
  the greater vtable (for construction vtables to work properly), and the
  vtables for virtual parts later.

Oops -- my posted algorithm doesn't accomplish that.  I've never quite
understood what's meant by the "algorithm for laying out base
classes".  (I understand the algorithm, but not how it induces an
ordering on the base subobjects.)

  I agree we need more specification of the ordering, which is why I tried
  to do so in the construction vtable section.  Can you look at that?  Do you
  think that should be reworded as a walk of the base classes not their
  offsets too?

Yes, I think that would be an improvement.  Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Feb 21 21:51:28 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 21 Feb 2000 13:51:28 -0800
Subject: Pointers-to-members
In-Reply-To: <20000221095841K.mitchell@codesourcery.com>
References: <20000221095841K.mitchell@codesourcery.com>
Message-ID: <20000221135128N.mitchell@codesourcery.com>


Following up on my own suggestion:

  The ABI document says that a NULL pointer-to-member function has 
  `ptr == 0'.  It does, not, however say whether or not a NULL
  pointer-to-member function also has `adj == 0'.

  I believe that this should be specified as well so that code generated
  to do comparison of pointers to members (of the same type) looks like:

    p1->ptr == p2->ptr && p1->adj == p2->adj

  and not:

    p1->ptr == p2->ptr && (!p1->ptr || (p1->adj == p2->adj))

  So, I would say:

    If the pointer-to-member is NULL, both fields are zero.  (Note:
    there are no non-NULL pointers-to-members for which the `ptr'
    field is non-zero.)

It's occurred to me that this imposes some overhead on casting
pointers-to-members around: now when you convert from a base pointer
to member to a derived version (or vice versa), you can't just adjust
the `adj' member willy-nilly; instead, you have to check first whether
or not the pointer is NULL.

So, I'm not sure any more which scheme is preferable -- but we
definitely need to say clearly which we want.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Feb 21 22:15:29 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 21 Feb 2000 14:15:29 -0800
Subject: Vtable index type
Message-ID: <20000221141529D.mitchell@codesourcery.com>


We should specify a type for vtable indices.  It seems to me that
`ptrdiff_t' is the obvious candidate.

This is important in that it limits the number of vtable entries we
can use.  (For example, g++ has historically used `short' for a vtable
index; that limited the size of vtables.)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Wed Feb 23 01:35:44 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 17:35:44 -0800
Subject: Virtual function call stuff, again
In-Reply-To: Mark Mitchell's message of "Tue, 22 Feb 2000 16:08:10 -0800"
References: <u966vhrkr1.fsf@yorick.cygnus.com> <20000222135458E.mitchell@codesourcery.com> <u9r9e4reki.fsf@yorick.cygnus.com> <20000222160810A.mitchell@codesourcery.com>
Message-ID: <u9ema4r98v.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:
 Jason> Actually, the algorithm for this case is very simple: use
 Jason> the same entry point as is used in the 'A-in-C' secondary
 Jason> vtable.

 > But there's no such thing if `A' is not a base class of `C'.  Do the
 > rest of your comments still apply?

How can C::f be the final overrider of A::f in B if C is not derived from A?

Jason



From mark at codesourcery.com  Wed Feb 23 01:52:57 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 17:52:57 -0800
Subject: Virtual function call stuff, again
In-Reply-To: <u9ema4r98v.fsf@yorick.cygnus.com>
References: <u9r9e4reki.fsf@yorick.cygnus.com>
	<20000222160810A.mitchell@codesourcery.com>
	<u9ema4r98v.fsf@yorick.cygnus.com>
Message-ID: <20000222175257I.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> How can C::f be the final overrider of A::f in B if C is
    Jason> not derived from A?

Doh.  Good; that allows me to drop one whole chunk of confusion.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Tue Feb 22 19:36:05 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 22 Feb 2000 19:36:05 +0000
Subject: Pointers-to-members
References: <20000221095841K.mitchell@codesourcery.com>
Message-ID: <38B2E525.E6D56AA@cup.hp.com>

Mark Mitchell wrote:
> 
> The ABI document says that a NULL pointer-to-member function has
> `ptr == 0'.  It does, not, however say whether or not a NULL
> pointer-to-member function also has `adj == 0'.
> 
> I believe that this should be specified as well so that code generated
> to do comparison of pointers to members (of the same type) looks like:
> 
>   p1->ptr == p2->ptr && p1->adj == p2->adj
> 
> and not:
> 
>   p1->ptr == p2->ptr && (!p1->ptr || (p1->adj == p2->adj))
> 
> So, I would say:
> 
>   If the pointer-to-member is NULL, both fields are zero.  (Note:
>   there are no non-NULL pointers-to-members for which the `ptr'
>   field is non-zero.)
             ^^^^^^^^

I assume you meant "There are no non-NULL pointers-to-members for which the
'ptr' field is zero", correct?


Christophe



From ddd at cup.hp.com  Tue Feb 22 19:28:23 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 22 Feb 2000 19:28:23 +0000
Subject: Updated mangling specs
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com> <200002150026.QAA22312@baalbek.engr.sgi.com> <u966vo7fep.fsf@casey.cygnus.com>
Message-ID: <38B2E357.7897CB8B@cup.hp.com>

Jason Merrill wrote:
> 
> dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
> 
> > > > Also, to allow cross-.o file inlining, you need to extend that to
> > > > any function (not only those explicitly marked inline.) Strictly
> > > > speaking, this is outside the ABI, but unless there are strong
> > > > reasons not to, I'd advocate mangling any static data, regardless of
> > > > whether the function is tagged inline or not.
> > >
> > > We should mangle the static data for any function that may be inlined;
> > > which functions those are depends on the compiler.
> >
> > I don't think that we can or should require that the static data
> > always have mangled symbols emitted -- that should be the responsibility
> > of an implementation that chooses to inline routines not declared
> > inline.  However, once the compiler chooses to emit them, it should use
> > the defined mangling for inline routines.
> 
> I'm not sure that we're disagreeing here.
> 
> If the compiler decides to inline the function in one translation
> unit, and not in another, we still need to share statics between
> inline and out-of-line copies.  Either we can say that the compiler
> should recognize that the function might be inlined in another TU and
> mangle the locals accordingly, or we can say that we should always
> mangle locals.  The latter might be the only way to deal with inlining
> differences between implementations...if we care.

Again, my point was that mangling statics is not well-defined enough for that.
Consider:

// File f1.C

static inline int foo()
{
	static int i = 0;
	return ++i;
}

extern int bar1()
{
	return foo();
}


// File f2.C

static inline int foo()
{
	static int i = 0;
	return --i;
}

extern int bar2()
{
	return foo();
}


// File f3.C
extern int bar1(), bar2();
int main()
{
	return bar1() + bar2();
}


Consider what happens if you want to inline bar1 and bar2. Our name mangling for
statics is not good enough, because i would be mangled the same. We need a file
name too. To me, it's good enough to use the 'escape' mechanism for that, but it
has to be there.



Regards
Christophe



From mark at codesourcery.com  Tue Feb 22 19:43:54 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 11:43:54 -0800
Subject: C implementations of the C++ ABI
Message-ID: <20000222114354R.mitchell@codesourcery.com>


I don't know if we've fully considered the impact of the C++ ABI on
tools that generate C code to implement C++.  Examples of these
include the KAI C++-to-C optimizing compiler, various error-checking
tools, and compilers for languages other than C++.  (For example, a
Python compiler might well generate C code, but conforming to the ABI,
so that it could be linked with C++ programs.)  The GNU standard IO
library manually creates vtables, and C structures that mirror C++
object layouts.

There's a reason that these tools don't generate/use C++.  In KAI,
it's because they're trying to compile C++ to C -- they are performing
optimizations that many C++ compilers don't manage.  In general, the
reason is that C, despite the efforts of the C++ ABI committee, will
probably be a more portable language than C++ for years to come.
Besides the ABI issues, there are tons of issues regarding language
conformance, library conformance, template model, etc.  Most vendors
still have a ways to go to reach full conformance, and even that won't
ensure easy interoperability with respect to things like templates.
Whereas, most modern C compilers can be invoked with `<compiler> -c
foo.c' and generally produce the `foo.o' that you expected.

So, I'm concerned that our ABI has constructs that are not
representable in C.  The ones that jump out at me our:

  o Thunks

    These don't concern me too much.  Generating a little bit of
    assembly gets you past these, and the performance wins are
    significant.

  o Exceptions

    There have always been exception-handling issues in C++-to-C
    translation, and related tools.  Generally, the people who do
    that don't care about exceptions, so we're probably OK here.

  o GP/address pairs in vtables

    This one concerns me the most.  I don't even know if there's 
    any kind of standard assembly syntax for this.  Is there?
    (If not, there should be -- otherwise, you can't say -S to your
    compiler and get anything sensible out.)

    (BTW, if there's only one GP/address pair per function that
    matters (which there normally would be, so that pointers to the
    same function compare equal), then you can do things like overrite
    the GP/address pair to automatically switch all calls to that
    function to a different place.  (Yes, I've seen programs that do
    this -- and where it seemed justifiable.)

All in all, I'm not really suggesting we change anything.  I'm just
trying to make sure we're aware that there's an issue, in case we're
not already aware.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Feb 22 20:22:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 12:22:58 -0800
Subject: Pointers-to-members
In-Reply-To: <38B2E525.E6D56AA@cup.hp.com>
References: <20000221095841K.mitchell@codesourcery.com>
	<38B2E525.E6D56AA@cup.hp.com>
Message-ID: <20000222122258L.mitchell@codesourcery.com>

>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:

    Christophe> Mark Mitchell wrote:
    >>  The ABI document says that a NULL pointer-to-member function
    >> has `ptr == 0'.  It does, not, however say whether or not a
    >> NULL pointer-to-member function also has `adj == 0'.
    >> 
    >> I believe that this should be specified as well so that code
    >> generated to do comparison of pointers to members (of the same
    >> type) looks like:
    >> 
    p1-> ptr == p2->ptr && p1->adj == p2->adj
    >>  and not:
    >> 
    p1-> ptr == p2->ptr && (!p1->ptr || (p1->adj == p2->adj))
    >>  So, I would say:
    >> 
    >> If the pointer-to-member is NULL, both fields are zero.  (Note:
    >> there are no non-NULL pointers-to-members for which the `ptr'
    >> field is non-zero.)

    Christophe>              ^^^^^^^^

    Christophe> I assume you meant "There are no non-NULL
    Christophe> pointers-to-members for which the 'ptr' field is
    Christophe> zero", correct?

Yes.  I apologize for my own idiocy.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed Feb 23 00:46:39 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 16:46:39 -0800
Subject: Oversize bitfields
Message-ID: <20000222164639E.mitchell@codesourcery.com>


I don't quite understand:

  When a bitfield member of a class is specified with a size greater
  than the field type declared, e.g. char c: 32, it is allocated as
  follows. The field alignment used is that of the largest integer type
  that will fit in the given size, and the first bits of the field
  (low-order for little-endian IA-64) are used to contain the actual
  data.

What does the `field alignment' mean here?  Do we mean that given:

  struct S { char c1 : 33; char c2: 33 };

that this structure will take up 16 bytes?  (The biggest type to fit
in either field is an `int', which has 4-byte size/alignment.)  So, if
we want to 4-byte align the fields, we put them at offsets 0 and 8,
respectively.  That's slightly in contrast to:

  struct S { short s1 : 15; short s2 : 1 };

where we use only two bytes for `S'; we don't try to align `s2' on a
`short' boundary.  

I understand the rationale: we might store a whole `int' in each
field, and then the larger alignment will win.  I'm just trying to be
sure I understand.

How about the following wording:

  Let n be the number of bits in the bitfield.  Let T be the largest
  integer type that will fit in n bits.  For the purposes of class
  layout, treat the field as if it were a non-bitfield of type `T',
  followed by n - 8 * sizeof (T) bits of padding.

That expresses nicely the idea that we want the field to be aligned as
if for a `T'.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Tue Feb 22 19:17:01 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 22 Feb 2000 19:17:01 +0000
Subject: Virtual function call stuff, again
References: <20000219155118D.mitchell@codesourcery.com>
Message-ID: <38B2E0AD.BB761E10@cup.hp.com>

Mark Mitchell wrote:
> 
>   The discussion in the `callee' section on "Virtual Function Calling
> Convention" is very unclear.  For example, it's not explained which
> classes are bases of which others.

Mark, I did not find anything containing "Virtual Function Calling Convention"
in the documentation. Could you specify an URL and quote the original text, it
would help me locating it...


>  Here's an attempted rewrite.
> Let's see if it's what y'all meant.

> 
>   o Suppose a class `A' defines a virtual function `A::f'.  The
>     primary vtable for `A' contains a pointer to an entry point
>     that performs no adjustment.
> 
>   o Suppose that a class `A' declares a virtual function `A::f',
>     and suppose that `A' is a base class in a hierarchy dominated
>     by another class `B'.  Suppose that the unique final overrider for
>     `A::f' in `B' is `C::f'.  We must determine what entry point
>     is used for `f' in the `A-in-B' secondary vtable.  Here is the
>     algorithm:
> 
>     - Find any path from `B' to `C' in the inheritance graph for `B'.
> 
>     - If there is no virtual base along the path, then create
>       an entry point which adjusts the `this' pointer from `A' to `C'.
>       This value can be computed statically when the `A-in-B' vtable
>       is created.  Then transfer control to the non-adjusting entry
>       point for `C::f'.

Yes. What's more, in that case, the offset is stored in the vtable at a
(possibly large) constant negative offset from the vptr. We called this offset
'convert_to_C', and it is used only when the final overrider is a C. The A-in-B
vtable contains a 'convert_to_C' value that converts from an A* to a C*. The
benefits are explained in
http://reality.sgi.com/dehnert_engr/cxx/cxx-closed.html, section B-1.


>     - If there is a virtual base along this path, let `V' be the
>       virtual base nearest to `C' along the path.  (In fact, `V'
>       will be `C' itself if `C' is a virtual base.)

You are considering a path between B and C, so V would be the closest between B
and C. In which case I do not understand the adjustment below ("Adjustment from
'A' to 'V'"). Either you are considering that V is between A and C, in which
case you need to adjust from A to V, or you are considering that V is between C
and B, in which case if you see it at call site, you would have to adjust from B
to V. Did I misunderstand?


> 
>       (Note that the choice of `V' is independent of the choice of path.
>       If there was more than one path, then there must have been a
>       virtual base along all of the paths, and there is a unique one
>       closest to `C'.)
> 
>       Now, create an entry point which first performs the adjustment
>       from `A' to `V'.  (This value can be computed statically, when
>       the `A-in-B' vtable is created.)  Then, adjust the `this'
>       pointer by the vcall offset stored in the secondary vtable for
>       `V' (i.e., the `V-in-B' vtable).  (This adjustment will adjust
>       the `this' pointer from `V' to `C'.)  Finally, transfer control
>       to the non-adjusting entry point for `C::f'.
> 
>   Is that correct?

Maybe, but I'm not sure I understood... :-)


So, starting with your example again. Sorry for the verbiage...

Case 1 is: V is between A and C.

- If you call through an A*, you call through the A vtable, which points to a
virtual-base-adjustment thunk. That thunk reads the C-to-A virtual base offset,
and adds that to get a C*, and then jumps to the non-adjusting C::f. Of course,
the C-to-A virtual base offset is not necessarily constant along the class
hierarchy, so for instance the C-to-A virtual base offset in a C is not the same
as the C-to-A virtual base offset in a B.

- If you call through a C*, you call through the C vtable. In that case, you
don't care if A is a virtual base, since C::f expects a C*. Virtual-base
adjustment to A, if necessary, would be done inside C::f. So the C vtable points
to the non-adjusting entry point.

- If you call through a B*, you call through the C vtable (the final overrider
for f), and you adjust to a C* statically.


Case 2: V is between C and B:

- If you call through an A*, you call through the A vtable. The offset from A to
C is constant in the class hierarchy, but there may be multiple bases A1, A2,
A3, with different offsets. The "classical" approach is to use multiple thunks
that convert from A1 to C, from A2 to C, from A3 to C. Because of the high cache
muss and branch misprediction penalty, I proposed that we rather have all
vtables A1-in-C, A2-in-C, ... contain an offset, call it 'Convert_to_C', that
adjusts from A1 to C, A2 to C, etc. This way, there can be a single adjusting
entry point that does this adjustment (although you can still emit thunks)

- If you call through a C*, you call through the C vtable, which points to the
non-adjusting entry point C::f.

- If you call through a B*, you need at call-site to convert from B* to C*,
which involves a dynamic adjustment using the B-to-V virtual base offsets in B's
vtable, followed by a static adjustment from V to C (which is known at
compile-time).


I'm not sure I clarified anything ;-)



>   It seems like the scheme specified in the ABI is advantageous in a
> situation where `C' is the same as `A', and `A' is the same as `V'.
> (In other words, if `A' is a virtual base and `A::f' is not overriden
> in `B'.)  Then, by emitting the vcall-adjusting entry point right
> before the main entry point for `C::f', calling `f' requires only one
> branch (to the entry point specified in the vtable), rather than two
> (to a thunk, and then from the thunk to the main function).  Right?

First, note that the scheme is believed to be advantageous whenever there is no
virtual inheritance, which I think is a frequent case. Cache locality plays a
big role here.

Second, in the virtual base case, there is no guarantee that the thunk will be
right before the non-adjusting entry point: as Jason pointed out, you cannot
find a single offset to use to perform the adjustment.

Third, I do not understand in this statement whether you are calling through an
A*, B* or C*.

> 
>   I still can't see why it is a win to use vcall offsets in the case
> where `A' and `V' are not the same class.  You already have to do one
> static adjustment in the entry point -- why not just adjust all the
> way to `B' directly, without bothering to look up the vcall offset?

I did not understand this question :-( If you feel a static thunk is better than
a dynamic lookup, then you can emit that thunk and point to it through the
vtable, as Jason pointed out. The ABI allows you to do that.


>   Furthermore, the actual algorithm used to perform the adjustments
> does not seem necessarily to be part of the ABI.  The layout of the
> vtables is certainly part of the ABI.  But, if one compiler wants to
> completely ignore the vcall offset entries in the vtables, and compute
> the entire adjustment statically, shouldn't that be permitted by the
> ABI, even though it might require one extra branch?  Surely that's
> just a quality-of-implementation issue?

Correct. Again, that seems clear to me from Jason's writeup:


Note that the ABI only specifies the multiple entry points; how those entry
points are provided is unspecified. An existing compiler which uses thunks could
be converted to use this ABI by only adding support for the vcall offsets. A
more efficient implementation would be to emit all of the thunks immediately
before the non-adjusting entry point to the function. Another might use
predication rather than branches to reach the main function. Another might emit
a new copy of the function for each entry point; this is a quality of
implementation issue.



Regards
Christophe "This stuff is complicated" de Dinechin



From mark at codesourcery.com  Wed Feb 23 00:03:13 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 16:03:13 -0800
Subject: Pointers-to-members
In-Reply-To: <38B31A05.CBFBE092@cup.hp.com>
References: <38B2E525.E6D56AA@cup.hp.com>
	<20000222122258L.mitchell@codesourcery.com>
	<38B31A05.CBFBE092@cup.hp.com>
Message-ID: <20000222160313J.mitchell@codesourcery.com>


  > Yes.  I apologize for my own idiocy.
				 ^^^^^^
  Another typo, I guess :-)

No, that's the right spelling. :-) Check www.dictionary.com.  I might
be an idiot, but at least I can spell! :-)

  Ach, but, what is the value for the NULL pointer to data member? I guess -1
  would do, unless there are cases I can't think of where the pointer to member
  would legitimately have a negative value. Maybe 0x8000000000000000
  is better...

I'm a step ahead of you. :-) I already started a thread on precisely
this.  Here's some more analysis:

  o All pointer-to-member offsets start out non-negative.
  o Only casts which would increase the `this' pointer could cause
    the pointer-to-member to go negative.
  o A reinterpret_cast leaves the value unspecified, except that:

     - NULL is converted to NULL
     - If you convert back, you're OK.

    But, therefore, converting a non-NULL value to NULL is explicitly
    permitted by the standard.

  o A pointer-to-base can be converted to a pointer-to-derived via
    an implicit conversion/static_cast.

    It's illegal to do this if the base is virtual.  But, that's the
    only case in which the `this' pointer can increase.

  o A pointer-to-derived can be converted to a pointer-to-base.  This
    will normally increase the `this' pointer.  The standard is a
    little unclear here, but I think it wants to say that this is
    illegal precisely in the cases where the offset would go negative:

      [expr.static.cast]

      If class B contains the original member, or is a base or derived
      class of the class containing the original member, the resulting
      pointer to member points to the original member.  Otherwise, the
      result of the cast is undefined.

    Consider this program:

      struct S
      {
	char c;
      };

      struct U 
      {
	char d;
      };

      struct T : public U, public S
      {
      };

      typedef char S::*sp;
      typedef char T::*tp;

      int main ()
      {
	sp s;
	tp t;

	t = &T::d;
	s = static_cast<sp> (t);

	if (s == 0)
	  return 1;
      }
  
   With GCC, this program wil return 1, i.e., the `&T::d' pointer has
   become NULL when converted to `char S::*'.  But, I think this
   behavior is OK: `S' does not contain the original member `U::d'.

So, adding `1' to the offset (and using `0' for NULL) is OK; so is
using `-1' for NULL, and using the offset for the pointer-to-member
itself.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed Feb 23 00:08:10 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 16:08:10 -0800
Subject: Virtual function call stuff, again
In-Reply-To: <u9r9e4reki.fsf@yorick.cygnus.com>
References: <u966vhrkr1.fsf@yorick.cygnus.com>
	<20000222135458E.mitchell@codesourcery.com>
	<u9r9e4reki.fsf@yorick.cygnus.com>
Message-ID: <20000222160810A.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> Actually, the algorithm for this case is very simple: use
    Jason> the same entry point as is used in the 'A-in-C' secondary
    Jason> vtable.

But there's no such thing if `A' is not a base class of `C'.  Do the
rest of your comments still apply?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed Feb 23 00:06:37 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 16:06:37 -0800
Subject: Vtable index type
In-Reply-To: <u9og98rebg.fsf@yorick.cygnus.com>
References: <u93dqksz08.fsf@yorick.cygnus.com>
	<20000222140448N.mitchell@codesourcery.com>
	<u9og98rebg.fsf@yorick.cygnus.com>
Message-ID: <20000222160637S.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> Actually, that's an offset (in bytes), not an index (in
    Jason> slots).  I suppose we should define "vtable offset"
    Jason> somewhere. 

Yup.  Especially since I misimplemented this in G++ as a result. :-(

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Tue Feb 22 23:40:45 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 15:40:45 -0800
Subject: Virtual function call stuff, again
In-Reply-To: Mark Mitchell's message of "Tue, 22 Feb 2000 13:54:58 -0800"
References: <20000219155118D.mitchell@codesourcery.com> <u966vhrkr1.fsf@yorick.cygnus.com> <20000222135458E.mitchell@codesourcery.com>
Message-ID: <u9r9e4reki.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >>   o Suppose a class `A' defines a virtual function `A::f'.  The 
 >>     primary vtable for `A' contains a pointer to an entry point
 >>     that performs no adjustment.

 >>   o Suppose that a class `A' declares a virtual function `A::f', 
 >>     and suppose that `A' is a base class in a hierarchy dominated 
 >>     by another class `B'.  Suppose that the unique final overrider for
 >>     `A::f' in `B' is `C::f'.  We must determine what entry point
 >>     is used for `f' in the `A-in-B' secondary vtable.  Here is the
 >>     algorithm:

Oops; I missed the basic misunderstanding in my previous reply.

Actually, the algorithm for this case is very simple: use the same entry
point as is used in the 'A-in-C' secondary vtable.  Since 'B' does not
override 'f', it does not introduce a new entry point.  That's the primary
design goal.

So the interesting question is, what do you put in the 'A-in-C' secondary
vtable?

 >>     - Find any path from `B' to `C' in the inheritance graph for `B'.

...from 'C' to 'A'...for 'C'.

 >>     - If there is no virtual base along the path, then create
 >>       an entry point which adjusts the `this' pointer from `A' to `C'.
 >>       This value can be computed statically when the `A-in-B' vtable
 >>       is created.  Then transfer control to the non-adjusting entry
 >>       point for `C::f'.

...when the 'A-in-C' vtable is created.

 >>     - If there is a virtual base along this path, let `V' be the
 >>       virtual base nearest to `C' along the path.  (In fact, `V'
 >>       will be `C' itself if `C' is a virtual base.)

 >   Rather, nearest to 'A'.

 > How is that defined?  We're looking at paths between `B' and `C'.  But
 > maybe I got that wrong, too?

Yes; see above.

 >>       (Note that the choice of `V' is independent of the choice of path.
 >>       If there was more than one path, then there must have been a
 >>       virtual base along all of the paths, and there is a unique one
 >>       closest to `C'.)

 >   No; we're looking for the most-derived base subobject of which our A is a
 >   non-virtual base, which is unique.

 > Something is under-specified there.  (We're looking for something that
 > is a virtual base, right?)  How, exactly, do we find `V'?  That's the
 > part that still seems most unclear to me.

Walk down the inheritance chain from A to C, and stop when you see the
first use of virtual inheritance.

 >>       Now, create an entry point which first performs the adjustment
 >>       from `A' to `V'.  (This value can be computed statically, when
 >>       the `A-in-B' vtable is created.)  Then, adjust the `this'

'A-in-C'

 >>       pointer by the vcall offset stored in the secondary vtable for
 >>       `V' (i.e., the `V-in-B' vtable).  (This adjustment will adjust
 >>       the `this' pointer from `V' to `C'.)  Finally, transfer control
 >>       to the non-adjusting entry point for `C::f'.

'V-in-B' is correct here.  When B is defined, the only thing that needs to
change in the secondary vtable for V is the vcall offset, not the entry
point.

 >   If C is different from A, but A is the same as V, then we need one entry
 >   point directly before the main function, which adds the vcall offset and
 >   falls through.

 >   If C != A != V, and V overrides f, then we need one more entry point,
 >   so we get:

 >   A vtable entry point
 >      adjusts the A* to a V* by a constant offset and falls through to
 >   V vtable entry point
 >      adjusts the V* to a C* by the vcall offset in the vtable and falls
 >      through to
 >   C::f

 > How does that work if there is more than one `A'?  I understand that
 > more than one `V' could be handled by having different vcall offsets
 > for each `V'.

If there is more than one A, then you can't just fall through, you have to
branch.  So you would add (at the beginning of the above):

A1 vtable entry point
  adjusts the A1* to a V* by a constant offset and jumps to the V entry point

But you can use a PC-relative branch in this situation, so the performance
hit is small.

 > Our first priority is to provide a conforming implementation.  I
 > expect that will mean that we don't take full advantage of the new
 > ABI.  But, the good news is that, because it's an ABI, we can take
 > more advantage of it later and still link with things produced by
 > earlier versions of the compiler.

Fair enough.

Jason



From jason at cygnus.com  Tue Feb 22 23:46:11 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 15:46:11 -0800
Subject: Vtable index type
In-Reply-To: Mark Mitchell's message of "Tue, 22 Feb 2000 14:04:48 -0800"
References: <20000221141529D.mitchell@codesourcery.com> <u93dqksz08.fsf@yorick.cygnus.com> <20000222140448N.mitchell@codesourcery.com>
Message-ID: <u9og98rebg.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:
>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >>> We should specify a type for vtable indices.  It seems to me
 >>> that `ptrdiff_t' is the obvious candidate.

 >>> This is important in that it limits the number of vtable
 >>> entries we can use.  (For example, g++ has historically used
 >>> `short' for a vtable index; that limited the size of vtables.)

 Jason> Where does a vtable index appear in the ABI?

 > Pointers-to-members.

Actually, that's an offset (in bytes), not an index (in slots).  I suppose
we should define "vtable offset" somewhere.  But the same issue applies.

 > Suppose we check the `ptr' field, and notice it's odd.  Now, we have to
 > divide by two and use the resulting thing as a vtable index.  If, say,
 > we only allowed n-bit indices, then we could shift right one bit, and
 > pull out just the low-order n-bits.  I don't know *why* anyone would
 > want to do that, but the ABI should say whether or not its legal to do
 > so.

Makes sense.  I agree that ptrdiff_t seems like the obvious resolution.

Jason



From mark at codesourcery.com  Tue Feb 22 20:21:18 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 12:21:18 -0800
Subject: Virtual function call stuff, again
In-Reply-To: <38B2E0AD.BB761E10@cup.hp.com>
References: <20000219155118D.mitchell@codesourcery.com>
	<38B2E0AD.BB761E10@cup.hp.com>
Message-ID: <20000222122118G.mitchell@codesourcery.com>

>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:

Thanks for helping me with this.

    Christophe> Mark, I did not find anything containing "Virtual
    Christophe> Function Calling Convention" in the
    Christophe> documentation. Could you specify an URL and quote the
    Christophe> original text, it would help me locating it...

http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html#vtable

There doesn't appear to be a tag for the "VFCC" section, but it's down
just a bit from the URL I gave.

    >> Here's an attempted rewrite.  Let's see if it's what y'all
    >> meant.

    >>  o Suppose a class `A' defines a virtual function `A::f'.  The
    >> primary vtable for `A' contains a pointer to an entry point
    >> that performs no adjustment.
    >> 
    >> o Suppose that a class `A' declares a virtual function `A::f',
    >> and suppose that `A' is a base class in a hierarchy dominated
    >> by another class `B'.  Suppose that the unique final overrider
    >> for `A::f' in `B' is `C::f'.  We must determine what entry
    >> point is used for `f' in the `A-in-B' secondary vtable.  Here
    >> is the algorithm:
    >> 
    >> - Find any path from `B' to `C' in the inheritance graph for
    >> `B'.
    >> 
    >> - If there is no virtual base along the path, then create an
    >> entry point which adjusts the `this' pointer from `A' to `C'.
    >> This value can be computed statically when the `A-in-B' vtable
    >> is created.  Then transfer control to the non-adjusting entry
    >> point for `C::f'.

    Christophe> Yes. What's more, in that case, the offset is stored
    Christophe> in the vtable at a (possibly large) constant negative
    Christophe> offset from the vptr. We called this offset
    Christophe> 'convert_to_C', and it is used only when the final
    Christophe> overrider is a C. The A-in-B vtable contains a
    Christophe> 'convert_to_C' value that converts from an A* to a
    Christophe> C*. The benefits are explained in
    Christophe> http://reality.sgi.com/dehnert_engr/cxx/cxx-closed.html,
    Christophe> section B-1.

I understand the high-level points of that discussion: what I don't
understand is exactly what goes where, when.  I'm not really trying to
reopen any issue -- I'm trying to force the committe to write down
what it decided.  At this point, the decision is not, quite frankly,
written in a form that anyone not on the committee is likely to
decipher.  (Well, at least I've tried hard, I'm not an idiot, I know
about this application domain, and I still can't figure it out.)

    >> - If there is a virtual base along this path, let `V' be the
    >> virtual base nearest to `C' along the path.  (In fact, `V' will
    >> be `C' itself if `C' is a virtual base.)

    Christophe> You are considering a path between B and C, so V would
    Christophe> be the closest between B and C. In which case I do not
    Christophe> understand the adjustment below ("Adjustment from 'A'
    Christophe> to 'V'"). Either you are considering that V is between
    Christophe> A and C, in which case you need to adjust from A to V,
    Christophe> or you are considering that V is between C and B, in
    Christophe> which case if you see it at call site, you would have
    Christophe> to adjust from B to V. Did I misunderstand?

You won't in general see `V' at the call site, if it's between C and
B, because you might have `A*' when you're making the call.  (If you
had a `B*', or a `C*', then `C::f' would be the unique final overrider
-- by hypothesis -- so you would have converted your pointer to a
`C*', and you be looking at the C-in-B vtable, rather than the A-in-B
vtable, which is what my discussion was talking about.)

I'm not sure where you're supposed to adjust `A' to.  That's what I'm
trying to find out.  It may not be the V that I suggested -- I'm not
sure.  I'm hoping that my words could serve as the model for whatever
the right answer is.  They're in the form of an algorithm that
explains exactly what to put in the vtable, in the general case, and
that's a good thing, since that's what an implementor needs to know.

    Christophe> So, starting with your example again. Sorry for the
    Christophe> verbiage...

    Christophe> Case 1 is: V is between A and C.

THere's no discussion of these two different cases in the current
writeup.  So, I'm already lost.  What you write below seems reasonably
logical -- but I'm not sure it's the same thing as in the document.

In general, "between A and C" doesn't make sense; they may be
unrelated. The picture I had in mind was:

              B
             / \
            A   C

In other words, B is the most derived class, C contains the final
overrider, we're looking at the vtable for A.  That's the general case
-- all other cases are special instances of this one.  But, I guess
for case 1, we're assuming C is derived from A?

    Christophe> - If you call through an A*, you call through the A
    Christophe> vtable, which points to a virtual-base-adjustment
    Christophe> thunk. That thunk reads the C-to-A virtual base
    Christophe> offset, and adds that to get a C*, and then jumps to

Where is this offset?  There's a vbase offset in C for converting to
A, if A is a virtual base of C.  But, there's no virtual base offset
in A, for converting to a C.  Where's V in all this?

    Christophe> the non-adjusting C::f. Of course, the C-to-A virtual
    Christophe> base offset is not necessarily constant along the
    Christophe> class hierarchy, so for instance the C-to-A virtual
    Christophe> base offset in a C is not the same as the C-to-A
    Christophe> virtual base offset in a B.

I don't understand this.

    Christophe> - If you call through a C*, you call through the C
    Christophe> vtable. In that case, you don't care if A is a virtual
    Christophe> base, since C::f expects a C*. Virtual-base adjustment
    Christophe> to A, if necessary, would be done inside C::f. So the
    Christophe> C vtable points to the non-adjusting entry point.

That one makes sense.

    Christophe> - If you call through a B*, you call through the C
    Christophe> vtable (the final overrider for f), and you adjust to
    Christophe> a C* statically.

That too.

    Christophe> Case 2: V is between C and B:

    Christophe> - If you call through an A*, you call through the A
    Christophe> vtable. The offset from A to C is constant in the
    Christophe> class hierarchy, but there may be multiple bases A1,
    Christophe> A2, A3, with different offsets. The "classical"

Are all these bases of type A?  Or are these just different bases, all
of which declare the same `f' overridden by `C::f'?

    Christophe> approach is to use multiple thunks that convert from
    Christophe> A1 to C, from A2 to C, from A3 to C. Because of the
    Christophe> high cache muss and branch misprediction penalty, I
    Christophe> proposed that we rather have all vtables A1-in-C,
    Christophe> A2-in-C, ... contain an offset, call it
    Christophe> 'Convert_to_C', that adjusts from A1 to C, A2 to C,
    Christophe> etc. This way, there can be a single adjusting entry
    Christophe> point that does this adjustment (although you can
    Christophe> still emit thunks)

Right -- I get that.  And the point is that you can store the
'convert_to_C' offset at some fixed negative index from the vptr from
each *unadjusted* `this' pointer? 

    Christophe> - If you call through a C*, you call through the C
    Christophe> vtable, which points to the non-adjusting entry point
    Christophe> C::f.

Yes.

    Christophe> - If you call through a B*, you need at call-site to
    Christophe> convert from B* to C*, which involves a dynamic
    Christophe> adjustment using the B-to-V virtual base offsets in
    Christophe> B's vtable, followed by a static adjustment from V to
    Christophe> C (which is known at compile-time).

Yes.  Note that in my attempted writeup, I wasn't trying to specify
how to call the function: I was trying to specify what you put in the
vtable for A.

    Christophe> I'm not sure I clarified anything ;-)

Somewhat. :-)

    Christophe> First, note that the scheme is believed to be
    Christophe> advantageous whenever there is no virtual inheritance,
    Christophe> which I think is a frequent case. Cache locality plays
    Christophe> a big role here.

OK.  It would really help if the ABI document contained some
non-normative notes explaining some of this, and giving some examples.
Unfortunately, I can't write these, because I don't know the answers.

    Christophe> Second, in the virtual base case, there is no
    Christophe> guarantee that the thunk will be right before the
    Christophe> non-adjusting entry point: as Jason pointed out, you
    Christophe> cannot find a single offset to use to perform the
    Christophe> adjustment.

    Christophe> Third, I do not understand in this statement whether
    Christophe> you are calling through an A*, B* or C*.

An A*: that's the point of figuring out what to put in the A-in-B
vtable.  (In general, we might be calling through something derived
from `A' but where `A::f' is the unique final overrider in that
objects static type.  So, we first convert to `A*' -- then use the
A-in-B vtable to get to `C::f'.)

    >>  I still can't see why it is a win to use vcall offsets in the
    >> case where `A' and `V' are not the same class.  You already
    >> have to do one static adjustment in the entry point -- why not
    >> just adjust all the way to `B' directly, without bothering to
    >> look up the vcall offset?

    Christophe> I did not understand this question :-( If you feel a

It seems to me, from:

   For each secondary vtable from a base 'D' which is a non-virtual
   base of a virtual base 'E', an additional entry point is generated
   in the secondary vtable for 'E' which first performs the constant
   adjustment from D* to E*, then the adjustment from E* to A* by
   adding the vcall offset for f stored in the secondary vtable for E.

(which I admittedly do not understand -- hence this email!) that there
are some situations where we have an entry point which *both* performs
a constant adjustment *and* adjustes via a vcall offset.  In other
words, it does two adjustments.  So the code for that entry point will
look like:

  entry:
    adjust by constant to a virtual base
    jump to vcall-adjusting-entry-point

(Then, elsewhere, we have:

  vcall-adjusting-entry-point:
    adjust by vcall offset
  f:
    /* here's where user code starts */)

Note that `entry' needs a jump at the end -- it can't just
fall-through (in general) because there may be lots of different such
double-adjusting things.  So, I'm asking why this is a win over just:

  entry:
    adjust by constant all the way to the destination
    jump to f

The point is that if we're going to adjust by a constant and then
jump, we might as well adjust all the way.
  
    Christophe> static thunk is better than a dynamic lookup, then you
    Christophe> can emit that thunk and point to it through the
    Christophe> vtable, as Jason pointed out. The ABI allows you to do
    Christophe> that.

That's unclear.  That may have been the intent, but there's no
discussion of what's normative and what's not in the ABI.

The ABI says:

    For each secondary vtable from a virtual base class 'C' which
    defines f, an additional entry point is generated which performs
    the adjustment from A* to C* by adding the vcall offset for f
    stored in the secondary vtable for A. 

It doesn't say that you can adjust in some other way, for instance.
It also says that the caller adjusts to the class containing the
unique final overrider.  It should just say that the caller locates
any class containing a virtual function table entry for the function,
converts `this' to that class, and calls the corresponding entry.
*Which* class is chosen isn't an ABI issue.  Then, there should be a
non-normative note that says (Note: it is probably most efficient to
convert to the class containing the unique final overrider.)

    >> Furthermore, the actual algorithm used to perform the
    >> adjustments does not seem necessarily to be part of the ABI.
    >> The layout of the vtables is certainly part of the ABI.  But,
    >> if one compiler wants to completely ignore the vcall offset
    >> entries in the vtables, and compute the entire adjustment
    >> statically, shouldn't that be permitted by the ABI, even though
    >> it might require one extra branch?  Surely that's just a
    >> quality-of-implementation issue?

    Christophe> Correct. Again, that seems clear to me from Jason's
    Christophe> writeup:

    Christophe> Note that the ABI only specifies the multiple entry
    Christophe> points; how those entry points are provided is
    Christophe> unspecified. An existing compiler which uses thunks
    Christophe> could be converted to use this ABI by only adding
    Christophe> support for the vcall offsets. A more efficient

That's the sentence that's unclear.  It should say something more
like:

    An existing compiler which uses thunks could be converted to use
    this ABI by adding vcall offsets in the vtable (as required by the
    ABI).  (The thunks generated need not be modified.)

I'm not trying to split hairs, or polish prose.  These are places
where I'm legitimately unsure as to the intent of the words written.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Tue Feb 22 23:21:41 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 22 Feb 2000 23:21:41 +0000
Subject: Pointers-to-members
References: <20000221095841K.mitchell@codesourcery.com>
		<38B2E525.E6D56AA@cup.hp.com> <20000222122258L.mitchell@codesourcery.com>
Message-ID: <38B31A05.CBFBE092@cup.hp.com>

Mark Mitchell wrote:
> 
> >>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
>     Christophe> Mark Mitchell wrote:
>     >>  The ABI document says that a NULL pointer-to-member function
>     >> has `ptr == 0'.  It does, not, however say whether or not a
>     >> NULL pointer-to-member function also has `adj == 0'.
>     >>
>     >> I believe that this should be specified as well so that code
>     >> generated to do comparison of pointers to members (of the same
>     >> type) looks like:
>     >>
>     p1-> ptr == p2->ptr && p1->adj == p2->adj
>     >>  and not:
>     >>
>     p1-> ptr == p2->ptr && (!p1->ptr || (p1->adj == p2->adj))
>     >>  So, I would say:
>     >>
>     >> If the pointer-to-member is NULL, both fields are zero.  (Note:
>     >> there are no non-NULL pointers-to-members for which the `ptr'
>     >> field is non-zero.)
> 
>     Christophe>              ^^^^^^^^
> 
>     Christophe> I assume you meant "There are no non-NULL
>     Christophe> pointers-to-members for which the 'ptr' field is
>     Christophe> zero", correct?
> 
> Yes.  I apologize for my own idiocy.
                               ^^^^^^
Another typo, I guess :-)

Ach, but, what is the value for the NULL pointer to data member? I guess -1
would do, unless there are cases I can't think of where the pointer to member
would legitimately have a negative value. Maybe 0x8000000000000000 is better...


Christophe



From mark at codesourcery.com  Tue Feb 22 22:04:48 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 14:04:48 -0800
Subject: Vtable index type
In-Reply-To: <u93dqksz08.fsf@yorick.cygnus.com>
References: <20000221141529D.mitchell@codesourcery.com>
	<u93dqksz08.fsf@yorick.cygnus.com>
Message-ID: <20000222140448N.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

    >> We should specify a type for vtable indices.  It seems to me
    >> that `ptrdiff_t' is the obvious candidate.

    >> This is important in that it limits the number of vtable
    >> entries we can use.  (For example, g++ has historically used
    >> `short' for a vtable index; that limited the size of vtables.)

    Jason> Where does a vtable index appear in the ABI?

Pointers-to-members.  Suppose we check the `ptr' field, and notice
it's odd.  Now, we have to divide by two and use the resulting thing
as a vtable index.  If, say, we only allowed n-bit indices, then we
could shift right one bit, and pull out just the low-order n-bits.  I
don't know *why* anyone would want to do that, but the ABI should say
whether or not its legal to do so.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Tue Feb 22 22:46:08 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 22 Feb 2000 22:46:08 +0000
Subject: Virtual function call stuff, again
References: <20000219155118D.mitchell@codesourcery.com>
		<38B2E0AD.BB761E10@cup.hp.com> <20000222122118G.mitchell@codesourcery.com>
Message-ID: <38B311B0.6BA019DD@cup.hp.com>

Mark Mitchell wrote:
> 
> >>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
> Thanks for helping me with this.
> 
>     Christophe> Mark, I did not find anything containing "Virtual
>     Christophe> Function Calling Convention" in the
>     Christophe> documentation. Could you specify an URL and quote the
>     Christophe> original text, it would help me locating it...
> 
> http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html#vtable
> 
> There doesn't appear to be a tag for the "VFCC" section, but it's down
> just a bit from the URL I gave.

Well, funny I did not find it the first time. A typo in the "find" box, I guess.
Sorry.


> 
> I understand the high-level points of that discussion: what I don't
> understand is exactly what goes where, when.  I'm not really trying to
> reopen any issue -- I'm trying to force the committe to write down
> what it decided.  At this point, the decision is not, quite frankly,
> written in a form that anyone not on the committee is likely to
> decipher.  (Well, at least I've tried hard, I'm not an idiot, I know
> about this application domain, and I still can't figure it out.)

I understand your remarks, and they are perfectly valid. I was trying to clarify
on your example. That's probably the wrong approach, though, since what you want
is a clear enough wording in the writeup. So let me go through the writeup and
see if I can improve things slightly, based on your comments.

Now, Jim, I just realized that for some reason, in the writeup, the vcall
offsets are restricted for "virtual bases" cases. I am unable to implement the
"single adjusting entry point" optimization if this is the case. I fixed it in
the attached writeup, but I may be wrong.

Jason's writeup to B-1 says that you have to implement the vcall offsets even if
you don't use them. I don't think we agreed to get rid of them (or is this
something else important I missed?)


> 
>     >> - If there is a virtual base along this path, let `V' be the
>     >> virtual base nearest to `C' along the path.  (In fact, `V' will
>     >> be `C' itself if `C' is a virtual base.)
> 
>     Christophe> You are considering a path between B and C, so V would
>     Christophe> be the closest between B and C. In which case I do not
>     Christophe> understand the adjustment below ("Adjustment from 'A'
>     Christophe> to 'V'"). Either you are considering that V is between
>     Christophe> A and C, in which case you need to adjust from A to V,
>     Christophe> or you are considering that V is between C and B, in
>     Christophe> which case if you see it at call site, you would have
>     Christophe> to adjust from B to V. Did I misunderstand?
> 
> You won't in general see `V' at the call site, if it's between C and
> B, because you might have `A*' when you're making the call.  (If you
> had a `B*', or a `C*', then `C::f' would be the unique final overrider
> -- by hypothesis -- so you would have converted your pointer to a
> `C*', and you be looking at the C-in-B vtable, rather than the A-in-B
> vtable, which is what my discussion was talking about.)

Violent agreement, apparently. So I must have misunderstood what you wrote. It
was unclear to me that you were discussing only the A-in-B vtable case.


> I'm not sure where you're supposed to adjust `A' to.  That's what I'm
> trying to find out.  It may not be the V that I suggested -- I'm not
> sure.  I'm hoping that my words could serve as the model for whatever
> the right answer is.  They're in the form of an algorithm that
> explains exactly what to put in the vtable, in the general case, and
> that's a good thing, since that's what an implementor needs to know.
> 
>     Christophe> So, starting with your example again. Sorry for the
>     Christophe> verbiage...
> 
>     Christophe> Case 1 is: V is between A and C.
> 
> THere's no discussion of these two different cases in the current
> writeup.  So, I'm already lost.  What you write below seems reasonably
> logical -- but I'm not sure it's the same thing as in the document.

The two cases were because I was trying to reconstruct the possible layouts from
what you said. I saw two cases, there was a third one (your pictogram below)
that I did not even see... These cases are not distinct in the writeup.


> In general, "between A and C" doesn't make sense; they may be
> unrelated. The picture I had in mind was:
> 
>               B
>              / \
>             A   C
> 
> In other words, B is the most derived class, C contains the final
> overrider, we're looking at the vtable for A.  That's the general case
> -- all other cases are special instances of this one.  But, I guess
> for case 1, we're assuming C is derived from A?

I thought this was your intent. Since again I have some trouble reconstructing
what you want (unless there is some additional base common to A and C where f is
first declared???)

The best would be for you to write the code for the case that annoys you.


>     Christophe> - If you call through an A*, you call through the A
>     Christophe> vtable, which points to a virtual-base-adjustment
>     Christophe> thunk. That thunk reads the C-to-A virtual base
>     Christophe> offset, and adds that to get a C*, and then jumps to
> 
> Where is this offset?  There's a vbase offset in C for converting to
> A, if A is a virtual base of C.  But, there's no virtual base offset
> in A, for converting to a C.  Where's V in all this?

I prefer not to add confusion until I see the code you have in mind.



Regards
Christophe



From mark at codesourcery.com  Tue Feb 22 21:54:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 13:54:58 -0800
Subject: Virtual function call stuff, again
In-Reply-To: <u966vhrkr1.fsf@yorick.cygnus.com>
References: <20000219155118D.mitchell@codesourcery.com>
	<u966vhrkr1.fsf@yorick.cygnus.com>
Message-ID: <20000222135458E.mitchell@codesourcery.com>


Jason --

Thanks to you, as well as Christophe, for helping to clear these
things up.

  >>>>> Mark Mitchell <mark at codesourcery.com> writes:

   >   o Suppose a class `A' defines a virtual function `A::f'.  The 
   >     primary vtable for `A' contains a pointer to an entry point
   >     that performs no adjustment.

   >   o Suppose that a class `A' declares a virtual function `A::f', 
   >     and suppose that `A' is a base class in a hierarchy dominated 
   >     by another class `B'.  Suppose that the unique final overrider for
   >     `A::f' in `B' is `C::f'.  We must determine what entry point
   >     is used for `f' in the `A-in-B' secondary vtable.  Here is the
   >     algorithm:

   >     - Find any path from `B' to `C' in the inheritance graph for `B'.

   >     - If there is no virtual base along the path, then create
   >       an entry point which adjusts the `this' pointer from `A' to `C'.
   >       This value can be computed statically when the `A-in-B' vtable
   >       is created.  Then transfer control to the non-adjusting entry
   >       point for `C::f'.

   >     - If there is a virtual base along this path, let `V' be the
   >       virtual base nearest to `C' along the path.  (In fact, `V'
   >       will be `C' itself if `C' is a virtual base.)

  Rather, nearest to 'A'.

How is that defined?  We're looking at paths between `B' and `C'.  But
maybe I got that wrong, too?

   >       (Note that the choice of `V' is independent of the choice of path.
   >       If there was more than one path, then there must have been a
   >       virtual base along all of the paths, and there is a unique one
   >       closest to `C'.)

  No; we're looking for the most-derived base subobject of which our A is a
  non-virtual base, which is unique.

Something is under-specified there.  (We're looking for something that
is a virtual base, right?)  How, exactly, do we find `V'?  That's the
part that still seems most unclear to me.

   >       Now, create an entry point which first performs the adjustment
   >       from `A' to `V'.  (This value can be computed statically, when
   >       the `A-in-B' vtable is created.)  Then, adjust the `this'
   >       pointer by the vcall offset stored in the secondary vtable for
   >       `V' (i.e., the `V-in-B' vtable).  (This adjustment will adjust
   >       the `this' pointer from `V' to `C'.)  Finally, transfer control
   >       to the non-adjusting entry point for `C::f'.

  This is correct.

Oh, good.  I got one right.

   >   It seems like the scheme specified in the ABI is advantageous in a
   > situation where `C' is the same as `A', and `A' is the same as `V'.
   > (In other words, if `A' is a virtual base and `A::f' is not overriden
   > in `B'.)  Then, by emitting the vcall-adjusting entry point right
   > before the main entry point for `C::f', calling `f' requires only one
   > branch (to the entry point specified in the vtable), rather than two
   > (to a thunk, and then from the thunk to the main function).  Right?

  Hmm?  If C is the same as A, no adjustment is necessary at all, and the
  vtable can point directly to the main function.

Sorry -- I can't remember what I was thinking.  I'm sure I had an idea
in there, but it's probably not important.

  If C is different from A, but A is the same as V, then we need one entry
  point directly before the main function, which adds the vcall offset and
  falls through.

  If C != A != V, and V overrides f, then we need one more entry point, so we
  get:

  A vtable entry point
     adjusts the A* to a V* by a constant offset and falls through to
  V vtable entry point
     adjusts the V* to a C* by the vcall offset in the vtable and falls
     through to
  C::f

How does that work if there is more than one `A'?  I understand that
more than one `V' could be handled by having different vcall offsets
for each `V'.

   >   I still can't see why it is a win to use vcall offsets in the case
   > where `A' and `V' are not the same class.  You already have to do one
   > static adjustment in the entry point -- why not just adjust all the
   > way to `B' directly, without bothering to look up the vcall offset?

  Because the offset from A* to B* (or to C*) may change in the presence of
  further derivation, requiring a third-party thunk (i.e. a thunk emitted
  apart from the main function).  That's what we're going to all this trouble
  to avoid.  We don't want to pay the price of that indirect jump, which is
  quite high on modern architectures due to branch prediction and cache
  locality problems.

I understand the architecture issues.  Just struggling with the ABI
solution to those issues. :-)

   >   Furthermore, the actual algorithm used to perform the adjustments
   > does not seem necessarily to be part of the ABI.  The layout of the
   > vtables is certainly part of the ABI.  But, if one compiler wants to
   > completely ignore the vcall offset entries in the vtables, and compute
   > the entire adjustment statically, shouldn't that be permitted by the
   > ABI, even though it might require one extra branch?  Surely that's
   > just a quality-of-implementation issue?

  I suppose so, though I hope you won't do that for g++; users have been
  complaining about the thunk penalty for some time, and the whole point of
  this scheme is to eliminate it.

Our first priority is to provide a conforming implementation.  I
expect that will mean that we don't take full advantage of the new
ABI.  But, the good news is that, because it's an ABI, we can take
more advantage of it later and still link with things produced by
earlier versions of the compiler.

Basically, one I'm trying to nail down right now is exactly how the
vcall offsets are calculated, where they go in the vtables, and so
forth.  Those are the ABI issues, now that we've agreed that what the
entry points actually do is up to the implementation.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Wed Feb 23 18:34:49 2000
From: jason at cygnus.com (Jason Merrill)
Date: 23 Feb 2000 10:34:49 -0800
Subject: Virtual function call stuff, again
In-Reply-To: Christophe de Dinechin's message of "Tue, 22 Feb 2000 22:46:08 +0000"
References: <20000219155118D.mitchell@codesourcery.com> <38B2E0AD.BB761E10@cup.hp.com> <20000222122118G.mitchell@codesourcery.com> <38B311B0.6BA019DD@cup.hp.com>
Message-ID: <u9u2izpy2e.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > Now, Jim, I just realized that for some reason, in the writeup, the
 > vcall offsets are restricted for "virtual bases" cases. I am unable to
 > implement the "single adjusting entry point" optimization if this is the
 > case. I fixed it in the attached writeup, but I may be wrong.

 > Jason's writeup to B-1 says that you have to implement the vcall offsets
 > even if you don't use them. I don't think we agreed to get rid of them
 > (or is this something else important I missed?)

Apparently so.  Your earlier response to Mark reflects your original
proposal, but what we eventually decided on was significantly different.
The vcall offsets are allocated in the secondary vtable for a virtual base,
one for each virtual function.  Converting from a nonvirtual base uses an
additional entry point.

>From my writeup in the issues list:

We have decided that for virtual functions not inherited from a virtual
base, regular thunks will work fine, since we can emit them immediately
before the function to avoid the indirect branch penalty; we will use
offsets in the vtable for functions that come from a virtual base, because
it is impossible to predict what the offset between the current class and
its virtual base will be in classes derived from the current class.

According to the issues list, we accepted my design at the 12/2 meeting.

Jason



From jason at cygnus.com  Wed Feb 23 18:43:03 2000
From: jason at cygnus.com (Jason Merrill)
Date: 23 Feb 2000 10:43:03 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: Mark Mitchell's message of "Tue, 22 Feb 2000 11:43:54 -0800"
References: <20000222114354R.mitchell@codesourcery.com>
Message-ID: <u9r9e3pxoo.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >   o GP/address pairs in vtables

 >     This one concerns me the most.  I don't even know if there's 
 >     any kind of standard assembly syntax for this.  Is there?
 >     (If not, there should be -- otherwise, you can't say -S to your
 >     compiler and get anything sensible out.)

Richard Henderson still doesn't believe that there's a suitable reloc for
this in the base ABI, and apparently I forgot to write up his explanation
for a wider audience.  Richard, care to repeat it in a less transient
medium?

Jason



From jason at cygnus.com  Wed Feb 23 18:51:45 2000
From: jason at cygnus.com (Jason Merrill)
Date: 23 Feb 2000 10:51:45 -0800
Subject: Pointers-to-members
In-Reply-To: Mark Mitchell's message of "Tue, 22 Feb 2000 16:03:13 -0800"
References: <38B2E525.E6D56AA@cup.hp.com> <20000222122258L.mitchell@codesourcery.com> <38B31A05.CBFBE092@cup.hp.com> <20000222160313J.mitchell@codesourcery.com>
Message-ID: <u9ln4bpxa6.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >   o A pointer-to-derived can be converted to a pointer-to-base.  This
 >     will normally increase the `this' pointer.  The standard is a
 >     little unclear here, but I think it wants to say that this is
 >     illegal precisely in the cases where the offset would go negative:

 >       [expr.static.cast]

 >       If class B contains the original member, or is a base or derived
 >       class of the class containing the original member, the resulting
 >       pointer to member points to the original member.  Otherwise, the
 >       result of the cast is undefined.

I don't see anything in the quoted text that would suggest that this is
illegal (or even undefined).  The standard then goes on to say explicitly
that it's OK to cast to a base that doesn't contain the member:

[Note: although class B need not contain the original member, the dynamic
type of the object on which the pointer to member is dereferenced must
contain the original member.]

Jason



From jason at cygnus.com  Tue Feb 22 21:35:58 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 13:35:58 -0800
Subject: Pointers-to-members
In-Reply-To: Mark Mitchell's message of "Mon, 21 Feb 2000 13:51:28 -0800"
References: <20000221095841K.mitchell@codesourcery.com> <20000221135128N.mitchell@codesourcery.com>
Message-ID: <u9zossrkch.fsf@yorick.cygnus.com>

My guess would be that casting is more common than comparison, though I
have no data for that.  Also, we can optimize comparison to NULL by
ignoring the adjustment entirely.

Jason



From mark at codesourcery.com  Tue Feb 22 22:45:13 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 14:45:13 -0800
Subject: Pointers-to-data members
Message-ID: <20000222144513U.mitchell@codesourcery.com>


We haven't specified a way to represent a NULL pointer to data member.
All we have is:

  A pointer to data member is an offset from the base address of the
  class object containing it, represented as a ptrdiff_t. It has the
  size and alignment attributes of a ptrdiff_t.

G++ presently adds one to the offset, allowing zero to serve as the
NULL pointer to member.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Tue Feb 22 21:33:59 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 13:33:59 -0800
Subject: Vtable index type
In-Reply-To: Mark Mitchell's message of "Mon, 21 Feb 2000 14:15:29 -0800"
References: <20000221141529D.mitchell@codesourcery.com>
Message-ID: <u93dqksz08.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 > We should specify a type for vtable indices.  It seems to me that
 > `ptrdiff_t' is the obvious candidate.

 > This is important in that it limits the number of vtable entries we
 > can use.  (For example, g++ has historically used `short' for a vtable
 > index; that limited the size of vtables.)

Where does a vtable index appear in the ABI?

Jason



From jason at cygnus.com  Tue Feb 22 20:56:15 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 12:56:15 -0800
Subject: Updated mangling specs
In-Reply-To: Christophe de Dinechin's message of "Tue, 22 Feb 2000 19:28:23 +0000"
References: <388F8D40.6FB44DD5@edg.com> <389F4E5F.E5112313@cup.hp.com> <200002150026.QAA22312@baalbek.engr.sgi.com> <u966vo7fep.fsf@casey.cygnus.com> <38B2E357.7897CB8B@cup.hp.com>
Message-ID: <u9900drm6o.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > // File f1.C

 > static inline int foo()
 > {
 > 	static int i = 0;
 > 	return ++i;
 > }

 > extern int bar1()
 > {
 > 	return foo();
 > }

 > [snip]

 > Consider what happens if you want to inline bar1 and bar2. Our name
 > mangling for statics is not good enough, because i would be mangled the
 > same. We need a file name too. To me, it's good enough to use the
 > 'escape' mechanism for that, but it has to be there.

Ah, I see.

The mangling specs define the mangling for things with external linkage;
for our purposes, a static local in an inline function with external
linkage also has external linkage.  In the situation you describe, foo::i
has internal linkage, but is promoted to external linkage via cross-module
inlining.

We could define what to do in this case, or we could just say that the
inliner should rename the symbol appropriately.

Jason



From mark at codesourcery.com  Wed Feb 23 19:28:51 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 23 Feb 2000 11:28:51 -0800
Subject: Pointers-to-members
In-Reply-To: <u9ln4bpxa6.fsf@yorick.cygnus.com>
References: <38B31A05.CBFBE092@cup.hp.com>
	<20000222160313J.mitchell@codesourcery.com>
	<u9ln4bpxa6.fsf@yorick.cygnus.com>
Message-ID: <20000223112851Y.mitchell@codesourcery.com>


  >>>>> Mark Mitchell <mark at codesourcery.com> writes:

   >   o A pointer-to-derived can be converted to a pointer-to-base.  This
   >     will normally increase the `this' pointer.  The standard is a
   >     little unclear here, but I think it wants to say that this is
   >     illegal precisely in the cases where the offset would go negative:

   >       [expr.static.cast]

   >       If class B contains the original member, or is a base or derived
   >       class of the class containing the original member, the resulting
   >       pointer to member points to the original member.  Otherwise, the
   >       result of the cast is undefined.

  I don't see anything in the quoted text that would suggest that this is
  illegal (or even undefined).  The standard then goes on to say explicitly
  that it's OK to cast to a base that doesn't contain the member:

  [Note: although class B need not contain the original member, the dynamic
  type of the object on which the pointer to member is dereferenced must
  contain the original member.]

That's what I meant by unclear.  It seems to me that the paragraph I
quoted was perhaps written with only single inheritance in mind.  I'm
not sure what implementation the framers had in mind for multiple
inheritance.

What does it mean to be a "class containing the original member"?  I
wasn't sure whether given:

  struct S { char c; };
  struct U { char d; };
  struct T : public U, public S { };

tat `T' contains the "original member" `d', or whether only `U' does,
for the purposes of this discussion.

If you interpretation is correct, then, AFAIK, most current
implementations behaves wrongly on this example (reposted from my
earlier message):

  struct S { char c; };
  struct U { char d; };
  struct T : public U, public S { };

  typedef char S::*sp;
  typedef char T::*tp;

  int main ()
  {
    sp s;
    tp t;

    t = &T::d;
    s = static_cast<sp> (t);

    if (s == 0)
      return 1;
  }

Both g++ and EDG-based compilers will say that `s' is NULL -- which is
bogus, if the cast is well-defined.  I assume Cfront would have gotten
this wrong as well, since the EDG ABI is pretty much the Cfront ABI.
So, there's certainly no real history of this working, for whatever
that's worth.

I guess using 0x80000000 for NULL is probably better, though -- this
example will work, and you don't have to subtract one when
dereferencing the pointer-to-member.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Wed Feb 23 19:42:18 2000
From: jason at cygnus.com (Jason Merrill)
Date: 23 Feb 2000 11:42:18 -0800
Subject: Pointers-to-members
In-Reply-To: Mark Mitchell's message of "Wed, 23 Feb 2000 11:28:51 -0800"
References: <38B31A05.CBFBE092@cup.hp.com> <20000222160313J.mitchell@codesourcery.com> <u9ln4bpxa6.fsf@yorick.cygnus.com> <20000223112851Y.mitchell@codesourcery.com>
Message-ID: <u9900bpuxx.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 > What does it mean to be a "class containing the original member"?  I
 > wasn't sure whether given:

 >   struct S { char c; };
 >   struct U { char d; };
 >   struct T : public U, public S { };

 > tat `T' contains the "original member" `d', or whether only `U' does,
 > for the purposes of this discussion.

Ah.  I was thinking of

struct S { char c; };
struct U { char d; };
struct T: public U, public S { char e; };

t = &T::e;
s = static_cast<sp>(t);

But now that I think about it, 'e' would still be at a positive offset from
an S*, so my point is invalid.  What you're saying makes sense to me now.

Jason



From mark at codesourcery.com  Tue Feb 22 22:01:50 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 22 Feb 2000 14:01:50 -0800
Subject: Pointers-to-members
In-Reply-To: <u9zossrkch.fsf@yorick.cygnus.com>
References: <20000221095841K.mitchell@codesourcery.com>
	<20000221135128N.mitchell@codesourcery.com>
	<u9zossrkch.fsf@yorick.cygnus.com>
Message-ID: <20000222140150W.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    Jason> My guess would be that casting is more common than
    Jason> comparison, though I have no data for that. 

I agree.  That's in keeping with my second posting on this topic,
where I realized that making both fields be zero would penalize
casting:

  It's occurred to me that this imposes some overhead on casting
  pointers-to-members around: now when you convert from a base pointer
  to member to a derived version (or vice versa), you can't just adjust
  the `adj' member willy-nilly; instead, you have to check first whether
  or not the pointer is NULL.

So, it would be helpful if we were to add:

  (Note: the `adj' field is not necessarily zero even when the
   pointer-to-member is NULL.  Therefore, casting a
   pointer-to-derived-member to a pointer-to-base-member (or vice
   versa) requires only an adjustment to the `adj' field.  However,
   comparsion of two pointers-to-members requires more than
   a bitwise comparision.  Code equivalent to:
   
     p1.ptr == p2.ptr && (!p1.ptr || (p1.adj == p2.adj))

   is required since in the case that p1.ptr and p2.ptr are both 
   zero, there `adj' fields are irrelevant.)

to the ABI document.

   Jason> Also, we can
   Jason> optimize comparison to NULL by ignoring the adjustment
   Jason> entirely.

True -- in either scheme.  But an additional argument in favor of the
above resolution.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From rth at cygnus.com  Wed Feb 23 20:26:07 2000
From: rth at cygnus.com (Richard Henderson)
Date: Wed, 23 Feb 2000 12:26:07 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <u9r9e3pxoo.fsf@yorick.cygnus.com>; from Jason Merrill on Wed, Feb 23, 2000 at 10:43:03AM -0800
References: <20000222114354R.mitchell@codesourcery.com> <u9r9e3pxoo.fsf@yorick.cygnus.com>
Message-ID: <20000223122607.A4098@cygnus.com>

On Wed, Feb 23, 2000 at 10:43:03AM -0800, Jason Merrill wrote:
>  >   o GP/address pairs in vtables
> 
>  >     This one concerns me the most.  I don't even know if there's 
>  >     any kind of standard assembly syntax for this.  Is there?
> 
> Richard Henderson still doesn't believe that there's a suitable reloc for
> this in the base ABI, and apparently I forgot to write up his explanation
> for a wider audience.  Richard, care to repeat it in a less transient
> medium?

There are no relocations in the base ABI to fill in an existing function
descriptor.  Nor are there relocations to acquire a function's gp with
which you could fill in a descriptor yourself.

There are three relocation types that cause the linker or loader to create
a descriptor in linker-controled memory and give the program a pointer to
that memory.

Reference SC-2916 v2.0 Unix System V Application Binary Interface,
Intel IA-64 Processor Supplement, section 4.3.1:

  R_IA_64_FPTR64LSB

	The descriptor is, in the case of dynamic symbols, created by the
	run-time loader.  This is because the descriptor must be globally
	unique to satisfy function pointer equality.

	GNU ld will statically create the descriptors for non-dynamic
	symbols when linking without -shared; dso's will contain no static
	descriptors because it is more work memory-reference-wise to
	adjust the descriptors for the dso load address than it is to
	just create them from scratch.

	The relocation itself is direct against the descriptor.

  R_IA_64_LTOFF_FPTR64LSB

	Same as above, except that a slot in the .got is created to hold
	the pointer to the descriptor.  The relocation itself is slot-gp.

  R_IA_64_PLTOFF64LSB

	Creates a non-unique descriptor to a PLT entry local to the dso.
	The memory is always statically allocated.  Unfortunately, the
	relocation is gp-relative and so is of no use in vtables.
	Moreover, R_IA_64_PLTOFF22 is the variant normally used, so the
	memory allocated for this eats into the small-data area.

I would suspect that this late in the game amending the ABI is not
an option.  So R_IA_64_FPTR64LSB, as heavyweight as it is, is your
only choice for a normal function descriptor.

There is one convoluted way I can see to define a vtable entry that
does not require runtime relocation of any form, at least if the 
symbol were private to the dso (via STV_HIDDEN or so).  If the symbol
is dynamic, there is no escaping some form of runtime relocation.

	data8	@pcrel(func#)
	data8	@gprel(func#)

Suppose r16 contains the address of the first word.

	ld8 r18 = [r16]
	adds r17 = 8, r16
	;;
	add r18 = r18, r16
	ld8 r17 = [r17]
	;;
	sub gp = r18, r17
	mov b6 = r18
	br.call.sptk.many b0 = b6

which is two more instructions, no more insn groups, and one fewer
memory reference than the standard indirect function descriptor sequence.

Note that GNU ld would currently abort on this because it doesn't
believe gp-relative relocations against dynamic symbols are legal.
Nor does glibc's ld.so know how to fix up such relocations.  However,
it is possible to implement if needed.


r~



From jason at cygnus.com  Tue Feb 22 21:27:14 2000
From: jason at cygnus.com (Jason Merrill)
Date: 22 Feb 2000 13:27:14 -0800
Subject: Virtual function call stuff, again
In-Reply-To: Mark Mitchell's message of "Sat, 19 Feb 2000 15:51:18 -0800"
References: <20000219155118D.mitchell@codesourcery.com>
Message-ID: <u966vhrkr1.fsf@yorick.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

 >   o Suppose a class `A' defines a virtual function `A::f'.  The 
 >     primary vtable for `A' contains a pointer to an entry point
 >     that performs no adjustment.

 >   o Suppose that a class `A' declares a virtual function `A::f', 
 >     and suppose that `A' is a base class in a hierarchy dominated 
 >     by another class `B'.  Suppose that the unique final overrider for
 >     `A::f' in `B' is `C::f'.  We must determine what entry point
 >     is used for `f' in the `A-in-B' secondary vtable.  Here is the
 >     algorithm:

 >     - Find any path from `B' to `C' in the inheritance graph for `B'.

 >     - If there is no virtual base along the path, then create
 >       an entry point which adjusts the `this' pointer from `A' to `C'.
 >       This value can be computed statically when the `A-in-B' vtable
 >       is created.  Then transfer control to the non-adjusting entry
 >       point for `C::f'.

 >     - If there is a virtual base along this path, let `V' be the
 >       virtual base nearest to `C' along the path.  (In fact, `V'
 >       will be `C' itself if `C' is a virtual base.)

Rather, nearest to 'A'.

 >       (Note that the choice of `V' is independent of the choice of path.
 >       If there was more than one path, then there must have been a
 >       virtual base along all of the paths, and there is a unique one
 >       closest to `C'.)

No; we're looking for the most-derived base subobject of which our A is a
non-virtual base, which is unique.

 >       Now, create an entry point which first performs the adjustment
 >       from `A' to `V'.  (This value can be computed statically, when
 >       the `A-in-B' vtable is created.)  Then, adjust the `this'
 >       pointer by the vcall offset stored in the secondary vtable for
 >       `V' (i.e., the `V-in-B' vtable).  (This adjustment will adjust
 >       the `this' pointer from `V' to `C'.)  Finally, transfer control
 >       to the non-adjusting entry point for `C::f'.

This is correct.

 >   It seems like the scheme specified in the ABI is advantageous in a
 > situation where `C' is the same as `A', and `A' is the same as `V'.
 > (In other words, if `A' is a virtual base and `A::f' is not overriden
 > in `B'.)  Then, by emitting the vcall-adjusting entry point right
 > before the main entry point for `C::f', calling `f' requires only one
 > branch (to the entry point specified in the vtable), rather than two
 > (to a thunk, and then from the thunk to the main function).  Right?

Hmm?  If C is the same as A, no adjustment is necessary at all, and the
vtable can point directly to the main function.

If C is different from A, but A is the same as V, then we need one entry
point directly before the main function, which adds the vcall offset and
falls through.

If C != A != V, and V overrides f, then we need one more entry point, so we
get:

A vtable entry point
   adjusts the A* to a V* by a constant offset and falls through to
V vtable entry point
   adjusts the V* to a C* by the vcall offset in the vtable and falls
   through to
C::f

 >   I still can't see why it is a win to use vcall offsets in the case
 > where `A' and `V' are not the same class.  You already have to do one
 > static adjustment in the entry point -- why not just adjust all the
 > way to `B' directly, without bothering to look up the vcall offset?

Because the offset from A* to B* (or to C*) may change in the presence of
further derivation, requiring a third-party thunk (i.e. a thunk emitted
apart from the main function).  That's what we're going to all this trouble
to avoid.  We don't want to pay the price of that indirect jump, which is
quite high on modern architectures due to branch prediction and cache
locality problems.

 >   Furthermore, the actual algorithm used to perform the adjustments
 > does not seem necessarily to be part of the ABI.  The layout of the
 > vtables is certainly part of the ABI.  But, if one compiler wants to
 > completely ignore the vcall offset entries in the vtables, and compute
 > the entire adjustment statically, shouldn't that be permitted by the
 > ABI, even though it might require one extra branch?  Surely that's
 > just a quality-of-implementation issue?

I suppose so, though I hope you won't do that for g++; users have been
complaining about the thunk penalty for some time, and the whole point of
this scheme is to eliminate it.

Jason



From ddd at cup.hp.com  Wed Feb 23 22:19:11 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 23 Feb 2000 22:19:11 +0000
Subject: C implementations of the C++ ABI
References: <20000222114354R.mitchell@codesourcery.com>
Message-ID: <38B45CDF.9E8BD6F2@cup.hp.com>

Mark Mitchell wrote:
> 
> 
> All in all, I'm not really suggesting we change anything.  I'm just
> trying to make sure we're aware that there's an issue, in case we're
> not already aware.
> 
We discussed it, and we have at least one company (EDG) in the team who may have
the need to generate C code in some cases. I think the agreement is that we do
care, but that a C-generating tool will either not be ABI compliant in some
cases, or require specific extensions (such as inline assembly) to work.

The case of EH tables is particularly interesting: any C-compatible EH model I
know of has a definite runtime cost (something like setjmp/longjmp, for
instance). We don't want to pay that price.


Best regards,
Christophe



From dehnert at baalbek.engr.sgi.com  Thu Feb 24 07:09:54 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 23 Feb 2000 23:09:54 -0800 (PST)
Subject: Meeting agenda
Message-ID: <200002240709.XAA08102@baalbek.engr.sgi.com>

Time to clarify...

It's amazing how much goes by when one's email is out of commission for
a couple of days.  Obviously, a couple of issues (at least) have become
a significant concern -- vcall offsets and virtual function calls, and
pointers to members.  At best, there's significant confusion.  I'd like
to use this meeting to slog through these as first priority.  Since the
vcall discussions are best done with pictures, it would be helpful if
Christophe and Jason were physically present (though if you can't, you
can't...).  Mark, your participation would probably be helpful too,
even just on the phone.

Following is an updated agenda.  The status pages are updated (as of
last Friday) and on the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Data layout and virtual function calls.

  B) Mangling.

  C) Exception handling.

So, take a look at the material associated with these issues:

  1) Quickie -- are the changes to the Data Layout document in red (e.g.
     ABI namespace writeup) OK?  I will make further clarifications in
     the excess-size bitfield writeup for Mark, and the ctor vtable and
     mangling discussions are still open.

  2) B-1:  I would like to work through the virtual function call
     protocol very carefully, so I understand it well enough to write
     it up (which will probably mean everyone else understands it well,
     too :-).  I see Mark found the description unclear, and Christophe
     doesn't see what he thought was there, so let's work through the
     options once more.  Let's try to understand both the mechanisms
     and the associated costs first, then deal with decisions.

  3) A-14:  Pointers-to-members -- clarify intent, and make necessary
     choices.

  4) C-4:  Construction vtables -- discuss Coleen's proposal.

  5) F-*:  Mangling -- How do we proceed with issues?

Issues that are active and awaiting proposals:

  a)  A-24:  Incomplete type RTTI (alternate proposal from Christophe).

  b) D-12:  Unwind table location.

Jim

-		Jim Dehnert  x3-4272



From ddd at cup.hp.com  Thu Feb 24 19:58:31 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 24 Feb 2000 19:58:31 +0000
Subject: Ooooops (Virtual functions)
References: <20000219155118D.mitchell@codesourcery.com> <38B2E0AD.BB761E10@cup.hp.com> <20000222122118G.mitchell@codesourcery.com> <38B311B0.6BA019DD@cup.hp.com> <u9u2izpy2e.fsf@yorick.cygnus.com>
Message-ID: <38B58D67.E1B189B4@cup.hp.com>

Folks,


After discussing with Jason, I definitely made a mistake in reading his writeup.
We killed my virtual call proposal without me noticing...

So, let me re-state the rationale and proposed implementation, and I'll try to
illustrate all cases with pseudo-code. Mark will be our sanity-checker by
implementing on his spare time, OK, Mark? ;-)


METHOD 1: THUNKS

A virtual function call going through a thunk will have the following code
trail:

		br	b0=(b6)
	thunk:	addi	r32=r32,this_delta
		br	target
	target:	// function body

We can assume reasonably that:
1/ The (b6) target is mispredicted always
2/ The thunk is not in the I-cache, because it depends on the (function, class)
pair, so it is rather infrequently called
3/ The thunk is more than 64-bytes or 128-bytes away from the target (with
16-bytes per bundle, this becomes true as soon as you have more than 4 thunks)
4/ The target code may or not be in the I-cache

For obvious reasons, I will subtract the cost of the first branch misprediction
in all the costs below, since this cost is shared between all implementations.

I'm trying to be vague enough and not disclose proprietary information. Let's
make the hypothetical hypothesis that, maybe, the cost of this sequence would be
between 5 and 20 cycles, with a 'typical' value at, say, 9 cycles. That's not
cheap.


METHOD 2: Add sequences

My proposal was to try to keep the thunks close to the 'target' label, and avoid
branches, so that we can consider for instance:

		br	b0=(b6)
	thunk3:	addi	r32=r32,this_delta1;;
	thunk2:	addi	r32=r32,this_delta2-this_delta1;;
	thunk1:	addi	r32=r32,this_delta3-this_delta2;;
	target:	// function body

This case would have an hypothetical cost which between 0+N/M and 9+N/M, where N
is the index of the thunk and M is the number of bundles executed per cycle. For
small N values and/or large M values, this becomes significantly better. One
important factor is that if there is an I-cache miss, at least, the prefetch
will start loading the body of the function. So the typical value this time
would be 9+N/M, where I assume that the function and the thunks are indeed in
the I-cache.


METHOD 3: Adjusting entry point

If the number of thunks created this way becomes too large for N/M to be really
smaller than 5, I proposed the following alternative:

		br	b0=(b6)
	common_thunk:
		add	r9=vptr,offset;;
		ld8	r9=[r9];;
		add	r32=r9,r32
	target:	// Function body		

This sequence would read the 'this_delta' value from the secondary vtable
corresponding to the type of the pointer being used. In the secondary vtable
B-in-C of any non-primary base B of class C, there would be a single such
'this_delta' converting from a B* to a C*. The constraint is that all such
values be stored at a fixed offset relative to their secondary vtable pointer.
See at end.

>From a cache perspective, it is important to note that the value loaded from the
secondary vtable is shared among virtual functions. That is, whether you call
ptr->f() or ptr->g(), you read the same value, as long as f() and g() are
overriden in the same class. Because of that, I believe that the likelihood of
D-cache miss for the load is significantly smaller than the likelihood of an
I-cache miss in the original sequence. I'll add below the cases with and without
D-cache miss.

Without D-cache miss, the cost of that sequence is anywhere between 3 and 12
cycles, with a sweet spot around 3 in the absence of I-cache miss. With D-cache
miss, it can be anywhere between 8 and 21 cycles, again, the sweet spot being
closer to 8 than from 21.


To summarize:
			Best	Typical	Worst
	Thunks		5	9	20
	AddAddAdd	0+N/M	0+N/M	9+N/M
	Adjust		3	3	18
	Adjust/D-miss	8	8	21

You notice that in the absence of D-cache miss, which I think we can justify,
this sequence is significantly better. I may get slightly worse than the thunk,
though, if you are really unlucky (that is, you manage to get a worst-case
D-cache miss and a worst-case I-cache miss in a row)

All this is, of course, purely hypothetical.


So the really good question is: can we allocate the 'this_delta' entries in the
secondary vtable so that they are at a constant offset in each secondary vtable?
My initial proposal was to allocate them at negative offsets from the secondary
vptr (where we also allocate the virtual base offsets), and to just take min(all
existing offsets) - 4. This has the obvious drawback that it introduces padding,
but it should work. Alternatively, we can just extend the vcall offsets to the
non-virtual inheritance case.


Regards
Christophe


Jason Merrill wrote:
> 
> >>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
>  > Now, Jim, I just realized that for some reason, in the writeup, the
>  > vcall offsets are restricted for "virtual bases" cases. I am unable to
>  > implement the "single adjusting entry point" optimization if this is the
>  > case. I fixed it in the attached writeup, but I may be wrong.
> 
>  > Jason's writeup to B-1 says that you have to implement the vcall offsets
>  > even if you don't use them. I don't think we agreed to get rid of them
>  > (or is this something else important I missed?)
> 
> Apparently so.  Your earlier response to Mark reflects your original
> proposal, but what we eventually decided on was significantly different.
> The vcall offsets are allocated in the secondary vtable for a virtual base,
> one for each virtual function.  Converting from a nonvirtual base uses an
> additional entry point.
> 
> >From my writeup in the issues list:
> 
> We have decided that for virtual functions not inherited from a virtual
> base, regular thunks will work fine, since we can emit them immediately
> before the function to avoid the indirect branch penalty; we will use
> offsets in the vtable for functions that come from a virtual base, because
> it is impossible to predict what the offset between the current class and
> its virtual base will be in classes derived from the current class.
> 
> According to the issues list, we accepted my design at the 12/2 meeting.
> 
> Jason



From ddd at cup.hp.com  Thu Feb 24 20:01:06 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 24 Feb 2000 20:01:06 +0000
Subject: Virtual function calls
Message-ID: <38B58E02.EC5806B8@cup.hp.com>

Here were my notes...


struct vtable_entry
{
#ifdef SHARED_LIBS
	void (*fptr) ();
	uint64 GP_value;
#else
	void (*fptr) ();
#endif
}


CASE 1:

struct A {
	virtual f();
}

A* ptr;
ptr->f();

struct vtbl<A> {
	ptrdiff_t	offset_to_top = 0;
	typeinfo *	typeinfo = typeinfo<A>;
VPTR->	vtable_entry	f = A::f;
};



CASE 2:

struct B : A { }

struct vtbl<B> {
	ptrdiff_t	offset_to_top = 0;
	typeinfo *	typeinfo = typeinfo<B>;
VPTR->	vtable_entry	f = A::f;
};


CASE 3:

struct C : A {
	virtual f();
}

struct vtbl<C> {
	ptrdiff_t	offset_to_top = 0;
	typeinfo *	typeinfo = typeinfo<C>;
VPTR->	vtable_entry	f = C::f;


CASE 4:

struct X { virtual unique(); };

struct D : X, A { }

struct vtbl<D> {
	ptrdiff_t	offset_to_top<X,D> = 0
	typeinfo *	typeinfo = typeinfo<D>
VPTR<D,X>->vtable_entry	unique = X::unique;

	ptrdiff_t	offset_to_top<A> = -sizeof(vptr);
	typeinfo *	typeinfo = typeinfo<D>
VPTR<A>-> vtable_entry	f = A::f;
}

Calling A::f():
	with an A*: No adjustment
	with a D*: Adjustment to an A* at call-site.
	A* -> D* adjustmnent is known at compile time.


CASE 5:

struct E : X, A { virtual f(); }

E::f receives an E* as the this pointer, not an A*.

struct vtbl<E> {
	ptrdiff_t	offset_to_top<X,D> = 0
	typeinfo *	typeinfo = typeinfo<E>
VPTR<E,X>->vtable_entry	unique = X::unique;
	vtable_entry	f = E::f

	ptrdiff_t	offset_to_top<A> = -sizeof(vptr);
	typeinfo *	typeinfo = typeinfo<E>
VPTR<A>-> vtable_entry	f = E::f_thunk<A, E>;	// Thunk converting from A to E
};


Calling E::f():
	With an A*: Call site: no adjustment.
		Adjustment done by E::f_thunk<A, E>
	With an E*: Call site: no adjustment, calls through the vptr<E>->f.


CASE 6:

struct G : virtual A { }

struct vtbl<G> {
	ptrdiff_t	G_to_A_offset = 0;

	ptrdiff_t	offset_to_top<X,D> = 0
	typeinfo *	typeinfo = typeinfo<G>
VPTR<G>->

	ptrdiff_t	offset_to_top<A> = -sizeof(vptr);
	typeinfo *	typeinfo = typeinfo<G>
VPTR<A>-> vtable_entry	f = A::f
};

Calling G::f:
	Through an A*: as case 1
	Throught a G*: Magically convert G* to A* (by adding the G_to_A_offset),
		then use the A* to call A::f.

The "magical" conversion to be specified later, using a vbase offset.


CASE 7:

struct H : virtual A { virtual f(); }

struct vtbl<H> {

};


CASE 8:

struct I : H { }



CASE 9:

struct J : H { virtual f(); }



From jason at cygnus.com  Thu Feb 24 20:58:58 2000
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 24 Feb 2000 12:58:58 -0800
Subject: vtable notes
Message-ID: <200002242058.MAA13113@yorick.cygnus.com>

The examples from today's discussion:

struct A {virtual void f ();}
  A->A::f

struct B: public A { };
  B::A->A::f

struct C: public A { virtual void f (); }
  C::A->C::f

struct X: { virtual void unique(); }
struct D: public X, public A { };
  D::X->X::unique
  D::A->A::f

struct E: public X, public A { virtual void f (); };
  E::X->X::unique
        E::f
  E::A->thunk E::f A*->E*

struct G: public virtual A { };
  G::A->A::f

struct H: public X, public virtual A { virtual void f (); }
  H::X->X::unique
  H::A->thunk H::f H::A*->H*

struct I: public H { int i; };
  I::X->X::unique
  I::A->thunk H::f I::A*->I::H*

And some thoughts, while this is fresh in my mind:

My design shares the thunks between H and I by putting the offset between A
and <the overriding class> into the secondary vtable for A, one offset per
virtual function.  Under this scheme, we get (at minimum) one thunk per:

  1) location of the vcall offset (for virtual bases)
  2) constant offset (for non-virtual bases)
  3) constant offset * location of vcall offset (for non-virtual bases of
     virtual bases)

Christophe's design proposes three changes:

  A) Add vcall offsets to secondary vtables for non-virtual bases,
     and use them in the calls.

The result of this would be that we would need one thunk per
  
  1) location of the vcall offset

He also proposes

  B) Share equal vcall offsets between functions in non-virtual inheritance

The result of this would be fewer vcall offsets to allocate.

  C) Ensure that the location of the vcall offset is the same for
     all secondary vtables

The result of this would be that we would need one thunk, period.

As I see it, A is a straightforward tradeoff; vtables get larger in the
case of non-virtual multiple inheritance, but we may be able to reduce the
number of thunks we use.  On the other hand, we won't be able to fall
through from a thunk that uses a vcall offset, so we might well end up
using the same thunks as in the existing design.

B is a simple improvement to A, reducing the size of the vtables.

C is the interesting part of Christophe's proposal.  It does sound like the
result would be faster (by about 2 units of speed) than the existing design
for calls through obscure bases in large inheritance structures.  However,
I'm not convinced that there exists a reasonable algorithm for allocating
vcall offsets in order to achieve this result, in the case of diamond
inheritance; even if there is, it would be much more complex than the one
for the current design.  This is why I don't think the change could be made
by tweaking a few words.

Before we discuss performance any further, I'd like Christophe to propose
an allocation strategy to accomplish C.  Or we could just agree to go
forward with the existing design.

Jason



From ddd at cup.hp.com  Thu Feb 24 21:31:44 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 24 Feb 2000 21:31:44 +0000
Subject: Do we need to reopen B1?
Message-ID: <38B5A340.BF809D85@cup.hp.com>

I believe in its current state, with my initial proposal for alternate entry
points scrapped, I think the answer is yes (at least from my point of view).

First, my proposal and Jason's are not opposed. Jason solved a case in virtual
inheritance that I had overlooked, by introducing vcall offsets. So vcall
offsets allow a same "thunk" to be shared between multiple subobjects in a class
that has a virtual base.

My proposal applies to the non-virtual multiple inheritance case, and allows a
same thunk to be shared between multiple subobjects in a class that has no
virtual base, as long as by the derived classes of that class, as long as they
do not override the virtual function and do not themselves have virtual
inheritance.


In the absence of the "adjusting entry points" I proposed, you have to use
thunks. Within a same class, of course, you can use the 'AddAddAdd' scheme,
since you know the different offsets at compile time for the various subobjects
that compose the class. However, a derived class cannot share this, because its
vtable may very well be emitted in a different .o. For instance, consider:

	struct A { virtual a(); int aa; };
	struct B { virtual b(); int bb; };
	struct C { virtual c(); int cc; };

	struct D : A, B { virtual b(); int dd; }
	struct E : D { /* Does not override b() */ }

The primary vtable for D points to D::b, no adjustment required. The secondary
vtable for B in D points to D::b with, say, an 'Add' adjustment, which would be
of -16 (from the B* to the D*).

When you emit the vtable for E, the good news is that the adjustment is the same
(-16 from B* to D*). The bad news is that you don't know how to locate the thunk
that adds -16 (unless we all agree on the algorithm for emitting this kind of
"AddAddAdd" thunk, which we did not.) Since there is no relocation that says
something like "Copy contents of the D vtable at offset X", there is no way to
build the vtable for E from a different translation unit so that is reuses the
'Add' thunk. So you end up emitting a real thunk. I believe I demonstrated in
another e-mail that these "real" thunks are bad for performance. They also cost
a lot of space (16 bytes per thunk at least). 


I also believe the problem gets only worse in the presence of shared libraries.
We said that we would preload the GP from the call site. So now the E vtable
entry for d() naively contains D's GP, but an E thunk. That E thunk needs to
branch to another load module. We are out of luck: the data to branch to that
other module (the function descriptor) is GP-relative, I believe, but relative
to D's GP. So the E vtable entry really needs to contain the GP for E, which
means that there is just no benefit in having the GP in the vtable. The E thunk
itself also needs to pay the full penalty of loading a GP and doing an indirect
branch. And I could not write it in less than 64 bytes.



So my proposal is simply that, for the non-virtual multiple inheritance case, we
have a this-pointer adjustment offset in each secondary vtable, that adjusts
form the secondary vtable class to the function's target class.

The algorithm I proposed to allocate these offsets was the following:

- While defining class C, we allocate a single offset "convert_to_C", that
converts from the class of the seconday vtable in which it is stored to the C
class.

- The convert_to_C in the C primary vtable is theoretically present, but its
value is zero, so it may be omitted.

- For all other classes, the offset of 'convert_to_C' relative to the secondary
vptr is constant. A naive algorithm to ensure that is that this offset is the
first negative offset not used by a 'convert_to_X' in any of the bases. I
acknoledge this generally may padding in the vtables, but I did not see a better
way to do it, short of using a double indirection.

This 'convert_to_C' is used by an adjusting entry point emitted immediatly prior
to the main, non-adjusting entry point, which computes this += convert_to_C. If
I use this secondary entry point at all, I know that the final overrider is
C::f, and that the call was in the form bptr->f(), where bptr is a non-primary
non-virtual base of C.

The same 'convert_to_C' value is shared by different virtual functions overriden
in C, no matter from which base they are overriden (the interesting case, of
course, being when they are overriden from multiple bases). The reason is that
if C::f override B::f, the delta is the same than if C::g overrides B::g. It may
be different than the delta between C::g and B2::g, but then I am using B2's
secondary vtable, which contains the B2->C conversion.


This scheme has the following benefits:

- For each virtual function, you emit a secondary entry point with a known size.
The best possible size is 48 bytes, unless some magic predication thingie I did
not think of can reduce that. No matter how many secondary vbases or how many
derived classes reuse that function, the size is 48.

- For each secondary base, you add 8 (or more if padding) bytes to the table.

- This scheme works accross shared libraries, since the thunk used is always
"tied" to the function.


I hope I clarified...

Best regards
Christophe



From jason at cygnus.com  Thu Feb 24 22:41:10 2000
From: jason at cygnus.com (Jason Merrill)
Date: 24 Feb 2000 14:41:10 -0800
Subject: Do we need to reopen B1?
In-Reply-To: Christophe de Dinechin's message of "Thu, 24 Feb 2000 21:31:44 +0000"
References: <38B5A340.BF809D85@cup.hp.com>
Message-ID: <u9d7pmmdfd.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > In the absence of the "adjusting entry points" I proposed, you have to
 > use thunks. Within a same class, of course, you can use the 'AddAddAdd'
 > scheme, since you know the different offsets at compile time for the
 > various subobjects that compose the class. However, a derived class
 > cannot share this, because its vtable may very well be emitted in a
 > different .o.

I strongly disagree.  This is the primary goal of my design.

 > For instance, consider:

 > 	struct A { virtual a(); int aa; };
 > 	struct B { virtual b(); int bb; };
 > 	struct C { virtual c(); int cc; };

 > 	struct D : A, B { virtual b(); int dd; }
 > 	struct E : D { /* Does not override b() */ }

 > The primary vtable for D points to D::b, no adjustment required. The
 > secondary vtable for B in D points to D::b with, say, an 'Add'
 > adjustment, which would be of -16 (from the B* to the D*).

 > When you emit the vtable for E, the good news is that the adjustment is
 > the same (-16 from B* to D*). The bad news is that you don't know how to
 > locate the thunk that adds -16 (unless we all agree on the algorithm for
 > emitting this kind of "AddAddAdd" thunk, which we did not.)

Oh, come on.  Yes, we still need to define what entry point symbols will
be emitted with D::b, and how they are mangled, so that derived classes can
refer to them.  But we certainly can do that.

[snip two paragraphs arguing against this straw man]

 > So my proposal is simply that, for the non-virtual multiple inheritance
 > case, we have a this-pointer adjustment offset in each secondary vtable,
 > that adjusts form the secondary vtable class to the function's target
 > class.

 > The algorithm I proposed to allocate these offsets was the following:

 > - While defining class C, we allocate a single offset "convert_to_C",
 > that converts from the class of the secondary vtable in which it is
 > stored to the C class.

We allocate this in each secondary vtable where we refer to a function
overridden in C, correct?

This changes the size of the secondary vtables, but we've agreed that
doesn't matter.

 > - The convert_to_C in the C primary vtable is theoretically present, but
 > its value is zero, so it may be omitted.

 > - For all other classes, the offset of 'convert_to_C' relative to the
 > secondary vptr is constant. A naive algorithm to ensure that is that
 > this offset is the first negative offset not used by a 'convert_to_X' in
 > any of the bases. I acknoledge this generally may padding in the
 > vtables, but I did not see a better way to do it, short of using a
 > double indirection.

"in any of the bases where we want to allocate this value".  OK.

 > This 'convert_to_C' is used by an adjusting entry point emitted
 > immediatly prior to the main, non-adjusting entry point, which computes
 > this += convert_to_C. If I use this secondary entry point at all, I know
 > that the final overrider is C::f, and that the call was in the form
 > bptr->f(), where bptr is a non-primary non-virtual base of C.

 > The same 'convert_to_C' value is shared by different virtual functions
			   ^^^^^ you mean vptr offset?

 > overriden in C, no matter from which base they are overriden (the
 > interesting case, of course, being when they are overriden from multiple
 > bases). The reason is that if C::f override B::f, the delta is the same
 > than if C::g overrides B::g. It may be different than the delta between
 > C::g and B2::g, but then I am using B2's secondary vtable, which
 > contains the B2->C conversion.

OK.

 > This scheme has the following benefits:

 > - For each virtual function, you emit a secondary entry point with a
 > known size.  The best possible size is 48 bytes, unless some magic
 > predication thingie I did not think of can reduce that. No matter how
 > many secondary vbases or how many derived classes reuse that function,
 > the size is 48.

You don't need it at all if none of your bases need an adjustment.

 > - For each secondary base, you add 8 (or more if padding) bytes to the
 > table.

"each secondary base which refers to a funtion overridden in C".  Yes.

 > - This scheme works accross shared libraries, since the thunk used is
 > always "tied" to the function.

This is also true for my design, as mentioned above.

As you say above, this only applies to non-virtual inheritance.  This
scheme could be combined with the existing vcall offsets for virtual bases
such that you would get one additional entry point per virtual base that
refers to the function, or two if non-virtual bases of that virtual base
also refer to the function.  Is this what you had in mind?

If so, I agree that this is a feasible design.  I'm still unconvinced that
it's a big win; since you're allocating the convert_to_foo slots at the
other end of the vtable from the function pointer, I don't see how you can
expect d-cache locality.

Jason



From ddd at cup.hp.com  Fri Feb 25 00:17:43 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 25 Feb 2000 00:17:43 +0000
Subject: vtable notes
References: <200002242058.MAA13113@yorick.cygnus.com>
Message-ID: <38B5CA27.FC034817@cup.hp.com>

Jason Merrill wrote:
> 
> 
>   C) Ensure that the location of the vcall offset is the same for
>      all secondary vtables

... for non-virtual inheritance only. For virtual inheritance, we need separate
vcall offsets, as you demonstrated. 


> The result of this would be that we would need one thunk, period.
> 
> As I see it, A is a straightforward tradeoff; vtables get larger in the
> case of non-virtual multiple inheritance, but we may be able to reduce the
> number of thunks we use.  On the other hand, we won't be able to fall
> through from a thunk that uses a vcall offset, so we might well end up
> using the same thunks as in the existing design.
> 
> B is a simple improvement to A, reducing the size of the vtables.
> 
> C is the interesting part of Christophe's proposal.  It does sound like the
> result would be faster (by about 2 units of speed) than the existing design
> for calls through obscure bases in large inheritance structures.  However,
> I'm not convinced that there exists a reasonable algorithm for allocating
> vcall offsets in order to achieve this result, in the case of diamond
> inheritance;

In the case of diamond inheritance, we give up that approach and use your vcall
offsets. So I hope the problem does not exist.


> even if there is, it would be much more complex than the one
> for the current design.  This is why I don't think the change could be made
> by tweaking a few words.

The tweaking of a few words I wanted was the following:

1/ Remove the restriction that vcall offsets be allocated only in the presence
of virtual inheritance. Instead, mandate them for virtual or multiple
inheritance.

2/ Change the allocation of vcall offsets so that:
- we allocate one per class when there is no virtual inheritance
- we allocate one per function as soon as there is virtual inheritance.

3/ Discuss how we allocate them (both cases are currently quite unclear, in my
opinion, so we needed to do that anyway.)


Regards
Christophe



From ddd at cup.hp.com  Fri Feb 25 02:10:36 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 25 Feb 2000 02:10:36 +0000
Subject: Do we need to reopen B1?
References: <38B5A340.BF809D85@cup.hp.com> <u9d7pmmdfd.fsf@yorick.cygnus.com>
Message-ID: <38B5E49C.54BE269E@cup.hp.com>

Jason Merrill wrote:
> 
> >>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
>  > In the absence of the "adjusting entry points" I proposed, you have to
>  > use thunks. Within a same class, of course, you can use the 'AddAddAdd'
>  > scheme, since you know the different offsets at compile time for the
>  > various subobjects that compose the class. However, a derived class
>  > cannot share this, because its vtable may very well be emitted in a
>  > different .o.
> 
> I strongly disagree.  This is the primary goal of my design.

Rereading through the e-mail and the writeup, I finally get it. But this was
totally obscured to me by the existing wording... So I guess Mark was not the
only one who got confused:

First:

	For each secondary vtable from a non-virtual base class 'B'
	which defines f, an additional entry point is generated which
	performs the constant adjustment from A* to B*. 

So, the intent is indeed that this is a real entry point, with a name and so on,
and that it actually converts from _ B* to A* _, correct? And this entry point
had a name that you can use to refer to it from other vtables, including in
other translation units, correct? So: we need to specify that name. Also, let's
no longer ever call them 'thunk', since to me a thunk is something that gets
emitted with the vtable, not with the target function.


I was also really sent off track by the note:

	Note that the ABI only specifies the multiple entry points;
	how those entry points are provided is unspecified. An existing
	compiler which uses thunks could be converted to use this ABI by
	only adding support for the vcall offsets. A more efficient
	implementation would be to emit all of the thunks immediately
	before the non-adjusting entry point to the function. Another
	might use predication rather than branches to reach the main
	function. Another might emit a new copy of the function for
	each entry point; this is a quality of implementation issue. 

Let me propose a few changes here:

	Note that the ABI only specifies the name and existence of
	multiple entry points. How those entry points are implemented
	is unspecified, as long as they are emitted with the corresponding
	virtual table. An existing compiler which uses thunks could be
	converted to use this ABI by only adding support for the vcall
	offsets (in the case of virtual inheritance), and by creating
	a named entry point and a thunk for each possible adjustment
	from a secondary base to the derived class (in the case of
	multiple, non-virtual inheritance).

	A more efficient implementation would be to emit all of the
	adjusting entry points immediately before the non-adjusting
	entry point to the function. Such thunks can also be combined
	in the form of multiple 'Add' instructions that fall through
	to the main entry point. Another implementation yet is to use
	predication rather than branches to reach the main function
	[Note: I'm not sure this actually works without a calling
	convention on predicates...]. Another might emit a new copy
	of the function for each entry point. Selecting one of these
	implementations is a quality of implementation issue.

Does this wording sound better?


> 
>  > For instance, consider:
> 
>  >      struct A { virtual a(); int aa; };
>  >      struct B { virtual b(); int bb; };
>  >      struct C { virtual c(); int cc; };
> 
>  >      struct D : A, B { virtual b(); int dd; }
>  >      struct E : D { /* Does not override b() */ }
> 
>  > The primary vtable for D points to D::b, no adjustment required. The
>  > secondary vtable for B in D points to D::b with, say, an 'Add'
>  > adjustment, which would be of -16 (from the B* to the D*).
> 
>  > When you emit the vtable for E, the good news is that the adjustment is
>  > the same (-16 from B* to D*). The bad news is that you don't know how to
>  > locate the thunk that adds -16 (unless we all agree on the algorithm for
>  > emitting this kind of "AddAddAdd" thunk, which we did not.)
> 
> Oh, come on.  Yes, we still need to define what entry point symbols will
> be emitted with D::b, and how they are mangled, so that derived classes can
> refer to them.  But we certainly can do that.

Of course, we can, which is why I said "unless we all agree [...], which we did
not"... To me, the initial wording just said: "Emit the thunk if you want".

[Egg on face: with that new understanding, what I wrote for shared libraries was
really n'importe quoi]


 
>  > So my proposal is simply that, for the non-virtual multiple inheritance
>  > case, we have a this-pointer adjustment offset in each secondary vtable,
>  > that adjusts form the secondary vtable class to the function's target
>  > class.
> 
>  > The algorithm I proposed to allocate these offsets was the following:
> 
>  > - While defining class C, we allocate a single offset "convert_to_C",
>  > that converts from the class of the secondary vtable in which it is
>  > stored to the C class.
> 
> We allocate this in each secondary vtable where we refer to a function
> overridden in C, correct?

Yes.

> 
> This changes the size of the secondary vtables, but we've agreed that
> doesn't matter.
> 
>  > - The convert_to_C in the C primary vtable is theoretically present, but
>  > its value is zero, so it may be omitted.
> 
>  > - For all other classes, the offset of 'convert_to_C' relative to the
>  > secondary vptr is constant. A naive algorithm to ensure that is that
>  > this offset is the first negative offset not used by a 'convert_to_X' in
>  > any of the bases. I acknoledge this generally may padding in the
>  > vtables, but I did not see a better way to do it, short of using a
>  > double indirection.
> 
> "in any of the bases where we want to allocate this value".  OK.

Correct.

> 
>  > This 'convert_to_C' is used by an adjusting entry point emitted
>  > immediatly prior to the main, non-adjusting entry point, which computes
>  > this += convert_to_C. If I use this secondary entry point at all, I know
>  > that the final overrider is C::f, and that the call was in the form
>  > bptr->f(), where bptr is a non-primary non-virtual base of C.
> 
>  > The same 'convert_to_C' value is shared by different virtual functions
>                            ^^^^^ you mean vptr offset?

Yes.

> 
>  > overriden in C, no matter from which base they are overriden (the
>  > interesting case, of course, being when they are overriden from multiple
>  > bases). The reason is that if C::f override B::f, the delta is the same
>  > than if C::g overrides B::g. It may be different than the delta between
>  > C::g and B2::g, but then I am using B2's secondary vtable, which
>  > contains the B2->C conversion.
> 
> OK.
> 
>  > This scheme has the following benefits:
> 
>  > - For each virtual function, you emit a secondary entry point with a
>  > known size.  The best possible size is 48 bytes, unless some magic
>  > predication thingie I did not think of can reduce that. No matter how
>  > many secondary vbases or how many derived classes reuse that function,
>  > the size is 48.
> 
> You don't need it at all if none of your bases need an adjustment.

Yes. But in that case, you don't need it in any of our schemes. I'm trying to
contrast this with the other thunk-generation models. 48 bytes is the cost of 3
of our adds, or of 3 "normal" thunks. So this scheme becomes beneficial
memory-wise for more than 3 bases with adjustment.

> 
>  > - For each secondary base, you add 8 (or more if padding) bytes to the
>  > table.
> 
> "each secondary base which refers to a funtion overridden in C".  Yes.
> 
>  > - This scheme works accross shared libraries, since the thunk used is
>  > always "tied" to the function.
> 
> This is also true for my design, as mentioned above.

Now I understand this.

> 
> As you say above, this only applies to non-virtual inheritance.  This
> scheme could be combined with the existing vcall offsets for virtual bases
> such that you would get one additional entry point per virtual base that
> refers to the function, or two if non-virtual bases of that virtual base
> also refer to the function.  Is this what you had in mind?

I believe the scheme _has to_ be combined with the vcall offsets. It doesn't
work for virtual inheritance. That's why I said earlier the two schemes were not
opposed. So, yes, that's definitely what I have in mind.

> 
> If so, I agree that this is a feasible design.  I'm still unconvinced that
> it's a big win; since you're allocating the convert_to_foo slots at the
> other end of the vtable from the function pointer, I don't see how you can
> expect d-cache locality.

I do not expect perfect D-cache locality (which is why I thought useful to
specify in a previous e-mail the cost of a D-cache miss). I'm still looking for
a better way to allocate it. Getting a better cache locality was the reason I
was considering duplicating that (as you do for vcall offsets) and putting it
next to the vtable entry.

On the other hand, a frequent case where you do get cache locality is if you
call different virtual functions for the same pointer in succession, and if the
functions are overriden in the same class. Say:

	for (i = 0; i < max; i++)
	{
		Shape *shape = shapes[i];
		shape->SetColor(red);
		shape->Scale(3.0);
		shape->Rotate(2.5);
		shape->Draw();
	}

This code seems fairly reasonable. In that case, you can expect to pay a cache
miss only for the first call. Note that this does not apply if g is called
through f, since in that case we use the non-adjusting entry-point anyway. On
the other hand, on that same code, there a high probability of I-cache miss for
each function, and of double I-cache miss for thunks. So thunks go to their
worst scenario, whereas adjusting entry points remain in their 'typical, no
D-cache miss' scenario. Here, we get 9 vs. 3 "abstract units of time".

I would not say that this is an incredible win. Yet, this is a win for some
common cases, it's not extraordinarily complicated, it was documented in my
initial proposal, and it got dropped, I believe, more by distraction than on
purpose (at least from my point of view.) We had found with 'AddAddAdd' an even
better way to deal with the most frequent case, but dropping the next case most
frequent case was not necessary.



Summary:

+ The best case is clearly the 'AddAddAdd' for a limited number of offsets. No
argument.

+ The second is adjusting entry point with no D-cache miss. This scenario is
between 1 and 3 times as bad as the previous one, depending on the number of
adds.

+ For third position, there is a tie speed-wise between the thunks and the
adjusting entry point with D-cache miss, but then I believe the adjusting
entry-point wins memory-wise except in pathological cases where padding would
dominate. Speed-wise, this scenario is about 3 times as bad as scenario 2.


As a reminder, the numbers I gave were  the following (I added memory usage):

                        Best    Typical Worst	I-mem	D-mem
        Thunks          5       9       20	16*F*C	0
        AddAddAdd       0+N/M   0+N/M   9+N/M	16*F*C	0
        Adjust          3       3       18	48*F	8*C+Pad
        Adjust/D-miss   8       8       21	48*F	8*C+Pad

C: number of secondary bases requiring adjustments. F: Number of virtual
functions overriden in current class.


Regards
Christophe



From ddd at cup.hp.com  Fri Feb 25 02:12:34 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 25 Feb 2000 02:12:34 +0000
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
References: <20000222114354R.mitchell@codesourcery.com> <u9r9e3pxoo.fsf@yorick.cygnus.com>
Message-ID: <38B5E512.D1230A2E@cup.hp.com>

Jason Merrill wrote:
> 
> >>>>> Mark Mitchell <mark at codesourcery.com> writes:
> 
>  >   o GP/address pairs in vtables
> 
>  >     This one concerns me the most.  I don't even know if there's
>  >     any kind of standard assembly syntax for this.  Is there?
>  >     (If not, there should be -- otherwise, you can't say -S to your
>  >     compiler and get anything sensible out.)
> 
> Richard Henderson still doesn't believe that there's a suitable reloc for
> this in the base ABI, and apparently I forgot to write up his explanation
> for a wider audience.  Richard, care to repeat it in a less transient
> medium?

I remember an early message saying something like: There is no suitable reloc,
but there is some relocation that does this by sheer luck. Let me see if I can
find it...

Ah, here is the text:

Richard Henderson of Cygnus points out that the IA-64 relocations don't
really support doing this.  However, the R_IA_64_IPLT*SB relocations do
perform the correct action.  The problem is that they are currently
specified to be valid only in executables and shared objects.  I
believe that the problem can be solved by simply removing this
restriction.  The static linker support required shouldn't be major --
it would presumably just pass the relocations through to the linked
object and let the dynamic linker deal with them.


Did this change?
Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Fri Feb 25 02:18:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 24 Feb 2000 18:18:40 -0800 (PST)
Subject: Conference phone
Message-ID: <200002250218.SAA18936@baalbek.engr.sgi.com>

> The usual number of the meeting 9337969 connected me to a room of different
> folks.  Has the number been changed?

Our dialin numbers work like conference rooms -- we reserve them, but
there's no builtin termination of the call when one group's time ends
and the next one ends.  So when this happens (the last two weeks now),
let the group on the line know that their time is up and another call
is beginning.  They'll probably stop quickly enough when they realize
they aren't private anymore :-).

Jim
-		Jim Dehnert  x3-4272



From rth at cygnus.com  Fri Feb 25 03:08:19 2000
From: rth at cygnus.com (Richard Henderson)
Date: Thu, 24 Feb 2000 19:08:19 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <38B5E512.D1230A2E@cup.hp.com>; from Christophe de Dinechin on Fri, Feb 25, 2000 at 02:12:34AM +0000
References: <20000222114354R.mitchell@codesourcery.com> <u9r9e3pxoo.fsf@yorick.cygnus.com> <38B5E512.D1230A2E@cup.hp.com>
Message-ID: <20000224190819.A560@cygnus.com>

On Fri, Feb 25, 2000 at 02:12:34AM +0000, Christophe de Dinechin wrote:
> However, the R_IA_64_IPLT*SB relocations do perform the correct action.

Not even close.  They carry a _lot_ of other semantic baggage
related to dynamic linking and lazy binding.



r~



From jason at cygnus.com  Fri Feb 25 08:18:18 2000
From: jason at cygnus.com (Jason Merrill)
Date: 25 Feb 2000 00:18:18 -0800
Subject: Do we need to reopen B1?
In-Reply-To: Christophe de Dinechin's message of "Fri, 25 Feb 2000 02:10:36 +0000"
References: <38B5A340.BF809D85@cup.hp.com> <u9d7pmmdfd.fsf@yorick.cygnus.com> <38B5E49C.54BE269E@cup.hp.com>
Message-ID: <u9snyhlmph.fsf@yorick.cygnus.com>

>>>>> Christophe de Dinechin <ddd at cup.hp.com> writes:

 > First:

 > 	For each secondary vtable from a non-virtual base class 'B'
 > 	which defines f, an additional entry point is generated which
 > 	performs the constant adjustment from A* to B*. 

 > So, the intent is indeed that this is a real entry point, with a name
 > and so on, and that it actually converts from _ B* to A* _, correct? And
 > this entry point had a name that you can use to refer to it from other
 > vtables, including in other translation units, correct?

It never occurred to me that it could be otherwise.

 > So: we need to specify that name. Also, let's no longer ever call them
 > 'thunk', since to me a thunk is something that gets emitted with the
 > vtable, not with the target function.

To me, a thunk is a small piece of code that mediates between caller and
callee.  But if you'd rather, we can restrict that term to "traditional",
floating thunks.

 > I was also really sent off track by the note:

 > 	Note that the ABI only specifies the multiple entry points;
 > 	how those entry points are provided is unspecified. An existing
 > 	compiler which uses thunks could be converted to use this ABI by
 > 	only adding support for the vcall offsets. A more efficient
 > 	implementation would be to emit all of the thunks immediately
 > 	before the non-adjusting entry point to the function. Another
 > 	might use predication rather than branches to reach the main
 > 	function. Another might emit a new copy of the function for
 > 	each entry point; this is a quality of implementation issue. 

 > Let me propose a few changes here:

 > 	Note that the ABI only specifies the name and existence of
 > 	multiple entry points. How those entry points are implemented
 > 	is unspecified

This works for me.

 >	, as long as they are emitted with the corresponding
 > 	virtual table.

No; this would disallow emitting them with the function, if the function
and vtable are defined in different places.  I don't think we need to
specify this.

 >      An existing compiler which uses thunks could be
 > 	converted to use this ABI by only adding support for the vcall
 > 	offsets (in the case of virtual inheritance), and by creating
 > 	a named entry point and a thunk for each possible adjustment
 > 	from a secondary base to the derived class (in the case of
 > 	multiple, non-virtual inheritance).

I don't understand "a named entry point and a thunk".  In this case, the
thunk is the entry point.

 > 	A more efficient implementation would be to emit all of the
 > 	adjusting entry points immediately before the non-adjusting
 > 	entry point to the function. Such thunks can also be combined
 > 	in the form of multiple 'Add' instructions that fall through
 > 	to the main entry point.

You used 'thunk'.  :)

 >      Another implementation yet is to use
 > 	predication rather than branches to reach the main function
 > 	[Note: I'm not sure this actually works without a calling
 > 	convention on predicates...].

I had been thinking about something like

foo:
   add *p
   set predicate
bar:
   [if not set] add *q
   ...

but I'd be perfectly happy to lose the predication language.

Jason



From mark at codesourcery.com  Fri Feb 25 09:37:22 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 25 Feb 2000 01:37:22 -0800
Subject: Virtual function call writeup
Message-ID: <20000225013722T.mitchell@codesourcery.com>


It seems that I finally understand Jason's proposal, i.e., the
currently accepted resolution.  I managed to write up the following
description, which, when run by Jason, came back with only minor
tweaks -- no major corrections.  That indicates I've probably got it,
now.

I hope that having a (relatively) clear writeup will help.

Thanks to all of you for helping.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com

Purpose
=======

The purpose of this document is to explain, at a high level, what
information must be present in the vtable for a class A which declares
a virtual function f in order that, given an pointer of type A*, the
caller can call the virtual function f.  This document does not
specify exactly where that information is located, nor does it specify
how to convert a pointer to a class derived from A to an A*, if that
is required.  In addition, this document provides the rationale behind
these design decisions, together with suggestions for implementing the
ABI in order to achieve maximum efficiency.

When this document uses the term "function pointer" it is understood
that this term may refer either to a traditional function pointer
(i.e., a pointer to a GP/address pair) or a GP/address pair itself.
Which of these alternatives will actually be used must be specified by
the ABI, but is not specified in this document.

Throughout, we assume that A is the class for which we are creating a
vtable, B is the most derived class in the hierarchy, and C is the
class that contains C::f, the unique final overrider for A.  This
document specifies the contents of the f entry in the A-in-B vtable.
(If A is primary base in the hierarchy, then the A-in-B vtable will be
shared with the derived class vtable -- but the contents of the A
portion of that vtable will still be as specified here.)

In all cases, the "non-adjusting entry point" for a virtual function
expects the `this' pointer to point to an instance of the class in
which the virtual function is defined.  In other words, the
non-adjusting entry point for C::f will expect that its `this'
pointer points to a C object.

We say that a subobject X is a "morally virtual" base of Y if X is an
indirect or direct base class of Y, and if X is either a virtual base
of Y, or the direct or indirect base of a virtual base of Y.

A's Vtable
==========

Case 1: A = C

  (In this case, we are creating either the primary vtable for A, or
  the A-in-B secondary vtable.)

  The vtable contains a function pointer pointing to the non-adjusting
  entry point for A::f.

Case 2: A != C

  In this case, we are creating the A-in-B secondary vtable.

  The vtable contains a pointer to an entry point that performs the
  adjustment from an A* to a C*, and then transfers control to the
  non-adjusting entry point for C::f.

Callee
======

For each direct or indirect base A of C that is not a morally virtual
base of C, the compiler must emit, in the same object file as the code
for C::f, an "A adjusting entry point" for C::f.  This entry point
will expect that its `this' pointer points to an A*, and will
convert it to a C* before transferring control to the non-adjusting
entry point for C::f.

For each direct or indirect virtual base V of C such that either V
declares f, or is derived from a class that declares f, the compiler
must emit, in the same object file as the code for C::f, an "V
adjusting entry point" for C::f.  This entry point will expect that
its `this' pointer points to the unique virtual V subobject of C.
(Note that there may in general be multiple V subobjects of C, but
that only one of them will be virtual.)  This entry point must examine
the V vtable given by its this point, extract the vcall offset
corresponding to f located in that vtable, and add this offset to the
this pointer.  (Note that, as specified in the data layout document,
when V is used as a virtual base, its vtable contains vcall offsets
for every virtual function declared in V or any of its bases.)  Then,
this entry point must transfer control to the non-adjusting entry
point.

For each morally virtual base M of C such that M is *not* a virtual
base, and such that M declares f, the compiler must emit, in the same
object file as the code for C::f, an "M adjusting entry point" for
C::f.  This entry point will expect that its `this' pointer points to
an A*, and will convert it to a V*, where V is the nearest virtual
base to M along the path from C to M.  Then, it will convert the V* to
a C* by using the vcall offset stored in the V's vtable.  (Note that
one implementation of the "M adjusting entry point" is to convert from
M* to V* and then transfer control to the "V adjusting entry point.")

Caller
======

When calling a virtual function f, through a pointer of static type
B*, the caller

  - Selects a (possibly improper) subobject A of B such that A
    declares f.  (In general, A may be the same as B.)  (Note that A
    need not define f; it may contain either a definition of f, or a
    declaration of f as a pure virtual function.)

  - Converts the B* to point to this subobject.  (Call the resulting
    pointer `a'.)

  - Uses the vtable pointer contained in the A subobject to locate
    the function pointer through which to perform the call.

  - Calls through this function pointer, passing `a' as the `this' 
    pointer.

(Note that in general it will be optimal to select the class which
contained the final overrider (i.e., C) as the class to which the B*
should be converted.  This class is always a satisfactory choice,
since it is known to contain a definition of f.  In addition, if the
dynamic type of the object is B, then C::f will be the function
ultimately selected by the call, which means that C's vtable will
contain a pointer to the non-adjusting entry point, meaning that no
additional adjustments to the `this' pointer will be required.

However, there may be cases in which choosing a different base
subobject could be superior.  For example, if there is an alternate
base D which also declares f, and a pointer to the D subobject is
already available, then it may be better to use the D subobject rather
than converting the B* to a C*, in order to avoid the cost of the
conversion.)

Implementation Notes
====================

The design specified here provides several benefits:

- In the case of single, non-virtual inheritance, calling a virtual
  function requires no adjustment to the `this' pointer, and no vcall
  offsets.  This is in keeping with the guiding principle that "you
  shouldn't pay for features you don't use."

- If the static type of an object is the same as its dynamic type,
  then no adjustment to the `this' pointer is required.

- All thunks can be emitted in the same translation unit as the
  overriding function.

- Thunks from classes that are not morally virtual bases do not
  require a branch to the non-adjusting entry point.

  We suggest the following implementation:

    m2: /* Thunk for morally virtual base M2.  */
        this += offsetof (V, M1) - offsetof (V, M2)
    m1: /* Thunk for morally virtual base M1.  */
        this -= offsetof (V, M1)
    v:  /* Thunk for virtual base V.  */
        this += vcall offset stored in V vtable
	goto f;
    a2: /* Thunk for non-virtual base A2.  */
        this += offsetof (B, A1) - offsetof (B, A2)
        /* Fall through.  */
    a1: /* Thunk for non-virtual base A1.  */
        this += offsetof (B, C) - offsetof (B, A1)
        /* Fall through.  */
    f:  /* Non-adjusting entry point.  */

  (Here `offsetof' is a compile-time computable function that gives
  the offset of its second parameter in its first parameter.)

  (Alternatively the `v' entry point above could be of the form:

    v: /* Thunk for virtual base V.  */
       this += vcall offset stored in V vtable 
               - offsetof (B, C) + offsetof (B, A2)
       /* Fall through.  */
   
   which alternative is better depends on how many adds follow at this
   point.  In general, if many adds remain before the non-adjusting
   entry point, it may be better to suffer the consequences of the
   indirect branch.)

  In this way, a virtual call through a base A1, A2, etc., that is not
  a virtual base of C (or a direct or indirect base of a virtual base
  of C), does not require an additional branch, and is therefore more
  likely to avoid icache misses.  Even the thunk for V may avoid
  severe icache penalties since it is located near the non-adjusting
  entry point for f.  Furthermore, if there are no non-virtual bases,
  then the sequence can become just:

    v: /* Thunk for virtual base V.  */
       this += vcall offset stored in V vtable
    f: /* Non-adjusting entry point.  */

Open Issues
===========

We should specify manglings for each of the thunks so that other
translation units can use them.



From ddd at cup.hp.com  Fri Feb 25 17:50:43 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 25 Feb 2000 17:50:43 +0000
Subject: Do we need to reopen B1?
References: <38B5A340.BF809D85@cup.hp.com> <u9d7pmmdfd.fsf@yorick.cygnus.com> <38B5E49C.54BE269E@cup.hp.com> <u9snyhlmph.fsf@yorick.cygnus.com>
Message-ID: <38B6C0F3.999DA9BC@cup.hp.com>

Jason Merrill wrote:
>  >      , as long as they are emitted with the corresponding
>  >      virtual table.
> 
> No; this would disallow emitting them with the function, if the function
> and vtable are defined in different places.  I don't think we need to
> specify this.

Ooops, you are correct. The sentence should indeed be "as long as they are
emitted whenever the main entry point is emitted."

> 
>  >      An existing compiler which uses thunks could be
>  >      converted to use this ABI by only adding support for the vcall
>  >      offsets (in the case of virtual inheritance), and by creating
>  >      a named entry point and a thunk for each possible adjustment
>  >      from a secondary base to the derived class (in the case of
>  >      multiple, non-virtual inheritance).
> 
> I don't understand "a named entry point and a thunk".  In this case, the
> thunk is the entry point.

The 'entry point' denotes a label with linkage. The 'thunk' denotes the code. I
agree the wording is not that good.


> 
>  >      A more efficient implementation would be to emit all of the
>  >      adjusting entry points immediately before the non-adjusting
>  >      entry point to the function. Such thunks can also be combined
>  >      in the form of multiple 'Add' instructions that fall through
>  >      to the main entry point.
> 
> You used 'thunk'.  :)

Ooops.

> 
>  >      Another implementation yet is to use
>  >      predication rather than branches to reach the main function
>  >      [Note: I'm not sure this actually works without a calling
>  >      convention on predicates...].
> 
> I had been thinking about something like
> 
> foo:
>    add *p
>    set predicate
> bar:
>    [if not set] add *q
>    ...
> 
> but I'd be perfectly happy to lose the predication language.
> 
> Jason

The problem is that you can't go to 'bar' unless you know that the predicate is
not set. That's what I called a "calling convention on predicates". Something
like "p777 is always reset at the time a virtual call branch is made", where
p777 would be part of the ABI.



Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Sat Feb 26 07:27:17 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 25 Feb 2000 23:27:17 -0800 (PST)
Subject: Virtual function call writeup
Message-ID: <200002260727.XAA27671@baalbek.engr.sgi.com>

Thanks to Mark for the writeup, and to Christophe and Jason for the
examples from the meeting.  I've done a couple things:

 1) I've added the examples to the abi-examples.html document,
    along with an implementation discussion (written before I saw
    Mark's, so that's not integrated, though I intend to).

 2) I've largely replaced the calling convention discussion in the
    abi-layout.html document with Mark's description, leaving in a
    bit of the old stuff that supplements what Mark wrote.

Take a look at these, please, and send your comments.

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From coleen at zko.dec.com  Mon Feb 28 19:35:21 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 28 Feb 2000 14:35:21 -0500
Subject: vcall offset question wrt. vtables
Message-ID: <38BACDF9.9B8C2C5B@zko.dec.com>

/*
I'm trying to understand where vcall offsets fit into the virtual
function table.  I have to confess lack of motivation up to this
point (since I think regular adjusting thunks are good enough for
real code, and wasn't planning on implementing them).  Since we've
opened the issue and are proposing a spec change, I thought I'd see
if I could understand them enough to implement zero sized slots for
them.

It seems in our vtable layout section, that 2 things grow upward if a
vtable is shared between base classes and that these things change the
fundamental premise that a vtable has the same entries on either side
of the vptr whether it is most derived or a base class subobject, in
the latter case, some entries may be added.

Consider this example:
*/

struct V {
        virtual void f() {}
        virtual void g() {}
};

struct V2 : virtual V {
        virtual void h() {}
};

struct V3 : virtual V2 {
        int v3; // prevent sharing for D.
        virtual void i() {}
};

struct D : virtual V3
{
        virtual void f() {}
        virtual void g() {}
        virtual void h() {}
        virtual void i() {}
};

main() {
  // Make example generate something
  D *d = new D;
}

/*
D's vtable for V3 in D would be shared by V2 and V, since when the
vtable is shared, we append functions on the end and base offsets onto
the beginning, would a V3 vtable in D look like this:

        (start with V)

        vcall offset f
        vcall offset g
        offset to top
        D::typeinfo
        &f (or some way to get there, thunk, gp pair, I don't care)
        &g

        (add on V2's shared vtable)

        vbase offset for V
        vcall offset for h
        vcall offset for f
        vcall offset for g
        offset to top
        D::typeinfo
        &f
        &g
        &h

        (add on V3's shared vtable)

        vbase offset for V2
        ??? vcall offset to i
        vbase offset for V
        vcall offset for h        vcall offset for g
        vcall offset for f
        offset to top
        D::typeinfo
        &f
        &g
        &h
        &i

Does this mean V3's vtable does not have the same format as if it
weren't virtual derived?  If V3 was nonvirtually derived, wouldn't it's
vtable look like this:

        (V3's vtable most derived)

        vbase ofset for V2
        vbase offset for V
        vcall offset for h
        vcall offset for g
        vcall offset for f
        offset to top
        D::typeinfo
        &f
        &g
        &h
        &i
*/

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From jason at cygnus.com  Mon Feb 28 22:54:40 2000
From: jason at cygnus.com (Jason Merrill)
Date: 28 Feb 2000 14:54:40 -0800
Subject: vcall offset question wrt. vtables
In-Reply-To: Coleen Phillimore's message of "Mon, 28 Feb 2000 14:35:21 -0500"
References: <38BACDF9.9B8C2C5B@zko.dec.com>
Message-ID: <u9n1olhr9r.fsf@yorick.cygnus.com>

>>>>> Coleen Phillimore <coleen at zko.dec.com> writes:

 >         (add on V3's shared vtable)

 >         vbase offset for V2
 >         ??? vcall offset to i

These are backwards.  The vbase offset is part of the V3 primary vtable,
while the vcall offset for i is only added when V3 is used as a virtual
base.

 > Does this mean V3's vtable does not have the same format as if it
 > weren't virtual derived?

No.  Though it does mean that if we share a vtable with a virtual base, the
vbase and vcall offsets may be interleaved.

Jason



From dehnert at baalbek.engr.sgi.com  Tue Feb 29 03:42:28 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 28 Feb 2000 19:42:28 -0800 (PST)
Subject: Pointers-to-members
Message-ID: <200002290342.TAA32845@baalbek.engr.sgi.com>

I've added new issues A-26/27 for the representation of NULL pointers
to members.  But I have a couple of questions:

-- For a pointer to member function, if the function is non-virtual,
   it doesn't seem that one ever needs to worry about the adjustments.
   If it's the same target function address, the only significance of
   the adjustment is how much you modify this before calling it, which
   is a property of the containing class rather than of the target.

-- But if the function is virtual, the "pointer" is an offset into the
   vtable, and if you really want to identify whether the ultimate
   function is the same it gets really messy, especially if you need to
   pass through "thunks" first.  Is this the semantics, or is it much
   simpler for some reason?

-- For a pointer to member data, Jason had me convinced that the
   displacement would never go negative because the bases are allocated
   before additional data members in the derived class, until I thought
   about virtual bases, where that's no longer true.  Is there a C++
   restriction that makes this not a problem, or...?

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 29 05:04:59 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 28 Feb 2000 21:04:59 -0800 (PST)
Subject: Vtable index type
References: <20000221141529D.mitchell@codesourcery.com>
    <u93dqksz08.fsf@yorick.cygnus.com>
    <20000222140448N.mitchell@codesourcery.com>
Message-ID: <200002290504.VAA33444@baalbek.engr.sgi.com>

> From: Jason Merrill <jason at cygnus.com>
> 
>  >>> We should specify a type for vtable indices.  It seems to me
>  >>> that `ptrdiff_t' is the obvious candidate.
> 
>  >>> This is important in that it limits the number of vtable
>  >>> entries we can use.  (For example, g++ has historically used
>  >>> `short' for a vtable index; that limited the size of vtables.)
> 
>  Jason> Where does a vtable index appear in the ABI?
> 
>  > Pointers-to-members.
> 
> Actually, that's an offset (in bytes), not an index (in slots).  I suppose
> we should define "vtable offset" somewhere.  But the same issue applies.
> 
>  > Suppose we check the `ptr' field, and notice it's odd.  Now, we have to
>  > divide by two and use the resulting thing as a vtable index.  If, say,
>  > we only allowed n-bit indices, then we could shift right one bit, and
>  > pull out just the low-order n-bits.  I don't know *why* anyone would
>  > want to do that, but the ABI should say whether or not its legal to do
>  > so.
> 
> Makes sense.  I agree that ptrdiff_t seems like the obvious resolution.

I've added this to the description of ptr in the Member Pointers
section of the layout document.  So unless anyone objects to this
resolution, we'll consider it done.

NOTE:  I also fixed the description to remove the "multipled by two"
part, since we had agreed not do do that (see the closed issues list,
A-11).  I apologize for not transcribing it correctly the first time.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Feb 29 06:10:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 28 Feb 2000 22:10:35 -0800 (PST)
Subject: Oversize bitfields
Message-ID: <200002290610.WAA33737@baalbek.engr.sgi.com>

I updated the oversize bitfield description, in the process moving it
to the main class allocation description and including a description
on non-oversize bitfield allocation.  Please take a look (it's red),
especially Mark, and let me know if it is clearer.

(The updates I've described today are in HTML, not yet in the PDF.)

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Tue Feb 29 07:01:44 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 28 Feb 2000 23:01:44 -0800
Subject: Pointers-to-members
In-Reply-To: <200002290342.TAA32845@baalbek.engr.sgi.com>
References: <200002290342.TAA32845@baalbek.engr.sgi.com>
Message-ID: <20000228230144O.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I've added new issues A-26/27 for the representation of NULL
    Jim> pointers to members.  But I have a couple of questions:

    Jim> -- For a pointer to member function, if the function is
    Jim> non-virtual, it doesn't seem that one ever needs to worry
    Jim> about the adjustments.  If it's the same target function
    Jim> address, the only significance of the adjustment is how much
    Jim> you modify this before calling it, which is a property of the
    Jim> containing class rather than of the target.

You still need to know whether or not the adjustment is guaranteed or
not -- if it is, then you have to make sure to keep it zero, and if it
isn't then you have to generate more complex code when doing
comparisions.

    Jim> -- But if the function is virtual, the "pointer" is an offset
    Jim> into the vtable, and if you really want to identify whether
    Jim> the ultimate function is the same it gets really messy,
    Jim> especially if you need to pass through "thunks" first.  Is
    Jim> this the semantics, or is it much simpler for some reason?

Ooh, ugh.  But in [expr.eq] we have:

  Otherwise  if either is a pointer to a virtual member func-
  tion, the result is unspecified.

so, we can do what we wish.

    Jim> -- For a pointer to member data, Jason had me convinced that
    Jim> the displacement would never go negative because the bases
    Jim> are allocated before additional data members in the derived
    Jim> class, until I thought about virtual bases, where that's no
    Jim> longer true.  Is there a C++ restriction that makes this not
    Jim> a problem, or...?

I think I submitted a "proof" of the non-negativity of
pointers-to-members in all cases.  I believe that you can't cast a
D::* to a B::* if B is a virtual base.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Feb 29 07:05:29 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 28 Feb 2000 23:05:29 -0800
Subject: Oversize bitfields
In-Reply-To: <200002290610.WAA33737@baalbek.engr.sgi.com>
References: <200002290610.WAA33737@baalbek.engr.sgi.com>
Message-ID: <20000228230529Z.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I updated the oversize bitfield description, in the process
    Jim> moving it to the main class allocation description and
    Jim> including a description on non-oversize bitfield allocation.
    Jim> Please take a look (it's red), especially Mark, and let me
    Jim> know if it is clearer.

I like it.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Tue Feb 29 19:26:10 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 29 Feb 2000 19:26:10 +0000
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com> <20000228230144O.mitchell@codesourcery.com>
Message-ID: <38BC1D52.210987C6@cup.hp.com>

Mark Mitchell wrote:
> 
> I think I submitted a "proof" of the non-negativity of
> pointers-to-members in all cases.  I believe that you can't cast a
> D::* to a B::* if B is a virtual base.

I believe in the proof. Yet, I'm a bit nervous, because the aCC compiler
currently had large delta between actual pointer to members and NULL pointer to
members. Just paranoia? Maybe. Or maybe there is a case we don't think of...
That's why I proposed 0x800...000 as the NULL value.


Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Tue Feb 29 21:45:31 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 29 Feb 2000 13:45:31 -0800 (PST)
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com>
    <20000228230144O.mitchell@codesourcery.com>
Message-ID: <200002292145.NAA34861@baalbek.engr.sgi.com>

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> Mark Mitchell wrote:
> > 
> > I think I submitted a "proof" of the non-negativity of
> > pointers-to-members in all cases.  I believe that you can't cast a
> > D::* to a B::* if B is a virtual base.
> 
> I believe in the proof. Yet, I'm a bit nervous, because the aCC compiler
> currently had large delta between actual pointer to members and NULL pointer to
> members. Just paranoia? Maybe. Or maybe there is a case we don't think of...
> That's why I proposed 0x800...000 as the NULL value.

OK, I got ambitious (foolish? reckless?) and went searching through the
Standard for pointers to members.  Here's what I found:

- There is a standard conversion (4.11) from A::* to B::* (same type)
  if B is derived from A, and A is not an inaccessible, ambiguous, or
  virtual base of B.

- There is a static cast (5.2.9) from B::* to A::* if the opposite
  standard conversion exists.  Note that this still excludes crossing
  the virtual base boundary.  The pointee member need not be in the
  target class, but must be in one of the classes derived from it.

- There is a reinterpret cast (5.2.10), but the only requirements are
  that NULL becomes NULL, and it is invertible.

- Comparisons (5.10) of pointers to virtual member functions are undefined.

So, conclusions:

- Since we always allocate non-virtual bases before data members,
  any base object in a derivation chain will have its base address
  smaller than any of the data members declared in members of the
  chain.  Therefore, the offset represented by a pointer-to-data-member
  will always be non-negative, even after the permitted conversions
  above.

  So, we could either use -1 for NULL, or use 0 and increment the
  offset.  0x800...000 is an unnecessary complication.

- For pointer-to-function-member comparisons, we only need to worry
  about non-virtual members and null.  Since the representation
  stores the actual address of the function descriptor, we should be
  able to just compare the pointers, and ignore the adjustment.

  For conversions between base classes, it seems that we need only
  modify the adjustment, and then only if one is not primary for the
  other.  For conversion to null, it seems that we need only set the
  pointer to 0, and can ignore the adjustment.

This seems simple enough.  So I must be missing something :-).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Tue Feb 29 21:58:21 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 29 Feb 2000 13:58:21 -0800
Subject: Pointers-to-members
In-Reply-To: <200002292145.NAA34861@baalbek.engr.sgi.com>
References: <200002290342.TAA32845@baalbek.engr.sgi.com>
	<20000228230144O.mitchell@codesourcery.com>
	<200002292145.NAA34861@baalbek.engr.sgi.com>
Message-ID: <20000229135821U.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> This seems simple enough.  So I must be missing something
    Jim> :-).

No, I think you managed to recreate my alegged proof from last
week. :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



