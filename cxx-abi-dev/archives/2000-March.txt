From dehnert at baalbek.engr.sgi.com  Wed Mar  1 09:22:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 01:22:24 -0800 (PST)
Subject: Do we need to reopen B1?
References: <38B5A340.BF809D85@cup.hp.com> <u9d7pmmdfd.fsf@yorick.cygnus.com>
Message-ID: <200003010922.BAA36606@baalbek.engr.sgi.com>

There are a number of things about the analysis here that are bothering
me.  Please bear with me while I describe them, and let me know where
I'm mixed up :).

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> > If so, I agree that this is a feasible design.  I'm still unconvinced that
> > it's a big win; since you're allocating the convert_to_foo slots at the
> > other end of the vtable from the function pointer, I don't see how you can
> > expect d-cache locality.
> 
> I do not expect perfect D-cache locality (which is why I thought useful to
> specify in a previous e-mail the cost of a D-cache miss). I'm still looking for
> a better way to allocate it. Getting a better cache locality was the reason I
> was considering duplicating that (as you do for vcall offsets) and putting it
> next to the vtable entry.
> 
> On the other hand, a frequent case where you do get cache locality is if you
> call different virtual functions for the same pointer in succession, and if the
> functions are overriden in the same class. Say:
> 
> 	for (i = 0; i < max; i++)
> 	{
> 		Shape *shape = shapes[i];
> 		shape->SetColor(red);
> 		shape->Scale(3.0);
> 		shape->Rotate(2.5);
> 		shape->Draw();
> 	}
> 
> This code seems fairly reasonable. In that case, you can expect to pay a cache
> miss only for the first call. Note that this does not apply if g is called
> through f, since in that case we use the non-adjusting entry-point anyway. On
> the other hand, on that same code, there a high probability of I-cache miss for
> each function, and of double I-cache miss for thunks. So thunks go to their
> worst scenario, whereas adjusting entry points remain in their 'typical, no
> D-cache miss' scenario. Here, we get 9 vs. 3 "abstract units of time".

First big problem.  In the case above (which I think of as the typical
one -- certainly the one relevant to the cost of branch mispredicts),
what is in common is the class containing the overridden function, i.e.
the source class Shape for the this pointer.  What varies is the class
where the final overrider resides, i.e. the target class of the this
conversion.  If the target class is the same, there will only be I$
misses the first time; if it varies, we'll get one at least the first
time for each target class.  That will be true whichever implementation
we use, since they all use different adjusting entries for different
overriders.

Furthermore, there's a potential for a D$ miss each time the target
class changes, since the vcall offset is coming from a different vtbl.
That doesn't occur for the "AddAddAdd" implementation, though, which
doesn't load anything from the vtbl.

I think the "3 units of time" is wrong.  An implementation using a
vcall offset has only a this pointer to work with.  It must load the
vptr (2 cycles at least on most modern implementations I know of, with
a cache hit, which it will always get because the caller just used it),
add a displacement to the vcall offset (1 cycle), load the vcall offset
(2 cycles plus possible D$ miss), and add the vcall offset (1 cycle).
So I think we get at least 6 cycles for such an implementation.  If I
assume that the usual override chain is short and non-virtual (and
ultimately I think I may be able to use profiling to make it usually
short), at 1 cycle per chain element the "AddAddAdd" method will be
hard to beat.

Next, let's think about "no D$ miss."  In order to have a single
adjusting entry point, it must be able to always find the vcall offsets
for a given target class/overrider (NOT for a given source class) at
the same position relative to the vptr for the source class.  That
means that all of the base classes of a given class with overriders
must have the same layout of vcall offsets.  Aside from the
implications of achieving this (which makes my head hurt), it means in
particular that they can't be with the function "pointers", which are
at different offsets in different bases.  So I don't think "no D$ miss"
is actually a likely scenario.

> Summary:
> 
> + The best case is clearly the 'AddAddAdd' for a limited number of offsets. No
> argument.
> 
> + The second is adjusting entry point with no D-cache miss. This scenario is
> between 1 and 3 times as bad as the previous one, depending on the number of
> adds.
> 
> + For third position, there is a tie speed-wise between the thunks and the
> adjusting entry point with D-cache miss, but then I believe the adjusting
> entry-point wins memory-wise except in pathological cases where padding would
> dominate. Speed-wise, this scenario is about 3 times as bad as scenario 2.
> 
> 
> As a reminder, the numbers I gave were  the following (I added memory usage):
> 
>                         Best    Typical Worst	I-mem	D-mem
>         Thunks          5       9       20	16*F*C	0
>         AddAddAdd       0+N/M   0+N/M   9+N/M	16*F*C	0
>         Adjust          3       3       18	48*F	8*C+Pad
>         Adjust/D-miss   8       8       21	48*F	8*C+Pad
> 
> C: number of secondary bases requiring adjustments. F: Number of virtual
> functions overriden in current class.

The I-mem case (16*F*C) isn't quite right.  Instead of F*C entries, you
need what I'll call F', meaning that you count all of the overridden
instances of f's, leaving out those with the same adjustment for the
same f.  The point is that just because C requires an adjustment for
one f, it might not require one for all the others (e.g. because some
of them don't define all of the overridden functions).

I don't fully understand some of the other entries, but beyond the
above comment about best case being at least 6, I suspect that they
don't matter much.  It looks to me like "AddAddAdd" is so much better
that the alternative isn't worth the complications it introduces.
But of course I may be misinterpreting things badly -- please comment
if so.

To answer the question of the Subject:  I haven't reopened issue B-1,
and think that before doing so we should see both a precise proposal
for how an alternate implementation would lay out the vcall offsets,
and a cleaned-up cost analysis based on the new proposal.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Mar  1 09:30:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 01:30:24 -0800 (PST)
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
References: <20000222114354R.mitchell@codesourcery.com>
    <u9r9e3pxoo.fsf@yorick.cygnus.com>
Message-ID: <200003010930.BAA36379@baalbek.engr.sgi.com>

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> Jason Merrill wrote:
> > 
> > >>>>> Mark Mitchell <mark at codesourcery.com> writes:
> > 
> >  >   o GP/address pairs in vtables
> > 
> >  >     This one concerns me the most.  I don't even know if there's
> >  >     any kind of standard assembly syntax for this.  Is there?
> >  >     (If not, there should be -- otherwise, you can't say -S to your
> >  >     compiler and get anything sensible out.)
> > 
> > Richard Henderson still doesn't believe that there's a suitable reloc for
> > this in the base ABI, and apparently I forgot to write up his explanation
> > for a wider audience.  Richard, care to repeat it in a less transient
> > medium?
> 
> Ah, here is the text:
> 
> Richard Henderson of Cygnus points out that the IA-64 relocations don't
> really support doing this.  However, the R_IA_64_IPLT*SB relocations do
> perform the correct action.  The problem is that they are currently
> specified to be valid only in executables and shared objects.  I
> believe that the problem can be solved by simply removing this
> restriction.  The static linker support required shouldn't be major --
> it would presumably just pass the relocations through to the linked
> object and let the dynamic linker deal with them.
> 
> Did this change?

The ABI group thought this was reasonable at its last meeting.  I've
submitted proposed replacement wording for the description of
R_IA_64_IPLT*SB with the effect of allowing them in relocatable
objects, and the ABI group members should be doing any necessary
checking with their linker and C++ people with the intent of resolving
this at our next meeting (mid-March).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From rth at cygnus.com  Wed Mar  1 10:31:21 2000
From: rth at cygnus.com (Richard Henderson)
Date: Wed, 1 Mar 2000 02:31:21 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <200003010930.BAA36379@baalbek.engr.sgi.com>; from Jim Dehnert on Wed, Mar 01, 2000 at 01:30:24AM -0800
References: <20000222114354R.mitchell@codesourcery.com> <u9r9e3pxoo.fsf@yorick.cygnus.com> <200003010930.BAA36379@baalbek.engr.sgi.com>
Message-ID: <20000301023121.A1705@cygnus.com>

On Wed, Mar 01, 2000 at 01:30:24AM -0800, Jim Dehnert wrote:
> The ABI group thought this was reasonable at its last meeting.  I've
> submitted proposed replacement wording for the description of
> R_IA_64_IPLT*SB with the effect of allowing them in relocatable
> objects...

I think it's unreasonable.  If we want this kind of relocation
we should invent a new relocation type.  Which I don't necessarily
think is unreasonable, but a pure pic solution without any runtime
relocation requirement might be better.

IPLT just has too many other semantics.

What exactly are you going to do when IPLT appears in a relocatable
object, referencing a dynamic symbol, and so needs to be copied into
the dso?  How are you going to differentiate that from an IPLT reloc
that is associated with the .IA_64.pltoff array? 



r~



From cary at cup.hp.com  Wed Mar  1 18:01:37 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 1 Mar 2000 10:01:37 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
Message-ID: <200003011801.KAA21493@adlmail.cup.hp.com>

>I think it's unreasonable.  If we want this kind of relocation
>we should invent a new relocation type.  Which I don't necessarily
>think is unreasonable, but a pure pic solution without any runtime
>relocation requirement might be better.
>
>IPLT just has too many other semantics.
>
>What exactly are you going to do when IPLT appears in a relocatable
>object, referencing a dynamic symbol, and so needs to be copied into
>the dso?  How are you going to differentiate that from an IPLT reloc
>that is associated with the .IA_64.pltoff array? 

The IPLT relocations have *exactly* the right semantics. It's just like 
the DIR relocations, which, when used in a relocatable object, pass 
through to the shared object as dynamic relocations -- the relocation has 
the same meaning, but it can only be applied at load time. 

The IPLT relocations were designed (it's not "sheer luck," as Christophe 
put it) to support the relocation of a function descriptor, and that's 
exactly what you need to relocate a function descriptor in the vtable. If 
you see it in a relocatable object, you have to pass the relocation 
through to the shared object, so the descriptor can be relocated at load 
time.

There are no other semantics associated with the IPLT relocations. You 
might be reading more into the description than is intended: when it 
refers to initializing it with a copy of the official function 
descriptor, that's analogous to a DIR relocation initializing the target 
with a copy of the address of the referenced symbol. All it really means 
is that the first doubleword should point to the function's entry point, 
and the second doubleword should contain the appropriate gp value.

-cary



From ddd at cup.hp.com  Wed Mar  1 19:57:10 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 01 Mar 2000 19:57:10 +0000
Subject: Do we need to reopen B1?
References: <38B5A340.BF809D85@cup.hp.com> <u9d7pmmdfd.fsf@yorick.cygnus.com> <200003010922.BAA36606@baalbek.engr.sgi.com>
Message-ID: <38BD7616.2BCC8F8D@cup.hp.com>

Jim Dehnert wrote:
> 
> There are a number of things about the analysis here that are bothering
> me.  Please bear with me while I describe them, and let me know where
> I'm mixed up :).
> 

> >       for (i = 0; i < max; i++)
> >       {
> >               Shape *shape = shapes[i];
> >               shape->SetColor(red);
> >               shape->Scale(3.0);
> >               shape->Rotate(2.5);
> >               shape->Draw();
> >       }
> >
 
> First big problem.  In the case above (which I think of as the typical
> one -- certainly the one relevant to the cost of branch mispredicts),
> what is in common is the class containing the overridden function, i.e.
> the source class Shape for the this pointer.  What varies is the class
> where the final overrider resides, i.e. the target class of the this
> conversion.  If the target class is the same, there will only be I$
> misses the first time; if it varies, we'll get one at least the first
> time for each target class.  That will be true whichever implementation
> we use, since they all use different adjusting entries for different
> overriders.
> 
> Furthermore, there's a potential for a D$ miss each time the target
> class changes, since the vcall offset is coming from a different vtbl.
> That doesn't occur for the "AddAddAdd" implementation, though, which
> doesn't load anything from the vtbl.

AddAddAdd is always the best. No argument. If you can use AddAddAdd, use it.

If everything is in the cache, which is also a common occurence (code is small
enought, or number of targets is small enough), then you are in the 'Best'
column, and this case is 5 for thunks, 3 for adjusting entry point, so the
adjusting entry point still wins. Actually, if you are really really lucky and
hammer on that code a lot, you may even get 3 for the thunk solution (the
document I have strongly implies this is quite unlikely after an indirect
branch)


The interesting case is obviously when the final overriding class changes. Say
that we have 2 possible final overriders, A and B, and say that for the
particular pointer instance, we have A::SetColor, A::Scale and then B::Rotate,
B::Draw.

On the thunks approach we have:

1/ Shape->A thunk for A::SetColor: One I-cache miss for the thunk (never seen
before), one I-cache miss for A::SetColor (the thunk is not close enough)

2/ Shape->A thunk for A::Scale: Same thing. There is no reason that any of the
I-misses above gave us anything

3/ Shape->B thunk for B::Rotate: Idem

4/ Shape->B thunk for B::Draw: Item.

So we have 2 I-cache misses each time. If on the next iteration the dynamic type
are C and D, we will get the same misses again. In other words, we can expect 8
I-cache misses per iteration in the worst case.


On the adjustment approach, we have:

1/ Shape->A vcall offset D-cache miss, read from the Shape vtable. One I-cache
miss only, since we fall through.

2/ Shape->A vcall offset again, read from the A::Scale adjusting entry point
through the same Shape vtable. This one, I believe, is in the D-cache. We have
one I-cache miss.

3/ Shape->B vcall offset, relative to the Shape vtable, read before entering
B::Rotate: This one has no strong guarantees. However, we can stuff something
like 4 or 8 adjustments per cache line, so the chances that reading the Shape->A
vcall offset would also have brought in the Shape->B vcall offset are non zero.
We have one I-cache miss.

4/ Shape->B vcall offset, relative to the Shape vtable, read before entering
B::Draw. No D-cache miss, likely I-cache miss.

Here, we would expect 4 I-cache misses and 2 D-cache misses. Please feel free to
re-run this scenario with A, B, C, D (no benefit of one vs. the other), A, A, A,
A (only one D-cache miss), etc.


What I was trying to say is: I believe adjustment it is better than thunks in
the 'best' case, and when it degrades, it would probably degrade better on
typical code I can think of.



> 
> I think the "3 units of time" is wrong.  An implementation using a
> vcall offset has only a this pointer to work with.  It must load the
> vptr (2 cycles at least on most modern implementations I know of, with
> a cache hit, which it will always get because the caller just used it),
> add a displacement to the vcall offset (1 cycle), load the vcall offset
> (2 cycles plus possible D$ miss), and add the vcall offset (1 cycle).
> So I think we get at least 6 cycles for such an implementation.  If I
> assume that the usual override chain is short and non-virtual (and
> ultimately I think I may be able to use profiling to make it usually
> short), at 1 cycle per chain element the "AddAddAdd" method will be
> hard to beat.

First, the sequence you are proposing is not what I described. Loading the vptr
is unnecessary, because the correct vptr has just been loaded. As I indicated in
the initial description, this assumes we define at the ABI level which register
we load the vptr into (just as we do for the 'this' pointer.)

Second: Most of the timing information is, I believe, not disclosed by Intel for
Merced, and certainly not for McKinley. I stick to my relative values, but I
never said they were cycles, and I did say that I had substracted some constant
costs that were assumed identical in all hypothesis (even if these costs are
cache miss costs which vary from execution to execution but would be identical
between two models, such as an initial I-cache miss at the begining of the
code).

Hint: an indirect branch is more likely to have a cost impact on a subsequent
branch than on a subsequent load. If you substract the cost that is common
between the two, you may end up with 1 and 0, even though neither executes in 0
cycles.


> Next, let's think about "no D$ miss."  In order to have a single
> adjusting entry point, it must be able to always find the vcall offsets
> for a given target class/overrider (NOT for a given source class) at
> the same position relative to the vptr for the source class.  That
> means that all of the base classes of a given class with overriders
> must have the same layout of vcall offsets.

That's correct.

>  Aside from the
> implications of achieving this (which makes my head hurt),

You cannot achieve in general that without holes (unused entries). Holes appear
in particular if you have:

struct Left: B1, B2, B3, B4, ... B99 {}
struct Right: C1 {}
struct Derived: Primary, Left, Right {}

In that case, with a dumb algorithm, there will be 98 unused vcall entries in
the vtable for Right. In practice, I don't think this is a real problem
(compared to the overall cost of the vtable in the above case, assuming we
duplicate function descriptors, etc)


> >
> > As a reminder, the numbers I gave were  the following (I added memory usage):
> >
> >                         Best    Typical Worst I-mem   D-mem
> >         Thunks          5       9       20    16*F*C  0
> >         AddAddAdd       0+N/M   0+N/M   9+N/M 16*F*C  0
> >         Adjust          3       3       18    48*F    8*C+Pad
> >         Adjust/D-miss   8       8       21    48*F    8*C+Pad
> >
> > C: number of secondary bases requiring adjustments. F: Number of virtual
> > functions overriden in current class.
> 
> The I-mem case (16*F*C) isn't quite right.  Instead of F*C entries, you
> need what I'll call F', meaning that you count all of the overridden
> instances of f's, leaving out those with the same adjustment for the
> same f.  The point is that just because C requires an adjustment for
> one f, it might not require one for all the others (e.g. because some
> of them don't define all of the overridden functions).

That's a more precise count. It doesn't change the fact that 16 > 8 and F' is in
all likelyhood > 1 (at least for the pathological case we are dealing with.)


> I suspect that they
> don't matter much.  It looks to me like "AddAddAdd" is so much better
> that the alternative isn't worth the complications it introduces.

I don't plan to replace AddAddAdd. I plan to replace thunks as the "backup"
solution when AddAddAdd become too costly.

What I'm suggesting is:

1/ if you have less than (say) 5 different displacements and no multiple
inheritance, use "AddAddAdd" (not required by the ABI).

2/ When you have more than 5 different displacements and no virtual base, add a
vcall entry in each secondary vtable which requires a displacement (required by
the ABI) and emit and adjusting entry point rather than emitting thunks (not
required by the ABI). We could add a rule saying that we do that only if this
does not involve unreasonable padding.

3/ In all other cases (in particular in the presence of virtual bases), emit
thunks


Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Wed Mar  1 20:53:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 12:53:07 -0800 (PST)
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
Message-ID: <200003012053.MAA37822@baalbek.engr.sgi.com>

>I think it's unreasonable.  If we want this kind of relocation
>we should invent a new relocation type.  Which I don't necessarily
>think is unreasonable, but a pure pic solution without any runtime
>relocation requirement might be better.
>
>IPLT just has too many other semantics.

???  IPLT has very simple semantics:  Here's a function descriptor,
here's the function it refers to, fill in the descriptor with the
function's address and GP.  No more, no less.  All we're suggesting is
removal of the restriction that it not occur in relocatable objects.

>What exactly are you going to do when IPLT appears in a relocatable
>object, referencing a dynamic symbol, and so needs to be copied into
>the dso?  How are you going to differentiate that from an IPLT reloc
>that is associated with the .IA_64.pltoff array? 

We want the linker to transfer the relocation to the output object file
for resolution by the dynamic linker.  The dynamic linker should handle
them exactly like it does the .IA_64.pltoff relocations -- the
semantics is identical.  So they don't need to be differentiated.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From ddd at cup.hp.com  Wed Mar  1 22:18:23 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 01 Mar 2000 22:18:23 +0000
Subject: Issue B1: Let's move on
Message-ID: <38BD972F.7E9DDFFA@cup.hp.com>

Folks,


I believe I'm now in the same state of mind I was in December... I do believe
there is something to be gained with my scheme, but certainly not enough that we
delay all the more important stuff. For now, stubs will do for me. And
AddAddAdd, of course.

We can discuss this for the ABI version 2. But I propose we do not discuss it
tomorrow.


Christophe
PS: Please keep this message as a reminder for next time I bring that up :-)



From dehnert at baalbek.engr.sgi.com  Wed Mar  1 22:33:38 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 14:33:38 -0800 (PST)
Subject: Issue B1: Vptr (was Let's move on)
Message-ID: <200003012233.OAA38019@baalbek.engr.sgi.com>

> I believe I'm now in the same state of mind I was in December... I do believe
> there is something to be gained with my scheme, but certainly not enough
> that we delay all the more important stuff. For now, stubs will do for me.
> And AddAddAdd, of course.
> 
> We can discuss this for the ABI version 2. But I propose we do not discuss it
> tomorrow.

OK.  One thing came up in Christophe's previous mail, though.  Has
anyone else been assuming that the vptr as well as "this" would be
passed to virtual functions, for whatever reason?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Wed Mar  1 22:43:17 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 01 Mar 2000 14:43:17 -0800
Subject: Issue B1: Vptr (was Let's move on)
In-Reply-To: <200003012233.OAA38019@baalbek.engr.sgi.com>
References: <200003012233.OAA38019@baalbek.engr.sgi.com>
Message-ID: <20000301144317V.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> OK.  One thing came up in Christophe's previous mail, though.
    Jim> Has anyone else been assuming that the vptr as well as "this"
    Jim> would be passed to virtual functions, for whatever reason?

Not I.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From rth at cygnus.com  Wed Mar  1 23:05:22 2000
From: rth at cygnus.com (Richard Henderson)
Date: Wed, 1 Mar 2000 15:05:22 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <200003012053.MAA37822@baalbek.engr.sgi.com>; from Jim Dehnert on Wed, Mar 01, 2000 at 12:53:07PM -0800
References: <200003012053.MAA37822@baalbek.engr.sgi.com>
Message-ID: <20000301150522.A16981@cygnus.com>

On Wed, Mar 01, 2000 at 12:53:07PM -0800, Jim Dehnert wrote:
> The dynamic linker should handle them exactly like it does
> the .IA_64.pltoff relocations -- the semantics is identical.
> So they don't need to be differentiated.

No, not exactly like.  When we're doing lazy binding the
.IA_64.pltoff entries are initially only adjusted for the
load address of the dso.

So you're planning on treating .rel.IA_64.pltoff specially.

Which means there ought to be additional guarantees by the
IA-64 ABI that are not provided by the generic ELF ABI.
Namely, that .rel.IA_64.pltoff is not included in DT_RELA/DT_RELASZ.



r~



From ddd at cup.hp.com  Wed Mar  1 23:43:05 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 01 Mar 2000 23:43:05 +0000
Subject: Issue B1: Vptr (was Let's move on)
References: <200003012233.OAA38019@baalbek.engr.sgi.com> <20000301144317V.mitchell@codesourcery.com>
Message-ID: <38BDAB09.64DCC56B@cup.hp.com>

Mark Mitchell wrote:
> 
> >>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>     Jim> OK.  One thing came up in Christophe's previous mail, though.
>     Jim> Has anyone else been assuming that the vptr as well as "this"
>     Jim> would be passed to virtual functions, for whatever reason?
> 
> Not I.

I did not either, but thinking about it, it might be useful for virtual base
adjustments.


Christophe



From jason at cygnus.com  Wed Mar  1 23:53:41 2000
From: jason at cygnus.com (Jason Merrill)
Date: 01 Mar 2000 15:53:41 -0800
Subject: Issue B1: Vptr (was Let's move on)
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Wed, 1 Mar 2000 14:33:38 -0800 (PST)"
References: <200003012233.OAA38019@baalbek.engr.sgi.com>
Message-ID: <u9g0uadz7e.fsf@yorick.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 > OK.  One thing came up in Christophe's previous mail, though.  Has
 > anyone else been assuming that the vptr as well as "this" would be
 > passed to virtual functions, for whatever reason?

No.

Jason



From dehnert at baalbek.engr.sgi.com  Thu Mar  2 00:50:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 16:50:24 -0800 (PST)
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
References: <200003012053.MAA37822@baalbek.engr.sgi.com>
Message-ID: <200003020050.QAA39542@baalbek.engr.sgi.com>

> From rth at cygnus.com  Wed Mar  1 15:05:46 2000
> 
> On Wed, Mar 01, 2000 at 12:53:07PM -0800, Jim Dehnert wrote:
> > The dynamic linker should handle them exactly like it does
> > the .IA_64.pltoff relocations -- the semantics is identical.
> > So they don't need to be differentiated.
> 
> No, not exactly like.  When we're doing lazy binding the
> .IA_64.pltoff entries are initially only adjusted for the
> load address of the dso.
> 
> So you're planning on treating .rel.IA_64.pltoff specially.
> 
> Which means there ought to be additional guarantees by the
> IA-64 ABI that are not provided by the generic ELF ABI.
> Namely, that .rel.IA_64.pltoff is not included in DT_RELA/DT_RELASZ.

OK, now I understand your issue, at least.  But the vtable might
actually benefit as much or more from lazy binding.  This does raise
another issue, though.  We found on MIPS that lazy binding had
occasional obnoxious interactions with optimization, e.g. when the
optimizer moves the load of the lazy-bound function pointer out of a
loop, and ends up calling rld (ld.so) every iteration.  I would not
object to having two versions of the relocation that allow or don't
allow lazy binding, but that seems orthogonal to the issue at hand.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar  2 01:30:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 1 Mar 2000 17:30:06 -0800 (PST)
Subject: Agenda for tomorrow (2 March 2000)
Message-ID: <200003020130.RAA38036@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

The agenda is based on these priorities:

  A) Data layout and virtual function calls.

  B) Mangling.

  C) Exception handling.

So, take a look at the material associated with these issues:

  1) B-1:  Any residual questions concerning what is specified?
     Is the current writeup in abi-layout sufficiently clear?
     How about the code examples and implementation discussion in
     abi-examples?

  2) Choose ABI namespace -- abi::, __abi::, or ?.

  3) A-26/27:  Null pointer-to-member representation.

  4) A-23:  RTTI class descriptors.  I think the only remaining issue
     is whether to keep the has-public-base flag.  Nathan has an action
     item to validate its utility, so I suggest that we close it
     (keeping the flag) and use the action item to track the question.

  5) B-9:  Primary base vtable embedding.  Do we want to: (a) put
     additional vfunc pointers after the secondary vtables, (b) promote
     non-virtual bases' vbase pointers, or (c) do nothing?

  6) C-4:  Construction vtables.  This is a significant issue -- please
     look at Coleen's proposal (in the layout document) carefully, if
     you haven't already.

  7) C-11:  Array constructors.  Do we want a special interface?

  8) C-12:  Return value of constructors.  void?  this?

  9) F-*:  Mangling.

  9) D-12:  Unwind table location.

Issues that are active and awaiting proposals:

  a)  A-24:  Incomplete type RTTI (alternate proposal from Christophe).

  b)  F-*:  Mangling (updated proposal from Daveed).

Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Thu Mar  2 09:27:34 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 02 Mar 2000 01:27:34 -0800
Subject: Reopen A-20/A-21?
Message-ID: <20000302012734G.mitchell@codesourcery.com>


I believe the resolution to A-20/A-21, dealing with array new, is
incorrect with respect to the C++ standard.  (In other words, I think
we'll make it impossible to implement the behavior required by the
standard.)

In particular, there are situations in which we do not allocate
cookies, even when allocating arrays of class type.

But, the standard guarantees that:

  [class.free]

  When  a delete-expression is executed, the selected deallocation func-
  tion shall be called with the address of the block of  storage  to  be
  reclaimed  as  its  first  argument and (if the two-parameter style is
  used) the size of the block as its second argument.3)

That paragraph doesn't require that the class type have a non-trivial
destructor.

I think that means the first bullet:

  No cookie is required if the array element type T has a trivial
  destructor (C++ standard, 12.4/3).

should read:

  No cookie is required if the array element type T has a trivial
  destructor ([class.dtor]) and the usual (array) deallocation
  function ([basic.stc.dynamic.deallocation]) function does not take 
  two arguments.

  (Note: if the usual array deallocation functions takes two
  arguments, then its second argument is of type size_t.  The standard
  guarantees that this function will be passed the number of bytes
  allocated with the previous array new expression.  See [class.free]
  for details.)

Let's either prove me wrong, or accept this resolution, tomorrow.  It
shouldn't take long either way.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Thu Mar  2 11:54:17 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 12:54:17 +0100
Subject: Agenda for tomorrow (2 March 2000)
In-Reply-To: <200003020130.RAA38036@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003020130.RAA38036@baalbek.engr.sgi.com>
Message-ID: <200003021154.MAA06528@pandora>

>   B) Mangling.

What is the latest proposal here? I have one version in reply to the
Feb 17 agenda, but if possible, I'd prefer to have the latest draft on
the Web.

Thanks,
Martin



From loewis at informatik.hu-berlin.de  Thu Mar  2 12:31:21 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 13:31:21 +0100
Subject: Agenda for tomorrow (2 March 2000)
In-Reply-To: <200003021154.MAA06528@pandora> (message from Martin von Loewis
	on Thu, 2 Mar 2000 12:54:17 +0100)
References: <200003020130.RAA38036@baalbek.engr.sgi.com> <200003021154.MAA06528@pandora>
Message-ID: <200003021231.NAA06976@pandora>

> What is the latest proposal here?

Oops, found it in the abi-layout document.

Martin



From loewis at informatik.hu-berlin.de  Thu Mar  2 13:46:30 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 14:46:30 +0100
Subject: Mangling issues
Message-ID: <200003021346.OAA07335@pandora>

While reviewing the mangling spec, I found a number of open questions,
which you may want to consider today:

1. When compressing names using S backward references, is the usage of
   such a backward reference a type as well? I.e. given

   void foo(Hello,World,World,Hello)

   is this 

   _Z3foo5Hello5WorldS1_S3_

   or is this

   _Z3foo5Hello5WorldS1_S2_

   instead (in which case the occurence of S1_ would not be counted as
   a type). My feeling is that those backward references count as
   types themselves, so the first answer would be correct.

2. When composing types using qualifiers, do the nested types get
   numbers as well? I.e. given

   void foo(Hello&,Hello,Hello&)

   is that

   _Z3fooR5Hello5HelloS2_

   (as suggested by example 7), or is there a way to refer to Hello
   already in the second parameter - even though the first parameter
   is Hello&, not Hello. If so, do the enclosed types come before or
   after the composed types, i.e. is the example mangled as

   _Z3fooR5HelloS1_S3_

   or is it

   _Z3fooR5HelloS2_S2_

   Also, if there is a way to refer back to a composed type either by
   composing it again, or by referring to a earlier composition -
   which one must be used? E.g. in the third parameter, it could be
   either one of above solutions, or, say

   _Z3fooR5HelloS1_RS1_

   This alternative uses the most recent encoding of Hello, and
   composes it to get something that is strictly shorter than the
   uncompressed version. Of course, referring to a less recent but
   more composed type would give better compression.

Regards,
Martin




From loewis at informatik.hu-berlin.de  Thu Mar  2 14:38:27 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 15:38:27 +0100
Subject: More mangling issues
Message-ID: <200003021438.PAA07593@pandora>

I just started writing a demangler, and found some more problems with
the mangling spec:

Example 8 should read '_Z1fIiEv'; the return type was missing.

For S<number>_ backward references, the spec does not say what the
relative order of template arguments and the specialization is, but
appears to assume that the arguments follow the specialization. That
seems unnatural: Consider

  N1N1TIiiE2mfE

Demangling would proceed by building up a list of types as they are
seen, so the list would be filled, in order

<open a new nested name>
  Process 1N, put "N" into the list
  Process 1T, put "N::T" into the list
  <open a new template argument list>
     Process i, put "int" into the list
     Process i, put "int" into the list
  <complete template arguments:>
  Combine template and arguments, 
    to get specialization N::T<int,int>, put that into the list
  Process 2mf, getting N::T<int,int>::mf
     - how do we know this is not a type?
<close nested name>

So, after this name is processed, my back-references list would be

S1_ N::T<int,int>
S2_ int
S3_ int
S4_ N::T
S5_ N

Or, more generally, the parts of a composed type preceed the complete
type.

Martin



From jason at cygnus.com  Thu Mar  2 02:16:59 2000
From: jason at cygnus.com (Jason Merrill)
Date: 01 Mar 2000 18:16:59 -0800
Subject: Issue B1: Vptr (was Let's move on)
In-Reply-To: Christophe de Dinechin's message of "Wed, 01 Mar 2000 23:43:05 +0000"
References: <200003012233.OAA38019@baalbek.engr.sgi.com> <20000301144317V.mitchell@codesourcery.com> <38BDAB09.64DCC56B@cup.hp.com>
Message-ID: <u9d7pef750.fsf@casey.cygnus.com>

Christophe de Dinechin <ddd at cup.hp.com> writes:

> Mark Mitchell wrote:
> > 
> > >>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> > 
> >     Jim> OK.  One thing came up in Christophe's previous mail, though.
> >     Jim> Has anyone else been assuming that the vptr as well as "this"
> >     Jim> would be passed to virtual functions, for whatever reason?
> > 
> > Not I.
> 
> I did not either, but thinking about it, it might be useful for
> virtual base adjustments.

I am strongly opposed to any caller-side overhead.  Furthermore, this
would make the calling convention for non-static member functions
different from that for other functions, which seems like a lose.

Jason



From daveed at edg.com  Thu Mar  2 16:26:23 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 02 Mar 2000 08:26:23 -0800
Subject: Mangling issues
References: <200003021346.OAA07335@pandora>
Message-ID: <38BE962F.DA12A7BD@edg.com>

Martin von Loewis wrote:
> 
> While reviewing the mangling spec, I found a number of open questions,
> which you may want to consider today:
> 
> 1. When compressing names using S backward references, is the usage of
>    such a backward reference a type as well? I.e. given
> 
>    void foo(Hello,World,World,Hello)
> 
>    is this
> 
>    _Z3foo5Hello5WorldS1_S3_
> 
>    or is this
> 
>    _Z3foo5Hello5WorldS1_S2_
> 
>    instead (in which case the occurence of S1_ would not be counted as
>    a type). My feeling is that those backward references count as
>    types themselves, so the first answer would be correct.

Agreed.

> 2. When composing types using qualifiers, do the nested types get
>    numbers as well? I.e. given
> 
>    void foo(Hello&,Hello,Hello&)
> 
>    is that
> 
>    _Z3fooR5Hello5HelloS2_
> 
>    (as suggested by example 7), or is there a way to refer to Hello
>    already in the second parameter - even though the first parameter
>    is Hello&, not Hello. If so, do the enclosed types come before or
>    after the composed types, i.e. is the example mangled as
> 
>    _Z3fooR5HelloS1_S3_

This is the intent.

>    or is it
> 
>    _Z3fooR5HelloS2_S2_
> 
>    Also, if there is a way to refer back to a composed type either by
>    composing it again, or by referring to a earlier composition -
>    which one must be used? E.g. in the third parameter, it could be
>    either one of above solutions, or, say
> 
>    _Z3fooR5HelloS1_RS1_
> 
>    This alternative uses the most recent encoding of Hello, and
>    composes it to get something that is strictly shorter than the
>    uncompressed version. Of course, referring to a less recent but
>    more composed type would give better compression.

I'll have to work on wording to make the above clear.  Basically, you
must compress a type as soon as you have the opportunity in its
"top-down" traversal (unless the compression enlarges the encoding).
This might sometimes be less optimal in that you must refer to a less
recent type that requires more digits to refer to (but I think that's
unusual).

	Daveed



From loewis at informatik.hu-berlin.de  Thu Mar  2 16:33:00 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 17:33:00 +0100
Subject: Construction vtables
Message-ID: <200003021633.RAA08707@pandora>

I just read the construction vtable passage, and I have some problems
understanding it.

First, the condition under which a class 'has' a VTT is
confusing. What exactly means condition 2), why is this alternative to
condition 1)? In particular, what does 'overridden along a virtual
path' mean? And how could condition 2 be true while condition 1 is
false?

I interpret this as saying: '... has a virtual function in a virtual
base class, which is overridden in a derived class'. So apparently the
class has to have a virtual base, which implies that condition 1 is
already true.

Also, where does the virtual function have to be overridden? In the
complete object, or in the class of the VTT? I'd assume the latter.

IOW, I think this needs to be phrased as

  1. indirect or direct virtual base classes, and
  2. one of the virtual bases is polymorphic (i.e. has virtual
     functions), and
  3. one of the virtual functions is overridden in the class being
     considered crossing a virtual boundary.

It may be possible to relax the conditions (e.g. for gcc, I only
considered 1. and 2.), however, this seems to be the condition that
requires VTT creation in the fewest cases.

Next, the ordering of entries in the individual subobject vtables
seems to be duplicated incorrectly from the normal vtable layout. The
document says, in the VTT section, that vbase offsets come first,
followed by vcall offsets. In "Virtual Table Order", the document says
the contrary. I suggest that the ordering of things in the
construction vtable is the same as in the vtable of a complete object,
and that this is documented by reference, not by duplication.

Finally, it is not clear whose responsibility to provide the VTT
pointer in the most derived object. It appears as if this is the
caller's responsibility. However, it is not clear how this works in
the case of virtual destructors (where the caller may not be aware of
the need for a destruction vtable).

There are two alternative resolutions:
a) the destructor has two entry points, one without destruction vtable
   and one with. If none is provided, the destructor uses the VTT of
   its type, and invokes the dtor with VTT
b) the destructor always takes two arguments, and the caller may fill
   in a value of zero - indicating that this is the most derived type.

The same approach could apply to constructors: a value of zero would
indicate, again, that the constructor has to fetch its VTT itself.

Regards,
Martin




From loewis at informatik.hu-berlin.de  Thu Mar  2 16:39:39 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 17:39:39 +0100
Subject: Mangling issues
In-Reply-To: <38BE962F.DA12A7BD@edg.com> (message from Daveed Vandevoorde on
	Thu, 02 Mar 2000 08:26:23 -0800)
References: <200003021346.OAA07335@pandora> <38BE962F.DA12A7BD@edg.com>
Message-ID: <200003021639.RAA08816@pandora>

> This is the intent.

Good.

> I'll have to work on wording to make the above clear.  Basically,
> you must compress a type as soon as you have the opportunity in its
> "top-down" traversal (unless the compression enlarges the encoding).
> This might sometimes be less optimal in that you must refer to a
> less recent type that requires more digits to refer to (but I think
> that's unusual).

I agree, and look forward to an updated version of the spec.

Martin



From loewis at informatik.hu-berlin.de  Thu Mar  2 16:47:04 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 17:47:04 +0100
Subject: Reopen A-20/A-21?
In-Reply-To: <20000302012734G.mitchell@codesourcery.com> (message from Mark
	Mitchell on Thu, 02 Mar 2000 01:27:34 -0800)
References: <20000302012734G.mitchell@codesourcery.com>
Message-ID: <200003021647.RAA08880@pandora>

> Let's either prove me wrong, or accept this resolution, tomorrow.

It seems you are right.

Martin



From coleen at zko.dec.com  Thu Mar  2 17:07:41 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 2 Mar 2000 12:07:41 -0500
Subject: Construction vtables
Message-ID: <200003021707.AA10529@philli.zko.dec.com>

> Reply-To: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> I just read the construction vtable passage, and I have some problems
> understanding it.
> 
> First, the condition under which a class 'has' a VTT is
> confusing. What exactly means condition 2), why is this alternative to
> condition 1)? In particular, what does 'overridden along a virtual
> path' mean? And how could condition 2 be true while condition 1 is
> false?
> 
> I interpret this as saying: '... has a virtual function in a virtual
> base class, which is overridden in a derived class'. So apparently the
> class has to have a virtual base, which implies that condition 1 is
> already true.
> 

Yes it is true.  I wrote this section based on a combination of the code I
had and the code that I was going to write.  The second condition doesn't
make sense anymore, because the construction vtable in this
document is the whole vtable for the base class, including the vtables
for the base class subobjects.  The second condition was to eliminate
generating construction vtables for some base class subobjects, but if
we do that, it changes the VTT layout and breaks the virtual base
offset field in rtti.

Contrary to my earlier mail, the order of sub-obj-vtables can be left to
right dfs traversal of the class hierarchy, as specified in the section
on vtable layout.  Or not specified, as pointed out by Mark Mitchell
about 2 weeks ago.

> Also, where does the virtual function have to be overridden? In the
> complete object, or in the class of the VTT? I'd assume the latter.
> 
> IOW, I think this needs to be phrased as
> 
>   1. indirect or direct virtual base classes, and
>   2. one of the virtual bases is polymorphic (i.e. has virtual
>      functions), and
>   3. one of the virtual functions is overridden in the class being
>      considered crossing a virtual boundary.
> 
> It may be possible to relax the conditions (e.g. for gcc, I only
> considered 1. and 2.), however, this seems to be the condition that
> requires VTT creation in the fewest cases.

I think only condition 1 applies.  If base class accesses
its virtual bases during construction, the offsets in the virtual
base part of the vtable will be wrong if it's part of a more
derived class with a different layout.

> 
> Next, the ordering of entries in the individual subobject vtables
> seems to be duplicated incorrectly from the normal vtable layout. The
> document says, in the VTT section, that vbase offsets come first,
> followed by vcall offsets. In "Virtual Table Order", the document says
> the contrary. I suggest that the ordering of things in the
> construction vtable is the same as in the vtable of a complete object,
> and that this is documented by reference, not by duplication.

Oh, yes, the ordering should be exactly the same.  I forgot where
the vcall offsets were.

> 
> Finally, it is not clear whose responsibility to provide the VTT
> pointer in the most derived object. It appears as if this is the
> caller's responsibility. However, it is not clear how this works in
> the case of virtual destructors (where the caller may not be aware of
> the need for a destruction vtable).
> 
> There are two alternative resolutions:
> a) the destructor has two entry points, one without destruction vtable
>    and one with. If none is provided, the destructor uses the VTT of
>    its type, and invokes the dtor with VTT
> b) the destructor always takes two arguments, and the caller may fill
>    in a value of zero - indicating that this is the most derived type.
> 
> The same approach could apply to constructors: a value of zero would
> indicate, again, that the constructor has to fetch its VTT itself.

Doesn't the ABI spec call for complete object ctor/dtors which would
create the VTT and subobject ctors/dtors that recieve the VTT in their
argument list?

I'm trying to implement what I specified now, so I anticipate some more
changes.   Don't discuss it at the con-call today.  I can't be there.

Thanks,
Coleen
> 
> Regards,
> Martin
> 
> 



From loewis at informatik.hu-berlin.de  Thu Mar  2 17:59:59 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 2 Mar 2000 18:59:59 +0100
Subject: Construction vtables
In-Reply-To: <200003021707.AA10529@philli.zko.dec.com> (message from Coleen
	Phillimore on Thu, 2 Mar 2000 12:07:41 -0500)
References: <200003021707.AA10529@philli.zko.dec.com>
Message-ID: <200003021759.SAA09586@pandora>

> I think only condition 1 applies.  If base class accesses its
> virtual bases during construction, the offsets in the virtual base
> part of the vtable will be wrong if it's part of a more derived
> class with a different layout.

Right. I was still assuming vbase pointers in the object (which g++
currently does), and forgetting that vbase offsets are in the vtable.

> Doesn't the ABI spec call for complete object ctor/dtors which would
> create the VTT and subobject ctors/dtors that recieve the VTT in their
> argument list?

What do you mean by 'create'? Dynamically, at run-time? I hope not.
The VTTs should be emitted statically according to some rule (probably
together with the vtables), and would get a certain external mangled
name. Also, constructors and destructors in classes with VTTs would
have a second implicit parameter (after this), which is the VTT
pointer.

My question is what the calling convention for destructors is. It
can't be 'caller passes VTT pointers', considering

struct Base{
  virtual ~Base();  //Base::~Base does not take VTT
};

struct Derived:virtual Base{
  ~Derived();  //~Derived does expect VTT
};

int main(){
  Base *b = new Derived;  // compiler may know to pass __VTT__Derived
  delete b;               // compiler cannot know to what VTT to pass
}

I think it must be specified what the caller passes in the VTT. Here
is my proposal, again:

  The caller passes 0 to as the VTT parameter of a constructor of a
  class with a VTT. It always passes 0 to the destructor, no matter
  whether the class has a VTT or not.

That way, a dtor in a class with VTT would look like this

Derived::~Derived(vtable **VTT){
  if (VTT==0) VTT = __VTT__Derived;
  this->vptr = VTT[0];
  ...
}

The alternative is that the caller passes the right VTT always, which
means that there need to be two destructor entry points in case of
virtual destructors.

Regards,
Martin



From ddd at cup.hp.com  Thu Mar  2 18:21:59 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 02 Mar 2000 18:21:59 +0000
Subject: Issue B1: Vptr (was Let's move on)
References: <200003012233.OAA38019@baalbek.engr.sgi.com> <20000301144317V.mitchell@codesourcery.com> <38BDAB09.64DCC56B@cup.hp.com> <u9d7pef750.fsf@casey.cygnus.com>
Message-ID: <38BEB147.6915FE87@cup.hp.com>

Jason Merrill wrote:
> 
> Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
> > Mark Mitchell wrote:
> > >
> > > >>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> > >
> > >     Jim> OK.  One thing came up in Christophe's previous mail, though.
> > >     Jim> Has anyone else been assuming that the vptr as well as "this"
> > >     Jim> would be passed to virtual functions, for whatever reason?
> > >
> > > Not I.
> >
> > I did not either, but thinking about it, it might be useful for
> > virtual base adjustments.
> 
> I am strongly opposed to any caller-side overhead.  Furthermore, this
> would make the calling convention for non-static member functions
> different from that for other functions, which seems like a lose.

The only caller-side overhead I can think of is that you add a constraint on the
register allocation for the temporary that will hold the vptr. Something like:
before the long branch, r8 is live and contains rptr. I take r8 because it is to
be garbled by the return value anyway, so it is "free" for any other use.

Do you believe the cost is significant? Could you explain why?


Regards,
Christophe



From rth at cygnus.com  Thu Mar  2 19:01:23 2000
From: rth at cygnus.com (Richard Henderson)
Date: Thu, 2 Mar 2000 11:01:23 -0800
Subject: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <200003020050.QAA39542@baalbek.engr.sgi.com>; from Jim Dehnert on Wed, Mar 01, 2000 at 04:50:24PM -0800
References: <200003012053.MAA37822@baalbek.engr.sgi.com> <200003020050.QAA39542@baalbek.engr.sgi.com>
Message-ID: <20000302110123.E21555@cygnus.com>

On Wed, Mar 01, 2000 at 04:50:24PM -0800, Jim Dehnert wrote:
> OK, now I understand your issue, at least.  But the vtable might
> actually benefit as much or more from lazy binding.

An interesting thought.  I suppose it might could even be made to work,
though you'd have to do odd things like put entries in .rel.IA-64.pltoff
that aren't against .IA-64.pltoff.  Or some other variant that gets it
covered by the DT_JMPREL array. 

You'd also need a minimal plt entry for each vtable entry.  That's
16 bytes a pop, and large dynamicly linked C++ applications might
start filling up the 1M(?) entry limit on minplt entries.  That limit
could be extended by changing the linker to use a different minplt
format for entries farther than a simple branch allows...

Well, perhaps this'll convince people to use STV_INTERNAL and the like.


r~



From dehnert at baalbek.engr.sgi.com  Thu Mar  2 21:36:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 2 Mar 2000 13:36:40 -0800 (PST)
Subject: Agenda for tomorrow (2 March 2000)
References: <200003020130.RAA38036@baalbek.engr.sgi.com>
Message-ID: <200003022136.NAA03335@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar  2 03:54:30 2000
> 
> >   B) Mangling.
> 
> What is the latest proposal here? I have one version in reply to the
> Feb 17 agenda, but if possible, I'd prefer to have the latest draft on
> the Web.

The latest version is that in the abi-layout.html/pdf document.  We
identified a couple more loose ends for the list today, and I asked
people to start trying to define answers for the loose ends for next
week.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar  2 22:20:49 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 2 Mar 2000 14:20:49 -0800 (PST)
Subject: today's con-call
Message-ID: <200003022220.OAA03506@baalbek.engr.sgi.com>

> From coleen at zko.dec.com  Thu Mar  2 09:11:01 2000
> 
> Jim,
> I can't make the con-call today because my husband (who usually
> watches the kids while I'm con-calling) is there this week.  Too
> bad I couldn't get him to represent me.

What good is he, then, anyway?  :-)  Anyway, no problem.

> I'm in the process of implementing construction vtables as I've
> specified, rather than the straight EDG way I had them, and I'll
> have some changes.  I'm also concerned about how gigantic they're
> coming out.  This is without the ever-expanding vcall offsets.

We shrunk them back.  But we did re-expand the vbase offsets today.
They shouldn't be so bad, though...

> I'm thinking of flying out for one of these meetings - possibly
> 2-3 weeks from now.  Can we arrange to talk about construction
> vtables and get people on site for that meeting?

Sure.  (Well, we can ASK people to be onsite, and some will come...)
It'll be good to see you face-to-face!  (And the opportunity may
convince more to come.)

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Mar  3 01:54:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 2 Mar 2000 17:54:47 -0800 (PST)
Subject: Array constructor/destructor update
Message-ID: <200003030154.RAA05063@baalbek.engr.sgi.com>

The layout document has been updated with today's decisions about
array constructors/destructors.

The cookie description is fixed at:

    http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html#array-cookies

The APIs of the runtime support are described at:

    http://reality.sgi.com/dehnert_engr/cxx/abi-layout.html#array-runtime

Please read them and send any comments...  Mark has agreed to provide
reference code for the runtime routines.

Jim

-		Jim Dehnert  x3-4272



From jds at sco.com  Fri Mar  3 13:49:19 2000
From: jds at sco.com (Silverstein  J.)
Date: Fri, 3 Mar 2000 08:49:19 -0500
Subject: [ia64-abi] Re: ia64 vtable entries (was: C implementations of the C++ ABI)
In-Reply-To: <20000302110123.E21555@cygnus.com>; from Richard Henderson on Thu, Mar 02, 2000 at 11:01:23AM -0800
References: <200003012053.MAA37822@baalbek.engr.sgi.com> <200003020050.QAA39542@baalbek.engr.sgi.com> <20000302110123.E21555@cygnus.com>
Message-ID: <20000303084919.A23073@sco.com>

On Thu, Mar 02, 2000 at 11:01:23AM -0800, Richard Henderson wrote:
> On Wed, Mar 01, 2000 at 04:50:24PM -0800, Jim Dehnert wrote:
> > OK, now I understand your issue, at least.  But the vtable might
> > actually benefit as much or more from lazy binding.
> 
> An interesting thought.  I suppose it might could even be made to work,
> though you'd have to do odd things like put entries in .rel.IA-64.pltoff
> that aren't against .IA-64.pltoff.  Or some other variant that gets it
> covered by the DT_JMPREL array. 
> 
> You'd also need a minimal plt entry for each vtable entry.  That's
> 16 bytes a pop, and large dynamicly linked C++ applications might
> start filling up the 1M(?) entry limit on minplt entries.  That limit
> could be extended by changing the linker to use a different minplt
> format for entries farther than a simple branch allows...
> 
> Well, perhaps this'll convince people to use STV_INTERNAL and the like.
> 
> 
> r~

Yes, you can't just decree that these entries participate in
lazy binding.  The lazy binding entries are set up to
branch to a portion of the plt that arranges to branch
into the dynamic linker, passing various arguments like
the index of the related relocation entry.  I think
we must specify that any IPLT relocation from a dot-o
goes into the part of the relocation table that is NOT
covered by DT_JMPREL and DT_PLTRELSZ.

Also, specifying the size of the function descriptors for
ILP32 objects as Jim's proposal does, goes beyond the
scope of this ABI.  While I agree with Jim's proposal,
I don't think all companies will.
-- 
Joel Silverstein
SCO Development Systems
jds at sco.com (908) 790-2371

All opinions expressed are my own.



From jason at cygnus.com  Fri Mar  3 17:04:44 2000
From: jason at cygnus.com (Jason Merrill)
Date: 03 Mar 2000 09:04:44 -0800
Subject: Array constructor/destructor update
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Thu, 2 Mar 2000 17:54:47 -0800 (PST)"
References: <200003030154.RAA05063@baalbek.engr.sgi.com>
Message-ID: <u9k8jkassz.fsf@yorick.cygnus.com>

I think __cxa_vec_destructor should take a number of elements, and not the
padding size, so that it can be used for destroying non-heap arrays.

How about "ctor" and "dtor"?

Jason



From jason at cygnus.com  Sun Mar  5 00:41:29 2000
From: jason at cygnus.com (Jason Merrill)
Date: 04 Mar 2000 16:41:29 -0800
Subject: Construction vtables
In-Reply-To: Martin von Loewis's message of "Thu, 2 Mar 2000 18:59:59 +0100"
References: <200003021707.AA10529@philli.zko.dec.com> <200003021759.SAA09586@pandora>
Message-ID: <u9n1oe8czq.fsf@yorick.cygnus.com>

>>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

 >> Doesn't the ABI spec call for complete object ctor/dtors which would
 >> create the VTT and subobject ctors/dtors that recieve the VTT in their
 >> argument list?

 > What do you mean by 'create'? Dynamically, at run-time? I hope not.
 > The VTTs should be emitted statically according to some rule (probably
 > together with the vtables), and would get a certain external mangled
 > name. Also, constructors and destructors in classes with VTTs would
 > have a second implicit parameter (after this), which is the VTT
 > pointer.

 > My question is what the calling convention for destructors is.

I think Colleen answered that question; see issues C-5 and C-6.  The
in-charge [cd]tors would not have a VTT parm; the not-in-charge versions
would.

 > The alternative is that the caller passes the right VTT always, which
 > means that there need to be two destructor entry points in case of
 > virtual destructors.

Which there already are (well, three, actually).

Jason



From loewis at informatik.hu-berlin.de  Mon Mar  6 15:01:53 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 6 Mar 2000 16:01:53 +0100
Subject: Construction vtables
In-Reply-To: <u9n1oe8czq.fsf@yorick.cygnus.com> (message from Jason Merrill on
	04 Mar 2000 16:41:29 -0800)
References: <200003021707.AA10529@philli.zko.dec.com> <200003021759.SAA09586@pandora> <u9n1oe8czq.fsf@yorick.cygnus.com>
Message-ID: <200003061501.QAA06244@pandora>

> I think Colleen answered that question; see issues C-5 and C-6.  The
> in-charge [cd]tors would not have a VTT parm; the not-in-charge versions
> would.

Thanks, now I understand - I did not realize that the in-charge
version would not require the VTT.

Martin



From dehnert at baalbek.engr.sgi.com  Tue Mar  7 01:47:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 6 Mar 2000 17:47:06 -0800 (PST)
Subject: Array constructor/destructor update
Message-ID: <200003070147.RAA17098@baalbek.engr.sgi.com>

Jason Merrill wrote:
> 
> I think __cxa_vec_destructor should take a number of elements, and not the
> padding size, so that it can be used for destroying non-heap arrays.

Fine with me.  It does mean that the cookie load has to happen at the caller.
Anyone have any objections?

> How about "ctor" and "dtor"?

Sure.  I'll change it.

Jim

PS:  Our network has been horrible from midday Friday until mid-Sunday.
Although I don't know that I missed any mail (and I did get mail during
the period), if you didn't get a response from me that you expected,
please resend.  (That probably applies to the other SGI people, too.)

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From jason at cygnus.com  Tue Mar  7 08:52:14 2000
From: jason at cygnus.com (Jason Merrill)
Date: 07 Mar 2000 00:52:14 -0800
Subject: Array constructor/destructor update
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Mon, 6 Mar 2000 17:47:06 -0800 (PST)"
References: <200003070147.RAA17098@baalbek.engr.sgi.com>
Message-ID: <u9k8jf40xt.fsf@yorick.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 > Jason Merrill wrote:
 >> 
 >> I think __cxa_vec_destructor should take a number of elements, and not the
 >> padding size, so that it can be used for destroying non-heap arrays.

 > Fine with me.  It does mean that the cookie load has to happen at the
 > caller.  Anyone have any objections?

That seems parallel to the _ctor case.

Jason



From ddd at cup.hp.com  Tue Mar  7 21:30:57 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Tue, 07 Mar 2000 21:30:57 +0000
Subject: Array constructor/destructor update
References: <200003070147.RAA17098@baalbek.engr.sgi.com> <u9k8jf40xt.fsf@yorick.cygnus.com>
Message-ID: <38C57511.88708F70@cup.hp.com>

Jason Merrill wrote:
> 
> >>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>  > Jason Merrill wrote:
>  >>
>  >> I think __cxa_vec_destructor should take a number of elements, and not the
>  >> padding size, so that it can be used for destroying non-heap arrays.
> 
>  > Fine with me.  It does mean that the cookie load has to happen at the
>  > caller.  Anyone have any objections?

The caller would be __cxa_vec_delete for dynamically allocated vectors, so there
would be a single instance of it. For static arrays, it will be a constant load
at call site.

Christophe



From loewis at informatik.hu-berlin.de  Tue Mar  7 22:16:37 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 7 Mar 2000 23:16:37 +0100
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
Message-ID: <200003072216.XAA14370@pandora>

I just tried to understand our scheme for covariant returns, and found
I couldn't. All I found was:

- there are different vtable entries for each different return type.
- at the end of issue B-2, it is explained that the exact definition
  is found in issue B-6.
- in issue B-6, it is explained that the resolution to that issue is
  found in the ABI layout document
- in the ABI layout document, there is no mentioning of covariant
  returns.

If desired, I can try to produce a draft.

Martin



From mark at codesourcery.com  Wed Mar  8 18:57:09 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 08 Mar 2000 10:57:09 -0800
Subject: Local statics
Message-ID: <20000308105709H.mitchell@codesourcery.com>


For the most part, the ABI doesn't have to talk about threading.  If,
for example, an implementation doesn't provide a thread-safe
exception-handling mechanism, then that's a limitation of the
implementation, but there's no reason that a library which only
expects there to be a single thread, created with a different
compiler, couldn't be linked with object files generated by the
implementation without thread-safe exception-handling.

However, we do need to decide what, if anything, to do about local
statics with constructors.  As a quality-of-implementation issue,
compilers should ensure that they are constructed only once.  Ensuring
this requires some kind of locking protocol; that requires ABI
standardization.

Or, did we already handle this in some other way?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Mar  8 23:54:11 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 8 Mar 2000 15:54:11 -0800 (PST)
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
Message-ID: <200003082354.PAA48549@baalbek.engr.sgi.com>

> Date: Tue, 7 Mar 2000 23:16:37 +0100
> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> I just tried to understand our scheme for covariant returns, and found
> I couldn't. All I found was:
> 
> - there are different vtable entries for each different return type.
> - at the end of issue B-2, it is explained that the exact definition
>   is found in issue B-6.
> - in issue B-6, it is explained that the resolution to that issue is
>   found in the ABI layout document
> - in the ABI layout document, there is no mentioning of covariant
>   returns.

You seem to be correct.  Let me try to explain my understanding of the
situation and an appropriate rule derived from that, and then those of
you more knowledgeable can clarify.

> If desired, I can try to produce a draft.

That would be good, if you have a better scheme than below.

First, a simple example:

	class T {
	  virtual void f();
	};
	class A {
	  virtual A* foo (void);
	};
	class B: public T, public A {
	  virtual A* foo (void);
	};
	class C: public B {
	  virtual C* foo (void);
	};
	A* a = new A;
	B* b = new B;	A* a_in_b = b;
	C* c = new C;	B* b_in_c = c;

Now, our layout rules, ignoring the covariant returns, provide:

  1. Vtable A:  entry for A::foo non-adjusting (a->foo)
  2. Vtable B:  entry for B::foo non-adjusting (b->foo)
  3. Vtable A-in-B (not primary):  entry for B::foo adjusting (a_in_b->foo)
  4. Vtable C:  entry for C::foo non-adjusting (c->foo)
  5. Vtable B-in-C (primary):  entry for C::foo non-adjusting (b_in_c->foo)
  6. Vtable A-in-C (not primary):  entry for C::foo adjusting (a_in_c->foo)

Now, if we assume that all of the adjusting entrypoints also adjust the
return pointer if necessary (it's not always, e.g. case (3)),
everything works fine EXCEPT case (5).  In that case, the B-in-C vtable
is primary, so the vtable C and vtable B-in-C entries for foo are the
same entry.  But the C entry needs no result adjustment, and the B
entry does (to an A*).

I think this can be dealt with by the following rule:

  The adjusting entrypoints referenced by vtable entries in secondary
  vtables must adjust both the this pointer and the covariant return
  pointer (if necessary).  If a derived class and its primary base
  share a vtable, and the derived class overrides a virtual function in
  the primary base's primary vtable with a different return type, then
  the shared vtable entry adjusts the return type to that required by
  the base class, and a second entry is allocated in the derived type's
  vtable (according to the position rules for any vfunc added by the
  derived class) for the overriding function, which adjusts neither
  this nor the return type.

Note that this rule does not provide what I originally assumed was
meant by "multiple entries for covariant returns," as it makes use of
the multiple entries already present in secondary vtables when it can.

Am I missing anything?  Is this clear?  Other comments?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar  9 05:57:39 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 8 Mar 2000 21:57:39 -0800 (PST)
Subject: Agenda for 9 March
Message-ID: <200003090557.VAA41698@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
Aside from the straightforward resolutions from the last meeting, I've:

 - Made minor changes in the construction vtable writeup based on the
   email.  Non-trifling things are in purple.

 - Added an alphabetized table of the mangling encoding characters to
   start us towards verifying lack of ambiguity.  Its a separate file
   for now, referenced from the layout document.

The agenda is based on these priorities:

  A) Data layout and virtual function calls.

  B) Mangling.

  C) Exception handling.

So, take a look at the material associated with these issues.
I'd like to make significant progress with (1) and (4) in particular.

  1) C-4:  Construction vtables.  This is a significant issue -- please
     look at Coleen's proposal (in the layout document) carefully, if
     you haven't already.

  2) C-11:  Array constructors.  Do the interface descriptions look OK?

  3) C-12:  Return value of constructors.  void?  this?

  4) F-*:  Mangling.

  5) D-12:  Unwind table location.

Issues that are active and awaiting proposals:

  a)  A-24:  Incomplete type RTTI (alternate proposal from Christophe).

  b)  F-*:  Mangling (updated proposal from Daveed).

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Thu Mar  9 12:31:20 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 9 Mar 2000 13:31:20 +0100
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
In-Reply-To: <200003082354.PAA48549@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003082354.PAA48549@baalbek.engr.sgi.com>
Message-ID: <200003091231.NAA23475@pandora>

> Note that this rule does not provide what I originally assumed was
> meant by "multiple entries for covariant returns," as it makes use of
> the multiple entries already present in secondary vtables when it
> can.

That would have been my proposal as well.

> Am I missing anything?  Is this clear?  Other comments?

I like it. Regarding Jason's comment, the critical phrase is

# and the derived class overrides a virtual function in the primary
# base's primary vtable with a different return type

I think this is also clear, saying that you need another entry if the
return type differs, even if no adjustments will be made. I think this
is fine, given that it only requires a slot in the vtable - the
function could be the same one as in the base vtable part.

Martin



From jason at cygnus.com  Thu Mar  9 09:37:17 2000
From: jason at cygnus.com (Jason Merrill)
Date: 09 Mar 2000 01:37:17 -0800
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Wed, 8 Mar 2000 15:54:11 -0800 (PST)"
References: <200003082354.PAA48549@baalbek.engr.sgi.com>
Message-ID: <u9u2igxz5e.fsf@yorick.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 > I think this can be dealt with by the following rule:

 >   The adjusting entrypoints referenced by vtable entries in secondary
 >   vtables must adjust both the this pointer and the covariant return
 >   pointer (if necessary).  If a derived class and its primary base
 >   share a vtable, and the derived class overrides a virtual function in
 >   the primary base's primary vtable with a different return type, then
 >   the shared vtable entry adjusts the return type to that required by
 >   the base class, and a second entry is allocated in the derived type's
 >   vtable (according to the position rules for any vfunc added by the
 >   derived class) for the overriding function, which adjusts neither
 >   this nor the return type.

 > Note that this rule does not provide what I originally assumed was
 > meant by "multiple entries for covariant returns," as it makes use of
 > the multiple entries already present in secondary vtables when it can.

I think that is what was meant.  To restate:

  When a virtual function is declared in a class, it gets a new vtable slot
  unless it overrides a function from the primary base and conversion
  between the two return types does not require an adjustment.

It seems unnecessary to force a new entry if the return types are related
by single inheritance.

Jason



From loewis at informatik.hu-berlin.de  Thu Mar  9 12:41:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 9 Mar 2000 13:41:55 +0100
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
In-Reply-To: <u9u2igxz5e.fsf@yorick.cygnus.com> (message from Jason Merrill on
	09 Mar 2000 01:37:17 -0800)
References: <200003082354.PAA48549@baalbek.engr.sgi.com> <u9u2igxz5e.fsf@yorick.cygnus.com>
Message-ID: <200003091241.NAA23526@pandora>

> I think that is what was meant.  To restate:
> 
>   When a virtual function is declared in a class, it gets a new vtable slot
>   unless it overrides a function from the primary base and conversion
>   between the two return types does not require an adjustment.
> 
> It seems unnecessary to force a new entry if the return types are related
> by single inheritance.

In the B-2 discussion, the notes say

# Agreement was reached to avoid the complication of eliminating some
# of the Vtable entries. Thus, the Vtable will have one entry for each
# accessible return type of a covariant virtual function.

I agree with that resolution; it follows that a new slot is allocated
even if there are no return adjustments. Of course, a smart compiler
would use the same function entry as in the base part, instead of
generating a new one.

Please note that this rule would also apply in case of different cv
qualification, as allowed per 10.3/5

# both pointers or references have the same cv?qualification and the
# class type in the return type of D::f has the same cv?qualification
# as or less cv?qualification than the class type in the return type
# of B::f.

So, in case of

struct Base{
  virtual const Base* foo();
};

struct Derived{
  virtual Base* foo();
};

there would be two vtable slots for Derived::foo, which would most
likely be implemented by the same entry point.

If that is undesirable, I would not object to re-opening B-2, and
indeed eliminating some vtable entries. However, I think it is fine as
it is now.

Martin




From loewis at informatik.hu-berlin.de  Thu Mar  9 11:29:35 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 9 Mar 2000 12:29:35 +0100
Subject: Local statics
In-Reply-To: <20000308105709H.mitchell@codesourcery.com> (message from Mark
	Mitchell on Wed, 08 Mar 2000 10:57:09 -0800)
References: <20000308105709H.mitchell@codesourcery.com>
Message-ID: <200003091129.MAA23156@pandora>

> Or, did we already handle this in some other way?

This is issue G-4. There has been a long debate on that one, but so
far, no conclusion was reached. Summarizing the positions so far, it
seems that we have about an even split of people for and against
potentially blocking initialisation.

No matter which solution is taken, I think the ABI *must* say
something about initialisation of local statics, to support the
at-most-once semantics even in the single-threaded case:

Since statics may appear in inline functions, references to the
statics from many translation units may occur. These shall all refer
to the same object, which is guaranteed by the mangling. However, the
object shall be at most once initialized, which is currently not
guaranteed, at least as far as the draft goes.

Martin



From jason at cygnus.com  Thu Mar  9 17:40:19 2000
From: jason at cygnus.com (Jason Merrill)
Date: 09 Mar 2000 09:40:19 -0800
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
In-Reply-To: Martin von Loewis's message of "Thu, 9 Mar 2000 13:41:55 +0100"
References: <200003082354.PAA48549@baalbek.engr.sgi.com> <u9u2igxz5e.fsf@yorick.cygnus.com> <200003091241.NAA23526@pandora>
Message-ID: <u9n1o8xcsc.fsf@yorick.cygnus.com>

>>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

 >> It seems unnecessary to force a new entry if the return types are related
 >> by single inheritance.

 > In the B-2 discussion, the notes say

 > # Agreement was reached to avoid the complication of eliminating some
 > # of the Vtable entries. Thus, the Vtable will have one entry for each
 > # accessible return type of a covariant virtual function.

 > I agree with that resolution; it follows that a new slot is allocated
 > even if there are no return adjustments.

I don't think that's what was meant by the resolution; I think it was
referring to our decision not to use Daveed's scheme for returning multiple
types from a single function.

It is trivial to determine whether or not an adjustment is necessary, and I
think we might as well.  What do other people think?

Jason



From ddd at cup.hp.com  Thu Mar  9 17:58:18 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 09 Mar 2000 17:58:18 +0000
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
References: <200003082354.PAA48549@baalbek.engr.sgi.com> <u9u2igxz5e.fsf@yorick.cygnus.com> <200003091241.NAA23526@pandora>
Message-ID: <38C7E63A.1E8EEC90@cup.hp.com>

Martin von Loewis wrote:
>
> In the B-2 discussion, the notes say
> 
> # Agreement was reached to avoid the complication of eliminating some
> # of the Vtable entries. Thus, the Vtable will have one entry for each
> # accessible return type of a covariant virtual function.
> 
> I agree with that resolution; it follows that a new slot is allocated
> even if there are no return adjustments. Of course, a smart compiler
> would use the same function entry as in the base part, instead of
> generating a new one.

Actually, I believe this is the only legal thing to do: for the caller, the
return type may be a pointer to an incomplete type, so it doesn't necessarily
know if there is an adjustment or not. So the slot needs to be present.


Christophe



From loewis at informatik.hu-berlin.de  Thu Mar  9 18:22:09 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 9 Mar 2000 19:22:09 +0100
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
In-Reply-To: <38C7E63A.1E8EEC90@cup.hp.com> (message from Christophe de
	Dinechin on Thu, 09 Mar 2000 17:58:18 +0000)
References: <200003082354.PAA48549@baalbek.engr.sgi.com> <u9u2igxz5e.fsf@yorick.cygnus.com> <200003091241.NAA23526@pandora> <38C7E63A.1E8EEC90@cup.hp.com>
Message-ID: <200003091822.TAA01439@pandora>

> Actually, I believe this is the only legal thing to do: for the caller, the
> return type may be a pointer to an incomplete type

No, that cannot happen; 10.3/5 says

# If the return type of D::f differs from the return type of B::f, the
# class type in the return type of D::f shall be complete at the point
# of declaration of D::f or shall be the class type D.

Martin




From ddd at cup.hp.com  Thu Mar  9 18:33:40 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 09 Mar 2000 18:33:40 +0000
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
References: <200003082354.PAA48549@baalbek.engr.sgi.com> <u9u2igxz5e.fsf@yorick.cygnus.com> <200003091241.NAA23526@pandora> <38C7E63A.1E8EEC90@cup.hp.com> <200003091822.TAA01439@pandora>
Message-ID: <38C7EE84.42E7CDAC@cup.hp.com>

Martin von Loewis wrote:
> 
> > Actually, I believe this is the only legal thing to do: for the caller, the
> > return type may be a pointer to an incomplete type
> 
> No, that cannot happen; 10.3/5 says
> 
> # If the return type of D::f differs from the return type of B::f, the
> # class type in the return type of D::f shall be complete at the point
> # of declaration of D::f or shall be the class type D.
> 
> Martin

You are correct.

Christophe



From jason at cygnus.com  Thu Mar  9 21:02:35 2000
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 9 Mar 2000 13:02:35 -0800
Subject: runtime mangling
Message-ID: <200003092102.NAA01294@yorick.cygnus.com>

Which of the runtime entry points specified by the ABI are extern "C", and
which are extern "C++"?  I've been assuming that most had "C" linkage, but
Nathan seems to have assumed otherwise in implementing the new RTTI stuff,
and we ought to specify...

Jason



From jfw at sgi.com  Thu Mar  9 21:12:12 2000
From: jfw at sgi.com (John Wilkinson)
Date: Thu, 09 Mar 2000 13:12:12 -0800
Subject: Mangling of member functions
Message-ID: <38C813AC.5C8F277@sgi.com>

As I read it, the first parameter in the mangled signature of a
nonstatic member function is not the this pointer.  So the question of
cv-qualified member functions would appear to be a loose end.

-- 
John Wilkinson



From dehnert at baalbek.engr.sgi.com  Thu Mar  9 21:26:30 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 9 Mar 2000 13:26:30 -0800 (PST)
Subject: runtime mangling
Message-ID: <200003092126.NAA51648@baalbek.engr.sgi.com>

> Date: Thu, 9 Mar 2000 13:02:35 -0800
> From: Jason Merrill <jason at cygnus.com>
> 
> Which of the runtime entry points specified by the ABI are extern "C", and
> which are extern "C++"?  I've been assuming that most had "C" linkage, but
> Nathan seems to have assumed otherwise in implementing the new RTTI stuff,
> and we ought to specify...

You're right, we need to.  I was making Nathan's assumption.
Specifically, with the exception of longjmp_unwind, which we expect
users to call from C, I was thinking in terms of using C++ linkage.

So, we need to identify the underlying principle.  Mine was:

	All runtime library entrypoints are extern "C++" except:

	  - Routines expected to be called frequently from C code,
	    e.g. longjmp_unwind.

I suspect your assumption would be captured by another exception:

	  - Routines called only from generated code, and likely
	    to be implemented in C, e.g. __cxa_vec_dtor (?).

Of course, in addition to a statement of the principles, we need to be
specific about each of the entrypoints, which I had intended to do by
referencing the ABI header file from the document.

What are people's preferences for the underlying principle?  The method
of specification?  We'll have a header file shortly from Nathan.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Thu Mar  9 21:47:23 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 9 Mar 2000 22:47:23 +0100
Subject: runtime mangling
In-Reply-To: <200003092126.NAA51648@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003092126.NAA51648@baalbek.engr.sgi.com>
Message-ID: <200003092147.WAA09599@pandora>

> What are people's preferences for the underlying principle?  The method
> of specification?

For the __cxa routines, it seems that linkage is not relevant to the
user; since they are in implementation namespace, there is no need to
put them explicitly into a reserved namespace. I think giving them C
linkage would be fine.

I could not find a definite decision on naming the namespace for
user-callable functions; I still dislike using a non-reserved name
(abi).  As you recall, the problem is that users could come up with
programs that are completely well-formed standard C++, which still
would fail in a C++ ABI implementation.

Regards,
Martin



From dehnert at baalbek.engr.sgi.com  Thu Mar  9 22:59:01 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 9 Mar 2000 14:59:01 -0800 (PST)
Subject: Resolution of B-2 not reflected in B-6 (aka covariant returns)
References: <200003082354.PAA48549@baalbek.engr.sgi.com>
    <u9u2igxz5e.fsf@yorick.cygnus.com> <200003091241.NAA23526@pandora>
Message-ID: <200003092259.OAA51981@baalbek.engr.sgi.com>

> From: Jason Merrill <jason at cygnus.com>
> Date: 09 Mar 2000 09:40:19 -0800
> 
> >>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:
> 
>  >> It seems unnecessary to force a new entry if the return types are related
>  >> by single inheritance.
> 
>  > In the B-2 discussion, the notes say
> 
>  > # Agreement was reached to avoid the complication of eliminating some
>  > # of the Vtable entries. Thus, the Vtable will have one entry for each
>  > # accessible return type of a covariant virtual function.
> 
>  > I agree with that resolution; it follows that a new slot is allocated
>  > even if there are no return adjustments.
> 
> I don't think that's what was meant by the resolution; I think it was
> referring to our decision not to use Daveed's scheme for returning multiple
> types from a single function.

This is also my recollection.

> It is trivial to determine whether or not an adjustment is necessary, and I
> think we might as well.  What do other people think?

I agree.  The definition appears to be simple.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Mar 10 00:09:12 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 9 Mar 2000 16:09:12 -0800 (PST)
Subject: New issue:  __int64 and friends
Message-ID: <200003100009.QAA52081@baalbek.engr.sgi.com>

The IA-64 software conventions define a number of implementation
types:  __int64, __int128 (and unsigned versions), __float80, and
__float128.  For those that match builtin types, i.e. __int64 and
__float80, this raises the question of whether they are intended
to be treated as typedefs of builtin types, or as new types.

In C, the significance is limited.  When matching function declarations
(prototypes and definitions), typedefs match but distinct types don't.
I can't think of any other place where default conversions and
identical representation won't hide the difference.

In C++, the effects are more dramatic.  Most important, perhaps, is
that distinct types will cause different mangling.  So the C++ ABI
group needs to know the choice.

My preference would be the typedef treatment, specifically:

	__int64 == long long (because it can be the same for both
				32-bit and 64-bit ABIs)
	__float80 == long double

On a related note, the SW Conventions document says (in a footnote)
that it is defining the __float128 so that everyone implementing it
will have matching representations, but it doesn't specify the
representation.

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Fri Mar 10 01:21:01 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 10 Mar 2000 02:21:01 +0100
Subject: New issue:  __int64 and friends
In-Reply-To: <200003100009.QAA52081@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003100009.QAA52081@baalbek.engr.sgi.com>
Message-ID: <200003100121.CAA10285@pandora>

> The IA-64 software conventions define a number of implementation
> types:  __int64, __int128 (and unsigned versions), __float80, and
> __float128.  For those that match builtin types, i.e. __int64 and
> __float80, this raises the question of whether they are intended
> to be treated as typedefs of builtin types, or as new types.
> 
> In C, the significance is limited.

In C99, there is also a type "long long", as well as a type "long
double". Whatever the C ABI says about these must be copied into the
C++ ABI. Otherwise,

  struct foo{
    long long x;
    int y;
  };

will have a different lay-out, depending on whether it is processed by
a C or a C++ compiler.

Furthermore, C99 defines <stdint.h>, with int64_t mandatory, and other
types optional. I guess a C99 implementation should be advised to
provide int128_t, and it would be a good idea if the base ABI
specified the exact definitions of the _least_ and _fast_ types
(e.g. uint_least32_t, int_fast16_t) as well as intmax_t for the same
reason: structure layout relying on those types should be identical
across implementations.

> My preference would be the typedef treatment, specifically:
> 
> 	__int64 == long long (because it can be the same for both
> 				32-bit and 64-bit ABIs)

That is reasonable.

> 	__float80 == long double

>From my (perhaps limited) viewpoint, __float128 would make a better
long double type. For one thing, the CORBA standard specifies that the
IDL type 'long double' is 128 bits on the wire. This is a pain to
implement on ia32.

> On a related note, the SW Conventions document says (in a footnote)
> that it is defining the __float128 so that everyone implementing it
> will have matching representations, but it doesn't specify the
> representation.

I think the current IEEE standard (IEC 60559:1989) specifies the
layout of the 128 bit floating point type. Without checking
(ie. taking the format from CORBA instead), this should be sign +
15bit-exponent + 112bit-mantissa, the exponent being with a bias of
16383.

Regards,
Martin



From dehnert at baalbek.engr.sgi.com  Fri Mar 10 02:25:21 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 9 Mar 2000 18:25:21 -0800 (PST)
Subject: B-2 (covariant returns) and vtable order
Message-ID: <200003100225.SAA52722@baalbek.engr.sgi.com>

I've updated the layout document (which now contains all the changes
that should have been there last night, too).  What I did today was
to combine the vtable content and order sections, and attempt to
clarify the ordering questions that have arisen.  Look for red, as
usual.

I specified new entries for covariant returns in the optimal fashion
suggested by Jason, i.e. no new entry if overriding a vfunc from the
primary base that requires no return adjustment.  (Note: that is not
the same as requiring the same type.)  If, after looking this over,
we can't quickly agree to this solution (or a same type condition),
I'll reopen B-2.

Send your notes...

Jim
-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Fri Mar 10 19:44:52 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 10 Mar 2000 20:44:52 +0100
Subject: More mangling issues
Message-ID: <200003101944.UAA09762@pandora>

I found a number of new problems with mangling: The compression scheme
mentions the order of type recording qualifiers and templates; a
similar mechanism probably applies to:

- function types
- array types
- pointer-to-member types

E.g. a for an array type, the array is less recent than the element
type.

Another issue: for pointer-to-member types, is the M qualifier already
pointer in itself? I.e. given

  _Z3fooPM2ABi

Is this foo(int AB::*) or foo(int AB::**)? Same for functions, which
leads to the question what _Z3fooPPM2ABFiE is.

Martin



From loewis at informatik.hu-berlin.de  Fri Mar 10 20:07:07 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 10 Mar 2000 21:07:07 +0100
Subject: Demangler prototype
Message-ID: <200003102007.VAA09823@pandora>

To see whether the mangling mechanism is well-specified, I put a
demangler together, which I'll attach below. It is very rough code, so
excuse the missing documentation :-) I believe it does everything that
has been specified so far, except for the St/Sb compression
short-cuts, and except for local names (Z prefix).

It is written in Python, so you need a Python installation to run
it. It currently work in command-line mode, where the mangled symbol
is passed as an argument, eg.

punica loewis 92 ( ~/work/cxxabi ) > ./demangle.py _Z5firstI3DuoEvT1_
void first<Duo>(/*T1=*/Duo)

You'll notice that it does not process all examples correctly; in
these cases, I either consider the example incorrect, or think that
the mangling mechanism is wrong as specified in the first place. Of
course, there also may be bugs left, please let me know.

While writing this demangler, I *think* I made sure that demangling is
unambiguous in all cases, so the only problem left for proof would be
to show that there is exactly one mangling for every possible
declaration. Eg. I would not catch the case that

  foo(void (*)(void))

could be either mangled as _Z3fooPFvvE or _Z3fooPFvE with the current
spec, which does not say whether the empty argument list is mangled as
(void) or not.

Anyway, comments are appreciated.

Martin

-------------- next part --------------
A non-text attachment was scrubbed...
Name: demangle.py
Type: application/octet-stream
Size: 10028 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000310/ddb4cb8d/attachment.obj>

From dehnert at sgi.com  Fri Mar 10 21:31:10 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Fri, 10 Mar 2000 13:31:10 -0800
Subject: runtime mangling
References: <200003092126.NAA51648@baalbek.engr.sgi.com> <200003092147.WAA09599@pandora>
Message-ID: <38C9699E.5666826@sgi.com>

Martin von Loewis wrote:
> 
> > What are people's preferences for the underlying principle?  The method
> > of specification?
> 
> For the __cxa routines, it seems that linkage is not relevant to the
> user; since they are in implementation namespace, there is no need to
> put them explicitly into a reserved namespace. I think giving them C
> linkage would be fine.

I put this exclusion into the layout document.  If it looks OK to people,
we'll leave it there as a statement of the principle.

> I could not find a definite decision on naming the namespace for
> user-callable functions; I still dislike using a non-reserved name
> (abi).  As you recall, the problem is that users could come up with
> programs that are completely well-formed standard C++, which still
> would fail in a C++ ABI implementation.

The decision, currently documented in the ABI layout document, is to use
a reserved name for the namespace (__cxxabiv1, I believe), and include
a aliasing declaration in the header file to treat it as "abi".  The
effect on users is that they will not conflict accidently with the
mangled names, and should get an immediate indication from the compiler
if they attempt to define namespace "abi" in the same file where they're
using the header.  This was felt to be a good compromise between providing
an easy-to-use name, and avoiding obscure link-time name conflicts.

Jim



From daveed at edg.com  Fri Mar 10 23:31:16 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 10 Mar 2000 15:31:16 -0800
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
Message-ID: <38C985C4.5764D02C@edg.com>

[...]
> Another issue: for pointer-to-member types, is the M qualifier already
> pointer in itself? I.e. given
> 
>   _Z3fooPM2ABi
> 
> Is this foo(int AB::*) or foo(int AB::**)?

The latter. "M" is pointer-to-member (which accounts for the first "*" token)
and P is plain pointer (to data or function).

> Same for functions, which leads to the question what _Z3fooPPM2ABFiE is.

If I'm not mistaken: Ret? foo(int (AB::***)()).

Note the contrast with _Z3fooM2ABPPFiE which I think is
	Ret? foo(int (**AB::*)())

Gotta love that syntax ;-)

(I'll try to work on your other points later on.)

	Daveed



From mark at codesourcery.com  Mon Mar 13 06:44:39 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 12 Mar 2000 22:44:39 -0800
Subject: Layout of structures: one more tweak
Message-ID: <20000312224439I.mitchell@codesourcery.com>


Folks --

  The layout of Non-POD Class Types is still a little bit unclear on
one point: the handling of data members whose type is a zero-sized
class.  For one thing, II.2 says "if D is not an empty base class",
which does not seem to allow a data member with non-zero size, even
though such things are clearly intended to be handled in this
paragraph.  I think that zero-sized data members were intended to be
handled there, as well.  So, I think II.2 should say:

  "if D is not an empty base class, or is a data member (of zero or
   non-zero size), ..."

  Anybody disagree?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Mar 14 21:08:58 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 14 Mar 2000 13:08:58 -0800 (PST)
Subject: Mangling writeup
References: <200003140200.SAA67660@baalbek.engr.sgi.com>
Message-ID: <200003142108.NAA73516@baalbek.engr.sgi.com>

This discussion (mangling) is probably of interest to the whole group now...

> Date: Mon, 13 Mar 2000 22:30:33 -0800
> From: Daveed Vandevoorde <daveed at edg.com>
> 
> Jim Dehnert wrote:
> > 
> > If you take a look at the ABI layout document, I've heavily reworked the
> > mangling writeup.  It incorporates a couple of choices we made last week
> > for the loose ends list, but primarily it converts the presentation to a
> > more consistent (I hope) BNF grammar for the mangling.  I think it
> > provides a clearer picture of just where various components occur, but
> > I'd appreciate it if you would take a careful look at it before I point
> > out its presence to the whole group tomorrow, for omissions, errors,
> > misunderstandings, etc.
>
> I'd rather not use "Sn" for the sentry because S<letter> was meant to be
> reserved for the abbreviation catalog.  How about GV (guard variable)
> instead?

Sounds good.

> Also, it occurs to me that return-types cannot be omitted from non-toplevel
> function types because:
> 	void f(int()) {}
> 	void f(double()) {}
> is a valid overload set.

I think the distinction required is that if we're encoding the type of
a function _object_, e.g. a top-level function name or a thunk, we
don't need the return type, whereas if the function _type_ is itself
what's being mangled, we need it.  True?

> (<value number> is a nonterminal without a production.)

The "value" is in italics, to be ignored, so this is <number>, which
appears in the first cluster of productions.

> > I haven't yet touched the compression or examples sections.  I've been
> > trying to figure out a good way to indicate in the grammar segments
> > which components get compressed, but haven't come up with a nice one
> > yet.  Ideas?
> 
> How about:
> 
> 	<substitution> ::= S <number> _
> 	               ::= Sb
> 	               ::= Ss
> 
> 	<type> ::= <substitution>
> 	       ::= <substitution> <template-args>
> 	<name> ::= <substitution>
> 	<nesting-qualifier> ::= <substitution>
> 	                    ::= <substitution> <template-args>
> 	<qualified-name> ::= St <name>
> 
> Hmmm, this doesn't reflect the fact that a substitution should not appear
> as a nonleading qualifier.

Why not?  It would be coincidental to find a match, and therefore
unusual, but would it be a problem?

> Maybe <nesting-qualifier>+ should be replaced
> by <qualifier> from:
> 	<simple-qualifier> ::= <source-name>
> 	                   ::= <source-name> <template-args>
> 
> 	<qualifier> ::= <simple-qualifier>+
> 	            ::= <substitution>
> 	            ::= <substitution> <simple-qualifier>+

How does the following work as a general principle?  Suppose that the
(grammatical) components that are candidates for later abbreviation are
precisely the same ones that may be replaced by a later abbreviation.
In that case, we need only be careful that our specification grammar
isolates replaceable components in their own productions, and then
indicate those productions, either by a special mark, or by adding a
"::= <substitution>" RHS (the latter would require some more care to
avoid including extras).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Mar 14 22:00:09 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 14 Mar 2000 14:00:09 -0800 (PST)
Subject: New issue:  __int64 and friends
References: <200003100009.QAA52081@baalbek.engr.sgi.com>
Message-ID: <200003142200.OAA73701@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar  9 17:21:15 2000
> 
> > The IA-64 software conventions define a number of implementation
> > types:  __int64, __int128 (and unsigned versions), __float80, and
> > __float128.  For those that match builtin types, i.e. __int64 and
> > __float80, this raises the question of whether they are intended
> > to be treated as typedefs of builtin types, or as new types.
> > =
> 
> > In C, the significance is limited.
> 
> In C99, there is also a type "long long", as well as a type "long
> double". Whatever the C ABI says about these must be copied into the
> C++ ABI.

That's the intent.

> Furthermore, C99 defines <stdint.h>, with int64_t mandatory, and other
> types optional. I guess a C99 implementation should be advised to
> provide int128_t, and it would be a good idea if the base ABI
> specified the exact definitions of the _least_ and _fast_ types
> (e.g. uint_least32_t, int_fast16_t) as well as intmax_t for the same
> reason: structure layout relying on those types should be identical
> across implementations.

These are all specified to be typedefs, with a header file defining
them and the related types/limits.  I think it should be usable
directly in a C++ program, and that we don't need to be concerned with
(re)defining any of its content.  (I haven't looked carefully to verify
that these speculations are valid, however.)

> From my (perhaps limited) viewpoint, __float128 would make a better
> long double type. For one thing, the CORBA standard specifies that the
> IDL type 'long double' is 128 bits on the wire. This is a pain to
> implement on ia32.

This was decided long ago by the base ABI group.  I don't think
attempting to change the decision is likely to be successful, without
getting into whether it would be a good idea...

> > On a related note, the SW Conventions document says (in a footnote)
> > that it is defining the __float128 so that everyone implementing it
> > will have matching representations, but it doesn't specify the
> > representation.
> 
> I think the current IEEE standard (IEC 60559:1989) specifies the
> layout of the 128 bit floating point type. Without checking
> (ie. taking the format from CORBA instead), this should be sign +
> 15bit-exponent + 112bit-mantissa, the exponent being with a bias of
> 16383.

I only have IEEE-754 (1985), which doesn't specify.  If there's a
standardized format somewhere (preferably IEEE, but CORBA's a fine
backup), that's probably what we should use.  Does someone have a solid
reference?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From cary at cup.hp.com  Tue Mar 14 22:37:30 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Tue, 14 Mar 2000 14:37:30 -0800
Subject: [ia64-abi] Re: New issue:  __int64 and friends
Message-ID: <200003142236.OAA25772@adlmail.cup.hp.com>

>> I think the current IEEE standard (IEC 60559:1989) specifies the
>> layout of the 128 bit floating point type. Without checking
>> (ie. taking the format from CORBA instead), this should be sign +
>> 15bit-exponent + 112bit-mantissa, the exponent being with a bias of
>> 16383.
>
>I only have IEEE-754 (1985), which doesn't specify.  If there's a
>standardized format somewhere (preferably IEEE, but CORBA's a fine
>backup), that's probably what we should use.  Does someone have a solid
>reference?

The common runtime document does specify the layout of __float128 (in 
footnote 3 to Table 4-1):

    ...A quad-precision floating-point number is a 128-bit
    quantity with a sign bit, a 15-bit biased exponent, and
    a 112-bit mantissa with an implicit integer bit.

This description nails down (I believe) all the parameters allowed the 
implementation by the IEEE standard.

-cary



From dehnert at baalbek.engr.sgi.com  Tue Mar 14 22:49:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 14 Mar 2000 14:49:05 -0800 (PST)
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
Message-ID: <200003142249.OAA49249@baalbek.engr.sgi.com>

> Date: Fri, 10 Mar 2000 15:31:16 -0800
> From: Daveed Vandevoorde <daveed at edg.com>
>
> > Another issue: for pointer-to-member types, is the M qualifier already
> > pointer in itself? I.e. given
> >
> >   _Z3fooPM2ABi
> >
> > Is this foo(int AB::*) or foo(int AB::**)?
>
> The latter. "M" is pointer-to-member (which accounts for the first "*" token)
> and P is plain pointer (to data or function).
>
> > Same for functions, which leads to the question what _Z3fooPPM2ABFiE is.
>
> If I'm not mistaken: Ret? foo(int (AB::***)()).

Actually, the mangling means that foo is a pointer to a pointer to a
member function of AB with int result and no parameters, which I think
is represented as:

        int (AB::***foo)();

True?

> Note the contrast with _Z3fooM2ABPPFiE which I think is
>       Ret? foo(int (**AB::*)())

Well, here foo is a pointer to member data of AB of type pointer to
pointer to function with int result and no parameters, which I think
is:

	int ( ** AB::*foo) ();

Am I close?

> Gotta love that syntax ;-)

Disgusting, I would have said...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Wed Mar 15 15:04:28 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 15 Mar 2000 16:04:28 +0100
Subject: New issue:  __int64 and friends
In-Reply-To: <200003142200.OAA73701@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003100009.QAA52081@baalbek.engr.sgi.com> <200003142200.OAA73701@baalbek.engr.sgi.com>
Message-ID: <200003151504.QAA28156@pandora>

> > Furthermore, C99 defines <stdint.h>, with int64_t mandatory, and other
> > types optional. I guess a C99 implementation should be advised to
> > provide int128_t, and it would be a good idea if the base ABI
> > specified the exact definitions of the _least_ and _fast_ types
> > (e.g. uint_least32_t, int_fast16_t) as well as intmax_t for the same
> > reason: structure layout relying on those types should be identical
> > across implementations.
> 
> These are all specified to be typedefs, with a header file defining
> them and the related types/limits.  I think it should be usable
> directly in a C++ program, and that we don't need to be concerned with
> (re)defining any of its content.

I agree this is not a C++ issue. I just was pointing out that the base
API needs to specify what those types are: the standard doesn't say
exactly, and it matters on the binary level.

> > From my (perhaps limited) viewpoint, __float128 would make a better
> > long double type. For one thing, the CORBA standard specifies that the
> > IDL type 'long double' is 128 bits on the wire. This is a pain to
> > implement on ia32.
> 
> This was decided long ago by the base ABI group.

I take 'this' here to mean that 'long double' in the base API is
__float80. I think that is a mistake long-term, but I don't think we
(C++) should debate it here - it is not a big mistake :-)

Regards,
Martin



From loewis at informatik.hu-berlin.de  Wed Mar 15 15:09:16 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 15 Mar 2000 16:09:16 +0100
Subject: More mangling issues
In-Reply-To: <200003142249.OAA49249@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003101944.UAA09762@pandora> <200003142249.OAA49249@baalbek.engr.sgi.com>
Message-ID: <200003151509.QAA28165@pandora>

> > > Same for functions, which leads to the question what _Z3fooPPM2ABFiE is.
> >
> > If I'm not mistaken: Ret? foo(int (AB::***)()).
> 
> Actually, the mangling means that foo is a pointer to a pointer to a
> member function of AB with int result and no parameters, which I think
> is represented as:
> 
>         int (AB::***foo)();
> 
> True?

No; this declaration is an object declaration. There is no need to put
the type of in object into its external name, so that would be _Z3foo.
The type is specified only for a function (or method).

Regards,
Martin



From nathan at codesourcery.com  Wed Mar 15 17:43:33 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Wed, 15 Mar 2000 17:43:33 +0000
Subject: cxxabi.h
Message-ID: <38CFCBC5.68314252@codesourcery.com>

Hi,
The abi header file is named `cxxabi.h', a pedant questions
whether this should be `cxxabi'.

17.4.1.2 implies that we want <cxxabi> for inclusion in C++ and
<cxxabi.h> to export the C parts only. If we're expecting parts
to be callable from C, we'd better make a C grokable file.

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From loewis at informatik.hu-berlin.de  Wed Mar 15 20:33:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 15 Mar 2000 21:33:55 +0100
Subject: Mangling: Allocating constructors
Message-ID: <200003152033.VAA00087@pandora>

I see that the current proposal specifies C3 and C4 for allocating
constructors. I think this is contradiction to the resolution of issue
C-6, which said that allocation is done by the caller.

Regards,
Martin



From dehnert at baalbek.engr.sgi.com  Wed Mar 15 21:35:09 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 13:35:09 -0800 (PST)
Subject: cxxabi.h
Message-ID: <200003152135.NAA76034@baalbek.engr.sgi.com>

> Date: Wed, 15 Mar 2000 17:43:33 +0000
> From: Nathan Sidwell <nathan at codesourcery.com>
> 
> Hi,
> The abi header file is named `cxxabi.h', a pedant questions
> whether this should be `cxxabi'.
> 
> 17.4.1.2 implies that we want <cxxabi> for inclusion in C++ and
> <cxxabi.h> to export the C parts only. If we're expecting parts
> to be callable from C, we'd better make a C grokable file.

That was the rationale.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Wed Mar 15 21:52:22 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 15 Mar 2000 13:52:22 -0800
Subject: Bit-fields
Message-ID: <20000315135222U.mitchell@codesourcery.com>


It seems to me that our handling of over-sized bitfields is a bit
over-generous.  For example, given:

  char c : 128;

we'll align the bitfield as for a `long long', even though the
standard specifically says the extra bits are ignored.  You can't take
the address of a bitfield (even though in our ABI it will be aligned),
so it's not even legal to take the address, cast it to some very long
type, and make use of the storage -- there's no way to get the offset
of the bitfield.  Why not just align this on a `char' boundary?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Mar 15 21:56:10 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 13:56:10 -0800 (PST)
Subject: Mangling: Allocating constructors
Message-ID: <200003152156.NAA76374@baalbek.engr.sgi.com>

> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> I see that the current proposal specifies C3 and C4 for allocating
> constructors. I think this is contradiction to the resolution of issue
> C-6, which said that allocation is done by the caller.

After a brief discussion last week, we opened a new issue at HP's
request to consider whether to _also_ support allocating constructors,
with a low priority (i.e. we'll worry about it later).  We observed
that there's nothing to prevent an implementation from adding an
allocating constructor, though the ABI doesn't require it, and the
mangling for them was intended to allow consistent names if that
happens (although an agreement on parameters would also be required).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Mar 15 22:05:03 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 14:05:03 -0800 (PST)
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
    <200003142249.OAA49249@baalbek.engr.sgi.com>
Message-ID: <200003152205.OAA76468@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Wed Mar 15 07:09:25 2000
> 
> > > > Same for functions, which leads to the question what _Z3fooPPM2ABFiE is.
> > >
> > > If I'm not mistaken: Ret? foo(int (AB::***)()).
> > 
> > Actually, the mangling means that foo is a pointer to a pointer to a
> > member function of AB with int result and no parameters, which I think
> > is represented as:
> > 
> >         int (AB::***foo)();
> > 
> > True?
> 
> No; this declaration is an object declaration. There is no need to put
> the type of in object into its external name, so that would be _Z3foo.
> The type is specified only for a function (or method).

Good point.  So the original mangling _Z3fooPPM2ABFiE, is invalid.
(Though, if types were present for objects, I think my declaration
would be the right one?)

Note that since yesterday's message I've converted the examples to a
table to make it easier to read, and in the process I fixed most of
them.  Most, if not all, of the fixes involved inserting the F...E
delimiters around function types.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From ddd at cup.hp.com  Wed Mar 15 22:21:51 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 15 Mar 2000 22:21:51 +0000
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
	    <200003142249.OAA49249@baalbek.engr.sgi.com> <200003152205.OAA76468@baalbek.engr.sgi.com>
Message-ID: <38D00CFF.88014D3C@cup.hp.com>

Jim Dehnert wrote:
>
> > No; this declaration is an object declaration. There is no need to put
> > the type of in object into its external name, so that would be _Z3foo.
> > The type is specified only for a function (or method).
> 
> Good point.  So the original mangling _Z3fooPPM2ABFiE, is invalid.
> (Though, if types were present for objects, I think my declaration
> would be the right one?)

Why do we half-mangle external declarations? That is, why _Z3foo rather than
foo? There is something that reads "[...] and file scope variables are not
mangled"

Christophe



From dehnert at baalbek.engr.sgi.com  Wed Mar 15 22:58:49 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 14:58:49 -0800 (PST)
Subject: Bit-fields
Message-ID: <200003152258.OAA76482@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> It seems to me that our handling of over-sized bitfields is a bit
> over-generous.  For example, given:
> 
>   char c : 128;
> 
> we'll align the bitfield as for a `long long', even though the
> standard specifically says the extra bits are ignored.  You can't take
> the address of a bitfield (even though in our ABI it will be aligned),
> so it's not even legal to take the address, cast it to some very long
> type, and make use of the storage -- there's no way to get the offset
> of the bitfield.  Why not just align this on a `char' boundary?

Because the only rationale anyone could remember for defining this
capability in C++, and the best one we could uncover for using it,
was the following:

	typedef enum { ... } E;
	class C {
	  ...
	  E e: 32;
	  ...
	};

The standard allows the compiler to allocate an E to any size type that
will hold it.  So if one wants to write such a class with a guarantee
of the size of field 'e', the bitfield syntax is required.  We felt
that extending this to the alignment treatment we chose finished that
job, and was a more concrete rationale than anything else we could come
up with.  If the user wants a minimally aligned bitfield, he can still
use the small type followed by an unnamed bitfield.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at sgi.com  Wed Mar 15 23:24:45 2000
From: austern at sgi.com (Matt Austern)
Date: Wed, 15 Mar 2000 15:24:45 -0800 (PST)
Subject: Issue A-24
Message-ID: <14544.5997.647093.281885@isolde.engr.sgi.com>

Jim and I have been thinking about Christophe's alternate proposal for
A-24.  It would be nice if the alternate works, because all of these
little id_proxy_ptr fields will be a nuisance.

I think it does work, provided that a __class_type_info for an
incomplete class can appear only as the end of a __pointer_type_info
chain.

The basic idea: as before, we add a new flag to __pointer_type_info,
in the same word as the cv-qualification flags.  This flag is 1 if
it's a pointer to an incomplete type, or a pointer to pointer to
incomplete type, etc.

We represent a pointer to incomplete class as a __pointer_type_info,
with the incomplete bit set, that points to a __class_type_info.
That __class_type_info contains the name of the incomplete class,
as usual.

(Christophe suggested a new class, __incomplete_class_info.  I see
no reason for it, though.  We don't need any information for
incomplete classes that we don't already have in __class_type_info.)

The __class_type_info for an incomplete type is mangled differently
than the typeinfo object for a complete type.  A __class_type_info
object for an incomplete type is static.  (As before, this is to make
sure a complete __class_type_info object in a DSO won't be overridden
by an incomplete __class_type_info object in an executable.)

To compare two pointers: if the incomplete flag is set in neither,
then we can use address equality of whatever lives at the end of the
__pointer_type_info chain.  If the incomplete flag is set in at least
one of them, then we use name equality to compare the types at the end
of the __pointer_type_info chain.

                        --Matt



From dehnert at baalbek.engr.sgi.com  Thu Mar 16 00:15:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 16:15:13 -0800 (PST)
Subject: Agenda for 16 March meeting
Message-ID: <200003160015.QAA76329@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
Aside from the straightforward resolutions from the last meeting, I've:

 - Reorganized the vtable writeup to eliminate ordering confusion.

 - Made changes in the construction vtable writeup based on the
   meeting.  I think it's much clearer about content.

 - Heavily reworked the mangling writeup, incorporating a pseudo-BNF
   grammar, adding a few constructs from the loose ends list, and
   fixing examples.

Please take a careful look at the colored text.  I'll start off by
going through it all carefully to resolve any questions.

Take a look at the material associated with the following issues.

  1) C-4:  Construction vtables.  Let's make sure we understand what
     remains, so we can close this when Coleen comes out next week
     (or come close).

  2) F-1:  Mangling.  Any problems with my changes?  Are loose ends
     proposals OK?  Examples issues?

     Let's talk about the name reuse mechanism.  I've suggested that
     we identify which constructs can be used as substitutes, and be
     substituted themselves, in terms of the grammar.  If this seems
     like a reasonable approach, let's go through the grammar in the
     layout document and identify the acceptable substitutes.

  3) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?

  3) F-4:  Empty throw specifications.  Should we deal with this in
     the mangling?

  4) F-6:  Demangler?

  5) F-7:  Mangling statics.

  6) A-23:  RTTI for incomplete types.

  7) D-12:  Unwind table location.

Issues that are active and awaiting proposals:

  a)  A-24:  Incomplete type RTTI (alternate proposal from Christophe).

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar 16 00:20:44 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 16:20:44 -0800 (PST)
Subject: TAKE -- C++ ABI: Updates from 9 March meeting
Message-ID: <200003160020.QAA77136@baalbek.engr.sgi.com>


Wed Mar 15 16:17:39 PST 2000
The following file(s) were checked into tiler.engr:/isms/osprey.src/osprey1.0

owebpages/Design/ABI/cxxABI/abi-layout.html - 1.26
	- [000314]: Construction vtable modifications. RTTI modifications for
	  incomplete class types. Mangling rework: grammar, new constructs,
	  function return types. [000309]: Add limits section. Specify NULL
	  member pointer values. Combine vtable content and order sections;
	  clarify ordering. Specify when distinct virtual function entries are
	  needed for overriders. Define (and modify) vector
	  constructor/destructor runtime APIs. Virtual base offsets are promoted
	  from non-virtual bases. 

owebpages/Design/ABI/cxxABI/abi-mangling.html - 1.2
	- Added class of code, new constructs. 

owebpages/Design/ABI/cxxABI/cxx-closed.html - 1.24
	- Closed C-11, C-12. 

owebpages/Design/ABI/cxxABI/cxx-open.html - 1.38
	- New C-13, C-14. Closed C-11, C-12. Additions to A-24, C-4, F-1. 

owebpages/Design/ABI/cxxABI/cxx-summary.html - 1.47
	- New C-13, C-14. Closed C-11, C-12. 




From dehnert at baalbek.engr.sgi.com  Thu Mar 16 04:06:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 15 Mar 2000 20:06:06 -0800 (PST)
Subject: Issue reminder
Message-ID: <200003160406.UAA77909@baalbek.engr.sgi.com>

We have several issues on the table from the C++ ABI group.  Since we
haven't gotten the expected email discussion traffic, I hope they've
all been considered and found satisfactory.  As a reminder, think about:

Issue 72:  COMDAT group sections
	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.html
	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.pdf

	This is critical to C++ features like vtables, inline
	functions, etc.

Issue 74:  Section indices
	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.html
	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.pdf

	This is a longer term concern, which will become more important
	with heavy COMDAT usage.

Issue 73:  Stack unwind interface
	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.html
	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.pdf

	This is mostly consistent with, but more completely specified
	than, the current SW Conventions description.

Issue ??:  IPLT relocations
	I sent a proposal a while back to extend these to .o files.
	Cygnus has expressed concern about conflict with the lazy
	loading semantics, which would be resolved by a second
	relocation which is identical but doesn't allow lazy binding.
	I don't care which approach is taken, in fact being able to
	force early binding might be useful in any case, but C++ will
	need to be able to relocate functions descriptors in vtables.

Issue ??:  Types
	I sent a note a couple of days ago.  We must decide whether
	__int64 and __float80 are distinct types, or typedefs of long
	long and long double.  As Martin pointed out, we should also
	specify bindings of the sized types defined by C2000.

Query:  Sorting approach
	C++ needs to be able to sort constructors and other
	initializers.  We have two proposals on the table -- one sorts
	sections, is implemented in Linux today, and MUST be supported
	in the linker; the other sorts elements within a section, and
	may be implemented either in the linker or in a runtime.  See

	http://reality.sgi.com/dehnert_engr/cxx/cxx-open.html#C2

	We would like feedback, in particular whether vendors would
	object to requiring the linker support for the first approach.
	(Note that either approach allows linker implementation.)

Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Thu Mar 16 07:01:14 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 15 Mar 2000 23:01:14 -0800
Subject: Bit-fields
In-Reply-To: <200003152258.OAA76482@baalbek.engr.sgi.com>
References: <200003152258.OAA76482@baalbek.engr.sgi.com>
Message-ID: <20000315230114X.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> The standard allows the compiler to allocate an E to any size
    Jim> type that will hold it.  So if one wants to write such a
    Jim> class with a guarantee of the size of field 'e', the bitfield
    Jim> syntax is required. 

Good, thanks -- I think I understood that once before, but forgot.
Thanks for taking the time to explain it again! :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Thu Mar 16 12:30:01 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 13:30:01 +0100
Subject: Mangling: Allocating constructors
In-Reply-To: <200003152156.NAA76374@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003152156.NAA76374@baalbek.engr.sgi.com>
Message-ID: <200003161230.NAA06311@pandora>

> After a brief discussion last week, we opened a new issue at HP's
> request to consider whether to _also_ support allocating constructors,
> with a low priority (i.e. we'll worry about it later).  We observed
> that there's nothing to prevent an implementation from adding an
> allocating constructor, though the ABI doesn't require it, and the
> mangling for them was intended to allow consistent names if that
> happens (although an agreement on parameters would also be required).

If that is an extension, then code relying on it being generated is
not ABI compliant, of course...

Martin



From loewis at informatik.hu-berlin.de  Thu Mar 16 12:34:38 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 13:34:38 +0100
Subject: More mangling issues
In-Reply-To: <200003152205.OAA76468@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003101944.UAA09762@pandora>
    <200003142249.OAA49249@baalbek.engr.sgi.com> <200003152205.OAA76468@baalbek.engr.sgi.com>
Message-ID: <200003161234.NAA06319@pandora>

> Good point.  So the original mangling _Z3fooPPM2ABFiE, is invalid.

It depends. I'd say the grammar was wrong, and should read

<encoding> ::= <name> [ <function parameters> ]
<function parameters> ::= <type>*

The question is whether '? foo(int)' should be '_Z3fooi' or
'_Z3fooFiE'. It would work either way. The original draft had the
first version, the new grammar the second.

> Note that since yesterday's message I've converted the examples to a
> table to make it easier to read, and in the process I fixed most of
> them.  Most, if not all, of the fixes involved inserting the F...E
> delimiters around function types.

Was there a deliberate decision to change the mangling? I think
neither is 'better' than the other, so I don't care too much...

Mrtin



From loewis at informatik.hu-berlin.de  Thu Mar 16 12:38:24 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 13:38:24 +0100
Subject: More mangling issues
In-Reply-To: <38D00CFF.88014D3C@cup.hp.com> (message from Christophe de
	Dinechin on Wed, 15 Mar 2000 22:21:51 +0000)
References: <200003101944.UAA09762@pandora>
     <200003142249.OAA49249@baalbek.engr.sgi.com> <200003152205.OAA76468@baalbek.engr.sgi.com> <38D00CFF.88014D3C@cup.hp.com>
Message-ID: <200003161238.NAA06328@pandora>

> Why do we half-mangle external declarations? That is, why _Z3foo rather than
> foo? There is something that reads "[...] and file scope variables are not
> mangled"

You are right, that 'int (**A::Afoo)()' declaration should be mangled
as 'foo'. I'd prefer to say 'global namespace' instead of 'file
scope', though. For one thing,

namespace Foo{
   int bar;
}

is mangled as _ZN3Foo3barE, and is still "file scope". Also, "file
scope" is often used to describe 

static int foo;

and we don't have an external name for that at all.

Martin



From loewis at informatik.hu-berlin.de  Thu Mar 16 13:05:34 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 14:05:34 +0100
Subject: Agenda for 16 March meeting
In-Reply-To: <200003160015.QAA76329@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003160015.QAA76329@baalbek.engr.sgi.com>
Message-ID: <200003161305.OAA06582@pandora>

>      Let's talk about the name reuse mechanism.  I've suggested that
>      we identify which constructs can be used as substitutes, and be
>      substituted themselves, in terms of the grammar.  If this seems
>      like a reasonable approach, let's go through the grammar in the
>      layout document and identify the acceptable substitutes.

I don't know whether you'll find the time, but I think the 'Sx'
mangling also deserves serious reconsiderations. I find the statement

# The abbreviation St is always treated as a qualifier and therefore
# does not need a N...E construct.

followed by the example

# _ZStN3_In4wardE

confusing at best, if not contradictory. I'd propose something along
the line of

<qualified-name> ::= <std-qual> <nesting-qualifier>+ <unqualified-name> E

<std-qual> ::= St
           ::= Sb
           ::= Ss

so that 'std::string' would be mangled as 'SsE', which is equivalent
to N3std12basic_stringIcN3std11char_traitsIcEEN3std9allocatorIcEEEE.
As such, it would also introduce the appropriate number of back
references, i.e.

S1 - std::basic_string<char,std::char_traits<char>,std::allocator<char>>
S2 - std::allocator<char>
S3 - char
S4 - std::allocator
S5 - std
S6 - std::char_traits<char>
S7 - char
S8 - std::char_traits
S9 - std
S10- char
S11- std::basic_string
S12- std

>   3) F-2:  Mangled name size.  Our hope has been that the substitution
>      mechanism will make further efforts unnecessary.  How do we go
>      about validating this?

If somebody gives me the longest mangled symbol ever seen in a real
project (plus the demangled version for that compiler), I can try to
remangle it with the new scheme.

>   4) F-6:  Demangler?

It is not too difficult to come up with an API, is it?

namespace abi{
  std::string demangle_mangled_name(const char*);
  std::string demangle_type(const char*);
}

which relate to the grammar productions <mangled-name> and <type>.

Regards,
Martin



From coleen at zko.dec.com  Thu Mar 16 15:37:54 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 16 Mar 2000 10:37:54 -0500
Subject: Changes for construction vtables.
Message-ID: <38D0FFD2.D9B99E89@zko.dec.com>


To minimize the size of vtables generated for construction vtables, I've
attached the changes in to this part of the ABI document.  I've chosen
a forest green for these changes.

Thanks,
Coleen


-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
A non-text attachment was scrubbed...
Name: abi-layout.html
Type: application/octet-stream
Size: 9275 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000316/3c0c55e7/attachment.obj>

From coleen at zko.dec.com  Thu Mar 16 15:58:34 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 16 Mar 2000 10:58:34 -0500
Subject: Real changes for construction vtables (ignore prior mail)
Message-ID: <38D104AA.58F9AC7F@zko.dec.com>


I was a bit premature.  I needed more forest green.  Attached is the
real revision for saving generation of construction vtables.

thanks,
Coleen

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ctorvtbls2.html
Type: application/octet-stream
Size: 10509 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000316/d5a0e050/attachment.obj>

From loewis at informatik.hu-berlin.de  Thu Mar 16 17:34:40 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 18:34:40 +0100
Subject: Real changes for construction vtables (ignore prior mail)
In-Reply-To: <38D104AA.58F9AC7F@zko.dec.com> (message from Coleen Phillimore
	on Thu, 16 Mar 2000 10:58:34 -0500)
References: <38D104AA.58F9AC7F@zko.dec.com>
Message-ID: <200003161734.SAA10395@pandora>

> I was a bit premature.  I needed more forest green.  Attached is the
> real revision for saving generation of construction vtables.

Please let me know if I summarise this correctly:

In a class requiring a VTT, the VTT does not contain the vtables for
all base subobject, but only for those that require a VTT themselves.

If that is the intent, how do I interpret the statement

# Addresses of secondary vtables that either have virtual bases or
# virtual functions overridden on a virtual path.

How can they have virtual functions overridden on a virtual path, if
they don't have virtual bases? I'd think the first condition would be
sufficient, right?

As an aside, I think this new proposal adds quite some complexity by
requiring a different layout of a vtable group referenced by the VTT
than a normal vtable group for the complete type (since vtables of
boring bases are not included in the VTT, but in a normal vtable
group).

Given that difference, I wonder whether the indirection mechanism in
the VTT is needed at all. Instead of passing a vtable** to the
not-in-charge ctors, could we not just pass a ctor vtable group?
I.e. the spec would read

The elements of the VTT array are in this order: 

  1. Primary vtable for the complete object.
  2. For each non-virtual subobject that needs a construction vtable,
     provide
      1. Primary construction vtable for the subobject.
      2. Secondary construction vtables for the subobjects that ...
  3. Secondary vtables of subobjects that have virtual bases.
  4. Construction vtables for each virtual subobject in initialization
     (DFS) order.

I believe all tables that get concatenated have a well-known size, so
we do no need the indirection that the VTT provides, do we?

Regards,
Martin




From ddd at cup.hp.com  Thu Mar 16 17:42:02 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 16 Mar 2000 17:42:02 +0000
Subject: Issue A-24
References: <14544.5997.647093.281885@isolde.engr.sgi.com>
Message-ID: <38D11CEA.DB79FEF2@cup.hp.com>

Matt,


This proposal looks fine, but is a bit different that what I wanted to do. My
initial intent was to try to create a situation where (without modifying the
linker):

- If the complete type info is there, the linker or dld resolves to it for all
(pointer) typeinfo that use it.

- If the complete type info is not there, then we keep multiple copies, and only
in that case do you pay the price for name comparison.

I did not find a proper way to do that. So currently, I actually have no real
proposal, and yours seem interesting.


Christophe


Matt Austern wrote:
> 
> I think it does work, provided that a __class_type_info for an
> incomplete class can appear only as the end of a __pointer_type_info
> chain.

I believe this is true (maybe you need to include references)


> (Christophe suggested a new class, __incomplete_class_info.  I see
> no reason for it, though.  We don't need any information for
> incomplete classes that we don't already have in __class_type_info.)
> 
I agree, once you have the bit indicating incompleteness at the top level.


> The __class_type_info for an incomplete type is mangled differently
> than the typeinfo object for a complete type.

Why? Note: I see no reason either way, but we are a bit short in mangling
prefixen.



From coleen at zko.dec.com  Thu Mar 16 18:00:06 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 16 Mar 2000 13:00:06 -0500
Subject: Real changes for construction vtables (ignore prior mail)
References: <38D104AA.58F9AC7F@zko.dec.com> <200003161734.SAA10395@pandora>
Message-ID: <38D12126.DE815325@zko.dec.com>

Martin von Loewis wrote:
> 
> > I was a bit premature.  I needed more forest green.  Attached is the
> > real revision for saving generation of construction vtables.
> 
> Please let me know if I summarise this correctly:
> 
> In a class requiring a VTT, the VTT does not contain the vtables for
> all base subobject, but only for those that require a VTT themselves.
> 
> If that is the intent, how do I interpret the statement
> 
> # Addresses of secondary vtables that either have virtual bases or
> # virtual functions overridden on a virtual path.
> 
> How can they have virtual functions overridden on a virtual path, if
> they don't have virtual bases? I'd think the first condition would be
> sufficient, right?

No.  If you have a class C that overrides a virtual function in a virtual
base class V (but V has no virtual bases itself), C still needs to have
a construction vtable for V.  The construction vtable for V during
construction of C in a more derived class D, may have a different vcall
offset to adjust for the overridden function than C where the most derived
class.  (I think these class names match the example that I provided with
the writeup originally).

> 
> As an aside, I think this new proposal adds quite some complexity by
> requiring a different layout of a vtable group referenced by the VTT
> than a normal vtable group for the complete type (since vtables of
> boring bases are not included in the VTT, but in a normal vtable
> group).

Yes, it does add complexity, which is why I didn't specify it at first.
But the boring class's vtable may add significant storage to the entire
vtable, which is why we decided this proposal was worth looking at.

> 
> Given that difference, I wonder whether the indirection mechanism in
> the VTT is needed at all. Instead of passing a vtable** to the
> not-in-charge ctors, could we not just pass a ctor vtable group?
> I.e. the spec would read

The VTT passed to base classes has the ctor vtable group for the base
class, but it also has the addresses of ctor vtable groups to pass from
the not-in-charge constructor to the constructors of it's base class
(all construction vtables are relative to the most derived class).
Representing it as an array seems the best way to do that.


> 
> The elements of the VTT array are in this order:
> 
>   1. Primary vtable for the complete object.
>   2. For each non-virtual subobject that needs a construction vtable,
>      provide
>       1. Primary construction vtable for the subobject.
>       2. Secondary construction vtables for the subobjects that ...
>   3. Secondary vtables of subobjects that have virtual bases.
>   4. Construction vtables for each virtual subobject in initialization
>      (DFS) order.
> 
> I believe all tables that get concatenated have a well-known size, so
> we do no need the indirection that the VTT provides, do we?

I don't think they do actually, because a construction vtable for a subobject
of a subobject may be at one offset for the complete object and another
for a more derived object.  I'll have to think about this.

Coleen

> 
> Regards,
> Martin

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From ddd at cup.hp.com  Thu Mar 16 18:24:03 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 16 Mar 2000 18:24:03 +0000
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
	     <200003142249.OAA49249@baalbek.engr.sgi.com> <200003152205.OAA76468@baalbek.engr.sgi.com> <38D00CFF.88014D3C@cup.hp.com> <200003161238.NAA06328@pandora>
Message-ID: <38D126C3.5244DE81@cup.hp.com>

Martin von Loewis wrote:
> 
> > Why do we half-mangle external declarations? That is, why _Z3foo rather than
> > foo? There is something that reads "[...] and file scope variables are not
> > mangled"
> 
> You are right, that 'int (**A::Afoo)()' declaration should be mangled
> as 'foo'. I'd prefer to say 'global namespace' instead of 'file
> scope', though. For one thing,
> 
> namespace Foo{
>    int bar;
> }
> 
> is mangled as _ZN3Foo3barE, and is still "file scope". Also, "file
> scope" is often used to describe
> 
> static int foo;
> 
> and we don't have an external name for that at all.

I agree. Jim, could you change the wording in the document, thank you.

Christophe



From ddd at cup.hp.com  Thu Mar 16 18:22:33 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 16 Mar 2000 18:22:33 +0000
Subject: Mangling: Allocating constructors
References: <200003152156.NAA76374@baalbek.engr.sgi.com> <200003161230.NAA06311@pandora>
Message-ID: <38D12669.6672D483@cup.hp.com>

Martin von Loewis wrote:
> 
> > After a brief discussion last week, we opened a new issue at HP's
> > request to consider whether to _also_ support allocating constructors,
> > with a low priority (i.e. we'll worry about it later).  We observed
> > that there's nothing to prevent an implementation from adding an
> > allocating constructor, though the ABI doesn't require it, and the
> > mangling for them was intended to allow consistent names if that
> > happens (although an agreement on parameters would also be required).
> 
> If that is an extension, then code relying on it being generated is
> not ABI compliant, of course...

Which is why I asked for the issue to be opened :-)

Christophe



From coleen at zko.dec.com  Thu Mar 16 20:03:01 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 16 Mar 2000 15:03:01 -0500
Subject: Longest mangled name in "real" code.
References: <200003160015.QAA76329@baalbek.engr.sgi.com> <200003161305.OAA06582@pandora>
Message-ID: <38D13DF5.B53F3835@zko.dec.com>


Martin,

/* This isn't exactly real code, but this test produces the
longest mangled name I've seen.  But there's lots of duplication.
*/

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
A non-text attachment was scrubbed...
Name: cxxc_bugs5514.cxx
Type: application/octet-stream
Size: 991 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000316/50383884/attachment.obj>

From cary at cup.hp.com  Thu Mar 16 20:18:31 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Thu, 16 Mar 2000 12:18:31 -0800
Subject: [ia64-abi] Issue reminder
Message-ID: <200003162017.MAA14755@adlmail.cup.hp.com>

>Issue 72:  COMDAT group sections
>	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.html
>	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.pdf
>
>	This is critical to C++ features like vtables, inline
>	functions, etc.

I have no issues with this proposal.


>Issue 74:  Section indices
>	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.html
>	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.pdf
>
>	This is a longer term concern, which will become more important
>	with heavy COMDAT usage.

I support this proposal. One thing that's not clear, though -- are the 
section indices 0xff00 - 0xffff still reserved, or are these values 
reserved only when seen in the st_shndx field? I assume you have intended 
the latter.

I would suggest adding some wording to make it clear that the extended 
section index does not reserve the range 0xff00 - 0xffff as special 
section indices. That is, once you see SHN_XINDEX in the st_shndx field, 
what you pull out of the extension section is a real section index. (I 
haven't yet taken the time to make sure that st_shndx is the only place 
where special section indices ever get used.)

This may take some creative re-wording in the gABI document, where it 
describes the reserved section indices.


>Issue 73:  Stack unwind interface
>	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.html
>	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.pdf
>
>	This is mostly consistent with, but more completely specified
>	than, the current SW Conventions description.

This looks OK to me. I haven't found anything that directly contradicts 
the common conventions document, so if you know of anything, please point 
it out to me. Any conflict is probably the result of over-specification 
at the common conventions level, so I'd probably propose to resolve most 
conflicts by removing material from the conventions document.

This material, being Unix specific, belongs in the psABI document, but 
not in the conventions document.


>Issue ??:  IPLT relocations
>	I sent a proposal a while back to extend these to .o files.
>	Cygnus has expressed concern about conflict with the lazy
>	loading semantics, which would be resolved by a second
>	relocation which is identical but doesn't allow lazy binding.
>	I don't care which approach is taken, in fact being able to
>	force early binding might be useful in any case, but C++ will
>	need to be able to relocate functions descriptors in vtables.

I don't think there's a conflict -- I'm hoping that the lack of further 
discussion on this issue indicates general agreement. Lazy binding is 
tied to the DT_JMPREL entry, not to the semantics of the IPLT relocation. 
At HP, it's been our intent for quite a while to use the IPLT relocations 
for this purpose, but we haven't planned any lazy binding support for 
vtables (the bookkeeping is considerably harder than for PLT entries), so 
these relocations will not be part of our DT_JMPREL set.


>Issue ??:  Types
>	I sent a note a couple of days ago.  We must decide whether
>	__int64 and __float80 are distinct types, or typedefs of long
>	long and long double.  As Martin pointed out, we should also
>	specify bindings of the sized types defined by C2000.

I thought you noted that this was just a C++ issue. Do we need to answer 
this at the base ABI level?


-cary



From dehnert at baalbek.engr.sgi.com  Thu Mar 16 20:37:36 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 16 Mar 2000 12:37:36 -0800 (PST)
Subject: Mangling: Allocating constructors
References: <200003152156.NAA76374@baalbek.engr.sgi.com>
Message-ID: <200003162037.MAA78332@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar 16 04:30:15 2000
> 
> > After a brief discussion last week, we opened a new issue at HP's
> > request to consider whether to _also_ support allocating constructors,
> > with a low priority (i.e. we'll worry about it later).  We observed
> > that there's nothing to prevent an implementation from adding an
> > allocating constructor, though the ABI doesn't require it, and the
> > mangling for them was intended to allow consistent names if that
> > happens (although an agreement on parameters would also be required).
> 
> If that is an extension, then code relying on it being generated is
> not ABI compliant, of course...

Of course.  Unless the same code using it also generated it (in which
case it could name it anything it wanted to...)

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar 16 20:41:53 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 16 Mar 2000 12:41:53 -0800 (PST)
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
    <200003142249.OAA49249@baalbek.engr.sgi.com>
    <200003152205.OAA76468@baalbek.engr.sgi.com>
Message-ID: <200003162041.MAA79538@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar 16 04:34:43 2000
> 
> > Good point.  So the original mangling _Z3fooPPM2ABFiE, is invalid.
> 
> It depends. I'd say the grammar was wrong, and should read
> 
> <encoding> ::= <name> [ <function parameters> ]
> <function parameters> ::= <type>*
> 
> The question is whether '? foo(int)' should be '_Z3fooi' or
> '_Z3fooFiE'. It would work either way. The original draft had the
> first version, the new grammar the second.
> 
> > Note that since yesterday's message I've converted the examples to a
> > table to make it easier to read, and in the process I fixed most of
> > them.  Most, if not all, of the fixes involved inserting the F...E
> > delimiters around function types.
> 
> Was there a deliberate decision to change the mangling? I think
> neither is 'better' than the other, so I don't care too much...

We decided today to go back to the original form.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From austern at sgi.com  Thu Mar 16 20:43:19 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 16 Mar 2000 12:43:19 -0800 (PST)
Subject: [ia64-abi] Issue reminder
In-Reply-To: <200003162017.MAA14755@adlmail.cup.hp.com>
References: <200003162017.MAA14755@adlmail.cup.hp.com>
Message-ID: <14545.18012.595298.280083@isolde.engr.sgi.com>


Cary Coutant writes:

 > >Issue ??:  Types
 > >	I sent a note a couple of days ago.  We must decide whether
 > >	__int64 and __float80 are distinct types, or typedefs of long
 > >	long and long double.  As Martin pointed out, we should also
 > >	specify bindings of the sized types defined by C2000.
 > 
 > I thought you noted that this was just a C++ issue. Do we need to answer 
 > this at the base ABI level?

Yes.  This is mostly a C++ issue, but it also matters for C.

First of all, consider the following C code:
    void f(__int64);
    void f(long n) {}
This is valid if __int64 is a typedef for long, otherwise it's
an error.

Second, C99 specifies a whole lot of typedefs and macros for integer
types.  inttypes.h is a C header, and it's important for everyone to
agree on its contents.

                        --Matt




From dehnert at baalbek.engr.sgi.com  Thu Mar 16 20:45:44 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 16 Mar 2000 12:45:44 -0800 (PST)
Subject: More mangling issues
References: <200003101944.UAA09762@pandora>
    <200003142249.OAA49249@baalbek.engr.sgi.com>
    <200003152205.OAA76468@baalbek.engr.sgi.com> <38D00CFF.88014D3C@cup.hp.com>
Message-ID: <200003162045.MAA79188@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar 16 04:38:44 2000
> 
> > Why do we half-mangle external declarations? That is, why _Z3foo rather than
> > foo? There is something that reads "[...] and file scope variables are not
> > mangled"
> 
> You are right, that 'int (**A::Afoo)()' declaration should be mangled
> as 'foo'.

We also noted today that we can't mangle "void foo()" as "foo" because
it needs to be distinguished from 'extern "C" foo(int)' and the like.

> I'd prefer to say 'global namespace' instead of 'file
> scope', though.

I'll try to change the terminology.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Thu Mar 16 22:13:45 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 16 Mar 2000 23:13:45 +0100
Subject: Longest mangled name in "real" code.
In-Reply-To: <38D13DF5.B53F3835@zko.dec.com> (message from Coleen Phillimore
	on Thu, 16 Mar 2000 15:03:01 -0500)
References: <200003160015.QAA76329@baalbek.engr.sgi.com> <200003161305.OAA06582@pandora> <38D13DF5.B53F3835@zko.dec.com>
Message-ID: <200003162213.XAA15747@pandora>

> This isn't exactly real code, but this test produces the
> longest mangled name I've seen.  But there's lots of duplication.

Coleen,

Thanks for the code. When passing this code to g++, it produced
exactly one large symbol: the constructor call for mapofamap. I tried
to come up with a mangling for the type; as a constructor, it would
only have an additional _ZD1 prefix, right?

Anyway, here are my results:

cxxc_bugs5514.cxx - original source
g++old        - current g++ mangling                   - 8163 bytes
g++squangling - new compressing 'squangling' mechanism -  266 bytes
abitype       - ABI conforming mangling of this type   -  162 bytes
fulltype      - demangled version of the type (no spaces)
genmap.py     - generator used to produce the mangling

I haven't had a chance to check this with some other compiler, if you
do, please let me know how they perform. Compared to g++, it seems
this does significantly better.

Please note that the generator is as experimental as the demangler, so
it may be incorrect. If you find errors in it, please le me know.

Regards,
Martin

-------------- next part --------------
A non-text attachment was scrubbed...
Name: abimangling.tgz
Type: application/octet-stream
Size: 4011 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000316/c9a19cb8/attachment.obj>

From austern at sgi.com  Thu Mar 16 23:12:55 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 16 Mar 2000 15:12:55 -0800 (PST)
Subject: Another mangling loose end
Message-ID: <14545.26482.774834.585686@isolde.engr.sgi.com>

Linkage specification is part of the type, and can be used for
overloading.  (7.5/1: "Two function types with different language
linkages are distinct types even if they are otherwise identical.")
That means they have to be mangled differently.

Example:
    typedef void (*FPTR)();
    extern "C" typedef void (*FPTR_c)();

    void f(FPTR   pf);    // These functions are overloaded on linkage
    void f(FPTR_c pf);    // specification.  They must be mangled
                          // differently.

Probably the simple solution: add linkage as a qualifier in function
types.

Issue: do we introduce mangling for C and C++ linkage only, or do
we handle other kinds of language linkage as well?

                        --Matt





From austern at sgi.com  Thu Mar 16 23:25:59 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 16 Mar 2000 15:25:59 -0800 (PST)
Subject: More proposals for the mangling dictionary
Message-ID: <14545.27936.27935.992015@isolde.engr.sgi.com>

std::basic_istream<char,  std::char_traits<char> >
std::basic_ostream<char,  std::char_traits<char> >
std::basic_iostream<char, std::char_traits<char> >



From dehnert at baalbek.engr.sgi.com  Thu Mar 16 23:27:30 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 16 Mar 2000 15:27:30 -0800 (PST)
Subject: [ia64-abi] Issue reminder
References: <200003162017.MAA14755@adlmail.cup.hp.com>
Message-ID: <200003162327.PAA79431@baalbek.engr.sgi.com>

> From austern at isolde  Thu Mar 16 12:44:44 2000
> 
> Cary Coutant writes:
> 
>  > >Issue ??:  Types
>  > >	I sent a note a couple of days ago.  We must decide whether
>  > >	__int64 and __float80 are distinct types, or typedefs of long
>  > >	long and long double.  As Martin pointed out, we should also
>  > >	specify bindings of the sized types defined by C2000.
>  > 
>  > I thought you noted that this was just a C++ issue. Do we need to answer 
>  > this at the base ABI level?
> 
> Yes.  This is mostly a C++ issue, but it also matters for C.
> 
> First of all, consider the following C code:
>     void f(__int64);
>     void f(long n) {}
> This is valid if __int64 is a typedef for long, otherwise it's
> an error.

So again, I propose that we treat:

	__int64 as a synonym for long long
	signed __int64 as a synonym for signed long long
	unsigned __int64 as a synonym for unsigned long long
	__float80 as a synonym for long double

But, I don't know whether we can do that, in the sense of whether we
can treat __int64 as a typedef AND then use signed/unsigned prefixes.
Does anyone know the rules?

> Second, C99 specifies a whole lot of typedefs and macros for integer
> types.  inttypes.h is a C header, and it's important for everyone to
> agree on its contents.

To be more specific, for those anxious to dive in and do the work,
take a look at C2000 section 7.18: Integer types (stdint.h).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From drepper at redhat.com  Thu Mar 16 23:42:39 2000
From: drepper at redhat.com (Ulrich Drepper)
Date: 16 Mar 2000 15:42:39 -0800
Subject: [ia64-abi] Issue reminder
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Thu, 16 Mar 2000 15:27:30 -0800 (PST)"
References: <200003162017.MAA14755@adlmail.cup.hp.com> <200003162327.PAA79431@baalbek.engr.sgi.com>
Message-ID: <m3wvn2iis0.fsf@localhost.localnet>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

> So again, I propose that we treat:
> [...]
> 	__float80 as a synonym for long double

If you want to the ABI be universally usable this is bad.  On SPARC,
PPC, and many other archs __float128 would be long double.  There is
no consistency.

-- 
---------------.      drepper at gnu.org  ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------



From austern at sgi.com  Thu Mar 16 23:53:42 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 16 Mar 2000 15:53:42 -0800 (PST)
Subject: [ia64-abi] Issue reminder
In-Reply-To: <m3wvn2iis0.fsf@localhost.localnet>
References: <200003162017.MAA14755@adlmail.cup.hp.com>
	<200003162327.PAA79431@baalbek.engr.sgi.com>
	<m3wvn2iis0.fsf@localhost.localnet>
Message-ID: <14545.29546.790779.327490@isolde.engr.sgi.com>


Ulrich Drepper writes:
 > dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
 > 
 > > So again, I propose that we treat:
 > > [...]
 > > 	__float80 as a synonym for long double
 > 
 > If you want to the ABI be universally usable this is bad.  On SPARC,
 > PPC, and many other archs __float128 would be long double.  There is
 > no consistency.

Parts of the ABI are universally usable, other parts are very specific 
to IA64.  So far we haven't tried to separate out those parts, since
our explicit purpose has been defining an IA64 ABI.

I agree, though, once we're done it would be very interesting to
isolate the platform-dependent stuff and turn the IA64 ABI into a
family of ABIs.




From dehnert at baalbek.engr.sgi.com  Fri Mar 17 00:38:16 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 16 Mar 2000 16:38:16 -0800 (PST)
Subject: [ia64-abi] Issue reminder
References: <200003162017.MAA14755@adlmail.cup.hp.com>
    <200003162327.PAA79431@baalbek.engr.sgi.com>
Message-ID: <200003170038.QAA80333@baalbek.engr.sgi.com>

> From drepper at cygnus.com  Thu Mar 16 15:45:00 2000
> 
> dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
> 
> > So again, I propose that we treat:
> > [...]
> > 	__float80 as a synonym for long double
> 
> If you want to the ABI be universally usable this is bad.  On SPARC,
> PPC, and many other archs __float128 would be long double.  There is
> no consistency.

I don't.  We're defining a 64-bit IA-64 psABI, where we've already
determined that long double is the native 80-bit type.

Of course, to the extent that we're also defining the language API,
there is an issue.  In C, I think it only affects the user if he
attempts to mix the types in different declarations of the same
function, which might work on one target and fail on another -- so he
shouldn't do it.  Furthermore, the only machines I can think of with
80-bit FP are IA-32 and IA-64, both of which use it for long double.
So even this won't produce any more porting problems than using
__float80 does in the first place.

C++ becomes much more interesting.  Introducing new fundamental types
requires different overloading and therefore mangling (so we'll have
to define it), which is straightforward.  But it also requires defining
the overload resolution/ambiguity rules, which isn't straightforward,
and probably other issues (I'm no expert in this area).  It will also
end up causing additional instantiations of templates.  It is for this
reason that we've suggested treating those we can as synonyms.

Now, there is a minor issue.  If one interprets "synonym" as
"typedef", doing "typedef long long __int64" does not enable one to use
"signed __int64" or "unsigned __int64".  So the synonym treatment would
require something deeper.

We could take another approach, more drastic on the surface, but
more in keeping with the C2000 standard.  That would be to remove
__int64 and __float80, and instead use the C2000 stdint.h and the
equivalent for floats (which we'd have to define).  We could
typedef them if anyone is already using them to minimize problems.
I'm sure that wouldn't avoid all issues, but it would leave us with
something more in the spirit of the C2000 standard.

Whatever the decision, we need to make it so C++ can do whatever ends
up being required.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Fri Mar 17 09:51:16 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 17 Mar 2000 10:51:16 +0100
Subject: [ia64-abi] Issue reminder
In-Reply-To: <200003162327.PAA79431@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003162017.MAA14755@adlmail.cup.hp.com> <200003162327.PAA79431@baalbek.engr.sgi.com>
Message-ID: <200003170951.KAA19757@pandora>

> But, I don't know whether we can do that, in the sense of whether we
> can treat __int64 as a typedef AND then use signed/unsigned prefixes.
> Does anyone know the rules?

This is an extension, so you (we) can do whatever we want. If you want
__int64 to be a full keyword, then specifying that formally is quite
involved. In [basic.fundamental]/2, you'd have a new signed integer
type. That gives you new standard conversion sequences, and so on...

You could say __int64 is a predefined #define.

Or you could say __int64 is a magic alias for 'long long', and should
be treated as 'int' in all places.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Fri Mar 17 09:55:45 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 17 Mar 2000 10:55:45 +0100
Subject: [ia64-abi] Issue reminder
In-Reply-To: <200003170038.QAA80333@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003162017.MAA14755@adlmail.cup.hp.com>
    <200003162327.PAA79431@baalbek.engr.sgi.com> <200003170038.QAA80333@baalbek.engr.sgi.com>
Message-ID: <200003170955.KAA19772@pandora>

> We could take another approach, more drastic on the surface, but
> more in keeping with the C2000 standard.  That would be to remove
> __int64 and __float80, and instead use the C2000 stdint.h and the
> equivalent for floats (which we'd have to define).

Yes! Were is it written that IA64 *has* to have a magic __int64 type?
<stdint.h> was specifically designed to not require such types, and
improve portability.

Martin




From loewis at informatik.hu-berlin.de  Fri Mar 17 10:04:18 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 17 Mar 2000 11:04:18 +0100
Subject: Another mangling loose end
In-Reply-To: <14545.26482.774834.585686@isolde.engr.sgi.com> (message from
	Matt Austern on Thu, 16 Mar 2000 15:12:55 -0800 (PST))
References: <14545.26482.774834.585686@isolde.engr.sgi.com>
Message-ID: <200003171004.LAA19828@pandora>

> Probably the simple solution: add linkage as a qualifier in function
> types.

Yes, that sounds simple.

> Issue: do we introduce mangling for C and C++ linkage only, or do
> we handle other kinds of language linkage as well?

Definitely not. Please have a look at Core Issue 13
(http://www.informatik.hu-berlin.de/~loewis/corer9.html#13), where one
of the suggested resolutions is to deprecate that feature (using
linkage specifiers on types).

Regards,
Martin



From dfp at sco.com  Fri Mar 17 15:49:00 2000
From: dfp at sco.com (dfp at sco.com)
Date: Fri, 17 Mar 2000 10:49 EST
Subject: [ia64-abi] Issue reminder
Message-ID: <200003171549.KAA11782@sfinx.newjersey.sco.com>

-----BEGIN PGP SIGNED MESSAGE-----

> >Issue 74:  Section indices
> >	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.html
> >	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.pdf
> >
> >	This is a longer term concern, which will become more important
> >	with heavy COMDAT usage.
> 
> I support this proposal. One thing that's not clear, though -- are the 
> section indices 0xff00 - 0xffff still reserved, or are these values 
> reserved only when seen in the st_shndx field? I assume you have intended 
> the latter.
> 
> I would suggest adding some wording to make it clear that the extended 
> section index does not reserve the range 0xff00 - 0xffff as special 
> section indices. That is, once you see SHN_XINDEX in the st_shndx field, 
> what you pull out of the extension section is a real section index. (I 
> haven't yet taken the time to make sure that st_shndx is the only place 
> where special section indices ever get used.)
> 
> This may take some creative re-wording in the gABI document, where it 
> describes the reserved section indices.

I'm not happy with the lack of a direct connection between
the symbol table and its parallel section.  It seems like
we could designate one of the entries in the symbol table
index 0 to be another sh_link equivalent.

Also, even though we don't have to produce ELF files that
use this extension, pretty much all ELF tools will need to
change to handle this.  This is in contrast to the COMDAT
proposal, for example.  I'm not sure that there's anything
we can do to address this issue without this impact, but
it is at the very least annoying.

> >Issue ??:  Types
> >	I sent a note a couple of days ago.  We must decide whether
> >	__int64 and __float80 are distinct types, or typedefs of long
> >	long and long double.  As Martin pointed out, we should also
> >	specify bindings of the sized types defined by C2000.
> 
> I thought you noted that this was just a C++ issue. Do we need to answer 
> this at the base ABI level?

> Yes.  This is mostly a C++ issue, but it also matters for C.
> 
> First of all, consider the following C code:
>     void f(__int64);
>     void f(long n) {}
> This is valid if __int64 is a typedef for long, otherwise it's
> an error.

Strangely, there doesn't seem to be an entry for "long"
in the IA64 conventions.  Take a look at Table 4-1.  Since
it's LP64, we all know that [signed] long and unsigned long
should be in the 8, 8 integer entries.

I also believe that the intent of __int64 is that it was
just a nomenclature convenience for 64 bit integers, just
like __int128 is for 128 bit integers.  Since the document
is really describing binary representations, there is no
requirement that there be anything like these names accepted
as keywords (or predefined macros) in any compiler.

As such, there's no issue about use of __int64 in source
code.  If implementations choose to provide such a name, I'm
confident that they'll "do it right".

The same argument applies to __float80 and __float128.

> Second, C99 specifies a whole lot of typedefs and macros for integer
> types.  inttypes.h is a C header, and it's important for everyone to
> agree on its contents.

The IA-64 LP64 conventions and ABI make the contents of
this header pretty much fall out without much thought.
If an implementation provides a 128 bit integer, then
it will have a different intmax_t (and so on) than those
implementations that have at most a 64 bit integer.  I
don't see any reason why we have to specify anything for
<inttypes.h> or <stdint.h>.

Dave Prosser dfp at sco.com (908)790-2358 Rm A332, SCO, Murray Hill, NJ
-----BEGIN PGP SIGNATURE-----
Version: 2.6.2

iQCVAwUBONJT8L3l4qe5Xxg5AQHJWgP/TZF5QB/urv8R2YQoLGmLyVEKWe3i3HcS
k+cInDsqt36ovvkLozUr/Hvww11IZSW+E5/jb9NIrkVN8T4+Br4kuWO8uZH+NPey
9gHqbmI/OAPreQmwFkxgQJF8OY9qblJN+xFGvBHXZGicH0JB/IpHPp77MqdDtV45
7sqzSwzOyxU=
=RnS4
-----END PGP SIGNATURE-----



From austern at sgi.com  Fri Mar 17 17:33:45 2000
From: austern at sgi.com (Matt Austern)
Date: Fri, 17 Mar 2000 09:33:45 -0800 (PST)
Subject: [ia64-abi] Issue reminder
In-Reply-To: <200003170951.KAA19757@pandora>
References: <200003162017.MAA14755@adlmail.cup.hp.com>
	<200003162327.PAA79431@baalbek.engr.sgi.com>
	<200003170951.KAA19757@pandora>
Message-ID: <14546.27160.978365.496064@isolde.engr.sgi.com>


Martin von Loewis writes:
 > > But, I don't know whether we can do that, in the sense of whether we
 > > can treat __int64 as a typedef AND then use signed/unsigned prefixes.
 > > Does anyone know the rules?
 > 
 > This is an extension, so you (we) can do whatever we want. If you want
 > __int64 to be a full keyword, then specifying that formally is quite
 > involved. In [basic.fundamental]/2, you'd have a new signed integer
 > type. That gives you new standard conversion sequences, and so on...

That's my feeling too.  Language extension is a very complicated game
when the language is as complicated as C++.  I'd hate to see us forced
into an unplanned extension just because of unanticipated consequences
from some other decision.

The only thing that might force us to treat this is a language
extension is the business of "signed __int64" and "unsigned __int64".
How strongly committed are people to that syntax?  When I read that
the first time, I hadn't realized that it was supposed to be code.  I
thought it was just supposed to be an English-language description of
signed and unsigned versions of a 64-bit integer type.  We could
accomplish that just as easily with "__int64" and "__uint64", or with
the C99 integer type typedefs.

                        --Matt



From austern at sgi.com  Fri Mar 17 17:43:00 2000
From: austern at sgi.com (Matt Austern)
Date: Fri, 17 Mar 2000 09:43:00 -0800 (PST)
Subject: Another mangling loose end
In-Reply-To: <200003171004.LAA19828@pandora>
References: <14545.26482.774834.585686@isolde.engr.sgi.com>
	<200003171004.LAA19828@pandora>
Message-ID: <14546.28110.277845.847175@isolde.engr.sgi.com>

Martin von Loewis writes:
 > > Probably the simple solution: add linkage as a qualifier in function
 > > types.
 > 
 > Yes, that sounds simple.
 > 
 > > Issue: do we introduce mangling for C and C++ linkage only, or do
 > > we handle other kinds of language linkage as well?
 > 
 > Definitely not. Please have a look at Core Issue 13
 > (http://www.informatik.hu-berlin.de/~loewis/corer9.html#13), where one
 > of the suggested resolutions is to deprecate that feature (using
 > linkage specifiers on types).

But Bill isn't suggesting that the committee should revisit the
decision to make linkage part of the type.  All he's suggesting is
that we change the syntax for attaching linkage to function types.

Bill's suggestion may be a good one; linkage specification for
function types is one of the ugliest parts of C++ declaration syntax,
which is saying a lot.  I don't think it affects our decisions,
though.  It's a source language issue, and the ABI issues will remain
the same.

                        --Matt




From cary at cup.hp.com  Fri Mar 17 17:58:12 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Fri, 17 Mar 2000 09:58:12 -0800
Subject: [ia64-abi] Issue 74 - Section Indices
Message-ID: <200003171757.JAA21269@adlmail.cup.hp.com>

>Also, even though we don't have to produce ELF files that
>use this extension, pretty much all ELF tools will need to
>change to handle this.  This is in contrast to the COMDAT
>proposal, for example.  I'm not sure that there's anything
>we can do to address this issue without this impact, but
>it is at the very least annoying.

I don't think this is true. A tool can ignore almost all of the proposal 
and still deal with any ELF file that doesn't have more than 0xff00 
sections. If they're not prepared to deal with large section tables, 
they'll see the special value SHN_XINDEX in the e_shnum field. Likewise, 
they can ignore the parallel array unless they see SHN_XINDEX in the 
st_shndx field.

I actually preferred the original suggestion to set e_shnum to 0 for 
large section tables. That way, old tools not prepared to deal with large 
section tables think they're looking at an empty file.

-cary



From cary at cup.hp.com  Fri Mar 17 18:21:11 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Fri, 17 Mar 2000 10:21:11 -0800
Subject: [ia64-abi] Issue reminder
Message-ID: <200003171820.KAA22116@adlmail.cup.hp.com>

>I also believe that the intent of __int64 is that it was
>just a nomenclature convenience for 64 bit integers, just
>like __int128 is for 128 bit integers.  Since the document
>is really describing binary representations, there is no
>requirement that there be anything like these names accepted
>as keywords (or predefined macros) in any compiler.
>
>As such, there's no issue about use of __int64 in source
>code.  If implementations choose to provide such a name, I'm
>confident that they'll "do it right".
>
>The same argument applies to __float80 and __float128.

Dave is right -- __int64, __int128, __float80, and __float128 are just 
notational conveniences for the core conventions document, which doesn't 
go so far as to specify what long, long long, and long double are.

An ABI document is expected to specify the standard types, so these "__" 
types aren't necessary in the ABI. Once the ABI has mapped a standard 
type to a hardware representation, the conventions document then provides 
the conventions for that type.

I'd be amenable to clarifying the core conventions document to this 
effect.

-cary



From dehnert at baalbek.engr.sgi.com  Sat Mar 18 02:04:18 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 17 Mar 2000 18:04:18 -0800 (PST)
Subject: Real changes for construction vtables (ignore prior mail)
References: <38D104AA.58F9AC7F@zko.dec.com> <200003161734.SAA10395@pandora>
Message-ID: <200003180204.SAA83428@baalbek.engr.sgi.com>

I've been working through this proposal, and I think I've noticed an
implication that is important.  If the construction vtable groups are
not replicas (in layout, not value) of the corresponding complete object
vtable groups, eliding the "boring" base class vtables, this affects
more than just constructors.  It affects any vtable references in any
functions which might be called from constructors, in that they may no
longer assume fixed order and offsets of the secondary vtables, and
therefore may not use the optimization of using one vtable pointer to
access all of them -- instead, they must always load the vtable pointer
for the particular subobject whose vtable they are referencing.

Am I interpreting this correctly?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Mar 18 02:44:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 17 Mar 2000 18:44:47 -0800 (PST)
Subject: Construction vtables in layout document
Message-ID: <200003180244.SAA83191@baalbek.engr.sgi.com>

I've incorporated changes from Coleen's proposal in the layout document,
in a format that should allow easy comparison.  There are no substantive
wording changes (yet :-), but I did modify the pseudo-code for the
constructor a bit to clarify.  Coleen, can you please verify that it
actually clarifies, and isn't wrong?

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Sat Mar 18 11:21:34 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Sat, 18 Mar 2000 12:21:34 +0100
Subject: Real changes for construction vtables (ignore prior mail)
In-Reply-To: <200003180204.SAA83428@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <38D104AA.58F9AC7F@zko.dec.com> <200003161734.SAA10395@pandora> <200003180204.SAA83428@baalbek.engr.sgi.com>
Message-ID: <200003181121.MAA28163@pandora>

> Am I interpreting this correctly?

I think your understanding is correct.

Martin



From mark at codesourcery.com  Sun Mar 19 03:42:34 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 18 Mar 2000 19:42:34 -0800
Subject: Typos in class-layout algorithm
Message-ID: <20000318194234A.mitchell@codesourcery.com>


The "Non-Virtual-Base Allocation" section in the data layout document
still contains a couple of typos:

  Finally allocate any direct or indirect virtual base classes (except
  the primary base class or any indirect primary base classes) as we did
  non-virtual base classes in step II-1, in inheritance graph
  order. Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)). If
  non-empty, also update align(C) and dsize(C) as in II-1.

II-1 is now about bitfields.  Why not just say that you should use
II-2 if the virtual base is non-empty, and II-3 if it is empty?

  The primary base class has already been allocated in I-3a.

That's now I-2b.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From coleen at zko.dec.com  Mon Mar 20 15:23:05 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 20 Mar 2000 10:23:05 -0500
Subject: Real changes for construction vtables (ignore prior mail)
References: <38D104AA.58F9AC7F@zko.dec.com> <200003161734.SAA10395@pandora> <200003180204.SAA83428@baalbek.engr.sgi.com>
Message-ID: <38D64259.BC714EF8@zko.dec.com>

Jim Dehnert wrote:
> 
> I've been working through this proposal, and I think I've noticed an
> implication that is important.  If the construction vtable groups are
> not replicas (in layout, not value) of the corresponding complete object
> vtable groups, eliding the "boring" base class vtables, this affects
> more than just constructors.  It affects any vtable references in any
> functions which might be called from constructors, in that they may no
> longer assume fixed order and offsets of the secondary vtables, and
> therefore may not use the optimization of using one vtable pointer to
> access all of them -- instead, they must always load the vtable pointer
> for the particular subobject whose vtable they are referencing.
> 
> Am I interpreting this correctly?

Yes, that is correct.  I thought this optimization was invalidated by
something else already - sharing primary virtual tables, wasn't it?  Because
primary vtables may be larger than expected by base classes in more derived
classes.

But if it wasn't, this would be a tradeoff.

Coleen

> 
> Jim
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From dehnert at baalbek.engr.sgi.com  Tue Mar 21 08:24:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 21 Mar 2000 00:24:05 -0800 (PST)
Subject: ABI layout update
Message-ID: <200003210824.AAA04528@baalbek.engr.sgi.com>

The document on the website is updated to reflect last weeks meeting
and email.  The most significant changes are Coleen's modified proposal
for construction vtables (already there Friday), and extensive mangling
changes, primarily to describe the substitutions.  Take a hard look --
I'll get the other documents tomorrow, I hope.

Jim
-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Tue Mar 21 21:45:30 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 21 Mar 2000 22:45:30 +0100
Subject: RTTI of local classes
Message-ID: <200003212145.WAA17941@pandora>

I was just reviewing the RTTI spec and see that type_info equalness is
based on type name mangling; this seems to be the right solution.

However, I think there are examples that break under that scheme:

struct Base{
  virtual ~Base();
};

static bool foo(Base* x){
  struct Derived:Base{};
  Base *y = new Derived;
  return typeid(*x)==typeid(*y);
}

typeinfo(*y).name() would be "Z3fooP4BaseE1_", right? Now, that could
also be the name of *x, if that was created in a different translation
unit, which also has a function foo(Base*) with a local type Derived.

I'm not sure about a conclusion. Is that well-formed C++ code with a
well-defined behaviour? Does our ABI support that? Should it? Is that
a defect in C++, as it is unimplementable?

Comments appreciated,
Martin




From loewis at informatik.hu-berlin.de  Tue Mar 21 22:06:18 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 21 Mar 2000 23:06:18 +0100
Subject: Mangling: Back-referencing in compressions
Message-ID: <200003212206.XAA18043@pandora>

I still find the description of the compression scheme confusing,
especially the sentence:

  All substitutable components are so numbered, including those that
  have been substituted already, but the substitution occurs only if
  "S<number>_" is strictly shorter than the unsubstituted encoding.

What I don't understand here is what exactly goes into the catalog, if
substitution occurs. Given

 void foo(Outer::Inner::x, Outer::Inner::y, Outer::Other)

I get (starting with least recent)

  Outer
  Outer::Inner
  Outer::Inner::x

so I can express the second parameter as S2_::y. After that, do I have a
catalog of

  Outer, Outer::Inner, Outer::Inner::x
  Outer, Outer::Inner, Outer::Inner::y

(ie. in case of substitution, all subcomponents went into the
catalog), or do I get

  Outer, Outer::Inner, Outer::Inner::x
  Outer::Inner, Outer::Inner::y

(i.e. only the entire substituted component goes into the
catalog). Depending on that, the external name would be either
_Z3fooN5Outer5Inner1xENS2_1yENS3_5OtherE or
_Z3fooN5Outer5Inner1xENS2_1yENS5_5OtherE

I think it would be sufficient to put only the entire component into
the catalog (*); its components are already in the catalog (further
back), so the can be identified as well.

Regards,
Martin

(*) This is different from what I wrote in an earlier message; I now
think there is no point in putting all elements of a deep structure
into the catalog, since that only results in a larger catalog, with no
benefit.



From mark at codesourcery.com  Tue Mar 21 22:16:31 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 21 Mar 2000 14:16:31 -0800
Subject: RTTI of local classes
In-Reply-To: <200003212145.WAA17941@pandora>
References: <200003212145.WAA17941@pandora>
Message-ID: <20000321141631Q.mitchell@codesourcery.com>

>>>>> "Martin" == Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

    Martin> I'm not sure about a conclusion. Is that well-formed C++
    Martin> code with a well-defined behaviour? Does our ABI support
    Martin> that? Should it? Is that a defect in C++, as it is
    Martin> unimplementable?

It's not really unimplementable.  At least no more so that anonymous
namespaces, right?  I mean, you could mangle some random information
(timestamps, etc.)  into the name, to keep the namespaces separate.

But, you're right -- it is an issue.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Tue Mar 21 22:29:09 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 21 Mar 2000 23:29:09 +0100
Subject: Mangling: std:: prefix
Message-ID: <200003212229.XAA18149@pandora>

I don't really know how much the special-casing of std:: buys us, but
if that is to be preserved, I propose the following grammar addition:

  <name> ::= St <unqualified-name>

Regards,
Martin




From dehnert at baalbek.engr.sgi.com  Tue Mar 21 22:51:38 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 21 Mar 2000 14:51:38 -0800 (PST)
Subject: Mangling: std:: prefix
Message-ID: <200003212251.OAA05765@baalbek.engr.sgi.com>

More updates...

I've cleaned up the "St" description -- it wasn't as hard today as it
was at midnight :-).  I concluded in the process that putting it
outside the N..E delimiters was inconsistent, so as written, either
it's inside like any other initial substitution, or there are no
delimiters.

I suggested a 'Y' qualifier for extern "C" functions.  All the good
letters were taken...

I think it would be a good idea to start the substitution numbering
from '0' instead of '1', but haven't made that change yet.  It gives us
one more single-digit substitution, at no apparent cost.

When I wrote the substitution description, I attempted to indicate
that if a larger construct were substituted, its components were not
added to the dictionary (but it was).  I based this on the examples,
I think, but we should decide Thursday between (a) this version and
the alternatives: (b) add the components too, or (c) don't add the
substituted construct either.

Please take another look...

---

> Date: Tue, 21 Mar 2000 23:29:09 +0100
> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> I don't really know how much the special-casing of std:: buys us, but
> if that is to be preserved, I propose the following grammar addition:
> 
>   <name> ::= St <unqualified-name>

Yes, that's the conclusion I came to, too.  It's already there.

---

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Mar 21 22:55:08 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 21 Mar 2000 14:55:08 -0800 (PST)
Subject: Real changes for construction vtables (ignore prior mail)
References: <38D104AA.58F9AC7F@zko.dec.com> <200003161734.SAA10395@pandora>
    <200003180204.SAA83428@baalbek.engr.sgi.com>
Message-ID: <200003212255.OAA05790@baalbek.engr.sgi.com>

> From coleen at zko.dec.com  Mon Mar 20 07:24:17 2000
> 
> Jim Dehnert wrote:
> > 
> > I've been working through this proposal, and I think I've noticed an
> > implication that is important.  If the construction vtable groups are
> > not replicas (in layout, not value) of the corresponding complete object
> > vtable groups, eliding the "boring" base class vtables, this affects
> > more than just constructors.  It affects any vtable references in any
> > functions which might be called from constructors, in that they may no
> > longer assume fixed order and offsets of the secondary vtables, and
> > therefore may not use the optimization of using one vtable pointer to
> > access all of them -- instead, they must always load the vtable pointer
> > for the particular subobject whose vtable they are referencing.
> > 
> > Am I interpreting this correctly?
> 
> Yes, that is correct.  I thought this optimization was invalidated by
> something else already - sharing primary virtual tables, wasn't it?
> Because primary vtables may be larger than expected by base classes
> in more derived classes.

Yes, that invalidates sharing the primary vptr with the secondary
vptrs, but it is still possible to use only one secondary vptr, no
matter how many (non-virtual) bases there are.

> But if it wasn't, this would be a tradeoff.

So it is a tradeoff...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Mar 22 00:16:21 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 21 Mar 2000 16:16:21 -0800 (PST)
Subject: Typos in class-layout algorithm
Message-ID: <200003220016.QAA06089@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> The "Non-Virtual-Base Allocation" section in the data layout document
> still contains a couple of typos:
> 
>   Finally allocate any direct or indirect virtual base classes (except
>   the primary base class or any indirect primary base classes) as we did
>   non-virtual base classes in step II-1, in inheritance graph
>   order. Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)). If
>   non-empty, also update align(C) and dsize(C) as in II-1.
> 
> II-1 is now about bitfields.  Why not just say that you should use
> II-2 if the virtual base is non-empty, and II-3 if it is empty?

Because the virtual bases don't update nvsize and nvalign.
Otherwise, I've got your fixes (plus one).  Thanks.

>   The primary base class has already been allocated in I-3a.
> 
> That's now I-2b.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Wed Mar 22 00:35:46 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 21 Mar 2000 16:35:46 -0800
Subject: Typos in class-layout algorithm
In-Reply-To: <200003220016.QAA06089@baalbek.engr.sgi.com>
References: <200003220016.QAA06089@baalbek.engr.sgi.com>
Message-ID: <20000321163546O.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> Because the virtual bases don't update nvsize and nvalign.

OK, good point.

    Jim> Otherwise, I've got your fixes (plus one).  Thanks.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Mar 22 00:52:39 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 21 Mar 2000 16:52:39 -0800 (PST)
Subject: Agenda for Thursday
Message-ID: <200003220052.QAA06262@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Addition of Coleen's alternate construction vtable proposal.

 - Further additions/changes to the mangling writeup. 

Please take a careful look at the colored text.  I'll start off by
going through it all carefully to resolve any questions.

Take a look at the material associated with the following issues.

  1) C-4:  Construction vtables.  Coleen will be here, so I'd like
     to get this as much done as we can.  Please try to carefully
     understand the proposals.

  2) F-1:  Mangling.  Settle the substitution dictionary.
     Any other issues with what's there?  It would be useful if
     people would go through the examples and make sure they match
     what's expected, and if additional examples could be contributed.

  3) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent -- does
     anyone else have some examples for him?

  3) F-4:  Empty throw specifications.  Should we deal with this in
     the mangling?

  4) F-6:  Demangler?

  5) F-7:  Mangling statics.

  6) A-23:  RTTI for incomplete types.

  7) D-12:  Unwind table location.

Jim

-		Jim Dehnert  x3-4272



From ddd at cup.hp.com  Wed Mar 22 00:57:55 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 22 Mar 2000 00:57:55 +0000
Subject: RTTI of local classes
References: <200003212145.WAA17941@pandora>
Message-ID: <38D81A93.FDC201E1@cup.hp.com>

You can make this work by having the mangling for any static function include
the file name. I raised a similar issue for static variables in static
functions.

Christophe


Martin von Loewis wrote:
> 
> I was just reviewing the RTTI spec and see that type_info equalness is
> based on type name mangling; this seems to be the right solution.
> 
> However, I think there are examples that break under that scheme:
> 
> struct Base{
>   virtual ~Base();
> };
> 
> static bool foo(Base* x){
>   struct Derived:Base{};
>   Base *y = new Derived;
>   return typeid(*x)==typeid(*y);
> }
> 
> typeinfo(*y).name() would be "Z3fooP4BaseE1_", right? Now, that could
> also be the name of *x, if that was created in a different translation
> unit, which also has a function foo(Base*) with a local type Derived.
> 
> I'm not sure about a conclusion. Is that well-formed C++ code with a
> well-defined behaviour? Does our ABI support that? Should it? Is that
> a defect in C++, as it is unimplementable?
> 
> Comments appreciated,
> Martin



From loewis at informatik.hu-berlin.de  Wed Mar 22 09:45:23 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 22 Mar 2000 10:45:23 +0100
Subject: RTTI of local classes
In-Reply-To: <38D81A93.FDC201E1@cup.hp.com> (message from Christophe de
	Dinechin on Wed, 22 Mar 2000 00:57:55 +0000)
References: <200003212145.WAA17941@pandora> <38D81A93.FDC201E1@cup.hp.com>
Message-ID: <200003220945.KAA22118@pandora>

> You can make this work by having the mangling for any static
> function include the file name. I raised a similar issue for static
> variables in static functions.

Indeed. As Mark points out, you can do whatever magic you'd do for
unnamed namespaces. I guess my whole point is that the normal ABI
rules don't apply, and that, instead, the ABI should declare such
names implementation-defined.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Wed Mar 22 14:41:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 22 Mar 2000 15:41:55 +0100
Subject: Mangling examples
Message-ID: <200003221441.PAA00358@pandora>

I have some corrections for the mangling examples

_ZN1N1fE                 N::f (i.e. it's not a function)
_ZN6System5Sound4beepE   System::Sound::beep  (likewise)

_Z1fI1XE vPV N1AIT1_E1T  should be _Z1fI1XEvPVN1AIT1_EE
_ZngILi42EE vN1AIXplT1_Li2EE1TE     has an extra space 
(the next ones do, as well - this is not really a problem, except
 when you cut'n paste it into a demangler :-)

Here are some more examples:

_Z3fooIiPFidEiEv         void foo<int,int(*)(double),int>()
_ZaSA4_i                 operator=(int[4])
_ZlsRSoRKSs              operator<<(std::ostream&,std::string const&)
(i.e. really operator<<(::std::basic_iostream<char,
std::char_traits<char> >&,::std::basic_string <char,::std::char_traits<char>,
		       ::std::allocator<char> > const &)
 

Regards,
Martin



From loewis at informatik.hu-berlin.de  Wed Mar 22 14:46:59 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 22 Mar 2000 15:46:59 +0100
Subject: Mangling: Special names
Message-ID: <200003221446.PAA01155@pandora>

According to the mangling syntax,

   Foo::Foo(int)

would be mangled as

   _ZN3FooC1Ei

i.e. the constructor <special-name> would syntactically fit only after
a qualified name. Is this intentional? Likewise, _ZN3Foo3BarTVE would
be the Foo::Bar virtual table.

I don't understand the Th and Tv special names: Instead of a
function-type, would you not need an <name> somewhere? Or even an
<encoding>?

Regards,
Martin




From loewis at informatik.hu-berlin.de  Thu Mar 23 07:53:05 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 23 Mar 2000 08:53:05 +0100
Subject: universal character names
Message-ID: <200003230753.IAA11057@pandora>

I could not find an issue for that, but I think it needs to be
one. 2.2, [lex.charset]/2 allows usage of universal-character-names in
C++ programs, especially in identifiers and strings. This gives us two
issues:

A) External names for identifiers containing unicode letters; e.g.

   namespace newmath{
      const long double \u03A0 = 3.14159265358979;
   }

   This is also an issue for C99, so it may be that the base ABI has a
   specification; we'd have to follow that at least for extern "C"
   names. If not, I propose that such names are encoded in UTF-8.

B) Object file representation of narrow and wide string literals
   containing such characters, eg.

      wchar_t MvL[]=L"Martin von L\u00F6wis";

   First, what is sizeof(wchar_t) in the base ABI? I'll assume 4 for
   the moment. Then, the question comes down to: What is the execution
   character set, and the wide execution character set? 2.2/3 says
   they are implementation-defined, so I guess we must define
   them. Typically, people expect this to be a run-time setting (which
   is a reasonable assumption), but it kind-of breaks for string
   literals.

   Proposal: The wide execution character set is UCS-4. The
   execution-character-set is "as-is", i.e. bytes from the source
   character set are copied unmodified to the object
   file. Universal-character-names appearing in narrow (ie. char)
   strings are not portable in this ABI (the other alternatives would
   be to say they are Latin-1, or encoded as UTF-8, I guess).

Martin



From eboling at inprise.com  Thu Mar 23 17:04:00 2000
From: eboling at inprise.com (Eli Boling)
Date: Thu, 23 Mar 2000 11:04:00 -0600
Subject: Unwind Table Location
References: <200003220052.QAA06262@baalbek.engr.sgi.com>
Message-ID: <38DA4E80.A69B807B@inprise.com>

>   7) D-12:  Unwind table location.

No one has oppined on this one so far, so I'd like to chip in.  I'd like it
if we could avoid imposing data structures on the language implementations
where possible.  I'd particularly like to avoid this in the area of
exception handling, as this is a place where different languages need to
cohabitate in the process space.  That's partly why I was happy to see the
functional interface in the C++ exception handling doc that you folks did.
My problems with the existing gcc mechanism revolve around the total
commitment requirement to the gcc data format, which prevents me from even
throwing exceptions past gcc frames without dying unless I fully conform to
their data format.

The updated proposal seems to handle most of my concerns, but I'd still
like to see the PC map hidden, so that language implementors can do as they
see fit with this.  To that end, I'd like to toss out the following
additions.  Note that these are tentative, based on my fiddling with it
just a bit for the past day or so.  I'm going to do a prototype to see how
it holds together.

I would like to see the unwind tables registered with the _Unwind library,
and referenced only through callbacks, like this:

typedef __personality_routine (*_Unwind_IPLookupFn)(uint64 IP,
void **pImplementationData);

int _Unwind_RegisterIPLookup(_Unwind_IPLookupFn LookupFn,
uint64 StartAddr, uint64 EndAddr);

void _Unwind_UnregisterIPLookup(_Unwind_IPLookupFn LookupFn);

The first function takes the address of a lookup function which returns a
personality and pointer to implementation specific data based on an IP.
Start and end addresses are made available so that the _Unwind library can
optimize calls to these routines.  When an exception is raised, the _Unwind
library looks up the current IP by calling these registered procedures.
The need for something like this was implied in the Intel Software
Conventions and Runtime Architecture Guide, Chap 11 (SCRAG is what I'll
call it.  What do you call it?).  Section 11.1.2 says that the dynamic
loader needs to provide an API for finding the unwind table.  I've just
changed the 'ownership' of the data a bit.

The second function lets you uninstall a lookup function.  That's for when
you're unloading, and you don't want to leave bad fn pointers floating.
Yes, the RTL for the language does have to cooperate, or things can go
south a considerable time after a module unloads.

The personality routine as it is stated in the C++ ABI doesn't have the
implementation specific data passed to it.  I'd like to add that:

typedef _Unwind_Reason_Code(*__personality_routine)(
 int version,
 _Unwind_Action actions,
 uint64 exceptionClass,
 _Unwind_Exception *exceptionObject,
 _Unwind_Context *context,
 void *ImplementationData);

The ImplementationData parameter is the item that is returned by the lookup
function that resolves the personality for a given IP.

Given these changes, the format of most of the unwind data in chapter 11 of
the SCRAG becomes mostly advisory (the frame info was already made so by
the current document).  Chapter 11 could essentially become an appendix
implementation that could be used by implementors if they chose, but not
forced on them.  The other thing that I like about the lookup registering
is that it allows implementors to innovate with respect to fast lookup
schemes within a loadable module.  The current scheme allows for no
innovation whatever.  I'd prefer that the implementors be left with the
option to build as fancy or as simple a scheme for lookups and frame
decomposition as possible, depending on the needs of the language.

Hope I wasn't too wordy.

-Eli





From alainm at cup.hp.com  Thu Mar 23 18:31:05 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Thu, 23 Mar 2000 10:31:05 -0800
Subject: mangling question.
Message-ID: <38DA62E9.705FB257@cup.hp.com>


I probably overlooked something, but I have a problem 
understanding the mangling grammar:

<nested-name> ::= N <qualified-name> E
    <qualified-name> ::= <CV-qualifier> <qualified-name>
                     ::= <compound-name>
                     ::= <substitution> // rule A
    <compound-name> ::= <nesting-prefix> <unqualified-name>
                   ::= <unqualified-name>
                   ::= <substitution> // rule B
    <nesting-prefix> ::= <nesting-prefix> <nesting-qualifier>
                     ::= <nesting-qualifier>
                     ::= <substitution>
    <nesting-qualifier> ::= <namespace source-name>
                        ::= <class-enum-name>

It seems to me that there are a few ambiguities (reduce/reduce)
related with <substitution>, for example if we consider rules A and B.

Note that I just started looking at the mangling, maybe I have missed 
something obvious in the text. (I haven't found anithing related qith
this in the last mails).

Alain



From dehnert at baalbek.engr.sgi.com  Thu Mar 23 21:53:57 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 23 Mar 2000 13:53:57 -0800 (PST)
Subject: mangling question.
Message-ID: <200003232153.NAA10351@baalbek.engr.sgi.com>

> Date: Thu, 23 Mar 2000 10:31:05 -0800
> From: Alain Miniussi <alainm at cup.hp.com>
> 
> I probably overlooked something, but I have a problem 
> understanding the mangling grammar:
> 
> <nested-name> ::= N <qualified-name> E
>     <qualified-name> ::= <CV-qualifier> <qualified-name>
>                      ::= <compound-name>
>                      ::= <substitution> // rule A
>     <compound-name> ::= <nesting-prefix> <unqualified-name>
>                    ::= <unqualified-name>
>                    ::= <substitution> // rule B
>     <nesting-prefix> ::= <nesting-prefix> <nesting-qualifier>
>                      ::= <nesting-qualifier>
>                      ::= <substitution>
>     <nesting-qualifier> ::= <namespace source-name>
>                         ::= <class-enum-name>
> 
> It seems to me that there are a few ambiguities (reduce/reduce)
> related with <substitution>, for example if we consider rules A and B.
> 
> Note that I just started looking at the mangling, maybe I have missed 
> something obvious in the text. (I haven't found anithing related qith
> this in the last mails).

Yes, it is ambiguous, but only in cases where the things it might be
substituted for are the same thing.  You should view the <substitution>
rules strictly as a notiational convenience for identifying the
components that may be substituted.  Does that help, or does your
concern go deeper than that?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From ddd at cup.hp.com  Thu Mar 23 23:00:44 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 23 Mar 2000 23:00:44 +0000
Subject: Unwind Table Location
References: <200003220052.QAA06262@baalbek.engr.sgi.com> <38DA4E80.A69B807B@inprise.com>
Message-ID: <38DAA21C.C120AAFC@cup.hp.com>

Eli Boling wrote:
> 
> >   7) D-12:  Unwind table location.

[...]

> The updated proposal seems to handle most of my concerns, but I'd still
> like to see the PC map hidden, so that language implementors can do as they
> see fit with this.

The idea is precisely that the PC-map is not language specific. Tools like
debuggers will work better with a consistent way to access it. Similarly, C++ EH
can work accross languages because the unwind table is language-independant.


> I would like to see the unwind tables registered with the _Unwind library,
> and referenced only through callbacks, like this:
> 
> typedef __personality_routine (*_Unwind_IPLookupFn)(uint64 IP,
> void **pImplementationData);
> 
> int _Unwind_RegisterIPLookup(_Unwind_IPLookupFn LookupFn,
> uint64 StartAddr, uint64 EndAddr);
> 
> void _Unwind_UnregisterIPLookup(_Unwind_IPLookupFn LookupFn);
> 

I don't like this for a few reasons. First, it makes unclear who "owns" the IP
lookup. In the proposed design, the "system" (== the system vendor) owns it. The
actual format of the table doesn't matter so much, what matters is the
_Unwind_XXX series of functions.

Another thing I don't like is the risk of becoming unable to throw from a static
object constructor or destructor because the above registration did not occur
yet / was undone already.


> The second function lets you uninstall a lookup function.  That's for when
> you're unloading, and you don't want to leave bad fn pointers floating.
> Yes, the RTL for the language does have to cooperate, or things can go
> south a considerable time after a module unloads.

Which is what I don't like :-) Again, this seems unnecessarily difficult for a
debugger to get right when loading/unloading your app.


Could you indicate a reason for doing this? Can you see a real performance issue
with the current layout of the IP table?


Regards
Christophe



From dehnert at baalbek.engr.sgi.com  Fri Mar 24 04:35:55 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 23 Mar 2000 20:35:55 -0800 (PST)
Subject: Layout document updates
Message-ID: <200003240435.UAA11945@baalbek.engr.sgi.com>

If you haven't gone through the color-coded changes in the layout
document carefully, you might want to (and send your comments).
They will make way Friday for a new batch in the HTML.  (I'll leave
up the PDF for a few days so you can access the older version.)

Jim
-		Jim Dehnert  x3-4272



From alainm at cup.hp.com  Fri Mar 24 23:22:11 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 24 Mar 2000 15:22:11 -0800
Subject: typo in special-name ?
Message-ID: <38DBF8A3.31CC1A10@cup.hp.com>


It seems that the <type> referenced in tye productions for 
<special-name> is not actualy in the rules.

Alain



From dehnert at baalbek.engr.sgi.com  Sat Mar 25 03:09:32 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 24 Mar 2000 19:09:32 -0800 (PST)
Subject: typo in special-name ?
Message-ID: <200003250309.TAA13900@baalbek.engr.sgi.com>

> Date: Fri, 24 Mar 2000 15:22:11 -0800
> From: Alain Miniussi <alainm at cup.hp.com>
> 
> It seems that the <type> referenced in tye productions for 
> <special-name> is not actualy in the rules.

I don't know what you mean.  <type> appears many places:
(Remember to ignore text in italics in non-terminal names.
I've removed some of it in the following.)

    <encoding-type> ::= <type>
                 ::= Tv <number> _ <name> <function-type><type>
  <type> ::= <builtin-type>
         ::= <function-type>
         ::= <class-enum-type>
         ::= <array-type>
         ::= <pointer-to-member-type>
  <type> ::= <CV-qualifier>
         ::= P <type>        # pointer-to
         ::= R <type>        # reference-to
         ::= C <type>        # complex pair (C 2000)
         ::= G <type>        # imaginary (C 2000)
         ::= U <source-name> <type>       # vendor extended type qualifier
  <CV-qualifier> ::= K <type>     # const
                 ::= V <type>        # volatile
                 ::= r <type>        # restrict (C 2000)
  <bare-function-type> ::= [Y] <type>*
  <array-type> ::= A [<number>] _ <type>
  <pointer-to-member-type> ::= M <class type> <member type>
  <template-arg> ::= <type>                       # type
  <template-arg> ::= L <type> <number> E  # literal
                 ::= L <type> <number> E     # literal

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Mar 25 04:51:29 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 24 Mar 2000 20:51:29 -0800 (PST)
Subject: Mangling examples
Message-ID: <200003250451.UAA14431@baalbek.engr.sgi.com>

Martin von Loewis wrote:
> 
> I have some corrections for the mangling examples
> 
> _ZN1N1fE                 N::f (i.e. it's not a function)
> _ZN6System5Sound4beepE   System::Sound::beep  (likewise)

Actually, both could be either a data item or a function.  I've fixed that.

> _Z1fI1XE vPV N1AIT1_E1T  should be _Z1fI1XEvPVN1AIT1_EE
                                     _Z1fI1XEvPVN1AIT1_E1TE

> _ZngILi42EE vN1AIXplT1_Li2EE1TE     has an extra space

The spaces are intentional for readability (not much, I know) -- ignore them,
per the column header.
 
> Here are some more examples:
> 
> _Z3fooIiPFidEiEv         void foo<int,int(*)(double),int>()
> _ZaSA4_i                 operator=(int[4])
> _ZlsRSoRKSs              operator<<(std::ostream&,std::string const&)
> (i.e. really operator<<(::std::basic_iostream<char,
> std::char_traits<char> >&,::std::basic_string <char,::std::char_traits<char>,
>                        ::std::allocator<char> > const &)

Thanks.  I added these.  Is the second one right, or should it be encoded
as a pointer to int?  (I don't know the C++ rule on this.)

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Mar 25 06:16:29 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 24 Mar 2000 22:16:29 -0800 (PST)
Subject: Updates
Message-ID: <200003250616.WAA14513@baalbek.engr.sgi.com>

I've updated the status pages (open, layout, mangling) for Thursday's
meeting _except_ the construction vtables.  Of particular interest might
be the mangling updates.  A bunch of examples have changed as a result
of the decisions.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Sat Mar 25 07:20:54 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 24 Mar 2000 23:20:54 -0800 (PST)
Subject: Mangling: Special names
Message-ID: <200003250720.XAA14840@baalbek.engr.sgi.com>

> Date: Wed, 22 Mar 2000 15:46:59 +0100
> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> According to the mangling syntax,
> 
>    Foo::Foo(int)
> 
> would be mangled as
> 
>    _ZN3FooC1Ei
> 
> i.e. the constructor <special-name> would syntactically fit only after
> a qualified name. Is this intentional?

Good question.  I interpreted C1/C2/C3/C4 as being the default
constructors, with the following derivation for Foo::Foo(), which is
the constructor for type Foo:

    <encoding>	-> _Z <name> <type>
		-> _Z <special-name> <class-enum-type>
		-> _Z C1 <source-name>
		-> _Z C1 3Foo

Your example, no longer the default constructor, becomes:

	_ZN3Foo3FooEi

Is that what you intended, Daveed?

> Likewise, _ZN3Foo3BarTVE would be the Foo::Bar virtual table.

No, it goes:

    <encoding>	-> _Z <name>	     <type>
		-> _Z <special-name> <class-enum-type>
		-> _Z TV	     <nested-name>
		-> _Z TV	     N 3Foo 3Bar E

> I don't understand the Th and Tv special names: Instead of a
> function-type, would you not need an <name> somewhere? Or even an
> <encoding>?

There is one.  Suppose we have A::foo(), and then derive B from A
with a B::foo() overriding.  Then B::foo() is

	_ZN1B3fooE

which serves as the base in the derivation for the override thunk from
A.  The non-virtual one, assuming the A->B adjustment is -36, is:

	Thn36_ <base name> <base function-type>
	Thn36_ N1B3fooE	   FE

The virtual one (i.e. A is a virtual base), assuming the vptr
displacement of the vcall offset is -12, is:

	Tv12 <base name> <base function-type> <base class type>
	Tv12 N1B3fooE	 FE		      1A

So in both cases, <base name> <base function-type> is essentially an
encoding, but the type is delimited (because it needs to be to separate
it from the base class type in the virtual case, though I guess it
could be eliminated in the non-virtual case).

Any other interpretations out there?  Must be...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From nathan at codesourcery.com  Sun Mar 26 09:16:34 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Sun, 26 Mar 2000 10:16:34 +0100
Subject: incomplete rtti
Message-ID: <38DDD572.4332C48D@codesourcery.com>

Hi,

I'm again puzzled as to how the new rtti scheme is supposed to work
with incomplete types. There's a contradiction in the layout doc. The
contradiction is understandable if you know what the intention is, but
I think it'd be confusing to someone reading this cold (it's still
confusing to me).

* `Assuming that after linking and loading only one type_info
  structure is active'.
* `Two abi::__pointer_type_info objects are compared for equality (i.e.
  of the types represented) by checking for equal target type RTTI
  pointers unless either or both have the incomplete flag set, in
  which case the pointed-to RTTI structures must be checked for
  equality (described below).'

The former is refering to complete types. As any `T cv *' is a complete
type, to test for equality of such a type only requires pointer
comparison of the type_info's representing that type. It is when
determining the equality of the targets for differently qualified `T cv
*' instances with incomplete T that we have to deal with multiple
instances of the __class_type_info for T. This type of comparison is
only of interest when looking for a qualification conversion on catch
matching. It is only the pointer to T which needs to consider this, a
pointer to pointer to T will not need to know about the completeness of
T.

So why does the __pointer_type_info class's incomplete target type
(0x8) apply when the ultimate non-pointer type is incomplete? I think
it should just apply when the immediately pointed-to type is
incomplete. 

Secondly I don't see how making the incomplete class type object static
linkage will avoid preemption. Suppose translation unit 1 contains
        struct A;
        ...
        typeid (A *);
and unit 2 contains
        struct B {};
        struct A : B {};
        ...
        typeid (A *);

The `typeid (A *)' objects emitted in 1 and 2 will have comdat linkage
and so only one will be active in the final program. We have no control
over which is actually selected by the linker (I don't think the linker
cares, because it is assuming that any comdat's named the same have the
same contents - yes?). Now, which of the abi::__class_type_info's for A
will the selected one point to? For this to work it must be the one in 2,
as that contains the complete information about the type. Will static
linkage of 1's instance behave this way? We need to specify that 1's
instance has weak linkage.

I suggest,

`If the target type of the pointer is an incomplete class type, directly
or indirectly, a dummy class RTTI is generated for the incomplete type
that will not resolve to the final complete class RTTI (because the
latter need not exist), possibly by making it a local static object,
and the incomplete target type flag is set in each pointer RTTI that
references it directly or indirectly. 

Two abi::__pointer_type_info objects are compared for equality (i.e. of
the types represented) by checking for equal target type RTTI pointers
unless either or both have the incomplete flag set, in which case the
pointed-to RTTI structures must be checked for equality (described
below).'

be replaced by

`If the target type of the pointer is an incomplete class type, a dummy
abi::__class_type_info is generated for the incomplete type. The dummy
instance is given weak linkage so it will not conflict with the complete
RTTI object which might be provided in another translation unit. The
abi::__pointer_type_info object which points to this incomplete type has
its incomplete target type flag set.'

`Two abi::__pointer_type_info objects are compared for equality in the
normal way, by comparing their addresses.  Checking for equality of the
pointed-to objects requires checking the incomplete target type flags of
the two (different) pointer objects. If neither is set, then the targets
can be compared in the normal way. If either is set then the NTBS of the
target type_info objects must be compared.'

`Note: Two different abi::__pointer_type_info objects can only point to
the same type, if the target type is differently qualified in each
pointer.'

The following paragraph describing abi::__class_type_info should be
deleted.

`Two abi::__class_type_info objects are normally compared for equality
(i.e. of the types represented) by comparison of their addresses.
However, incomplete class RTTI objects, which can only be accessed via
abi::__pointer_type_info objects, must be compared for equality by
comparison of the name NTBS in their std::type_info bases. '

The following paragraph

`This RTTI class may also be used for incomplete class types when
referenced by a pointer RTTI, in which case it must be prevented from
preempting the RTTI for the complete class type, for instance by
emitting it as a static object (without external linkage).'

should be replaced by

`This RTTI class may also be used for incomplete class types when
referenced by a pointer RTTI, in which case it must be prevented from
preempting the RTTI for the complete class type, by giving it
weak linkage.'

With these changes, given
        struct A;
type_info's will be of the following form (using gcc's mangling
& __attribute__)

__class_type_info tf_1A __attribute__ ((weak)) ("1A"); // typeid (A)
__pointer_type_info tf_P1A ("P1A", 0x8, &tf_1A); // typeid (A *)
__pointer_type_info tf_PP1A ("PP1A", 0, &tf_P1A); // typeid (A **)

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From loewis at informatik.hu-berlin.de  Mon Mar 27 13:48:02 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 27 Mar 2000 15:48:02 +0200
Subject: Mangling: grammar too permissive
Message-ID: <200003271348.PAA04370@pandora>

After reviewing today's mangling grammar, I found that it allows a
number of constructions that can't possibly appear, and that can be
easily correct in the grammar:

1. <substitution> in <qualified name>: This allows <nested-names> of
   NSi_E, where i is either a letter or a (base-36) digit. I think
   this cannot, or should not, occur: If you can substitute the entire
   <qualified-name>, you should use Si_ instead.

   Solution: Remove <substitution> alternative in <qualified name>

2. extra alternatives in <encoding-type>: In all cases where an
   encoding-type can occur, it always identifies a
   bare-function-type; it never is a type or a substitution on its
   own. Therefore, I propose to remove the encoding-type, and replace
   its two occurences with bare-function-type.

3. extern "C" allowed at toplevel. The grammar allows _Z3fooYi, which
   would be extern "C" ??? foo(int). However (as the text points out),
   that would be mangled as "foo", so it cannot happen.
   Solution: Move [Y] from <bare-function-type> into <function-type>.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Mon Mar 27 14:05:50 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 27 Mar 2000 16:05:50 +0200
Subject: Mangling: Special names
In-Reply-To: <200003250720.XAA14840@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003250720.XAA14840@baalbek.engr.sgi.com>
Message-ID: <200003271405.QAA04559@pandora>

> Good question.  I interpreted C1/C2/C3/C4 as being the default
> constructors, with the following derivation for Foo::Foo(), which is
> the constructor for type Foo:
> 
>     <encoding>	-> _Z <name> <type>
> 		-> _Z <special-name> <class-enum-type>
> 		-> _Z C1 <source-name>
> 		-> _Z C1 3Foo
> 
> Your example, no longer the default constructor, becomes:
> 
> 	_ZN3Foo3FooEi

No, that won't work. Is this the in-charge, or not-in-charge
constructor? Is it allocating or not?

Reconsidering this, I think it is right to have the special names as
unqualified names in a nested name. Just as you'd have

_ZN3FoongE

to denote Foo::operator!(); you also have C1,... as *names* of the
constructors. Since we need more than one name per constructor, we
need to make them special

> > Likewise, _ZN3Foo3BarTVE would be the Foo::Bar virtual table.
> 
> No, it goes:
> 
>     <encoding>	-> _Z <name>	     <type>
> 		-> _Z <special-name> <class-enum-type>
> 		-> _Z TV	     <nested-name>
> 		-> _Z TV	     N 3Foo 3Bar E

In my view, the Foo::Bar virtual table is a static member of Foo::Bar,
which would be written down as 'Foo::Bar::__vtable'. Just as this
specific member would be encoded as

  _ZN3Foo3Bar8__vtableE

I would assume that the vtable is encoded with TV as the name of the
static member. Your approach would also work, but I feel this is more
consistent that way.

[Th and Tv discussion deleted]
> Any other interpretations out there?

Thanks, it seems clear now.

Martin



From loewis at informatik.hu-berlin.de  Mon Mar 27 14:09:00 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 27 Mar 2000 16:09:00 +0200
Subject: Mangling examples
Message-ID: <200003271409.QAA04684@pandora>

[Resend, because original message returned with

550 <cxx-abi at sgi.com>... User unknown          ]

> > _ZaSA4_i                 operator=(int[4])
[...]
> Thanks.  I added these.  Is the second one right, or should it be encoded
> as a pointer to int?

You're right, it's not. You can use this instead

_ZN3FooIA4_iE3barE            Foo<int[4]>::bar

Regards,
Martin



From alainm at cup.hp.com  Mon Mar 27 17:48:00 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Mon, 27 Mar 2000 09:48:00 -0800
Subject: typo in special-name ?
References: <200003250309.TAA13900@baalbek.engr.sgi.com>
Message-ID: <38DF9ED0.59CEF9C3@cup.hp.com>

Jim Dehnert wrote:
> 
> > Date: Fri, 24 Mar 2000 15:22:11 -0800
> > From: Alain Miniussi <alainm at cup.hp.com>
> >
> > It seems that the <type> referenced in tye productions for
> > <special-name> is not actualy in the rules.
> 
> I don't know what you mean.  <type> appears many places:

I mean that, for <special-name>, I read:
<special-name> ::= TV # virtual table
                      # <type> is vtable's class type
And did not understood that <type> refered actualy to <nesting-prefix> 
in the <compound> production, and expected to see it (or <class-enum> )
in the rhs of <special-name> := ....

Sorry,

Alain


> (Remember to ignore text in italics in non-terminal names.
> I've removed some of it in the following.)
> 
>     <encoding-type> ::= <type>
>                  ::= Tv <number> _ <name> <function-type><type>
>   <type> ::= <builtin-type>
>          ::= <function-type>
>          ::= <class-enum-type>
>          ::= <array-type>
>          ::= <pointer-to-member-type>
>   <type> ::= <CV-qualifier>
>          ::= P <type>        # pointer-to
>          ::= R <type>        # reference-to
>          ::= C <type>        # complex pair (C 2000)
>          ::= G <type>        # imaginary (C 2000)
>          ::= U <source-name> <type>       # vendor extended type qualifier
>   <CV-qualifier> ::= K <type>     # const
>                  ::= V <type>        # volatile
>                  ::= r <type>        # restrict (C 2000)
>   <bare-function-type> ::= [Y] <type>*
>   <array-type> ::= A [<number>] _ <type>
>   <pointer-to-member-type> ::= M <class type> <member type>
>   <template-arg> ::= <type>                       # type
>   <template-arg> ::= L <type> <number> E  # literal
>                  ::= L <type> <number> E     # literal
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272



From ddd at cup.hp.com  Mon Mar 27 20:03:07 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 27 Mar 2000 20:03:07 +0000
Subject: Mangling: Special names
References: <200003250720.XAA14840@baalbek.engr.sgi.com>
Message-ID: <38DFBE7B.AB409FAD@cup.hp.com>

Jim Dehnert wrote:
> 
> Good question.  I interpreted C1/C2/C3/C4 as being the default
> constructors, with the following derivation for Foo::Foo(), which is
> the constructor for type Foo:
> 
>     <encoding>  -> _Z <name> <type>
>                 -> _Z <special-name> <class-enum-type>
>                 -> _Z C1 <source-name>
>                 -> _Z C1 3Foo
> 
This made me think: does it buy us something to have a special encoding for copy
constructor and assignment operator when, for class C, their parameter is const
C & ? In general, for members of class C, could we reserve a one letter encoding
for const C &?


Christophe



From loewis at informatik.hu-berlin.de  Mon Mar 27 22:09:14 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 28 Mar 2000 00:09:14 +0200
Subject: Mangling: Special names
In-Reply-To: <38DFBE7B.AB409FAD@cup.hp.com> (message from Christophe de
	Dinechin on Mon, 27 Mar 2000 20:03:07 +0000)
References: <200003250720.XAA14840@baalbek.engr.sgi.com> <38DFBE7B.AB409FAD@cup.hp.com>
Message-ID: <200003272209.AAA13530@pandora>

> This made me think: does it buy us something to have a special
> encoding for copy constructor and assignment operator when, for
> class C, their parameter is const C & ? In general, for members of
> class C, could we reserve a one letter encoding for const C &?

I would not think so. If you follow my interpretation (i.e. Cx is an
<unqualified-name>, qualified by the class of which it is a
constructor), then the compression dictionary will have the type in it
already. As a matter of fact, I think 'a::b::c::c(a::b::c const &)'
will be

_ZN1a1b1cC1ERKS_

since the full class name was the last thing put into the dictionary
when we came to the parameter list (unless the method name is also
supposed to be in the dictionary, in which case the back-reference
would be S1_). With a special encoding it would save us a total of one
character on the first occurence, and nothing on the second - we will
have the const-reference type already in the dictionary.

The same reasoning applies to member functions as well - the class
will be in the compression table when we come to the parameter list.

Regards,
Martin



From ddd at cup.hp.com  Mon Mar 27 23:27:00 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Mon, 27 Mar 2000 23:27:00 +0000
Subject: Mangling: Special names
References: <200003250720.XAA14840@baalbek.engr.sgi.com> <38DFBE7B.AB409FAD@cup.hp.com> <200003272209.AAA13530@pandora>
Message-ID: <38DFEE44.AF60189B@cup.hp.com>

Martin von Loewis wrote:
> 
> > This made me think: does it buy us something to have a special
> > encoding for copy constructor and assignment operator when, for
> > class C, their parameter is const C & ? In general, for members of
> > class C, could we reserve a one letter encoding for const C &?
> 
> I would not think so. If you follow my interpretation (i.e. Cx is an
> <unqualified-name>, qualified by the class of which it is a
> constructor), then the compression dictionary will have the type in it
> already. As a matter of fact, I think 'a::b::c::c(a::b::c const &)'
> will be
> 
> _ZN1a1b1cC1ERKS_
> 
> since the full class name was the last thing put into the dictionary
> when we came to the parameter list (unless the method name is also
> supposed to be in the dictionary, in which case the back-reference
> would be S1_). With a special encoding it would save us a total of one
> character on the first occurence, and nothing on the second - we will
> have the const-reference type already in the dictionary.
> 
> The same reasoning applies to member functions as well - the class
> will be in the compression table when we come to the parameter list.

I agree with all that. I was precisely proposing that we replace RKS_ with, say,
'@'. I believe that's three chars saved each time. Oh well, I don't know if it's
worth it.

Christophe



From austern at sgi.com  Tue Mar 28 00:11:45 2000
From: austern at sgi.com (Matt Austern)
Date: Mon, 27 Mar 2000 16:11:45 -0800 (PST)
Subject: Another mangling issue
Message-ID: <14559.62996.739920.919118@isolde.engr.sgi.com>

We discussed this at the very end of last week's meeting, but we
should probably also raise it on the mailing list.

The mangling for X::f() (a member function with no arguments, with
arbitrary result type) is _ZN1X1fE.  The mangling for X::f (a
static member variable, of arbitrary type) is also _ZN1X1fE.

This has two disadvantages.  First, a demangler doesn't know what to
do with this mangled name.  Should it be demangled as a function, or
as a variable?  Second, we fail to detect some easily detectable ODR
violations.

I propose that we change the mangling for a function of no arguments,
and that we mangle it as a function with a single argument of type
void.  Under this proposal _ZN1X1fE would unambiguously demangle
as X::f, and the mangling for X::f() would be _ZN1X1fEv.

                        --Matt




From dehnert at baalbek.engr.sgi.com  Tue Mar 28 03:37:43 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 27 Mar 2000 19:37:43 -0800 (PST)
Subject: Mangling: grammar too permissive
Message-ID: <200003280337.TAA21392@baalbek.engr.sgi.com>

> From: Martin von Loewis <loewis at informatik.hu-berlin.de>
> 
> After reviewing today's mangling grammar, I found that it allows a
> number of constructions that can't possibly appear, and that can be
> easily correct in the grammar:
> 
> 1. <substitution> in <qualified name>: This allows <nested-names> of
>    NSi_E, where i is either a letter or a (base-36) digit. I think
>    this cannot, or should not, occur: If you can substitute the entire
>    <qualified-name>, you should use Si_ instead.
> 
>    Solution: Remove <substitution> alternative in <qualified name>

No, it's needed to be able to substitute for Ktype when we've
already seen VKtype.

> 2. extra alternatives in <encoding-type>: In all cases where an
>    encoding-type can occur, it always identifies a
>    bare-function-type; it never is a type or a substitution on its
>    own. Therefore, I propose to remove the encoding-type, and replace
>    its two occurences with bare-function-type.

No, <encoding-type> also encodes a <type> in the case of a vtable,
where <name> is the <special-name> VT, and <type> is the relevant class
type.  (Though this could probably be fixed by other rearrangements.)

> 3. extern "C" allowed at toplevel. The grammar allows _Z3fooYi, which
>    would be extern "C" ??? foo(int). However (as the text points out),
>    that would be mangled as "foo", so it cannot happen.
>    Solution: Move [Y] from <bare-function-type> into <function-type>.

OK, I did that.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Mar 28 03:44:33 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 27 Mar 2000 19:44:33 -0800 (PST)
Subject: Mangling: Special names
References: <200003250720.XAA14840@baalbek.engr.sgi.com>
Message-ID: <200003280344.TAA20987@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Mon Mar 27 06:05:59 2000
> 
> No, that won't work. Is this the in-charge, or not-in-charge
> constructor? Is it allocating or not?
> 
> Reconsidering this, I think it is right to have the special names as
> unqualified names in a nested name. Just as you'd have
> 
> _ZN3FoongE
> 
> to denote Foo::operator!(); you also have C1,... as *names* of the
> constructors. Since we need more than one name per constructor, we
> need to make them special

Yes, I think you're right.  I've changed it.

> > > Likewise, _ZN3Foo3BarTVE would be the Foo::Bar virtual table.
> > 
> > No, it goes:
> > 
> >     <encoding>	-> _Z <name>	     <type>
> > 		-> _Z <special-name> <class-enum-type>
> > 		-> _Z TV	     <nested-name>
> > 		-> _Z TV	     N 3Foo 3Bar E
> 
> In my view, the Foo::Bar virtual table is a static member of Foo::Bar,
> which would be written down as 'Foo::Bar::__vtable'. Just as this
> specific member would be encoded as
> 
>   _ZN3Foo3Bar8__vtableE
> 
> I would assume that the vtable is encoded with TV as the name of the
> static member. Your approach would also work, but I feel this is more
> consistent that way.

Hmmm, I hadn't thought of it that way.  Your method would work, too,
though sometimes it would result in extra N...E delimiters, as in the
vtable for a simple class Foo, which would become _ZN3FooTVE instead of
_ZTV3Foo.  Not a huge difference -- does anyone else have an opinion?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From loewis at informatik.hu-berlin.de  Tue Mar 28 17:07:57 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 28 Mar 2000 19:07:57 +0200
Subject: Another mangling issue
In-Reply-To: <14559.62996.739920.919118@isolde.engr.sgi.com> (message from
	Matt Austern on Mon, 27 Mar 2000 16:11:45 -0800 (PST))
References: <14559.62996.739920.919118@isolde.engr.sgi.com>
Message-ID: <200003281707.TAA05775@pandora>

> I propose that we change the mangling for a function of no arguments,
> and that we mangle it as a function with a single argument of type
> void.  Under this proposal _ZN1X1fE would unambiguously demangle
> as X::f, and the mangling for X::f() would be _ZN1X1fEv.

That sounds good to me.

Martin



From loewis at informatik.hu-berlin.de  Tue Mar 28 17:20:19 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 28 Mar 2000 19:20:19 +0200
Subject: Mangling: grammar too permissive
In-Reply-To: <200003280337.TAA21392@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003280337.TAA21392@baalbek.engr.sgi.com>
Message-ID: <200003281720.TAA06937@pandora>

> No, it's needed to be able to substitute for Ktype when we've
> already seen VKtype.

Ah, right.

> > 2. extra alternatives in <encoding-type>: In all cases where an
> >    encoding-type can occur, it always identifies a
> >    bare-function-type; it never is a type or a substitution on its
> >    own. Therefore, I propose to remove the encoding-type, and replace
> >    its two occurences with bare-function-type.
> 
> No, <encoding-type> also encodes a <type> in the case of a vtable,
> where <name> is the <special-name> VT, and <type> is the relevant class
> type.  (Though this could probably be fixed by other rearrangements.)

As I said, I'd prefer the other arrangement. As a matter of fact, I
didn't really grasp the idea that the top-level type could be used to
denote the type for the vtable. So even if this approach is used, the
documentation should be better, e.g. in the VT description

  # <encoding-type> is vtable's class type

Also, a forward references could not hurt:

  <encoding-type> ::= <type>                # for vtables
                  ::= <bare-function-type>  # for functions   
                  ::= <substitution>        # In what cases?

The <substitution> case refers to the substitution section, but
that does not talk about <encoding-type>s at all...

Regards,
Martin



From mark at codesourcery.com  Tue Mar 28 19:39:25 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 28 Mar 2000 11:39:25 -0800
Subject: Typo in RTTI description
Message-ID: <20000328113925R.mitchell@codesourcery.com>


In the __dynamic_cast pseudo-code, the last parameter is called
`src2dst_offset', but in the pseudo code it is called
`obj2sub_offset'.  We should pick one of these.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Mar 28 21:47:55 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 28 Mar 2000 13:47:55 -0800 (PST)
Subject: Updated files
Message-ID: <200003282147.NAA22919@baalbek.engr.sgi.com>

The issues documents and layout have been updated, with extensive changes
to the latter based on last week's meeting and subsequent email.  In
particular, I tried to elaborate Coleen's ctor vtable writeup, including
adding an example.  But I got confused enough that there are likely errors.
Coleen, could you take a careful look, please?

I have not incorporated Martin's suggested re-arrangement of the VT special
names, but will shortly assuming noone objects.  What's there is a better
description of what I had intended.  This is lurching towards consistency,
but it's not there yet...

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Mar 28 23:11:03 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 28 Mar 2000 15:11:03 -0800 (PST)
Subject: incomplete rtti
Message-ID: <200003282311.PAA23050@baalbek.engr.sgi.com>

> Date: Sun, 26 Mar 2000 10:16:34 +0100
> From: Nathan Sidwell <nathan at codesourcery.com>
> 
> Hi,
> 
> I'm again puzzled as to how the new rtti scheme is supposed to work
> with incomplete types. There's a contradiction in the layout doc. The
> contradiction is understandable if you know what the intention is, but
> I think it'd be confusing to someone reading this cold (it's still
> confusing to me).
> 
> * `Assuming that after linking and loading only one type_info
>   structure is active'.
> * `Two abi::__pointer_type_info objects are compared for equality (i.e.
>   of the types represented) by checking for equal target type RTTI
>   pointers unless either or both have the incomplete flag set, in
>   which case the pointed-to RTTI structures must be checked for
>   equality (described below).'

I've tried to clarify the first of these.  Take a look.  But...

> The former is refering to complete types. As any `T cv *' is a complete
> type, to test for equality of such a type only requires pointer
> comparison of the type_info's representing that type. It is when
> determining the equality of the targets for differently qualified `T cv
> *' instances with incomplete T that we have to deal with multiple
> instances of the __class_type_info for T. This type of comparison is
> only of interest when looking for a qualification conversion on catch
> matching. It is only the pointer to T which needs to consider this, a
> pointer to pointer to T will not need to know about the completeness of
> T.

This assumption is untrue.  The problem is that weak types don't work
like you assume on most systems.  With the exception of Linux and Irix,
most systems do not distinguish between weak and "strong" symbols once
an object is linked.  Therefore, given a weak RTTI in the main
executable and a strong RTTI in a DSO, they would preempt the latter
with the former.  As a result, it is necessary to make our incomplete
class RTTI not just weak, but distinct.  Once it is distinct, the
pointer RTTI referencing it must be distinct from one referencing the
complete version, and so on up the pointer chain, and it is not
possible to compare them at any level.

Our solution is to use the ABI-defined external mangled RTTI name only
for complete types.  RTTI generated for pointer-to-incomplete-type must
be different.  We leave it to the implementation to decide how, but two
workable approaches are (a) make it a local static, or (b) mangle it
differently and use COMDAT to remove duplicates; but at least one
incomplete RTTI would remain, and it would not be the same as the
complete one even after preemption.

> So why does the __pointer_type_info class's incomplete target type
> (0x8) apply when the ultimate non-pointer type is incomplete? I think
> it should just apply when the immediately pointed-to type is
> incomplete. 
> 
> Secondly I don't see how making the incomplete class type object static
> linkage will avoid preemption. Suppose translation unit 1 contains
>         struct A;
>         ...
>         typeid (A *);
> and unit 2 contains
>         struct B {};
>         struct A : B {};
>         ...
>         typeid (A *);
> 
> The `typeid (A *)' objects emitted in 1 and 2 will have comdat linkage
> and so only one will be active in the final program. We have no control
> over which is actually selected by the linker (I don't think the linker
> cares, because it is assuming that any comdat's named the same have the
> same contents - yes?). Now, which of the abi::__class_type_info's for A
> will the selected one point to? For this to work it must be the one in 2,
> as that contains the complete information about the type. Will static
> linkage of 1's instance behave this way? We need to specify that 1's
> instance has weak linkage.

I hope this helps clear up the confusion.

Jim


-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Mar 29 23:08:36 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 29 Mar 2000 15:08:36 -0800 (PST)
Subject: IA-64 ABI meeting results
Message-ID: <200003292308.PAA25863@baalbek.engr.sgi.com>

The following is a brief summary of what happened in the IA-64 base ABI
meeting a couple weeks ago.  It is primarily for the benefit of the C++
ABI group (and therefore includes only the C++-relevant issues), but
I hope the attendees can also correct my memory as necessary.
If you do, or if you want to discuss things further, it would be nice
to separate issues and change the email subject :-).

>Issue 72:  COMDAT group sections
>	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.html
>	http://reality.sgi.com/dehnert_engr/abi/prop-72-comdat.pdf
>
>	This is critical to C++ features like vtables, inline
>	functions, etc.

The group was in general agreement with this.  Joel (SCO) will write up
the necessary gABI changes.


>Issue 74:  Section indices
>	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.html
>	http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.pdf
>
>	This is a longer term concern, which will become more important
>	with heavy COMDAT usage.

There was also general agreement that this was necessary, but more
discussion on details.  Issues that came up were:

- Using fields in the reserved section header 0 for the overflow
  section count and string section index risks breaking code that is
  depending on the currently specified zero values, e.g. by using them
  as a sentry to terminate a loop.  Discussion of alternatives, i.e.
  extending the ELF header or avoiding the string table overflow by
  requiring that its index be "small" were ultimately rejected as no
  better, leaving us with the originally proposed overflow fields.

- What is done with indices that are small enough to fit in the symbol
  table fields when the overflow table is required and present?  Must
  they be correct in both places?  Or may the overflow table contain
  zero and require reference to the original?

  The resolution (as I recall) is to require correct values in the
  overflow table, so all references to it will be valid, even though
  the symbol table value must always be checked first anyway (to detect
  the reserved special values).  An implementation could presumably
  either put real values in the symbol table, or always put the
  overflow value there and require reference to the overflow table,
  though that would not be optimal.

- How are the reserved section indices (0xff00-0xffff) treated outside
  the original symbol table fields?  Should they remain reserved,
  leaving a hole in the section number space?  Should we have no
  reserved full indices, since they're only (currently) used in symbol
  table indices?  Should we reserve different indices at the high end
  of the 32-bit index space?

  The resolution (as I recall faintly) is to reserve new values at the
  high end of the range, and avoid the hole.  Am I correct?

I will update my proposal to reflect these clarifications.
Then Joel will need to draft gABI changes.


>Issue 73/83:  Stack unwind interface
>	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.html
>	http://reality.sgi.com/dehnert_engr/cxx/abi-eh.pdf
>
>	This is mostly consistent with, but more completely specified
>	than, the current SW Conventions description.

No objection was raised.  Cary has looked at it and sees no conflict
with the current specification.  This should go into the psABI
document, but no drafter has been identified.


>Issue 89??:  IPLT relocations
>	I sent a proposal a while back to extend these to .o files.
>	Cygnus has expressed concern about conflict with the lazy
>	loading semantics, which would be resolved by a second
>	relocation which is identical but doesn't allow lazy binding.
>	I don't care which approach is taken, in fact being able to
>	force early binding might be useful in any case, but C++ will
>	need to be able to relocate functions descriptors in vtables.

There was little or no discussion of this at the meeting.  The most
recent comment is Cary's:

> I don't think there's a conflict -- I'm hoping that the lack of further 
> discussion on this issue indicates general agreement. Lazy binding is 
> tied to the DT_JMPREL entry, not to the semantics of the IPLT relocation. 
> At HP, it's been our intent for quite a while to use the IPLT relocations 
> for this purpose, but we haven't planned any lazy binding support for 
> vtables (the bookkeeping is considerably harder than for PLT entries), so 
> these relocations will not be part of our DT_JMPREL set.

We should try to resolve this at the next meeting.  Does this meet your
concerns, Richard?


>Issue 82:  Priority Initialization Feedback

There is a base ABI group reluctance to specify something that is
C++-specific.  I will attempt to clarify for the group the minimum base
ABI requirement to support this feature under our proposals.  (I do
interpret the reluctance as favoring the original proposal over
required linker sorting.  However, I suspect that given all vendors'
support for C++, the underlying reluctance is unrealistic and can be
overcome.)


>Issue 90??:  Types
>	I sent a note a couple of days ago.  We must decide whether
>	__int64 and __float80 are distinct types, or typedefs of long
>	long and long double.  As Martin pointed out, we should also
>	specify bindings of the sized types defined by C2000.

Cary observed that these "types" in the conventions document were
intended purely as an expository tool, and volunteered to clarify that.

--

For the C++ group, I don't think any of the results require revisiting
decisions yet.

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Mar 29 23:10:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 29 Mar 2000 15:10:24 -0800 (PST)
Subject: Agenda for tomorrow
Message-ID: <200003292310.PAA25922@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Adoption and some editorial revision of Coleen's alternate
   construction vtable proposal.

 - Further additions/changes to the mangling writeup. 

Please take a careful look at the colored text.  I'll start off by
going through it all carefully to resolve any questions.

Take a look at the material associated with the following issues.

  1) * Virtual calls.  There is an inconsistency in the writeup
     between the description of virtual calls from morally virtual
     bases, and the definition of where vcall offsets are (and the
     mangling assumptions based on it).  Let's clear it up.

  2) C-4:  Construction vtables.  Are my editorial elaborations
     correct?  The example?  (I doubt it.)  Does everyone now
     understand the proposals?

  3) A-24:  RTTI for incomplete types.  Can we close this with the
     current description?

  4) F-1:  Mangling loose ends.  Local names and RTTI matching.
     Further Sx abbreviations?  Parameterless function mangling.

  5) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent -- does
     anyone else have some examples for him?

  6) F-4:  Empty throw specifications.  Should we deal with this in
     the mangling?

  7) F-6:  Demangler?

  8) F-7:  Mangling statics.

  9) D-12:  Unwind table location.

Jim

-		Jim Dehnert  x3-4272



From coleen at zko.dec.com  Thu Mar 30 00:28:27 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Wed, 29 Mar 2000 19:28:27 -0500
Subject: Updated files
References: <200003282147.NAA22919@baalbek.engr.sgi.com>
Message-ID: <38E29FAB.1106BDB6@zko.dec.com>


I attached my comments on construction vtables.  I won't be able to
listen to the con-call tomorrow (and definitely not fly out).

Have fun,
Coleen
-------------- next part --------------


>From the ctorvtbls writeup:

> c.Ed. Note: Don't we need the equivalent of secondary vptrs here, too? 

Yes, maybe it would be better to eliminate a,b,c and say in 2:

>2.Secondary VTTs: for each non-virtual subobject B of D, that requires a
> construction vtable by virtue of having virtual bases, a sub-VTT for
> B-in-D, which contains: <insert change color here> address in #1, #2, #3.

Note that step #2 is recursive on #1, #2 and #3.  This might simplify
the description somewhat.

Then for #3 put the better sentence from 2b "Subobject A of B needs a
construction ..."

Note this changes the definition slightly.  There is only a need for a
secondary VTT if the nonvirtual subobject has a virtual base (not if it
has an overridden virtual function).  There is a need for the secondary ptr
in the VTT (step #3) if either the base has virtual base or overridden virtual
functions.

The example:

I changed the example slightly to add 'int' members to all the classes, so 
there isn't so much sharing to confuse the issue.  I also added 'virtual'
for member function 'f' which I think was intended.  The example's hard to
follow, but I think it's mostly right, see my comments below.
>
> // 1. Primary vptr:
>  D * has virtual bases
>
>  // 2. Secondary VTTs:
>    C1 * has virtual base
>      V1-in-C1 in D secondary vptr
V1 is a virtual base class, so it's not in VTT
>        A1-in-...-C2 in D secondary vptr
nonvirtual base in virtual base class V1, not in VTT
>
>    C2 * has virtual bases
>      V2-in-C2 in D secondary vptr *
>        V1-in-V2-in-C2 in D secondary vptr *
Yes, this is right. V1 and V2 secondary vptrs for C2 need
construction vtables, because V2 has virtual bases and V1 has
virtual calls overridden on virtual path.
I think the nesting should be the same.
>          A1-in-...-C2 in D secondary vptr *
This one is shared by V1, so not in VTT.
>
>  // 3. Secondary vptrs:
>    C1-in-D secondary vptr
This is shared with D, so not in VTT.
>      V1-in-D secondary vptr *
>        A1-in-V1-in-D secondary vptr (shared with V1)
>    C2-in-D secondary vptr
>      V2-in-D secondary vptr
>
>  // 4. Virtual VTTs:
>    (V1 can use complete object constructor).
>    V2 * has virtual base, has overridden f()
>      V1-in-V2 in D secondary VTT
>        A1-in-V1 * has overridden f()
>      V1-in-V2 in D secondary vptr
>        A1-in-V1-in-V2 in D secondary vptr
>
I think this is right.

So, I have 10 entries in the VTT for D (ignore external names):

    static const long *__VTT_1D[8] =
    {__7__vtbl_1D,  // primary complete vptr for D
// Secondary VTT for C1
     __7__vtbl_2C1_2C1__1D,  // construction vtbl for C1 in D
// Secondary VTT for C2
     __7__vtbl_2C2_2C2__1D,  // construction vtbl for C2 in D
     __7__vtbl_2V2_2C2__1D,  // construction vtbl for V2 in C in D
     __7__vtbl_2V1_2C2__1D,  // construction vtbl for V1 in C in D
// secondary vptrs for D
     __7__vtbl_2C21D,
     __7__vtbl_2V21D, 
     __7__vtbl_2V11D, 
// virtual part
     __7__vtbl_2V2_2V2__1D, 
     __7__vtbl_2V1_2V2__1D};

The red in the 'Subobject Construction and Destruction' section looks
fine.

Coleen

From cary at cup.hp.com  Thu Mar 30 00:43:33 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Wed, 29 Mar 2000 16:43:33 -0800
Subject: [ia64-abi] IA-64 ABI meeting results
Message-ID: <200003300042.QAA08081@adlmail.cup.hp.com>

>- How are the reserved section indices (0xff00-0xffff) treated outside
>  the original symbol table fields?  Should they remain reserved,
>  leaving a hole in the section number space?  Should we have no
>  reserved full indices, since they're only (currently) used in symbol
>  table indices?  Should we reserve different indices at the high end
>  of the 32-bit index space?
>
>  The resolution (as I recall faintly) is to reserve new values at the
>  high end of the range, and avoid the hole.  Am I correct?

My recollection is that we decided that the reserved values are reserved 
only for the 16-bit st_shndx field of the original symbol table entry. 
Extended section table indices can go as high as 0xffffffff.

-cary



From drepper at redhat.com  Thu Mar 30 00:51:27 2000
From: drepper at redhat.com (Ulrich Drepper)
Date: 29 Mar 2000 16:51:27 -0800
Subject: [ia64-abi] IA-64 ABI meeting results
In-Reply-To: Cary Coutant's message of "Wed, 29 Mar 2000 16:43:33 -0800"
References: <200003300042.QAA08081@adlmail.cup.hp.com>
Message-ID: <m3zorh2sc0.fsf@localhost.localnet>

Cary Coutant <cary at cup.hp.com> writes:

> >  The resolution (as I recall faintly) is to reserve new values at the
> >  high end of the range, and avoid the hole.  Am I correct?
> 
> My recollection is that we decided that the reserved values are reserved 
> only for the 16-bit st_shndx field of the original symbol table entry. 
> Extended section table indices can go as high as 0xffffffff.

Cary is right, this is at least what we concluded lacking cases where
this might cause problems.

-- 
---------------.      drepper at gnu.org  ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------



From loewis at informatik.hu-berlin.de  Thu Mar 30 08:51:39 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 30 Mar 2000 10:51:39 +0200
Subject: Initializer priorities (Was: IA-64 ABI meeting results)
In-Reply-To: <200003292308.PAA25863@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200003292308.PAA25863@baalbek.engr.sgi.com>
Message-ID: <200003300851.KAA04570@pandora>

> >Issue 82:  Priority Initialization Feedback
> 
> There is a base ABI group reluctance to specify something that is
> C++-specific.

I may be missing something, but... Why is this an issue for C++ in the
first place? I see this proposal in issue C-2 (order of constructors).
However, I feel that this issue is sufficiently answered already:

# Meeting concensus is that the desirable order is right to left on
# the link command line, i.e. last listed relocatable object is
# initialized first.

What exactly is the requirement for specifying anything more than
that? The C++ standard leaves the order explicitly
implementation-defined, so portable programs should not expect any
particular order. Also, Standard C++ does not provide a mechanism for
assigning priorities to specific objects.

To me, this looks like a vendor extension, even though it is supported
by a number of vendors (in one way or the other). What I don't see is
the general utility of this facility. Perhaps someone can explain the
requirements that lead to this extension?

Regards,
Martin




From nathan at codesourcery.com  Thu Mar 30 12:12:29 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Thu, 30 Mar 2000 13:12:29 +0100
Subject: incomplete rtti
References: <200003282311.PAA23050@baalbek.engr.sgi.com>
Message-ID: <38E344AD.128D8722@codesourcery.com>

Jim Dehnert wrote:

>This assumption is untrue.  The problem is that weak types don't work
>like you assume on most systems.  With the exception of Linux and Irix,
>most systems do not distinguish between weak and "strong" symbols once
>an object is linked.  Therefore, given a weak RTTI in the main
>executable and a strong RTTI in a DSO, they would preempt the latter
>with the former.  As a result, it is necessary to make our incomplete
>class RTTI not just weak, but distinct.  Once it is distinct, the
>pointer RTTI referencing it must be distinct from one referencing the
>complete version, and so on up the pointer chain, and it is not
>possible to compare them at any level.

Ok, thanks for the clarification about that. Let me just see if I
understand DSO linking properly. If we have a loaded object file which
refered to a non-defined weakly declared symbol, that object file will
have resolved the symbol to zero. Loading a DSO which defines that
symbol will not affect the already loaded object file, which remains
having the value zero. Ok?

>Our solution is to use the ABI-defined external mangled RTTI name only
>for complete types.  RTTI generated for pointer-to-incomplete-type must
>be different.  We leave it to the implementation to decide how, but two
>workable approaches are (a) make it a local static, or (b) mangle it
>differently and use COMDAT to remove duplicates; but at least one
>incomplete RTTI would remain, and it would not be the same as the
>complete one even after preemption.

Ok, this needs more documentation. There are three uses for the rtti
information, which we _don't_ have to solve with the same rtti object.
We have attempted to use a single type_info for all three uses, but
that is not necessary, and in some cases we have separate objects (of
the same type, __pointer_type_info) for the same type (T *...*, for
incomplete T).

1) A distinct lvalue for the typeid operator
2) A class heirarchy descriptor for dynamic_cast
3) A class heirarchy and pointer qualification descriptor for catch
matching.

Consider a source file `foo' consisting of these snippets
        struct A;
        typeid (A *); //1
        catch (A **); //2
1 would produce a __pointer_type_info of the following shape
tf_P1A: comdat  ; call this foo.tf_P1A
        name = "P1A"
        flags = 0
        target = weak tf_1A

The TU would not need to emit the (incomplete) type_info for A itself,
but leave a dangling weak reference. That will become zero, unless
another TU is linked in which provides it.

2 must produce information about the entire pointer chain, from the
layout doc that would be
_tf_PP1A: static
        name = "PP1A"
        flags = 8
        target = _tf_P1A
_tf_P1A: static
        name = "P1A"
        flags = 8
        target = _tf_1A
_tf_1A: static
        name = "1A"

Ok?

Now, if we another source `baz' with a definition of A,
        struct B {};
        struct A : B {};
        typeid (A *); //1a
        catch (A **); //2a
        throw (A *)NULL;  //3a

1a would produce the same __pointer_type_info as before, but this time
we would emit comdat typeinfo for the catch clause 2a, and throw 3a is
also permitted.
tf_PP1A: comdat
        name = "PP1A"
        flags = 0
        target = tf_P1A
tf_P1A: comdat  ; call this baz.tf_P1A
        name = "P1A"
        flags = 0
        target = tf_1A
tf_1A: comdat
        name = "1A"
        base = tf_1B
tf_1B: comdat
        name = "1B"

of course tf_P1A is the same object that 1a forced us to emit.

Now the $BIGNUM dollar question. What if `foo' is our executable and
`baz' is the DSO? foo.tf_P1A will be the `active' definition of tf_P1A,
and it will have a NULL target value. Therefore baz.tf_P1A is not
selected and baz.tf_PP1A's target will resolve to foo.tf_P1A. Also the
throw 3a will refer to tf_P1A, which will be resolved by foo.tf_P1A.
That has an incomplete target type, so 3a won't have information about
A being derived from B, and thus won't match a catch (B *) clause.

Perhaps I'm being dense, and there's still something about comdat
linkage I don't understand. But to my understanding the previous
paragraph is the same problem with DSO's I originally raised before
this incomplete type info was addressed.

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From ddd at cup.hp.com  Thu Mar 30 17:31:32 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 30 Mar 2000 17:31:32 +0000
Subject: Initializer priorities (Was: IA-64 ABI meeting results)
References: <200003292308.PAA25863@baalbek.engr.sgi.com> <200003300851.KAA04570@pandora>
Message-ID: <38E38F74.7D4E3C2F@cup.hp.com>

Martin von Loewis wrote:
> 
> To me, this looks like a vendor extension, even though it is supported
> by a number of vendors (in one way or the other). What I don't see is
> the general utility of this facility. Perhaps someone can explain the
> requirements that lead to this extension?

To the best of my understanding, this is also HP's position (both Cary and me).

Regards
Christophe



From ddd at cup.hp.com  Thu Mar 30 20:02:05 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 30 Mar 2000 20:02:05 +0000
Subject: Demangling interface
Message-ID: <38E3B2BD.74214CF3@cup.hp.com>

Here is the interface HP offers today. As I said, it seems overly complicated,
compared to what Matt proposed. On the plus side, it has handling of erroneous
input, which I believe we need to define.

Regards
Christophe


class TDemangler {
public:
  void * operator new(size_t size) {
    return (void*)malloc(size);
  }

  void operator delete(void *deadObject) {
    free(deadObject);
  }

  TDemangler();
  TDemangler(const char *mangledDecl);
  ~TDemangler();

  enum Status { OK, Empty, Error, Truncated };
    
  void reset();
  Status getStatus() const { return status; }
  Status demangleDecl(const char *mangledDecl);
  Status demangleType(const char *mangledType);
  Status copy(char *result, size_t maxToCopy /*including null*/) const;
  Status copy(char *result, size_t maxToCopy /*including null*/,
	      char *name, size_t nameLength) const;
    
private:
  Status status;
  const char *p;
  const char *end;
  void partial(bool top, bool typeOfExternalDecl = false);
  void typeName(size_t &baseOffset, size_t &baseLength);
  void templateArgs();
  void writePrefix(const char *text, size_t length);
  void writeSuffix(const char *text, size_t length);
  void writeDuplicate(unsigned offset, unsigned length);
  void writeBaseName(const char *baseName, size_t baseNameLength,
		     size_t classNameOffset, size_t classNameLength);
  enum Spacing { Before, None, After };
  void writeQualifiers(const char *cv, Spacing spacing);
  size_t extractCount();
  void demangleDecl();

  char *buffer;
  size_t bufferSize;
  enum { InternalBufferSize = 200 };
  char internalBuffer[InternalBufferSize];
  size_t nameSize;
  size_t prefixSize;
  size_t suffixSize;
  bool spaceBeforeName;
  void makeAvailable(size_t length);
  void merge();
  static size_t min(size_t a, size_t b) { return a < b ? a : b; }
};



From coleen at zko.dec.com  Thu Mar 30 21:58:16 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 30 Mar 2000 16:58:16 -0500
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com>
Message-ID: <38E3CDF8.EAADCD92@zko.dec.com>


For pointers to virtual functions, the ABI used to say multiply
by two and add one.  I thought the purpose of this was to be able
to distinguish between non-virtual and virtual functions.

It appears that the multiplication by two was removed.  Why?
If a virtual function occupies slot 3 in the vtable, you can't OR
with '1' to determine whether the function is virtual anymore.
Also, if you have a virtual function in slot 7 in the vtable, then add
one, it'll look like a quadword aligned address from the lower bytes.

Was there a new way to distinguish between non-virtual and virtual
functions in pointer to member functions, that I missed?

thanks,
Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From coleen at zko.dec.com  Thu Mar 30 22:24:57 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 30 Mar 2000 17:24:57 -0500
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com> <38E3CDF8.EAADCD92@zko.dec.com>
Message-ID: <38E3D439.CEE7ACA4@zko.dec.com>


Never mind, it's offset in bytes, not index anymore.  I get it.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From dehnert at baalbek.engr.sgi.com  Thu Mar 30 22:33:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 30 Mar 2000 14:33:06 -0800 (PST)
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com>
Message-ID: <200003302233.OAA28727@baalbek.engr.sgi.com>

> Date: Thu, 30 Mar 2000 16:58:16 -0500
> From: Coleen Phillimore <coleen at zko.dec.com>
> 
> For pointers to virtual functions, the ABI used to say multiply
> by two and add one.  I thought the purpose of this was to be able
> to distinguish between non-virtual and virtual functions.
> 
> It appears that the multiplication by two was removed.  Why?
> If a virtual function occupies slot 3 in the vtable, you can't OR
> with '1' to determine whether the function is virtual anymore.
> Also, if you have a virtual function in slot 7 in the vtable, then add
> one, it'll look like a quadword aligned address from the lower bytes.
> 
> Was there a new way to distinguish between non-virtual and virtual
> functions in pointer to member functions, that I missed?

Yes.  We're using a slot offset, not a slot index.  So the low-order
2-3 bits are always zero, and we just OR in the virtual flag, and just
mask it off.  We did this because on most modern processors, shifting
is something to be avoided, and we don't want to require the divide-
by-two.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From coleen at zko.dec.com  Thu Mar 30 22:35:44 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 30 Mar 2000 17:35:44 -0500
Subject: Pointers-to-members
References: <200002290342.TAA32845@baalbek.engr.sgi.com> <200003302233.OAA28727@baalbek.engr.sgi.com>
Message-ID: <38E3D6C0.42FCDC43@zko.dec.com>

Jim Dehnert wrote:
> 
> > Date: Thu, 30 Mar 2000 16:58:16 -0500
> > From: Coleen Phillimore <coleen at zko.dec.com>
> >
> > For pointers to virtual functions, the ABI used to say multiply
> > by two and add one.  I thought the purpose of this was to be able
> > to distinguish between non-virtual and virtual functions.
> >
> > It appears that the multiplication by two was removed.  Why?
> > If a virtual function occupies slot 3 in the vtable, you can't OR
> > with '1' to determine whether the function is virtual anymore.
> > Also, if you have a virtual function in slot 7 in the vtable, then add
> > one, it'll look like a quadword aligned address from the lower bytes.
> >
> > Was there a new way to distinguish between non-virtual and virtual
> > functions in pointer to member functions, that I missed?
> 
> Yes.  We're using a slot offset, not a slot index.  So the low-order
> 2-3 bits are always zero, and we just OR in the virtual flag, and just
> mask it off.  We did this because on most modern processors, shifting
> is something to be avoided, and we don't want to require the divide-
> by-two.

Yes, definitely a good change, once I figured out what was changed.

Coleen

> 
> Jim
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From dehnert at baalbek.engr.sgi.com  Thu Mar 30 23:31:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 30 Mar 2000 15:31:13 -0800 (PST)
Subject: Proposal 74: Section index limitations
Message-ID: <200003302331.PAA29004@baalbek.engr.sgi.com>

I've updated the proposal based on our discussions at the last meeting.
See http://reality.sgi.com/dehnert_engr/abi/prop-74-sindex.{html,pdf}.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu Mar 30 23:51:52 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 30 Mar 2000 15:51:52 -0800 (PST)
Subject: Initializer priorities (Was: IA-64 ABI meeting results)
References: <200003292308.PAA25863@baalbek.engr.sgi.com>
Message-ID: <200003302351.PAA29075@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de  Thu Mar 30 00:51:51 2000
> 
> # Meeting concensus is that the desirable order is right to left on
> # the link command line, i.e. last listed relocatable object is
> # initialized first.
> 
> What exactly is the requirement for specifying anything more than
> that? The C++ standard leaves the order explicitly
> implementation-defined, so portable programs should not expect any
> particular order. Also, Standard C++ does not provide a mechanism for
> assigning priorities to specific objects.

That's correct, and several vendors, including IBM and gnu, have
concluded that the priority extension is highly desirable.  The C++
ABI group simply observed that given a choice between accepting
incompatibility between extensions or defining a simple facility that
would provide compatibility between vendors that chose to support this,
we preferred the latter.

> To me, this looks like a vendor extension, even though it is supported
> by a number of vendors (in one way or the other). What I don't see is
> the general utility of this facility. Perhaps someone can explain the
> requirements that lead to this extension?

Since SGI has not implemented this, I hope one of those who have will
provide a more detailed answer.  But I recall the rationale discussed
as being essentially that as applications grow, it becomes more and
more desirable to be able to coordinate initialization between
declarations in different object files, allowing declarations to be
placed based on program design rather than constructor interactions.
A secondary concern is being able to coordinate C++ initialization with
initialization in other languages.

Would IBM or Cygnus care to elaborate?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Mar 31 00:20:21 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 30 Mar 2000 16:20:21 -0800 (PST)
Subject: Issue 82:  Initializer priorities
References: <200003292308.PAA25863@baalbek.engr.sgi.com>
Message-ID: <200003310020.QAA29143@baalbek.engr.sgi.com>

Since I promised to summarize the minimum ABI support required for this:

	Define a new section type, SHT_CXX_PRIORITY_INIT.

	The linker must concatenate the SHT_CXX_PRIORITY_INIT sections
	in the linked output file.  (Note that this is the defined
	default behavior for an unrecognized section type.)

On a system where the linker does no more than this, the C++
implementation must do the following:

	In bracketing files for the link (e.g. crt1.o and crtn.o),
	emit delimiting labels in the SHT_CXX_PRIORITY_INIT section,
	and entries in INITARRAY that call an initialization
	routine that passes the labels (all STV_HIDDEN to avoid
	conflicts between DSOs).  The call at the beginning would
	sort the SHT_CXX_PRIORITY_INIT vector by priority and invoke
	the negative-priority initializers, and the one at the end
	would invoke the positive-priority initializers.

So, I think the ABI-required support for this version is almost
nothing, and even the C++ library support is trivial.  (This is part of
the reason I think this is a good idea even though SGI hasn't
previously supported this feature.)  I also think that a vendor serious
about the extension would probably want to do the sorting in the
linker, but since it can be done in place after constructing the output
section, that's not hard, either (a simple call to STL sort :-).
It could be made more powerful by also doing insertion of
initialization entries specied in other ways, but that has a smaller
benefit probably.

The alternate proposal, based on the current g++ implementation,
handles the sorting by encoding the sort key in the section name,
and sorting sections.  That is, one might have sections .cxi$5,
.cxi$3, .cxi$9 in various object files, and the linker would produce a
single concatenated section ordered .cxi$3, .cxi$5, .cxi$9.

The advantages of this proposal are that it is more general (it can
sort sections for other purposes, and the sorted units need not be
the same size), and gnu already implements it.

Its disadvantages are that (a) it is a harder sorting problem,
since the sections must be sorted in the linker prior to section
layout, (b) the linker _must_ support the sorting, (c) it might need
more sections, since different priorities must be handled by putting
the entries in different sections, and (d) it depends on
interpretation of the section name instead of section types and
attributes.

Jim

-		Jim Dehnert  x3-4272



From drepper at redhat.com  Fri Mar 31 00:43:25 2000
From: drepper at redhat.com (Ulrich Drepper)
Date: 30 Mar 2000 16:43:25 -0800
Subject: Issue 82:  Initializer priorities
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Thu, 30 Mar 2000 16:20:21 -0800 (PST)"
References: <200003292308.PAA25863@baalbek.engr.sgi.com> <200003310020.QAA29143@baalbek.engr.sgi.com>
Message-ID: <m3bt3wx93m.fsf@localhost.localnet>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

> 	Define a new section type, SHT_CXX_PRIORITY_INIT.
> 
> 	The linker must concatenate the SHT_CXX_PRIORITY_INIT sections
> 	in the linked output file.  (Note that this is the defined
> 	default behavior for an unrecognized section type.)

This name definitely should not contain CXX in the name.  It is useful
outside C++.

> 	In bracketing files for the link (e.g. crt1.o and crtn.o),

It's normally crti and crtn, not crt1.

-- 
---------------.      drepper at gnu.org  ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------



From msw at eng.sun.com  Fri Mar 31 17:23:31 2000
From: msw at eng.sun.com (Mike Walker)
Date: Fri, 31 Mar 2000 09:23:31 -0800
Subject: [ia64-abi] Issue 82:  Initializer priorities
References: <200003292308.PAA25863@baalbek.engr.sgi.com> <200003310020.QAA29143@baalbek.engr.sgi.com>
Message-ID: <38E4DF13.C1998D17@eng.sun.com>

Jim Dehnert wrote:

> 
> On a system where the linker does no more than this, the C++
> implementation must do the following:
> 
>         In bracketing files for the link (e.g. crt1.o and crtn.o),
>         emit delimiting labels in the SHT_CXX_PRIORITY_INIT section,
>         and entries in INITARRAY that call an initialization
>         routine that passes the labels (all STV_HIDDEN to avoid
>         conflicts between DSOs).  The call at the beginning would
>         sort the SHT_CXX_PRIORITY_INIT vector by priority and invoke
>         the negative-priority initializers, and the one at the end
>         would invoke the positive-priority initializers.

I think it's worth hi-lighting that one of the main motivations 
for us introducing the DT_INITARRAY & DT_FINIARRAY was so that
we could move away from the requirement of having crt*.o
modules when a final link is performed.  Ideally - they are no
longer required for the ia64 development environment.

This proposal introduces a new dependency on the crt*.o modules
which we were trying to move away from.  Is that an issue
for others?

I know that we at Sun are a long way from being crt'less so
it's not that big of an issue for us - but it's worth bringing up
for discussion.


_Mike_


-- 
---
Michael Walker                           Michael.Walker at Eng.Sun.Com
Linker Developer                         (650) 786-5744
Sun Microsystems, Inc.
901 San Antonio Road, MS MPK17-307 Palo Alto, CA 94303-4900



From mark at codesourcery.com  Fri Mar 31 17:55:08 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 31 Mar 2000 09:55:08 -0800
Subject: Initialization priorities
Message-ID: <20000331095508R.mitchell@codesourcery.com>


I've been thinking about this, and I think I'm leaning towards not
mandating this as part of the ABI. (*) I don't see that this feature
is that useful, and it's (almost) the only thing we're mandating
that's not part of standard C++.

One thing that worries me is this kind of code:

  struct S { S (); };
  struct T { T (); };

  S s;
  T t;

but where `t' gets initialized first.  It's very confusing to realize
that the T constructor can't rely on `s' being initialized; one of the
nice things about C++ is that lexical ordering implies initialization
ordering, which means that you can (usually) assume variables are in a
good state.  (For instance, with locals, the standard goes to
considerable effort to disallow any way of talking about an
uninitialized variable; code like:

   goto label;
   S s;
   label:

is illegal.)

So, I'm not even sure this is a great language feature, let alone
something that we should mandate support for in the ABI.  Furthermore,
we haven't provided a syntax for doing this, so programs using these
features will only be portable at the object-file level anyhow -- not
at the compiler level.  Vendors who do not support this feature in
their compilers may well "forget" to implement it in their linkers as
well, rendering it a non-standard anyhow.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com

(*) I admit to arguing against most extensions, whenever they are  
    proposed, so you should bear that in mind.



From cary at cup.hp.com  Fri Mar 31 18:03:33 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Fri, 31 Mar 2000 10:03:33 -0800
Subject: [ia64-abi] Issue 82:  Initializer priorities
Message-ID: <200003311802.KAA07607@adlmail.cup.hp.com>

>Since I promised to summarize the minimum ABI support required for this:
>
>	Define a new section type, SHT_CXX_PRIORITY_INIT.
>
>	The linker must concatenate the SHT_CXX_PRIORITY_INIT sections
>	in the linked output file.  (Note that this is the defined
>	default behavior for an unrecognized section type.)
>
>On a system where the linker does no more than this, the C++
>implementation must do the following:
>
>	In bracketing files for the link (e.g. crt1.o and crtn.o),
>	emit delimiting labels in the SHT_CXX_PRIORITY_INIT section,
>	and entries in INITARRAY that call an initialization
>	routine that passes the labels (all STV_HIDDEN to avoid
>	conflicts between DSOs).  The call at the beginning would
>	sort the SHT_CXX_PRIORITY_INIT vector by priority and invoke
>	the negative-priority initializers, and the one at the end
>	would invoke the positive-priority initializers.

I agree with Ulrich that "CXX" does not belong in the name. But I also 
believe that you don't even need a special section type. I don't see any 
special treatment required of this section beyond SHT_PROGBITS. Your 
bracketing files provide the necessary labels so that the initialization 
routine can find the section.

I understand the argument that the special section type might allow a 
linker to do the sorting if it chose to do so, but you can do that with a 
vendor-specific section type, and the compatibility rules ensure that 
other linkers will treat that section type properly.

This description sounds like it affects the initializer order only within 
a DSO. How does it address reordering of initializers across DSOs?

-cary



From mark at codesourcery.com  Fri Mar 31 18:25:47 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 31 Mar 2000 10:25:47 -0800
Subject: Mangling/templates
Message-ID: <20000331102547K.mitchell@codesourcery.com>


If we really want ABI compatibility, we have to decide whether:

  A<J + 3 + 2>

is the same as A<J + 5> and/or A<J + 2 + 3> when manging expressions.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Fri Mar 31 20:35:54 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 31 Mar 2000 12:35:54 -0800
Subject: Initialization priorities
In-Reply-To: <872568B3.006A1F97.00@d53mta04h.boulder.ibm.com>
References: <872568B3.006A1F97.00@d53mta04h.boulder.ibm.com>
Message-ID: <20000331123554X.mitchell@codesourcery.com>

>>>>> "mendell" == mendell  <mendell at ca.ibm.com> writes:

    mendell> The compiler is not allowed to initialize t before s in
    mendell> the example below.  If you put a #pragma priority between
    mendell> the two, the values before and after must be such that t
    mendell> is alwas initialized after s.

I do not believe that is true in GCC, but it may well be true in your
compiler.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mendell at ca.ibm.com  Fri Mar 31 19:18:41 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Fri, 31 Mar 2000 14:18:41 -0500
Subject: Initialization priorities
Message-ID: <852568B3.007970AB.00@D51MTA05.pok.ibm.com>

The compiler is not allowed to initialize t before s in the example below.
If you put a #pragma priority between the two, the values before and after
must be such that t is alwas initialized after s.

Mark

I've been thinking about this, and I think I'm leaning towards not
mandating this as part of the ABI. (*) I don't see that this feature
is that useful, and it's (almost) the only thing we're mandating
that's not part of standard C++.

One thing that worries me is this kind of code:

  struct S { S (); };
  struct T { T (); };

  S s;
  T t;

but where `t' gets initialized first.  It's very confusing to realize
that the T constructor can't rely on `s' being initialized; one of the
nice things about C++ is that lexical ordering implies initialization
ordering, which means that you can (usually) assume variables are in a
good state.  (For instance, with locals, the standard goes to
considerable effort to disallow any way of talking about an
uninitialized variable; code like:

   goto label;
   S s;
   label:

is illegal.)

So, I'm not even sure this is a great language feature, let alone
something that we should mandate support for in the ABI.  Furthermore,
we haven't provided a syntax for doing this, so programs using these
features will only be portable at the object-file level anyhow -- not
at the compiler level.  Vendors who do not support this feature in
their compilers may well "forget" to implement it in their linkers as
well, rendering it a non-standard anyhow.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com

(*) I admit to arguing against most extensions, whenever they are
    proposed, so you should bear that in mind.






From jfw at sgi.com  Fri Mar 31 22:09:36 2000
From: jfw at sgi.com (John Wilkinson)
Date: Fri, 31 Mar 2000 14:09:36 -0800
Subject: mangling of local names
Message-ID: <38E52220.E80B8ADD@sgi.com>

Here's some proposed new language for local name mangling:


-- 
John Wilkinson
-------------- next part --------------
Here is a proposed revision for the scope encoding section:

Occasionally an entity in a local scope must be mangled too (e.g. because
inlining or template instantiation causes multiple translation
units to require access to that entity).  The encoding for such entities
is as follows:

  <local-name> := Z <'function' encoding> E [<discriminator>] <'entity' name>
	       := Z <'function' encoding> E S <hashed-literal>

  <discriminator> := <number>_

The second production is used for string literals, which are hashed using
some yet-to-be-determined function.  Note that this assumes that the
same string literal occurring twice in a given function in fact represents
a single entity, i.e. has a unique address.

In the first production, the discriminator will be present only for the
second and later occurrences of the same name within a single function.
In this case <number> is n - 2, if this is the nth occurrence, in lexical
order, of the given name.  It is expected that this will be the 'natural'
order in most compilers.

In any case, trouble would arise only if different compilation units
including the same code were compiled by different compilers, and 
multiple entities requiring mangling had the same name.

