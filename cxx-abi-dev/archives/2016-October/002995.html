<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [cxx-abi-dev] manglings for exception specifications in	function types
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20%5Bcxx-abi-dev%5D%20manglings%20for%20exception%20specifications%20in%0A%09function%20types&In-Reply-To=%3CCAGL0aWfdvmgBT5QkuM3J9nOzOVLMApGw3qNigxjahOksHVejOA%40mail.gmail.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="002994.html">
   <LINK REL="Next"  HREF="002996.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[cxx-abi-dev] manglings for exception specifications in	function types</H1>
    <B>Richard Smith</B> 
    <A HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20%5Bcxx-abi-dev%5D%20manglings%20for%20exception%20specifications%20in%0A%09function%20types&In-Reply-To=%3CCAGL0aWfdvmgBT5QkuM3J9nOzOVLMApGw3qNigxjahOksHVejOA%40mail.gmail.com%3E"
       TITLE="[cxx-abi-dev] manglings for exception specifications in	function types">richardsmith at google.com
       </A><BR>
    <I>Thu Oct 13 18:29:47 UTC 2016</I>
    <P><UL>
        <LI>Previous message: <A HREF="002994.html">[cxx-abi-dev] manglings for exception specifications in function types
</A></li>
        <LI>Next message: <A HREF="002996.html">[cxx-abi-dev] manglings for exception specifications in function types
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2995">[ date ]</a>
              <a href="thread.html#2995">[ thread ]</a>
              <a href="subject.html#2995">[ subject ]</a>
              <a href="author.html#2995">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>On 13 October 2016 at 10:39, John McCall &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">rjmccall at apple.com</A>&gt; wrote:

&gt;<i> On Oct 12, 2016, at 5:07 PM, Richard Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">richardsmith at google.com</A>&gt;
</I>&gt;<i> wrote:
</I>&gt;<i> On 12 October 2016 at 16:34, John McCall &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">rjmccall at apple.com</A>&gt; wrote:
</I>&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On Oct 12, 2016, at 2:09 PM, Richard Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">richardsmith at google.com</A>&gt;
</I>&gt;&gt;<i> wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> On 12 October 2016 at 13:51, John McCall &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">rjmccall at apple.com</A>&gt; wrote:
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> On Oct 12, 2016, at 11:58 AM, Richard Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">richardsmith at google.com</A>&gt;
</I>&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;<i> On 11 October 2016 at 19:20, John McCall &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">rjmccall at apple.com</A>&gt; wrote:
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> On Oct 11, 2016, at 4:20 PM, Richard Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">richardsmith at google.com</A>&gt;
</I>&gt;&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;&gt;<i> On 11 October 2016 at 15:17, John McCall &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">rjmccall at apple.com</A>&gt; wrote:
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> On Oct 11, 2016, at 2:11 PM, Richard Smith &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">richardsmith at google.com</A>&gt;
</I>&gt;&gt;&gt;&gt;&gt;<i> wrote:
</I>&gt;&gt;&gt;&gt;&gt;<i> Under
</I>&gt;&gt;&gt;&gt;&gt;<i>   <A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html</A>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> the noexceptness of a function type is now part of the type. As a
</I>&gt;&gt;&gt;&gt;&gt;<i> result, we need manglings for exception-specifications on function
</I>&gt;&gt;&gt;&gt;&gt;<i> pointer/reference types:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> void f(void()) {}
</I>&gt;&gt;&gt;&gt;&gt;<i> void f(void() noexcept) {} // ok, overload not redefinition
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> (It's not clear to me whether or not this was also necessary prior to
</I>&gt;&gt;&gt;&gt;&gt;<i> C++17 to handle dependent exception specifications that appear lexically
</I>&gt;&gt;&gt;&gt;&gt;<i> within the parameter list of a function template, and actual implementation
</I>&gt;&gt;&gt;&gt;&gt;<i> practice varies as to whether such exception specifications are SFINAEable.)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> In order to handle overloading/SFINAE on exception specifications in
</I>&gt;&gt;&gt;&gt;&gt;<i> dependent cases, we need to be able to mangle not only &quot;noexcept&quot;, but also
</I>&gt;&gt;&gt;&gt;&gt;<i> &quot;noexcept(expression)&quot; and &quot;throw(&lt;types&gt;)&quot;. Suggestion for manglings:
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> &lt;exception-spec&gt; ::=
</I>&gt;&gt;&gt;&gt;&gt;<i>   nx  -- non-throwing exception specification
</I>&gt;&gt;&gt;&gt;&gt;<i>   nX &lt;expression&gt; E  -- computed (value-dependent) noexcept
</I>&gt;&gt;&gt;&gt;&gt;<i>   tw &lt;type&gt;* E  -- throw (types)
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> &lt;function-type&gt; ::= [&lt;CV-qualifiers&gt;] [&lt;exception-spec&gt;] [Dx] F [Y]
</I>&gt;&gt;&gt;&gt;&gt;<i> &lt;bare-function-type&gt; [&lt;ref-qualifier&gt;] E
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> In the case of throw(a, b, c), we could omit types that are neither
</I>&gt;&gt;&gt;&gt;&gt;<i> instantiation-dependent nor pack expansions (if that omits all types, we
</I>&gt;&gt;&gt;&gt;&gt;<i> can use the 'nx' mangling instead), since C++17 says you can't overload on
</I>&gt;&gt;&gt;&gt;&gt;<i> the actual types in the dynamic exception specification, and we otherwise
</I>&gt;&gt;&gt;&gt;&gt;<i> only need them to be present if they might result in a substitution failure.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> Thoughts?
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> I think this is an amazingly late change to the language with pretty
</I>&gt;&gt;&gt;&gt;&gt;<i> thin justification; does that count?
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> This really is a major change which can reasonably be expected to
</I>&gt;&gt;&gt;&gt;&gt;<i> cause substantial source and binary breakage.  The proposal mentions
</I>&gt;&gt;&gt;&gt;&gt;<i> transaction_safe as a feature that added similar complexity, but that
</I>&gt;&gt;&gt;&gt;&gt;<i> analogy is weak because (1) TM is expected to be an optional TS, whereas
</I>&gt;&gt;&gt;&gt;&gt;<i> noexcept is a mandatory core language feature, and (2) existing code does
</I>&gt;&gt;&gt;&gt;&gt;<i> not use the transaction_safe attribute, whereas noexcept and throw() have
</I>&gt;&gt;&gt;&gt;&gt;<i> seen widespread adoption, in the latter case for years.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> If it is a goal of this proposal to eliminate the underspecified fake
</I>&gt;&gt;&gt;&gt;&gt;<i> type system around exception specifications, it is worth noting that it
</I>&gt;&gt;&gt;&gt;&gt;<i> completely fails to do so, since the checking rules for direct function
</I>&gt;&gt;&gt;&gt;&gt;<i> pointer assignments are still quite a bit stronger than those provided by
</I>&gt;&gt;&gt;&gt;&gt;<i> the new type system.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> That was indeed a goal here. Can you expand on how it fails? Ignoring
</I>&gt;&gt;&gt;&gt;<i> the (deprecated) dynamic exception specifications, this new approach seems
</I>&gt;&gt;&gt;&gt;<i> stronger than the old type system, since it works for function types being
</I>&gt;&gt;&gt;&gt;<i> arbitrarily nested within other types, not just one level deep within
</I>&gt;&gt;&gt;&gt;<i> function types and pointers.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Are there any implementations which actually plan to throw out the
</I>&gt;&gt;&gt;&gt;<i> dynamic exception specification matching logic?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> *shrug* Maybe MSVC? Any conforming C++17 implementation will need to
</I>&gt;&gt;&gt;<i> demote that side of their enforcement to a warning. And I think there are
</I>&gt;&gt;&gt;<i> NB comments for C++17 proposing that we apply <A HREF="http://www.open-std.org/">http://www.open-std.org/</A>
</I>&gt;&gt;&gt;<i> jtc1/sc22/wg21/docs/papers/2016/p0003r4.html for C++17 rather than
</I>&gt;&gt;&gt;<i> waiting for C++20.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Not enforcing the old rules is also compatibility-breaking, of course,
</I>&gt;&gt;&gt;<i> because of SFINAE.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Hmm, I thought we had added a rule to allow B to be deduced in
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>   template&lt;class R, class ...A, bool B&gt; void f(R(A...) noexcept(B));
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> but it looks like we actually didn't. =(
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Hmm, that would work pretty well for this case.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Yes, the above is a problem, if noexcept function types start to appear
</I>&gt;&gt;&gt;&gt;<i> in existing code (for instance through use of decltype or by code that
</I>&gt;&gt;&gt;&gt;<i> passes around noexcept function pointers).
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Well, recall that noexcept function types have always been writable;
</I>&gt;&gt;&gt;&gt;<i> they just didn't necessarily get enforced reliably.  Also, noexcept and
</I>&gt;&gt;&gt;&gt;<i> throw() are pretty popular, and aren't there proposals to infer them in
</I>&gt;&gt;&gt;&gt;<i> more cases?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Proposals, yes, but nothing in C++17.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I think it's reasonable to anticipate that when judging how often
</I>&gt;&gt;&gt;<i> functions will be noexcept.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> It's really hard to say abstractly how much impact this will have.
</I>&gt;&gt;&gt;&gt;<i> There's a lot of potential for breakage, but it's also quite possible that
</I>&gt;&gt;&gt;&gt;<i> there won't be many changes and that almost all of them will be lost in the
</I>&gt;&gt;&gt;&gt;<i> great grey expanse of C++ binary compatibility.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We'll have an implementation soon, and then we can find out whether this
</I>&gt;&gt;&gt;<i> is a problem in practice.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I'll admit that I don't attend committee meetings, but I thought that
</I>&gt;&gt;&gt;<i> implementation experience was expected *prior* to standardization, not
</I>&gt;&gt;&gt;<i> something that gets done months after voting the thing in concurrently with
</I>&gt;&gt;&gt;<i> the committee finalizing the language in a draft for next year's release.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Some of us try to push for that. So far we've not had much success.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> A pity.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Okay.  Doug Gregor has strong opinions about this, but I'll let him speak
</I>&gt;&gt;<i> for himself if he wants; I'll drop my own objections to the feature pending
</I>&gt;&gt;<i> implementation experience.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> You will note that I have omitted the necessary specializations for
</I>&gt;&gt;&gt;&gt;&gt;<i> &quot;transaction_safe&quot;, as well as the incredibly common extension of
</I>&gt;&gt;&gt;&gt;&gt;<i> specialized calling conventions.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i> This also breaks source compatibility for template matching, and
</I>&gt;&gt;&gt;&gt;&gt;<i> basically every function template in the standard library is going to
</I>&gt;&gt;&gt;&gt;&gt;<i> change manglings (and become *much* larger) due to noexcept expressions now
</I>&gt;&gt;&gt;&gt;&gt;<i> being mangled.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> It's a problem, but I don't think it's as bad as you claim. The
</I>&gt;&gt;&gt;&gt;<i> mangling of a function still wouldn't include its exception specification;
</I>&gt;&gt;&gt;&gt;<i> this would only affect mangling in cases where a parameter or return type
</I>&gt;&gt;&gt;&gt;<i> or template argument involves a function type with an
</I>&gt;&gt;&gt;&gt;<i> exception-specification -- a lot less common than every function template
</I>&gt;&gt;&gt;&gt;<i> in the standard library, but this still does change manglings for existing
</I>&gt;&gt;&gt;&gt;<i> code.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> Okay, so it only triggers SFINAE failures in nested function types, and
</I>&gt;&gt;&gt;&gt;<i> you can't overload templates by it?  I agree that that helps a lot.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> And the entire proposal seems to have forgotten about
</I>&gt;&gt;&gt;&gt;&gt;<i> reference-to-function types.
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> The change to [dcl.init.ref]p4 allows a reference to non-noexcept
</I>&gt;&gt;&gt;&gt;<i> function to bind to a noexcept function, and this indirectly allows the
</I>&gt;&gt;&gt;&gt;<i> same during overload resolution, casts, and so on. What additional
</I>&gt;&gt;&gt;&gt;<i> considerations were missed?
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> I hadn't realized that the expression logic was so consistent about
</I>&gt;&gt;&gt;&gt;<i> defining e.g. the behavior of the conditional operator on l-values in terms
</I>&gt;&gt;&gt;&gt;<i> of reference binding.  I apologize.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;<i> ...I see that this adds a new special case to exception handling.
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> Yes; I'd forgotten to mention this side of the ABI change.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> We'll also need a new flag on type_info objects to model this. In line
</I>&gt;&gt;&gt;<i> with the transaction_safe changes that Jason proposed, I suggest adding a
</I>&gt;&gt;&gt;<i> __noexcept_mask = 0x40 to __pbase_type_info, and representing a pointer to
</I>&gt;&gt;&gt;<i> noexcept function as a pointer with __noexcept_mask bit set to the
</I>&gt;&gt;&gt;<i> corresponding *non-noexcept* function pointer type.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;&gt;<i> I strongly disagree; we should take this opportunity to revisit that
</I>&gt;&gt;&gt;<i> decision.  The floodgates are open, and this set of function type
</I>&gt;&gt;&gt;<i> attributes is clearly going to grow over time.  (It's actually
</I>&gt;&gt;&gt;<i> transaction_safe that really drives this point home; noexcept is at least a
</I>&gt;&gt;&gt;<i> longstanding part of the core language in various forms.)  We also have a
</I>&gt;&gt;&gt;<i> lot of vendor-specific function type attributes that are part of the type
</I>&gt;&gt;&gt;<i> but just aren't standardized and can't be represented in type_info.  I
</I>&gt;&gt;&gt;<i> don't think it makes sense to indefinitely keep hacking these things into
</I>&gt;&gt;&gt;<i> the pointer type flags; we should just bite the bullet and create a new
</I>&gt;&gt;&gt;<i> function_type_info subclass.
</I>&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Oh, for what it's worth, this is actually mandatory: typeid does have to
</I>&gt;&gt;<i> be able to return a type_info for an arbitrary type, not just a pointer or
</I>&gt;&gt;<i> member pointer for it.  typeid does not perform function-to-pointer
</I>&gt;&gt;<i> conversion on an expression operand, and it can also be used with an
</I>&gt;&gt;<i> arbitrary type-id.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> We definitely need different type_info for the qualified and unqualified
</I>&gt;<i> types, but I don't think that implies that the pointee type in the
</I>&gt;<i> type_info for corresponding function pointers must be different. GCC's
</I>&gt;<i> approach for transaction_safe is that the pointee type_info referenced by a
</I>&gt;<i> pointer type_info is always the function type *without* the
</I>&gt;<i> transaction_safe mangling, so the marking is present only on the pointer
</I>&gt;<i> type_info. That's definitely not ideal, but does seem to work.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Ah, I think I see.  You're suggesting that the type_info for 'void(*)()
</I>&gt;<i> noexcept' could just be an attributed pointer to the type_info for
</I>&gt;<i> 'void()', but that the type_info for 'void() noexcept' would be some
</I>&gt;<i> different sort of thing.  I agree that this is possible, but it might paint
</I>&gt;<i> us into a corner; e.g. if the committee ever standardizes a richer
</I>&gt;<i> reflection system based on type_info, I would expect it to have some way to
</I>&gt;<i> ask for the pointee type of a pointer as a type_info, which we would then
</I>&gt;<i> be unable to implement correctly.
</I>&gt;<i>
</I>&gt;<i> That said, I like the end result of this approach a lot more:
</I>&gt;<i>
</I>&gt;&gt;<i> OK. How about this:
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> class __qualified_function_type_info : public __function_type_info {
</I>&gt;&gt;<i> public:
</I>&gt;&gt;<i>   const __function_type_info *__base_type;
</I>&gt;&gt;<i>   unsigned int __qualifiers;
</I>&gt;&gt;<i>   enum __qualifiers_mask {
</I>&gt;&gt;<i>     __const_mask = 0x01,
</I>&gt;&gt;<i>     __volatile_mask = 0x02,
</I>&gt;&gt;<i>     __restrict_mask = 0x04,
</I>&gt;&gt;<i>     __lval_ref_mask = 0x08,
</I>&gt;&gt;<i>     __rval_ref_mask = 0x10,
</I>&gt;&gt;<i>     __noexcept_mask = 0x20,
</I>&gt;&gt;<i>     __transaction_safe_mask = 0x40
</I>&gt;&gt;<i>   };
</I>&gt;&gt;<i> };
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> ... where __base_type is the unqualified function type, included to avoid
</I>&gt;&gt;<i> the need for string comparisons when checking for a matching exception
</I>&gt;&gt;<i> handler. The base class __function_type_info would be used for types with
</I>&gt;&gt;<i> no qualifiers.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Representing the base type this way makes sense to me.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> Adding a new class does have backwards deployment problems: normally
</I>&gt;&gt;<i> these type_infos are emitted by the ABI library, but it won't have this
</I>&gt;&gt;<i> class on older targets.  I don't think we want to lazily emit this class in
</I>&gt;&gt;<i> every translation unit that uses it; that's a lot of code, including some
</I>&gt;&gt;<i> that's intricately tied to the EH mechanism.  On Darwin, I don't have any
</I>&gt;&gt;<i> problem with saying that we just don't support the extended information
</I>&gt;&gt;<i> unless the minimum deployment target is an OS that provides the class;
</I>&gt;&gt;<i> after all, the exceptions machinery won't support it without updates
</I>&gt;&gt;<i> either.  Is a similar answer acceptable to other people, or do we need
</I>&gt;&gt;<i> something more sophisticated?
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> It's definitely a pain for Clang targeting GNU OSs, since we support using
</I>&gt;<i> the installed version of libsupc++ as our ABI library. If the only fallout
</I>&gt;<i> were that you couldn't throw a noexcept function pointer and catch it as a
</I>&gt;<i> non-noexcept function pointer, that'd be fine, but link errors for the
</I>&gt;<i> __qualified_function_type_info vtable seem problematic.
</I>&gt;<i>
</I>&gt;<i> We could potentially lazily emit that one symbol as a weak alias for the
</I>&gt;<i> __function_type_info vtable, but we tried something like that with sized
</I>&gt;<i> deallocation (which had largely similar issues) and found it to be more
</I>&gt;<i> trouble than it was worth.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> I don't remember all the issues for sized deallocation, but at least some
</I>&gt;<i> of them wouldn't apply here.  IIRC, sized deallocation actually had to be a
</I>&gt;<i> weak alias to a local implementation in order to satisfy the ABI /
</I>&gt;<i> delegation rules, which wouldn't be true here.  More importantly, sized
</I>&gt;<i> deallocation required adding code to the majority of translation units,
</I>&gt;<i> which, uh, I don't expect we'll see similar problems from here.  Still,
</I>&gt;<i> this is asking a lot of of the linker/loader.
</I>&gt;<i>
</I>
The large number of duplicate copies was a pain, but wasn't the reason we
ended up turning that mechanism off. I don't exactly recall the details,
but the gist was that we needed linker magic to force a user replacement
version from the main binary to be exported so that DSOs would see it, but
that mechanism had problematic interactions with weak definitions.

We can avoid introducing the new class if we can find some other way to
&gt;<i> encode in the object that it has extra fields.  Unfortunately, a
</I>&gt;<i> __function_type_info only has a v-table pointer (inviolate) and a name
</I>&gt;<i> pointer (just a const char*, i.e. 1-byte aligned).  We can't put anything
</I>&gt;<i> in the string itself because it has to be globally uniqued, and if our name
</I>&gt;<i> &quot;wins&quot; and is used in a different type_info which doesn't provide the extra
</I>&gt;<i> fields, we're in trouble.  So I don't think this is possible.
</I>&gt;<i>
</I>&gt;<i> But lazily emitting the v-table also creates nasty problems, chiefly
</I>&gt;<i> because it requires us to also emit the virtual function definitions
</I>&gt;<i> lazily, and those are pretty complex.
</I>&gt;<i>
</I>&gt;<i> Can we emit a weak definition in the compiler runtime library, or does
</I>&gt;<i> that have the same problems as a weak definition in every translation unit?
</I>&gt;<i>
</I>
In our case, for some targets there simply is no compiler runtime library
that we control. We might not even be involved in the link step.

Perhaps we could use an ifunc selecting between the vtable of
__qualified_function_type_info (if it's defined) and that of
__function_type_info (otherwise) as the vptr of the type_info object for a
qualified function type.

&gt;<i> It might also be reasonable to reserve a bit for 'noreturn', since several
</I>&gt;&gt;<i> compilers treat it as part of the function type in some way.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I'm not sure this is the right representation for function type
</I>&gt;&gt;<i> qualifiers.  It seems to me that there are two kinds:
</I>&gt;&gt;<i>   - those that create a (trivially-convertible) subtype of the
</I>&gt;&gt;<i> unqualified type, like 'unwind', 'noexcept', and (for the implementations
</I>&gt;&gt;<i> that make this decision) 'noreturn', and
</I>&gt;&gt;<i>   - those that don't, like cvr-qualifiers, ref-qualifiers, and calling
</I>&gt;&gt;<i> conventions.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i> There's been some recent talk of permitting pointer-to-member-function
</I>&gt;<i> conversions that remove cvr-qualifiers and add ref-qualifiers; those two
</I>&gt;<i> may end up in the &quot;trivially-convertible&quot; camp for C++20.
</I>&gt;<i>
</I>&gt;<i> <A HREF="http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1555">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1555</A> suggests
</I>&gt;<i> allowing implicit conversion between extern &quot;C&quot; function types and
</I>&gt;<i> non-extern-&quot;C&quot; function types in cases where the two calling conventions
</I>&gt;<i> are the same, as a way of resolving the issues leading to longstanding lack
</I>&gt;<i> of implementation of extern &quot;C&quot; function types by most vendors.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> Okay, I accept that the standardized attributes should just be represented
</I>&gt;<i> as specific bits and that baking subtyping into the representation is
</I>&gt;<i> fraught.  So maybe the representation should be:
</I>&gt;<i>
</I>&gt;<i> class __qualified_function_type_info : public __function_type_info {
</I>&gt;<i> public:
</I>&gt;<i>   const __function_type_info *__base_type;
</I>&gt;<i>   unsigned int __qualifiers;
</I>&gt;<i>   enum __qualifiers_mask {
</I>&gt;<i>     __const_mask = 0x01,
</I>&gt;<i>     __volatile_mask = 0x02,
</I>&gt;<i>     __restrict_mask = 0x04,
</I>&gt;<i>     __lval_ref_mask = 0x08,
</I>&gt;<i>     __rval_ref_mask = 0x10,
</I>&gt;<i>     __noexcept_mask = 0x20,
</I>&gt;<i>     __transaction_safe_mask = 0x40
</I>&gt;<i>   };
</I>&gt;<i>   const char *__extended_qualifiers;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> And the convertibility check requires the extended qualifiers to either
</I>&gt;<i> both be null or string-compare equal.
</I>&gt;<i>
</I>
What does this buy us over keeping the extended qualifiers in the base
type? Is the idea that a target-specific runtime could choose to allow more
conversions based on extended qualifiers?


&gt;<i> John.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i> But I would certainly grant that it doesn't make sense to use these flags
</I>&gt;<i> to model, for instance, actually-different calling conventions.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;&gt;<i> EH matching needs to verify that the subtyping qualifiers of the source
</I>&gt;&gt;<i> type are a superset of the subtyping qualifiers of the target type, and it
</I>&gt;&gt;<i> needs to verify that the other qualifiers match exactly.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> I don't think catch-matching on a qualified function pointer type is an
</I>&gt;&gt;<i> operation we need to expend a lot of effort optimizing.  I would rather
</I>&gt;&gt;<i> have a more general representation that allows fairly painless vendor
</I>&gt;&gt;<i> extension; I think that calls for at least the ability to have *some*
</I>&gt;&gt;<i> string-based matching, even if maybe the standard ones get allocated to
</I>&gt;&gt;<i> bit-fields.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i> John.
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20161013/0956274b/attachment-0001.html">http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20161013/0956274b/attachment-0001.html</A>&gt;
</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="002994.html">[cxx-abi-dev] manglings for exception specifications in function types
</A></li>
	<LI>Next message: <A HREF="002996.html">[cxx-abi-dev] manglings for exception specifications in function types
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2995">[ date ]</a>
              <a href="thread.html#2995">[ thread ]</a>
              <a href="subject.html#2995">[ subject ]</a>
              <a href="author.html#2995">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">More information about the cxx-abi-dev
mailing list</a><br>
</body></html>
