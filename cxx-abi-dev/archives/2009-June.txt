From zibi at ca.ibm.com  Mon Jun  1 12:52:14 2009
From: zibi at ca.ibm.com (Zbigniew Sarbinowski)
Date: Mon, 1 Jun 2009 08:52:14 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <4A22ABF2.5070109@codesourcery.com>
Message-ID: <OFC0921C04.9EE37C28-ON852575C8.00462E33-852575C8.0046B427@ca.ibm.com>

> Dennis Handly wrote:
>
> > Not on my implementation where C and C++ calling conventions are the
same.
>
> Given the precedent set with __cxa_pure_virtual, I think we should just
> stick with extern "C".  Having half a solution isn't really very
> interesting.  If we care about implementations where C and C++ linkage
> are incompatible, we should go through the document, find places where
> that assumption shows, and add new entry points as necessary.  (We
> cannot of course remove the existing functions, but we could add new
> functions with C++ linkage.)
>
> But, are there are at this point any implementations for which C and C++
> linkage are incompatible in terms of calling conventions?  If this is
> just a theoretical concern, then we should leave it alone; that the ABI
> constrains new implementations which wish to follow the ABI is not an
> inherent problem.
> Mark Mitchell

Yes, on MVS system C and C++ linkage has different calling convention in
non-xplink mode.  In xplink they are the same but we have to support
non-xplink path as well.

Regards, ______________________________________
Zbigniew Sarbinowski (Zibi)  C++ FE development
8200 Warden Ave. Markham ON, L6G 1C7
C2/712/8200/MKM  Tel: 905-413-6071

-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/4784025c/attachment.html>

From perry at ca.ibm.com  Mon Jun  1 13:46:41 2009
From: perry at ca.ibm.com (Sean Perry)
Date: Mon, 1 Jun 2009 09:46:41 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <4A22ABF2.5070109@codesourcery.com>
Message-ID: <OFBCCDBB4A.3B4C53C4-ON852575C8.004AB83C-852575C8.004BB0C6@ca.ibm.com>


On zSeries (i.e. 390) the linkage for C and C++ are different.  Identifying
all the places and providing solutions to the mixed linkage problems in the
document is a prereq to implementing the C++ABI in zSeries compilers.

--
Sean Perry
Compiler Development
IBM Canada Lab
(905)-413-6031 (tie 313-6031), fax (905)-413-4839



                                                                           
             Mark Mitchell                                                 
             <mark at codesourcer                                             
             y.com>                                                     To 
                                       Dennis Handly <dhandly at cup.hp.com>  
             05/31/09 12:10 PM                                          cc 
                                       cxx-abi-dev at codesourcery.com        
                                                                   Subject 
                                       Re: [cxx-abi-dev] Deleted virtual   
                                       functions                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           




Dennis Handly wrote:

> Not on my implementation where C and C++ calling conventions are the
same.

Given the precedent set with __cxa_pure_virtual, I think we should just
stick with extern "C".  Having half a solution isn't really very
interesting.  If we care about implementations where C and C++ linkage
are incompatible, we should go through the document, find places where
that assumption shows, and add new entry points as necessary.  (We
cannot of course remove the existing functions, but we could add new
functions with C++ linkage.)

But, are there are at this point any implementations for which C and C++
linkage are incompatible in terms of calling conventions?  If this is
just a theoretical concern, then we should leave it alone; that the ABI
constrains new implementations which wish to follow the ABI is not an
inherent problem.

>> (Note that some implementations of __cxa_pure_virtual call fprintf, and
>> thereby drag in the whole I/O library; it's not just the cost of the
>> __cxa_pure_virtual function itself.)
>
> I don't see this as an issue.  If there is a __cxa_pure_virtual that
> calls fprintf the cost is already paid?  At least in a shared lib
> implementation.

Yes -- but for small embedded systems there are no shared libraries.

> I assume the Standard says that if you manage to call that function, it's
> your tough luck?  ;-)

Yes.

> Are we going to explain that "may" in detail in the ABI so we don't have
to
> have this mail exchange again?

We can ask Daveed if he will add a note to his drafting. :-)  If not, I
can add one.

--
Mark Mitchell
CodeSourcery
mark at codesourcery.com
(650) 331-3385 x713
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/094ebf62/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: graycol.gif
Type: image/gif
Size: 105 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/094ebf62/attachment.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: pic25833.gif
Type: image/gif
Size: 1255 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/094ebf62/attachment-0001.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ecblank.gif
Type: image/gif
Size: 45 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/094ebf62/attachment-0002.gif>

From daveed at edg.com  Mon Jun  1 15:28:21 2009
From: daveed at edg.com (David Vandevoorde)
Date: Mon, 1 Jun 2009 11:28:21 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <4A22ABF2.5070109@codesourcery.com>
References: <200905300456.VAA07353@hpcll183.cup.hp.com> <4A22ABF2.5070109@codesourcery.com>
Message-ID: <7BB8C915-6191-42E9-9D0C-0155596FA625@edg.com>


On May 31, 2009, at 12:10 PM, Mark Mitchell wrote:

> Dennis Handly wrote:
[...]
>> Are we going to explain that "may" in detail in the ABI so we don't  
>> have to
>> have this mail exchange again?
>
> We can ask Daveed if he will add a note to his drafting. :-)  If  
> not, I
> can add one.


I'll add the note.

	Daveed



From mark at codesourcery.com  Mon Jun  1 16:08:26 2009
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 01 Jun 2009 09:08:26 -0700
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <OFBCCDBB4A.3B4C53C4-ON852575C8.004AB83C-852575C8.004BB0C6@ca.ibm.com>
References: <OFBCCDBB4A.3B4C53C4-ON852575C8.004AB83C-852575C8.004BB0C6@ca.ibm.com>
Message-ID: <4A23FCFA.1070403@codesourcery.com>

Sean Perry wrote:

> On zSeries (i.e. 390) the linkage for C and C++ are different.
> Identifying all the places and providing solutions to the mixed linkage
> problems in the document is a prereq to implementing the C++ABI in
> zSeries compilers.

If you are going to change the ABI anyhow, would you reconsider this
difference in linkage?  The ABI document defines various C++ things in
terms of their C equivalents; for example, the ABI for a C++ non-static
function member is defined in terms of the ABI for a C function with an
extra parameter for "this".

In any case, if maintaining separate calling conventions for C and C++
is necessary, yes, I think you'll have to go through the document,
identify those places, and propose solutions.  The solutions need to
preserve backwards compatibility, so you may need to introduce some new
APIs that are used only on systems where the linkages do not match up.

-- 
Mark Mitchell
CodeSourcery
mark at codesourcery.com
(650) 331-3385 x713


From crowl at google.com  Mon Jun  1 18:35:14 2009
From: crowl at google.com (Lawrence Crowl)
Date: Mon, 1 Jun 2009 11:35:14 -0700
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <OFC0921C04.9EE37C28-ON852575C8.00462E33-852575C8.0046B427@ca.ibm.com>
References: <4A22ABF2.5070109@codesourcery.com>
	 <OFC0921C04.9EE37C28-ON852575C8.00462E33-852575C8.0046B427@ca.ibm.com>
Message-ID: <29bd08b70906011135p2de98771o1370dbf6cccf7bc0@mail.gmail.com>

On 6/1/09, Zbigniew Sarbinowski <zibi at ca.ibm.com> wrote:
> > But, are there are at this point any implementations for which C
> > and C++ linkage are incompatible in terms of calling conventions?
> > If this is just a theoretical concern, then we should leave it
> > alone; that the ABI constrains new implementations which wish
> > to follow the ABI is not an inherent problem.
>
> Yes, on MVS system C and C++ linkage has different calling
> convention in non-xplink mode. In xplink they are the same but
> we have to support non-xplink path as well.

Because modern calling conventions are better than older conventions
for C++, some older systems could get a performance improvement
by using a different calling convention for extern C++ functions.
It is unlikely that a vendor will follow that path unless there
are other reasons to create a new ABI for C++.

-- 
Lawrence Crowl


From perry at ca.ibm.com  Mon Jun  1 21:34:50 2009
From: perry at ca.ibm.com (Sean Perry)
Date: Mon, 1 Jun 2009 17:34:50 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <4A23FCFA.1070403@codesourcery.com>
Message-ID: <OFC466A0B4.BAF63D2E-ON852575C8.0067A4F7-852575C8.00768D08@ca.ibm.com>


Unfortunately, I don't think changing the calling convention would be an
option.  We will need to clean up the ABI.  In the meantime we should try
to make sure that new changes doesn't compound the problem.

Another area I've had concerns about is the comparison for equality of the
typeid operator (2.9.3).  There is a statement that doing a straight
address comparison is sufficient for testing equality.  That doesn't always
work when you considered shared libraries.  I am sure one of the python
boost failures for xlC on linux is because the two sides of a comparison
aren't resolving to the same object as you would expect.  I was initially
worried about systems like AIX where runtime symbol resolution wasn't the
norm, but I'm starting to think Linux has the same problem.
--
Sean Perry
Compiler Development
IBM Canada Lab
(905)-413-6031 (tie 313-6031), fax (905)-413-4839



                                                                           
             Mark Mitchell                                                 
             <mark at codesourcer                                             
             y.com>                                                     To 
                                       Sean Perry/Toronto/IBM at IBMCA        
             06/01/09 12:08 PM                                          cc 
                                       cxx-abi-dev at codesourcery.com,       
                                       Dennis Handly <dhandly at cup.hp.com>  
                                                                   Subject 
                                       Re: [cxx-abi-dev] Deleted virtual   
                                       functions                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           




Sean Perry wrote:

> On zSeries (i.e. 390) the linkage for C and C++ are different.
> Identifying all the places and providing solutions to the mixed linkage
> problems in the document is a prereq to implementing the C++ABI in
> zSeries compilers.

If you are going to change the ABI anyhow, would you reconsider this
difference in linkage?  The ABI document defines various C++ things in
terms of their C equivalents; for example, the ABI for a C++ non-static
function member is defined in terms of the ABI for a C function with an
extra parameter for "this".

In any case, if maintaining separate calling conventions for C and C++
is necessary, yes, I think you'll have to go through the document,
identify those places, and propose solutions.  The solutions need to
preserve backwards compatibility, so you may need to introduce some new
APIs that are used only on systems where the linkages do not match up.

--
Mark Mitchell
CodeSourcery
mark at codesourcery.com
(650) 331-3385 x713
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/71445c70/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: graycol.gif
Type: image/gif
Size: 105 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/71445c70/attachment.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: pic13971.gif
Type: image/gif
Size: 1255 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/71445c70/attachment-0001.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ecblank.gif
Type: image/gif
Size: 45 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090601/71445c70/attachment-0002.gif>

From mark at codesourcery.com  Mon Jun  1 21:45:23 2009
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 01 Jun 2009 14:45:23 -0700
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <OFC466A0B4.BAF63D2E-ON852575C8.0067A4F7-852575C8.00768D08@ca.ibm.com>
References: <OFC466A0B4.BAF63D2E-ON852575C8.0067A4F7-852575C8.00768D08@ca.ibm.com>
Message-ID: <4A244BF3.8060501@codesourcery.com>

Sean Perry wrote:

> Another area I've had concerns about is the comparison for equality of
> the typeid operator (2.9.3). There is a statement that doing a straight
> address comparison is sufficient for testing equality.

There's no way to win completely on this issue.  Some people want types
with the same name in different shared libraries to be the same type;
other people don't.  For example, when building plugins, you often want
each shared library to be completely independent; if my plugin's "class
Plugin" is the same as your plugin's "class Plugin", very bad things happen.

The approach in the ABI is, in my opinion, close to optimal.  On a
system like Linux, you can mark things as exported from a shared
library, or not.  If you do, then the dynamic linker can merge the
addresses, and the types are "the same".  If you don't, then they're
not.  The programmer gets to choose.

On other systems (e.g., DLL-based systems) you have no choice but to use
string comparison.  In that case, you'll lose in the plugin case.  Yes,
we could document a variant of the ABI that does string-based comparison
if need be.

-- 
Mark Mitchell
CodeSourcery
mark at codesourcery.com
(650) 331-3385 x713


From dhandly at cup.hp.com  Tue Jun  2 01:30:50 2009
From: dhandly at cup.hp.com (Dennis Handly)
Date: Mon, 1 Jun 2009 18:30:50 -0700 (PDT)
Subject: [cxx-abi-dev] Deleted virtual functions
Message-ID: <200906020130.SAA19461@hpcll183.cup.hp.com>

>From: Sean Perry <perry at ca.ibm.com>
>Another area I've had concerns about is the comparison for equality of the
>typeid operator (2.9.3).  There is a statement that doing a straight
>address comparison is sufficient for testing equality.  That doesn't always
>work when you considered shared libraries.

Yes, we had issues with customers porting and we told them tough, you
must make the symbols visible.  (See Mark's comments.)  We fiddled with
compiler options and made it hard to hide compiler generated class metadata.

>  I am sure one of the python
>boost failures for xlC on linux is because the two sides of a comparison
>aren't resolving to the same object as you would expect.  I was initially
>worried about systems like AIX where runtime symbol resolution wasn't the
>norm
Sean Perry

Of course a big important customer came along and we did this:
_HP_ACC_TI_STRING_COMPARE is always on in our runtime lib.

  bool operator== (const type_info& __arg) const
    { return __name == __arg.__name
#if defined(__ia64) && defined(_HP_ACC_TI_STRING_COMPARE)
      || do_string_compare && strcmp(__name, __arg.__name) == 0
#endif
       ; }

#if defined(__ia64) && defined(_HP_ACC_TI_STRING_COMPARE)
  static int do_string_compare;
#endif

>From: Mark Mitchell <mark at codesourcery.com>
>other people don't.  For example, when building plugins, you often want
>each shared library to be completely independent; if my plugin's "class
>Plugin" is the same as your plugin's "class Plugin", very bad things happen.

They should use lawyers to solve this, not engineers.  ;-)

We had to tell another important customer over and over this violated the
ODR rule.  And our above changes making it hard to hide these classes
caused them issues.  They didn't want to use the mangled name for many
classes.  They finally accepted our reasoning, since other vendors had
to use kludges too.  :-)

>If you do, then the dynamic linker can merge the
>addresses, and the types are "the same".  If you don't, then they're
>not.  The programmer gets to choose.

Right, provided he has enough documentation.

>On other systems (e.g., DLL-based systems) you have no choice but to use
>string comparison.  In that case, you'll lose in the plugin case.
Mark Mitchell

Has anyone reviewed the proposed new standard for C++ and shlibs?

Prem and I provided enough questions in the Hawaii meeting they pulled it.
Future directions in the standard should be thought out for the ABI.


From crowl at google.com  Tue Jun  2 01:55:38 2009
From: crowl at google.com (Lawrence Crowl)
Date: Mon, 1 Jun 2009 18:55:38 -0700
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <200906020130.SAA19461@hpcll183.cup.hp.com>
References: <200906020130.SAA19461@hpcll183.cup.hp.com>
Message-ID: <29bd08b70906011855i67cb7f42p9d8648b21644050d@mail.gmail.com>

On 6/1/09, Dennis Handly <dhandly at cup.hp.com> wrote:
> Has anyone reviewed the proposed new standard for C++ and shlibs?

I have been keeping an eye on the issues, and trying to avoid
making matters worse.  However, there are no good solutions without
language support.  In particular, the language needs to recognize
a layer of scoping between the translation unit and the program.

> Prem and I provided enough questions in the Hawaii meeting they
> pulled it.

Yeah, I was working on that proposal.  I think we did our users
a disservice by abandoning the work.  For those that may not have
seen it, the latest draft paper is here:
http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2425.html
Work on the paper stopped when the committee abandoned the work,
so the paper is rough, has gaps, etc.

The module work would have addressed some of the problems with
dynamic libraries, but it too was dropped from C++0x.

> Future directions in the standard should be thought out for
> the ABI.

I don't follow this comment.  Can you clarify your intent?

-- 
Lawrence Crowl


From dhandly at cup.hp.com  Tue Jun  2 02:21:51 2009
From: dhandly at cup.hp.com (Dennis Handly)
Date: Mon, 1 Jun 2009 19:21:51 -0700 (PDT)
Subject: [cxx-abi-dev] Deleted virtual functions
Message-ID: <200906020221.TAA19937@hpcll183.cup.hp.com>

>From: Lawrence Crowl <crowl at google.com>
>I have been keeping an eye on the issues, and trying to avoid
>making matters worse.  However, there are no good solutions without
>language support.  In particular, the language needs to recognize
>a layer of scoping between the translation unit and the program.

Yes, that was part of it.

>I think we did our users a disservice by abandoning the work.

Don't blame me.  ;-)
I was saying we could do most of it but we would have to work harder
in the runtime.

>> Future directions in the standard should be thought out for the ABI.

>I don't follow this comment.  Can you clarify your intent?
Lawrence Crowl

The issues that Sean and Mark brought up, whether the type_infos (and
dynamic_casts) are the same or not.  Based on their visibility to a
dynamic loader.

I don't know if the questions we raised were in your URL?
http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2425.html


From crowl at google.com  Tue Jun  2 18:41:39 2009
From: crowl at google.com (Lawrence Crowl)
Date: Tue, 2 Jun 2009 11:41:39 -0700
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <200906020221.TAA19937@hpcll183.cup.hp.com>
References: <200906020221.TAA19937@hpcll183.cup.hp.com>
Message-ID: <29bd08b70906021141u5fddd61bube6944beb506939@mail.gmail.com>

On 6/1/09, Dennis Handly <dhandly at cup.hp.com> wrote:
> From: Lawrence Crowl <crowl at google.com>
> > I have been keeping an eye on the issues, and trying to avoid
> > making matters worse.  However, there are no good solutions
> > without language support.  In particular, the language needs
> > to recognize a layer of scoping between the translation unit
> > and the program.
>
> Yes, that was part of it.
>
> > I think we did our users a disservice by abandoning the work.
>
> Don't blame me.  ;-)  I was saying we could do most of it but we
> would have to work harder in the runtime.

I'm not blaming anyone, just expressing frustration.

> > > Future directions in the standard should be thought out for
> > > the ABI.
> >
> > I don't follow this comment.  Can you clarify your intent?
>
> The issues that Sean and Mark brought up, whether the type_infos (and
> dynamic_casts) are the same or not.  Based on their visibility to a
> dynamic loader.
>
> I don't know if the questions we raised were in your URL?
> http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2425.html

In reviewing the paper, not explicitly.  The intent was that
type_infos for protected or private types be distinct between
libraries.  Anything else would lead to unreliable combination
of libraries.

We are a bit off topic here, though.

-- 
Lawrence Crowl


From jason at redhat.com  Tue Jun  2 19:45:15 2009
From: jason at redhat.com (Jason Merrill)
Date: Tue, 02 Jun 2009 15:45:15 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <200906020130.SAA19461@hpcll183.cup.hp.com>
References: <200906020130.SAA19461@hpcll183.cup.hp.com>
Message-ID: <4A25814B.2080404@redhat.com>

Dennis Handly wrote:
>> From: Mark Mitchell <mark at codesourcery.com>
>> other people don't.  For example, when building plugins, you often want
>> each shared library to be completely independent; if my plugin's "class
>> Plugin" is the same as your plugin's "class Plugin", very bad things happen.
> 
> We had to tell another important customer over and over this violated the
> ODR rule.  And our above changes making it hard to hide these classes
> caused them issues.  They didn't want to use the mangled name for many
> classes.  They finally accepted our reasoning, since other vendors had
> to use kludges too.  :-)

Talking about plugins reminds me of a different problem we've run into 
on Linux: you have two plugins A and B that both link against the same 
shared library C.  A and B are loaded with RTLD_LOCAL to avoid symbol 
conflicts.  If there are symbols defined in all three of A B and C, 
references in A and C are bound to the definition in A, while references 
in B are bound to the definition in B.  If the symbol is a typeid, and B 
calls a C function which throws an exception of that type, B can't catch 
it because the symbols don't match.

The same issue can come up with static data in inlines or templates, 
either data members or function local statics; this case can't be worked 
around with string comparison, though it's also less likely to be 
encountered.

I've been talking to Ulrich Drepper about ways to deal with this, and 
we've decided to go ahead with a solution that makes affected objects 
unique through the whole loaded program regardless of RTLD_LOCAL; we 
have namespaces to deal with name collisions.  I'm not sure if we 
actually want to use this for typeinfos, but I don't see a better 
solution for r/w data.

Sorry I didn't mention this to the list sooner.

Jason


From perry at ca.ibm.com  Tue Jun  2 20:49:13 2009
From: perry at ca.ibm.com (Sean Perry)
Date: Tue, 2 Jun 2009 16:49:13 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <4A25814B.2080404@redhat.com>
Message-ID: <OF7C3EF339.2099A264-ON852575C9.0071E1AD-852575C9.00725F9E@ca.ibm.com>


Hey, that sounds exactly like the issue we are having with the
boost/python.  I hadn't reached the point of isolating the problem to
RTLD_LOCAL yet.  If you build two libraries with boost/python and load them
in a python script and try to throw a predefined exception from one of the
two (I forget if it is the first or second), the exception is not caught.

--
Sean Perry
Compiler Development
IBM Canada Lab
(905)-413-6031 (tie 313-6031), fax (905)-413-4839



                                                                           
             Jason Merrill                                                 
             <jason at redhat.com                                             
             >                                                          To 
                                       Dennis Handly <dhandly at cup.hp.com>  
             06/02/2009 03:45                                           cc 
             PM                        mark at codesourcery.com, Sean         
                                       Perry/Toronto/IBM at IBMCA,            
                                       cxx-abi-dev at codesourcery.com        
                                                                   Subject 
                                       Re: [cxx-abi-dev] Deleted virtual   
                                       functions                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           
                                                                           




Dennis Handly wrote:
>> From: Mark Mitchell <mark at codesourcery.com>
>> other people don't.  For example, when building plugins, you often want
>> each shared library to be completely independent; if my plugin's "class
>> Plugin" is the same as your plugin's "class Plugin", very bad things
happen.
>
> We had to tell another important customer over and over this violated the
> ODR rule.  And our above changes making it hard to hide these classes
> caused them issues.  They didn't want to use the mangled name for many
> classes.  They finally accepted our reasoning, since other vendors had
> to use kludges too.  :-)

Talking about plugins reminds me of a different problem we've run into
on Linux: you have two plugins A and B that both link against the same
shared library C.  A and B are loaded with RTLD_LOCAL to avoid symbol
conflicts.  If there are symbols defined in all three of A B and C,
references in A and C are bound to the definition in A, while references
in B are bound to the definition in B.  If the symbol is a typeid, and B
calls a C function which throws an exception of that type, B can't catch
it because the symbols don't match.

The same issue can come up with static data in inlines or templates,
either data members or function local statics; this case can't be worked
around with string comparison, though it's also less likely to be
encountered.

I've been talking to Ulrich Drepper about ways to deal with this, and
we've decided to go ahead with a solution that makes affected objects
unique through the whole loaded program regardless of RTLD_LOCAL; we
have namespaces to deal with name collisions.  I'm not sure if we
actually want to use this for typeinfos, but I don't see a better
solution for r/w data.

Sorry I didn't mention this to the list sooner.

Jason
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090602/f1d82b25/attachment.html>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: graycol.gif
Type: image/gif
Size: 105 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090602/f1d82b25/attachment.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: pic22457.gif
Type: image/gif
Size: 1255 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090602/f1d82b25/attachment-0001.gif>
-------------- next part --------------
A non-text attachment was scrubbed...
Name: ecblank.gif
Type: image/gif
Size: 45 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20090602/f1d82b25/attachment-0002.gif>

From dhandly at cup.hp.com  Wed Jun  3 03:07:59 2009
From: dhandly at cup.hp.com (Dennis Handly)
Date: Tue, 2 Jun 2009 20:07:59 -0700 (PDT)
Subject: [cxx-abi-dev] Deleted virtual functions
Message-ID: <200906030307.UAA25437@hpcll183.cup.hp.com>

>From: Lawrence Crowl <crowl at google.com>
>The intent was that type_infos for protected or private types be
>distinct between libraries.  Anything else would lead to unreliable combination
>of libraries.

Right.  Hopefully I mentioned that to Prem.

>From: Jason Merrill <jason at redhat.com>
>Talking about plugins reminds me of a different problem we've run into 
>on Linux: you have two plugins A and B that both link against the same 
>shared library C.  A and B are loaded with RTLD_LOCAL to avoid symbol 

This should be obvious.  RTLD_LOCAL is another evil linker option that
stabs C++ in the back.  ;-)
They go all the way back to cfront days.

>we've decided to go ahead with a solution that makes affected objects 
>unique through the whole loaded program regardless of RTLD_LOCAL;

How?  If the dynamic loader hides it, how can you make them unique
without some magic global repository of names?

>we have namespaces to deal with name collisions.
Jason

You mean you have lawyers handle it?  ;-)

>From: Sean Perry <perry at ca.ibm.com>
>that sounds exactly like the issue we are having with the
>boost/python.  I hadn't reached the point of isolating the problem to
>RTLD_LOCAL yet.  If you build two libraries with boost/python and load them
>in a python script and try to throw a predefined exception from one of the
>two the exception is not caught.

Yes, we have had customers complaining about not caught or dynamic_casts
not working, with RTLD_LOCAL.  I cringe when I see RTLD_LOCAL.  :-(


From jason at redhat.com  Wed Jun  3 15:45:04 2009
From: jason at redhat.com (Jason Merrill)
Date: Wed, 03 Jun 2009 11:45:04 -0400
Subject: [cxx-abi-dev] Deleted virtual functions
In-Reply-To: <200906030307.UAA25437@hpcll183.cup.hp.com>
References: <200906030307.UAA25437@hpcll183.cup.hp.com>
Message-ID: <4A269A80.70303@redhat.com>

Dennis Handly wrote:
>> we've decided to go ahead with a solution that makes affected objects 
>> unique through the whole loaded program regardless of RTLD_LOCAL;
> 
> How?  If the dynamic loader hides it, how can you make them unique
> without some magic global repository of names?

Well, basically with some magic global repository of names: we are 
changing the dynamic loader to put such symbols to a separate hashtable.

Jason


From daveed at edg.com  Wed Jun  3 20:59:51 2009
From: daveed at edg.com (David Vandevoorde)
Date: Wed, 3 Jun 2009 16:59:51 -0400
Subject: Transfer modes for parameters and return values
Message-ID: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>

Hello again,

In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type  
parameters and class type return values are passed via the address of  
a reference if the class type has
	(a) a nontrivial destructor, or
	(b) a nontrivial copy constructor.

Should we now also add to that:
	(c) a (nontrivial) move constructor
?

(There is currently no notion of "trivial move constructor", but I  
think there are suggestions to introduce that in the future.)

	Daveed



From crowl at google.com  Wed Jun  3 21:23:00 2009
From: crowl at google.com (Lawrence Crowl)
Date: Wed, 3 Jun 2009 14:23:00 -0700
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
Message-ID: <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com>

On 6/3/09, David Vandevoorde <daveed at edg.com> wrote:
> Hello again,
>
>  In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type parameters
> and class type return values are passed via the address of a reference if
> the class type has
>         (a) a nontrivial destructor, or
>         (b) a nontrivial copy constructor.
>
>  Should we now also add to that:
>         (c) a (nontrivial) move constructor
>  ?
>
>  (There is currently no notion of "trivial move constructor", but I think
> there are suggestions to introduce that in the future.)

I'm not sure I can predict the binary consequences of such a notion
until it is actually defined.  So, I would rather wait until then.

-- 
Lawrence Crowl


From jason at redhat.com  Wed Jun  3 21:26:15 2009
From: jason at redhat.com (Jason Merrill)
Date: Wed, 03 Jun 2009 17:26:15 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
Message-ID: <4A26EA77.8030702@redhat.com>

David Vandevoorde wrote:
> Hello again,
> 
> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type 
> parameters and class type return values are passed via the address of a 
> reference if the class type has
>     (a) a nontrivial destructor, or
>     (b) a nontrivial copy constructor.
> 
> Should we now also add to that:
>     (c) a (nontrivial) move constructor
> ?

I'm not sure.  We need to pass by reference in the case of a nontrivial 
copy constructor because it's invalid to do a bitwise copy in that case. 
  We need to do it in the case of a nontrivial destructor so that the 
caller can control when the destructor is run depending on copy elision. 
  Neither of those really applies to the move constructor.

Jason


From daveed at edg.com  Wed Jun  3 22:39:18 2009
From: daveed at edg.com (David Vandevoorde)
Date: Wed, 3 Jun 2009 18:39:18 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <4A26EA77.8030702@redhat.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <4A26EA77.8030702@redhat.com>
Message-ID: <29D6D2F9-5B64-42FA-87C9-CEA7D13E636C@edg.com>


On Jun 3, 2009, at 5:26 PM, Jason Merrill wrote:

> David Vandevoorde wrote:
>> Hello again,
>> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type  
>> parameters and class type return values are passed via the address  
>> of a reference if the class type has
>>    (a) a nontrivial destructor, or
>>    (b) a nontrivial copy constructor.
>> Should we now also add to that:
>>    (c) a (nontrivial) move constructor
>> ?
>
> I'm not sure.  We need to pass by reference in the case of a  
> nontrivial copy constructor because it's invalid to do a bitwise  
> copy in that case.  We need to do it in the case of a nontrivial  
> destructor so that the caller can control when the destructor is run  
> depending on copy elision.  Neither of those really applies to the  
> move constructor.


Consider the following example:

	struct S {
	  S();
	  S(S&&);
	private:
	  S(S const&) = default;    // Trivial copy constructor.
	};

	void f(S);

	int main() {
	  f(S());
	}

My understanding is that the move constructor must be called to pass  
the argument directly to f, and that the trivial copy constructor  
cannot be called as an extra step in that case.  (I.e., although this  
is called "copy initialization", it's really very much like default  
initialization.)

No?

	Daveed



From daveed at edg.com  Wed Jun  3 23:12:33 2009
From: daveed at edg.com (David Vandevoorde)
Date: Wed, 3 Jun 2009 19:12:33 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <29D6D2F9-5B64-42FA-87C9-CEA7D13E636C@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <4A26EA77.8030702@redhat.com> <29D6D2F9-5B64-42FA-87C9-CEA7D13E636C@edg.com>
Message-ID: <91C8B6E4-047E-4146-83C7-6A3F2FFED37B@edg.com>


On Jun 3, 2009, at 6:39 PM, David Vandevoorde wrote:

>
> On Jun 3, 2009, at 5:26 PM, Jason Merrill wrote:
>
>> David Vandevoorde wrote:
>>> Hello again,
>>> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type  
>>> parameters and class type return values are passed via the address  
>>> of a reference if the class type has
>>>   (a) a nontrivial destructor, or
>>>   (b) a nontrivial copy constructor.
>>> Should we now also add to that:
>>>   (c) a (nontrivial) move constructor
>>> ?
>>
>> I'm not sure.  We need to pass by reference in the case of a  
>> nontrivial copy constructor because it's invalid to do a bitwise  
>> copy in that case.  We need to do it in the case of a nontrivial  
>> destructor so that the caller can control when the destructor is  
>> run depending on copy elision.  Neither of those really applies to  
>> the move constructor.
>
>
> Consider the following example:
>
> 	struct S {
> 	  S();
> 	  S(S&&);
> 	private:
> 	  S(S const&) = default;    // Trivial copy constructor.
> 	};
>
> 	void f(S);
>
> 	int main() {
> 	  f(S());
> 	}
>
> My understanding is that the move constructor must be called to pass  
> the argument directly to f, and that the trivial copy constructor  
> cannot be called as an extra step in that case.  (I.e., although  
> this is called "copy initialization", it's really very much like  
> default initialization.)

I meant "...very much like direct initialization.)".

	Daveed


>
> No?
>
> 	Daveed
>



From daveed at edg.com  Wed Jun  3 23:59:20 2009
From: daveed at edg.com (David Vandevoorde)
Date: Wed, 3 Jun 2009 19:59:20 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com>
Message-ID: <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com>


On Jun 3, 2009, at 5:23 PM, Lawrence Crowl wrote:

> On 6/3/09, David Vandevoorde <daveed at edg.com> wrote:
>> Hello again,
>>
>> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type  
>> parameters
>> and class type return values are passed via the address of a  
>> reference if
>> the class type has
>>        (a) a nontrivial destructor, or
>>        (b) a nontrivial copy constructor.
>>
>> Should we now also add to that:
>>        (c) a (nontrivial) move constructor
>> ?
>>
>> (There is currently no notion of "trivial move constructor", but I  
>> think
>> there are suggestions to introduce that in the future.)
>
> I'm not sure I can predict the binary consequences of such a notion
> until it is actually defined.  So, I would rather wait until then.


It doesn't really have to be defined formally: A constructor for class  
X whose first parameter has type
	X cv-quals&&
and whose other parameters have a default argument or are the ellipsis  
parameter.  Such a constructor can be preferred over the trivial copy  
constructor for "rvalue copying" (i.e., moving) purposes.

	Daveed



From crowl at google.com  Thu Jun  4 06:07:46 2009
From: crowl at google.com (Lawrence Crowl)
Date: Wed, 3 Jun 2009 23:07:46 -0700
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
	 <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com>
	 <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com>
Message-ID: <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com>

On Wed, Jun 3, 2009 at 4:59 PM, David Vandevoorde <daveed at edg.com> wrote:
> On Jun 3, 2009, at 5:23 PM, Lawrence Crowl wrote:
>> On 6/3/09, David Vandevoorde <daveed at edg.com> wrote:
>>>
>>> Hello again,
>>>
>>> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type
>>> parameters
>>> and class type return values are passed via the address of a reference if
>>> the class type has
>>> ? ? ? (a) a nontrivial destructor, or
>>> ? ? ? (b) a nontrivial copy constructor.
>>>
>>> Should we now also add to that:
>>> ? ? ? (c) a (nontrivial) move constructor
>>> ?
>>>
>>> (There is currently no notion of "trivial move constructor", but I think
>>> there are suggestions to introduce that in the future.)
>>
>> I'm not sure I can predict the binary consequences of such a notion
>> until it is actually defined. ?So, I would rather wait until then.
>
> It doesn't really have to be defined formally: A constructor for class X
> whose first parameter has type
> ? ? ? ?X cv-quals&&
> and whose other parameters have a default argument or are the ellipsis
> parameter. ?Such a constructor can be preferred over the trivial copy
> constructor for "rvalue copying" (i.e., moving) purposes.

I think I am confused.  I have two comments, and I don't know which
applies.

Since we don't know what a 'trivial' move constructor is, how do we know
how it might be implemented, and therefore whether it affects the ABI?

The choice of constructor isn't part of the ABI, but of the semantics of
the program.  Once the semantics are picked, the ABI keeps it stable, so
I don't see how any preference for the move constructor would require
us to modify how we represent parameters for copy construction.

-- 
Lawrence Crowl


From daveed at edg.com  Thu Jun  4 15:05:49 2009
From: daveed at edg.com (David Vandevoorde)
Date: Thu, 4 Jun 2009 11:05:49 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com> <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com> <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com>
Message-ID: <5976EE10-A642-4E16-AE92-2DDBAF6C659B@edg.com>


On Jun 4, 2009, at 2:07 AM, Lawrence Crowl wrote:

> On Wed, Jun 3, 2009 at 4:59 PM, David Vandevoorde <daveed at edg.com>  
> wrote:
>> On Jun 3, 2009, at 5:23 PM, Lawrence Crowl wrote:
>>> On 6/3/09, David Vandevoorde <daveed at edg.com> wrote:
>>>>
>>>> Hello again,
>>>>
>>>> In 3.1.1 and 3.1.4, the ABI specifies that "by value" class type
>>>> parameters
>>>> and class type return values are passed via the address of a  
>>>> reference if
>>>> the class type has
>>>>       (a) a nontrivial destructor, or
>>>>       (b) a nontrivial copy constructor.
>>>>
>>>> Should we now also add to that:
>>>>       (c) a (nontrivial) move constructor
>>>> ?
>>>>
>>>> (There is currently no notion of "trivial move constructor", but  
>>>> I think
>>>> there are suggestions to introduce that in the future.)
>>>
>>> I'm not sure I can predict the binary consequences of such a notion
>>> until it is actually defined.  So, I would rather wait until then.
>>
>> It doesn't really have to be defined formally: A constructor for  
>> class X
>> whose first parameter has type
>>        X cv-quals&&
>> and whose other parameters have a default argument or are the  
>> ellipsis
>> parameter.  Such a constructor can be preferred over the trivial copy
>> constructor for "rvalue copying" (i.e., moving) purposes.
>
> I think I am confused.  I have two comments, and I don't know which
> applies.
>
> Since we don't know what a 'trivial' move constructor is, how do we  
> know
> how it might be implemented, and therefore whether it affects the ABI?
>
> The choice of constructor isn't part of the ABI, but of the  
> semantics of
> the program.  Once the semantics are picked, the ABI keeps it  
> stable, so
> I don't see how any preference for the move constructor would require
> us to modify how we represent parameters for copy construction.


Let me address the second comment first.  The language rules have a  
consequence for the ABI.  A user-provided move constructor can do  
things with the "this" pointer, and that means that the object moved  
to (the one pointed to by "this") must be in memory, not in  
registers.  However, right now, the criterion for passing the argument  
in memory instead of (potentially) in registers, is based solely on  
the nature of the destructor and copy constructors.

Regarding your first comment, I'm postulating that if "trivial move  
constructor" were introduced it would imply that such a constructor  
could be implemented as a bitwise move (i.e., via register transfer).

Note that if I'm correct, there is already a bug in the ABI because a  
class like:

	struct S {
	  S(int);
	};
	void f(S);

today is passed "by trivial copy" in the function f (according to the  
ABI).  However, my understanding is that in

	int main() {
	  f(3);
	}

no copy constructor should be called (even "conceptually") for the  
argument transfer (i.e., despite it being a "copy initialization" it  
behaves like a "direct initialization).  Unfortunately, that's not  
possible with the ABI.  In practice, I think all implementations  
instead do the following:
	- initialize a temporary with "S tmp(3);"
	- bitwise copy the temporary to the parameter variable of f

Now consider the following completion of the code above:

        #include <assert.h>

         S *p;

         S::S(int) { p = this; }

         void f(S x) {
           assert(&x == p);
         }

I _think_ that program is supposed to terminate normally (according to  
the language rules), but with real implementations the assertion fails.

We cannot fix the ABI if that's indeed a bug, but we can avoid it for  
classes with user-provided "move constructors" (since they didn't  
previously exist).  Also, I have this vague sense that it is more  
important for such cases: Ordinarily, one doesn't play "this-pointer  
games" such as those in the program above with converting  
constructors, but with move constructors perhaps that might be more  
frequent.

	Daveed



From jason at redhat.com  Thu Jun  4 21:34:15 2009
From: jason at redhat.com (Jason Merrill)
Date: Thu, 04 Jun 2009 17:34:15 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <5976EE10-A642-4E16-AE92-2DDBAF6C659B@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com> <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com> <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com> <5976EE10-A642-4E16-AE92-2DDBAF6C659B@edg.com>
Message-ID: <4A283DD7.5020809@redhat.com>

David Vandevoorde wrote:
> Note that if I'm correct, there is already a bug in the ABI because a 
> class like:
> 
>     struct S {
>       S(int);
>     };
>     void f(S);
> 
> today is passed "by trivial copy" in the function f (according to the 
> ABI).  However, my understanding is that in
> 
>     int main() {
>       f(3);
>     }
> 
> no copy constructor should be called (even "conceptually") for the 
> argument transfer (i.e., despite it being a "copy initialization" it 
> behaves like a "direct initialization).

No.  To copy-initialize the parameter of f, we first convert 3 to S 
using the constructor, then construct the parameter using that temporary 
S as an argument, which invokes the (trivial) copy constructor.

However, I think you are right about your earlier move constructor 
example: since the argument S() has type S already, we don't do the 
two-step initialization, so we can't do a (trivial) copy afterward.

This line of reasoning also applies to any other constructor which can 
be called with an argument of the that class or a derived class, but I 
think before rvalue references it was impossible to write an alternative 
constructor which would ever be preferred over the implicitly declared 
copy constructor for an argument of that class type.

So now I think we do need your suggested change.

Jason


From daveed at edg.com  Fri Jun  5 00:49:42 2009
From: daveed at edg.com (David Vandevoorde)
Date: Thu, 4 Jun 2009 20:49:42 -0400
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <4A283DD7.5020809@redhat.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com> <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com> <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com> <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com> <5976EE10-A642-4E16-AE92-2DDBAF6C659B@edg.com> <4A283DD7.5020809@redhat.com>
Message-ID: <7BEF0CC8-EFDA-4196-BDEB-46ADC929D69A@edg.com>


On Jun 4, 2009, at 5:34 PM, Jason Merrill wrote:

> David Vandevoorde wrote:
>> Note that if I'm correct, there is already a bug in the ABI because  
>> a class like:
>>    struct S {
>>      S(int);
>>    };
>>    void f(S);
>> today is passed "by trivial copy" in the function f (according to  
>> the ABI).  However, my understanding is that in
>>    int main() {
>>      f(3);
>>    }
>> no copy constructor should be called (even "conceptually") for the  
>> argument transfer (i.e., despite it being a "copy initialization"  
>> it behaves like a "direct initialization).
>
> No.  To copy-initialize the parameter of f, we first convert 3 to S  
> using the constructor, then construct the parameter using that  
> temporary S as an argument, which invokes the (trivial) copy  
> constructor.
>
> However, I think you are right about your earlier move constructor  
> example: since the argument S() has type S already, we don't do the  
> two-step initialization, so we can't do a (trivial) copy afterward.


Ah yes, that's right.

> This line of reasoning also applies to any other constructor which  
> can be called with an argument of the that class or a derived class,  
> but I think before rvalue references it was impossible to write an  
> alternative constructor which would ever be preferred over the  
> implicitly declared copy constructor for an argument of that class  
> type.


How about:

	struct D;
	struct B {
	  B(D&);
	};
	struct D: B {} d;
	void f(B);
	int main() {
	  f(d);
	}

I think this exercise the "derived class" case, and so if I understand  
correctly it requires a direct-initialization-like approach for B.   
However, since B has a trivial copy constructor, the transfer mode of  
f(B) doesn't allow for that.

(I think that's contrived enough that even if this shows an ABI bug it  
doesn't require a fix per se.)

>
> So now I think we do need your suggested change.


Thanks.  I'll try to write that up too.  Some other ideas in this area  
have occurred to me and I'll bring them up on the WG21 reflector.  It  
may be that the outcome of that affects the ABI spec.

	Daveed



From crowl at google.com  Mon Jun  8 17:01:12 2009
From: crowl at google.com (Lawrence Crowl)
Date: Mon, 8 Jun 2009 10:01:12 -0700
Subject: [cxx-abi-dev] Transfer modes for parameters and return values
In-Reply-To: <7BEF0CC8-EFDA-4196-BDEB-46ADC929D69A@edg.com>
References: <12821666-AC74-48C0-9599-F91ED9099093@edg.com>
	 <29bd08b70906031423q7336790q1a9b9fe2eb406b0@mail.gmail.com>
	 <6C3260CC-B8E3-4DEB-A7A2-660B202E08C4@edg.com>
	 <29bd08b70906032307m620cdd99n55d909677991557b@mail.gmail.com>
	 <5976EE10-A642-4E16-AE92-2DDBAF6C659B@edg.com>
	 <4A283DD7.5020809@redhat.com>
	 <7BEF0CC8-EFDA-4196-BDEB-46ADC929D69A@edg.com>
Message-ID: <29bd08b70906081001r3864a44x411252bf3188c35b@mail.gmail.com>

On Thu, Jun 4, 2009 at 5:49 PM, David Vandevoorde<daveed at edg.com> wrote:
> Some other ideas in this area have occurred to me and I'll bring them
> up on the WG21 reflector. ?It may be that the outcome of that affects
> the ABI spec.

Which was my concern.  Defining the ABI for that which doesn't yet
exist seems premature.  :-)

-- 
Lawrence Crowl


From daveed at edg.com  Mon Jun 22 18:56:56 2009
From: daveed at edg.com (David Vandevoorde)
Date: Mon, 22 Jun 2009 14:56:56 -0400
Subject: Local name discriminators
Message-ID: <B6D0FCB5-86A0-4543-AEF7-A65E47389A62@edg.com>

5.1.6 "Scope Encoding" has this to say (among other things):

> Occasionally entities in local scopes must be mangled too (e.g.  
> because inlining or template compilation causes multiple translation  
> units to require access to that entity). The encoding for such  
> entities is as follows:
>
> <local-name> := Z <function encoding> E <entity name>  
> [<discriminator>]
>             := Z <function encoding> E s [<discriminator>]
> <discriminator> := _ <non-negative number>
> The first production is used for named local static objects and  
> classes, which are identified by their declared names. The <entity  
> name> may itself be a compound name, but it is relative to the  
> closest enclosing function, i.e. none of the components of the  
> function encoding appear in the entity name.

This seems to suggest that the first production doesn't apply to  
member functions of local classes, nor to local enumeration types.

I assume that's unintentional since the next sentence says:

> It is possible to have nested function scopes, e.g. when dealing  
> with a member function in a local class. In such cases, the function  
> encoding will itself have <local-name> structure.

and the other production of <local-name> doesn't apply at all.

Now consider the following example:

	void x() {
	  { struct X {}; }
	  struct X {
	    void foo() { foo(); } // #1
	  } x1;
	  x1.foo();
	  { struct X {
	      void foo() { foo(); }  // #2
	    } x2;
	    x2.foo();
	  }
	}

g++ produces the following mangled names for the X::foo members:

	_ZZ1xvEN1X3fooE_0v  for #1
	_ZZ1xvEN1X3fooE_1v  for #2


Note that both have discriminators, for which the spec says:
> The discriminator is used only for the second and later occurrences  
> of the same name within a single function. In this case <number> is  
> n - 2, if this is the nth occurrence, in lexical order, of the given  
> name.

The "same name" here is X::foo and #1 is the first occurrence (no  
discriminator needed) while #2 is the second occurrence (disciminator  
value 0).  So I would've expected instead:

	_ZZ1xvEN1X3fooEv    for #1
	_ZZ1xvEN1X3fooE_0v  for #2

Is this correct?

(EDG has a different interpretation:

	_ZZ1xvEN1X_03fooEv  for #1

	_ZZ1xvEN1X_13fooEv  for #2

but that's a bug too.)


We could change the spec to ensure that g++'s approach is  
"standard" (assuming that I understand what g++ really does here).   
I.e., we could specify that the "discriminator" discriminates the "top- 
level component" of colliding local names.  I think that would be  
sufficient.


Now consider a different example:

	class C {} c;

	inline int g() {
	  { struct X {}; }
	  { struct X {}; }
	  struct X {} x;
	  struct Y { int f(X x, C c) { return f(x, c); }; } y;
	  return y.f(x, c) + g();
	};

	int main() {
	  return g();
	}

(bad recursion written as a quick hack to force compilers to spill the  
inline functions).


The mangling for g()::Y::f is

	ZZ1gvEN1Y1fEZ1gvE1X_11C
	                   ^^^

The problem here is that there is no delimiter after the discriminator  
"_1" to separate it from the "1" that indicates the length of the  
class name "C".  So this cannot in general be demangled.  (Such  
situations become more common in C++0x where local classes can be  
template arguments.)

Addressing this requires a change that is technically ABI breakage,  
but I think we can do it so that real-world programs are highly  
unlikely to break by saying that a <discriminator> is "_<n>" for <n>  
<= 9 (that's unchanged), but "__<n>_" when <n> >= 10 (I assume here  
that <n> >= 10 doesn't happen in real programs).

Any thoughts?

	Daveed


P.S.: There are related issues with unnamed local classes in C++0x,  
but I plan to address those along with closure types in a separate  
proposal.



