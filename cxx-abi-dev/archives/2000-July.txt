From mark at codesourcery.com  Sun Jul  2 16:56:21 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 02 Jul 2000 09:56:21 -0700
Subject: Covariant returns
Message-ID: <20000702095621D.mitchell@codesourcery.com>


Although the closed issues list discusses covariant returns, the ABI
document itself does not.  It looks like we agreed on providing
alternate entry points for non-trivial covariant returns.  In that
case, we need to specify the order in the vtabe in which such entries
appear.  Since we also provide a copy of a virtual function in the
primary vtable when a derived class orverrides a virtual function from
a secondary base, we need to know whether to make copies of all the
entry points, or just the one with the same signature as that provided
in the derived class.  There also need to be vcall offsets for all of
the covariant returns.  Other issues?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 07:09:11 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 00:09:11 -0700 (PDT)
Subject: VTT example
References: <20000627170232F.mitchell@codesourcery.com>
Message-ID: <200007050709.AAA15561@baalbek.engr.sgi.com>

I've fixed the explanation...

> However, the reason is not that V1 is
> primary; the reason is that V! has no virtual bases.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 08:09:31 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 01:09:31 -0700 (PDT)
Subject: error in VTT example
Message-ID: <200007050809.BAA15801@baalbek.engr.sgi.com>

> Date: Thu, 29 Jun 2000 11:11:11 -0700 (PDT)
> From: Alex Samuel <samuel at codesourcery.com>
> 
> There is I believe an error in the VTT example presented in section
> 2.6.2.  
> 
> The order of secondary virtual pointers is stated as inheritance graph
> preorder.  Primary non-virtual bases are omitted.  Therefore I believe
> the order of the secondary vptrs in the in example VTT should be V1,
> C2, V2 (as opposed to C2, V2, V1 as shown in entries [5], [6], and
> [7]).  Though C1 is skipped because it's a primary base, the preorder
> traversal has to continue to its children (or else in other
> inheritance graphs some base classes will be missed completely).
> Therefore you get to V1 via C1 before hitting C2.
> 
> It might make sense to clarify this in 2.6.2, item 3, with language
> something like,
> 
>     The order of the virtual pointers is inheritance graph preorder.
>     Though primary non-virtual bases do not get secondary virtual
>     pointers, they do not otherwise affect the ordering.

This is fixed.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 08:18:31 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 01:18:31 -0700 (PDT)
Subject: Pure virtual functions
Message-ID: <200007050818.BAA14411@baalbek.engr.sgi.com>

> Subject: Pure virtual functions
> From: Mark Mitchell <mark at codesourcery.com>
> 
> We need to have a standard entry point to put in vtables to indicate a
> pure virtual function.  (Some compilers use __pure_virtual, for
> example.)  I think we want:
> 
>   extern "C" void __cxa_pure_virtual ();
> 
> Assuming there's no objection, let's just add this to the document for
> review at the next meeting.

Issue B-10

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 08:28:00 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 01:28:00 -0700 (PDT)
Subject: Subobject constructors
Message-ID: <200007050828.BAA15826@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> The wording in 3.3 about subobject constructors is misleading:
> 
>   If the not-in-charge constructor calls constructors for base class
>   subobjects that do not need construction vtables, the construction
>   vtable parameter is not passed to the base class subobject
>   constructor, and the base class subobject constructors use their
>   complete object vtables for initialization.
> 
> This is also true when an in-charge constructor is making the call.
> There is never a need to pass a VTT to a base class subobject that
> doesn't have virtual bases.

See if it looks better now...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 08:48:02 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 01:48:02 -0700 (PDT)
Subject: Covariant returns
Message-ID: <200007050848.BAA15863@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> Although the closed issues list discusses covariant returns, the ABI
> document itself does not.  It looks like we agreed on providing
> alternate entry points for non-trivial covariant returns.

Added a clause in 2.5.2 Category 2.

> In that
> case, we need to specify the order in the vtable in which such entries
> appear.

The same place where it would appear if it weren't overriding.  Is
there a specific place where the comment is required?

> Since we also provide a copy of a virtual function in the
> primary vtable when a derived class orverrides a virtual function from
> a secondary base, we need to know whether to make copies of all the
> entry points, or just the one with the same signature as that provided
> in the derived class.

Both.  See the addition to 2.5.2 Category 2.

> There also need to be vcall offsets for all of the covariant returns.

Added a clause in 2.5.2 Category 3.

> Other issues?

Anyone think of any?  Please look at my additions...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 08:53:41 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 01:53:41 -0700 (PDT)
Subject: Meeting reminder
Message-ID: <200007050853.BAA15891@baalbek.engr.sgi.com>

There will be a meeting Thursday at 10, as usual.  The HTML files are
updated.  The PDF files will be updated tomorrow (well, today), and I'll
send an agenda.

Jim
-		Jim Dehnert  x3-4272



From jason at redhat.com  Wed Jul  5 01:09:47 2000
From: jason at redhat.com (Jason Merrill)
Date: 04 Jul 2000 21:09:47 -0400
Subject: Covariant returns
In-Reply-To: Mark Mitchell's message of "Sun, 02 Jul 2000 09:56:21 -0700"
References: <20000702095621D.mitchell@codesourcery.com>
Message-ID: <u9zonxwffo.fsf@casey.soma.redhat.com>

Mark Mitchell <mark at codesourcery.com> writes:

> Although the closed issues list discusses covariant returns, the ABI
> document itself does not.  It looks like we agreed on providing
> alternate entry points for non-trivial covariant returns.  In that
> case, we need to specify the order in the vtable in which such entries
> appear.

I don't think we do.  The only case where we would need an additional
entry point would be when the function is coming from a secondary
vtable.  But we are already promoting vtable entries from secondary
vtables into primary vtables; that entry should point to the covariant
return entry point.

No, I take it back.  If the return types are not simply pointers to
the classes in which the functions are defined, but some other
pair of related types, then we might need a return adjustment in a
case where we wouldn't need a 'this' adjustment.

In that case, I would suggest just adding the new entry at the end of
the vtable, just as if the function were new.

> Since we also provide a copy of a virtual function in the primary
> vtable when a derived class overrides a virtual function from a
> secondary base, we need to know whether to make copies of all the
> entry points, or just the one with the same signature as that
> provided in the derived class.

Each class type should have exactly one entry point for a particular
virtual function.  In the case mentioned above, we might have two
entry points in the primary vtable, but one would only be referred to
through a pointer to the base type.

> There also need to be vcall offsets for all of the covariant
> returns.

Why would we need anything that we wouldn't already need for functions
without covariant returns?

Jason



From mark at codesourcery.com  Wed Jul  5 16:43:11 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jul 2000 09:43:11 -0700
Subject: Subobject constructors
In-Reply-To: <200007050828.BAA15826@baalbek.engr.sgi.com>
References: <200007050828.BAA15826@baalbek.engr.sgi.com>
Message-ID: <20000705094311E.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> See if it looks better now...

Yes, thanks!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed Jul  5 16:49:57 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jul 2000 09:49:57 -0700
Subject: Covariant returns
In-Reply-To: <u9zonxwffo.fsf@casey.soma.redhat.com>
References: <20000702095621D.mitchell@codesourcery.com>
	<u9zonxwffo.fsf@casey.soma.redhat.com>
Message-ID: <20000705094957K.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at redhat.com> writes:

    >> There also need to be vcall offsets for all of the covariant
    >> returns.

    Jason> Why would we need anything that we wouldn't already need
    Jason> for functions without covariant returns?

I didn't mean to imply that -- just that we would have to treat
covariant returns just like ordinary functions.  The present language
didn't make that clear.

In other words, when we read the document we are meant to think of the
various covariant returns as different functions -- but that's not the
way an ordinary human would likely read it.  An ordinary human would
think that the overriding function is just one function, not N where N
is the number of covariant returns. :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed Jul  5 16:41:25 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jul 2000 09:41:25 -0700
Subject: VTT example
In-Reply-To: <200007050709.AAA15561@baalbek.engr.sgi.com>
References: <20000627170232F.mitchell@codesourcery.com>
	<200007050709.AAA15561@baalbek.engr.sgi.com>
Message-ID: <20000705094125R.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I've fixed the explanation...

    >> However, the reason is not that V1 is primary; the reason is
    >> that V! has no virtual bases.

Thanks!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at cygnus.com  Wed Jul  5 19:46:20 2000
From: jason at cygnus.com (Jason Merrill)
Date: 05 Jul 2000 12:46:20 -0700
Subject: Covariant returns
In-Reply-To: Mark Mitchell's message of "Wed, 05 Jul 2000 09:49:57 -0700"
References: <20000702095621D.mitchell@codesourcery.com> <u9zonxwffo.fsf@casey.soma.redhat.com> <20000705094957K.mitchell@codesourcery.com>
Message-ID: <u9zonwcqcz.fsf@decepticon.cygnus.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

>>>>> "Jason" == Jason Merrill <jason at redhat.com> writes:
 >>> There also need to be vcall offsets for all of the covariant
 >>> returns.

 Jason> Why would we need anything that we wouldn't already need
 Jason> for functions without covariant returns?

 > I didn't mean to imply that -- just that we would have to treat
 > covariant returns just like ordinary functions.  The present language
 > didn't make that clear.

 > In other words, when we read the document we are meant to think of the
 > various covariant returns as different functions

That's what I'm disagreeing with.  Why would we need to do so?

 > An ordinary human would think that the overriding function is just one
 > function, not N where N is the number of covariant returns. :-)

And so would I.  :)

Jason



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 21:23:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 14:23:40 -0700 (PDT)
Subject: Covariant returns
References: <20000702095621D.mitchell@codesourcery.com>
Message-ID: <200007052123.OAA01520@baalbek.engr.sgi.com>

Let me try introducing some concreteness into this discussion.  I
think I've figured out the source of confusion, but then maybe I've
just become confused...

Suppose we have:

	class A { ... };
	class B: public A { ... };

	class V {
		...
		virtual A* f ();
		...
	};
	class W: virtual public V {
		...
		virtual B* f ();
		...
	};

	W *w;
	V *v = w;

Suppose initially that no bases are primary.  (And check my example
before you believe anything...)

Now, if I call w->f(), I get the basic W::f, with no adjustments.
This is what should happen if I use the "normal" entry for f in the W
vtable.

If I call v->f(), it's more complicated.  I get a thunk which (a)
adjusts v to a W*, (b) calls W::f, and (c) adjusts the resulting B*
back to an A*.  This is what should happen if I use the "normal" entry
for f in the V-in-W secondary vtable.

So far, so good.  The W vtable contains the overriding W::f vptr.
The V-in-W secondary vtable contains the thunk vptr.  Nothing special
for the covariant return types, except that the thunk is messier.
I note, as an aside so far, that if W did not override V::f, we would
have a "promoted" vptr for it in the W vtable to make it easier to
call.  But that has nothing to do with covariant return types either.

Next, suppose V is the primary base of W.  Now they share a vtable, and
therefore an f vptr.  If the f's had the same return type, there would
be no adjustments to be made, and that f vptr could just point to the
overriding W::f.  But because they have covariant return types, v->f()
must still adjust on return, so the "shared" vptr must do that, and W's
vtable needs to have another entry for the "normal" W::f vptr.  What we
decided before (issue B-2), and what seems to have started Mark down
this discussion path, is that we will have two such entries whether or
not a caller could figure out the necessary adjustment (B* to A*, I
presume), though I don't know how it could be possible in general if he
is calling v->f().

(My thoughts went down a dark alley at this point.  Even if the return
types were the same, if X is derived from V and W in such a way that V
is no longer primary in the W subobject, then V::f and W::f would need
different adjustments and therefore distinct entries.  So I thought
briefly that this required two entries in the W vtable.  But if V and W
are split in this way, the main entry in the W-in-X vtable is no longer
shared with the V-in-X vtable, so this was a red herring.)

Finally, suppose we have:

	class X: virtual public W {
	  ...
	};

Now, we specify that the vptrs from W get promoted to the X vtable.
That presumably means both of them in the case at hand.  Correct?
I'm guessing that this was Mark's original point.  Correct?  Am I
missing anything that Jason or Mark was trying to point out? Screwing
it up?  Where precisely do we need to say more in the draft?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 23:07:54 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 16:07:54 -0700 (PDT)
Subject: rtti
Message-ID: <200007052307.QAA02124@baalbek.engr.sgi.com>

> Date: Mon, 12 Jun 2000 22:27:56 +0100
> From: Nathan Sidwell <nathan at codesourcery.com>
> 
> Here's G++'s cxxabi.h and related files for comments, and my findings
> about action item 37. For those unfamiliar with gcc's runtime layout
> here's what the files contain
> 
> typeinfo	class type_info declaration
> cxxabi.h	the abi's support type_info classes and prototypes
> vec.cc		the abi's vector new and delete helpers
> tinfo.h		runtime header for tinfo.cc & tinfo2.cc
> tinfo.cc	dynamic cast and catch matching routines
> tinfo2.cc	abi's non-class type_info definitions
> 
> the latter 3 files contain a big #if for gcc's old and new abis. for the
> new abi __GXX_ABI_VERSION will be 100. Also, gcc doesn't provide <cstddef>
> (but it's part of the library), so std::size_t, std::ptrdiff_t aren't
> available in the header files, hence the use of __SIZE_TYPE__ and
> __PTRDIFF_TYPE__ in header files.

I've added these files to the web site, referenced from the summary
page.  We may want to clean out the non-ABI parts at some point and
reference them from the draft ABI (as non-normative examples).

> 1) The class definitions in cxxabi.h have inconsistent names for the data
> members. In some cases each field is prefixed with the shortened class
> name (for instance __vmi_class_type_info::vmi_offset_flags), in other
> cases the abi doc doesn't specify a name, and there is no prefix (eg
> __pbase_type_info:::quals). My preference is for non-prefixed names,
> as that is a more usual in C++ (after all, we've had structure scope
> for a long time). We should use a consistent naming scheme, and I'd
> prefer it to be the non-prefixed form.

I've put this on the agenda for tomorrow.  If we have concensus to do
this, we'll need someone to go through carefully and identify all the
changes.  Or maybe we can do it at the meeting...

> 2) As to the usefulness of __vmi_class_type_info::non_public_base_mask
> and __vmi_class_type_info::public_base_mask. It transpired that neither
> were useful. there were two places where public_base_mask might be used,
> but I suspect that to be premature optimization. non_public_base_mask
> turned out to not be useful. In all cases of considering a non-public
> base, one already knew the base was non-public, and the
> non_diamond_repeat_mask and diamond_shaped_mask were useful. Therefore,
> in resolution of item 37 I propose removing both non_public_base_mask
> and public_base_mask from the vmi_flags.

Also on the agenda for tomorrow.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Jul  5 23:25:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Jul 2000 16:25:47 -0700 (PDT)
Subject: Agenda for 6 July meeting
Message-ID: <200007052325.QAA02287@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web (HTML now, PDF later) at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

-- (Nothing substantive, just clarification)

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.

  1) C-15:  Alternate vector allocator/deallocator routine support.

  2) C-16:  Runtime for copy constructors.

  3) D-17:  Runtime for bad_cast, bad_typeid.

  4) B-10:  Runtime for pure virtual functions.

  5) Should the vector allocator/deallocator/constructor/destructor
     runtime routines be extern "C"?  (Allows platform-independent
     calls other than from C++.)  Similarly dynamic_cast.

  6) Promoting covariant return vptrs from virtual base vtables.

  7) Remove __vmi_class_type_info::non_public_base_mask and
     __vmi_class_type_info::public_base_mask?  (See Nathan's mail
     of 12 June).

  8) Consistent naming for type_info data members (see Nathan's mail
     of 12 June).

  9) Mangling grammar modifications (see Alex Samuel's mail).

 10) C-2:  Priority for constructors.  I think the base ABI group has
     agreed to assign us a section type for this.  I'll try to get it
     pinned down in the next meeting (Monday).

Refresh your memory of the following for the next meeting (20 July):

  1) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

Please also give some thought to what else (not on our lists) ought to
be considered at this point.

Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Thu Jul  6 02:23:09 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jul 2000 19:23:09 -0700
Subject: Covariant returns
In-Reply-To: <u9zonwcqcz.fsf@decepticon.cygnus.com>
References: <u9zonxwffo.fsf@casey.soma.redhat.com>
	<20000705094957K.mitchell@codesourcery.com>
	<u9zonwcqcz.fsf@decepticon.cygnus.com>
Message-ID: <20000705192309T.mitchell@codesourcery.com>

>>>>> "Jason" == Jason Merrill <jason at cygnus.com> writes:

    >> In other words, when we read the document we are meant to think
    >> of the various covariant returns as different functions

    Jason> That's what I'm disagreeing with.  Why would we need to do
    Jason> so?

Well we need two entry points, right?  And there's no discussion of
covariant routines in vtable layout, etc.  So, we need to say
*something* about where that entry point goes.  I think we want to say
that when you already have `Base* Base::f()' and you override it with
`Derived* Derived::f' you treat that as if the user wrote `Base*
Derived::f' and also `Derived* Derived::fprime', i.e., override the
old entry and add a new one, in the place where fprime's entry would
otherwise go.

I don't think I'm saying anything remotely deep -- just that the spec
didn't say anything at all. :-)

    >> An ordinary human would think that the overriding function is
    >> just one function, not N where N is the number of covariant
    >> returns. :-)

    Jason> And so would I.  :)

No, no -- you're an *extraordinary* human...

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Thu Jul  6 02:29:00 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Jul 2000 19:29:00 -0700
Subject: Covariant returns
In-Reply-To: <200007052123.OAA01520@baalbek.engr.sgi.com>
References: <20000702095621D.mitchell@codesourcery.com>
	<200007052123.OAA01520@baalbek.engr.sgi.com>
Message-ID: <20000705192900H.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> Now, we specify that the vptrs from W get promoted to the X
    Jim> vtable.  That presumably means both of them in the case at
    Jim> hand.  Correct?  I'm guessing that this was Mark's original
    Jim> point.  Correct?  Am I missing anything that Jason or Mark
    Jim> was trying to point out? Screwing it up?  Where precisely do
    Jim> we need to say more in the draft?

I think you've highlighted all the issues.  And your proposed answers
sound right to me, FWIW. :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ravi.narayanaswamy at intel.com  Thu Jul  6 16:58:45 2000
From: ravi.narayanaswamy at intel.com (Narayanaswamy, Ravi)
Date: Thu, 6 Jul 2000 09:58:45 -0700 
Subject: unwind section
Message-ID: <4575832C8E71D111AC4100A0C96B512706660626@fmsmsx36.fm.intel.com>

Could someone tell me how can I get the beginning of 
unwind section at run time in C++ program.  Is there any symbol that 
identifies the beginning and end of this section?

Ravi
Intel Corporation




From ddd at cup.hp.com  Thu Jul  6 17:47:54 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 06 Jul 2000 17:47:54 +0000
Subject: unwind section
References: <4575832C8E71D111AC4100A0C96B512706660626@fmsmsx36.fm.intel.com>
Message-ID: <3964C64A.6662D865@cup.hp.com>

"Narayanaswamy, Ravi" wrote:
> 
> Could someone tell me how can I get the beginning of
> unwind section at run time in C++ program.  Is there any symbol that
> identifies the beginning and end of this section?
> 
What we currently do is:

- for static builds, there is a special symbol

- for dynamic builds, we ask our dynamic loader to find the unwind section for a
given load module (from the IP)


This is invoked by the (low level) unwind library for the target system, which
uses a private interface to dld. We discussed it during the meetings, and it
seemed OK to have this private interface under the hood.


Regards
Christophe



From jason at cygnus.com  Thu Jul  6 17:47:00 2000
From: jason at cygnus.com (Jason Merrill)
Date: 06 Jul 2000 10:47:00 -0700
Subject: Covariant returns
In-Reply-To: Jim Dehnert's message of "Wed, 5 Jul 2000 14:23:40 -0700 (PDT)"
References: <20000702095621D.mitchell@codesourcery.com> <200007052123.OAA01520@baalbek.engr.sgi.com>
Message-ID: <u9itujcfsb.fsf@decepticon.cygnus.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 > Suppose we have:

 > 	class A { ... };
 > 	class B: public A { ... };

 > 	class V {
 > 		...
 > 		virtual A* f ();
 > 		...
 > 	};
 > 	class W: virtual public V {
 > 		...
 > 		virtual B* f ();
 > 		...
 > 	};

 > 	W *w;
 > 	V *v = w;

 > Suppose initially that no bases are primary.  (And check my example
 > before you believe anything...)

 > Now, if I call w->f(), I get the basic W::f, with no adjustments.
 > This is what should happen if I use the "normal" entry for f in the W
 > vtable.

Yes.

 > If I call v->f(), it's more complicated.  I get a thunk which (a)
 > adjusts v to a W*, (b) calls W::f, and (c) adjusts the resulting B*
 > back to an A*.  This is what should happen if I use the "normal" entry
 > for f in the V-in-W secondary vtable.

Yes.

 > So far, so good.  The W vtable contains the overriding W::f vptr.
 > The V-in-W secondary vtable contains the thunk vptr.  Nothing special
 > for the covariant return types, except that the thunk is messier.

Yes.  I thought that Mark was suggesting that the W vtable in this case
would have two entries for f; that's what I was disagreeing with.

 > I note, as an aside so far, that if W did not override V::f, we would
 > have a "promoted" vptr for it in the W vtable to make it easier to
 > call.  But that has nothing to do with covariant return types either.

Yes.

 > Next, suppose V is the primary base of W.  Now they share a vtable, and
 > therefore an f vptr.  If the f's had the same return type, there would
 > be no adjustments to be made, and that f vptr could just point to the
 > overriding W::f.  But because they have covariant return types, v->f()
 > must still adjust on return, so the "shared" vptr must do that, and W's
 > vtable needs to have another entry for the "normal" W::f vptr.

Yes, we will have two entries in the primary vtable.  One is logically part
of the V-in-W vtable, one is logically part of the W vtable.

 > Finally, suppose we have:

 > 	class X: virtual public W {
 > 	  ...
 > 	};

 > Now, we specify that the vptrs from W get promoted to the X vtable.
 > That presumably means both of them in the case at hand.  Correct?

I disagree with this, too.  Only the W copy should be promoted.  The V copy
is only called through a V*, so there's no reason to promote it.

Each class' vtable only needs one entry per function, regardless of
covariant returns.  The only exception comes from the case where two
classes share a vtable, but that exception is only physical; the logical
rule stands.

Jason



From dehnert at baalbek.engr.sgi.com  Thu Jul  6 21:09:25 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 6 Jul 2000 14:09:25 -0700 (PDT)
Subject: Notes from the meeting
Message-ID: <200007062109.OAA05188@baalbek.engr.sgi.com>

>From today's (6 July) meeting agenda:

1-4) Mark's runtime proposals were all accepted.  I will incorporate
     them in the draft, and close the issues except where non-cursory
     review seems desirable.

  5) The vector allocator/deallocator runtimes will be extern "C".

  6) Covariant returns.  It is the concensus that further wording is
     required.  I agree with Jason's latest mail on the subject.
     Could Jason and Mark please attempt to identify where comments
     are required?  (I will too, but...)

  7) I will remove the extra flags from __vmi_class_type_info.

  8) I will attempt a more consistent renaming of the type_info data
     members, without prefixes.

  9) We generally accepted Alex's proposed mangling grammar modifications,
     with a couple of minor changes that will appear in the draft.

     There is one significant problem, related to covariant return
     types.  When the overridden function is defined in the primary
     base class of the class defining the overriding function, they
     require the same 'this' adjustment, which is what is used for our
     mangling, but differ in their result adjustments.  We concluded
     that we needed to include the result adjustments in the mangling.

     Upon further thought, though, I don't think this is needed.  The
     two functions have different definitions, with different
     hierarchical names.  The result adjustment is determined by which
     function is called and where it is called from, and there
     shouldn't be an opportunity to confuse them.

     Am I missing something?

Also, on Alex's request, we revisited the issue of thread-safe one-time
initialization.  We agreed that, if there's to be any hope of
interoperability of compilers supporting it, they need the same API for
handling the guard variable.

The proposed solution is to strongly suggest that implementors who
hope ever to support this call a routine:

	extern "C" int __cxx_gv_test_and_set ( long long *gv );

The routine returns "true" to only one caller, and "false" to all
others after the first has released the lock.  We neglected to note
that the release also needs specification.  How about:

	extern "C" void __cxx_gv_release ( long long *gv );

Comments?

Next meeting 20 July.

Jim

-		Jim Dehnert  x3-4272



From ddd at cup.hp.com  Thu Jul  6 22:01:48 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 06 Jul 2000 22:01:48 +0000
Subject: Notes from the meeting
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
Message-ID: <396501CC.DFC06E55@cup.hp.com>

Jim Dehnert wrote:
> 
> Also, on Alex's request, we revisited the issue of thread-safe one-time
> initialization.  We agreed that, if there's to be any hope of
> interoperability of compilers supporting it, they need the same API for
> handling the guard variable.
> 
> The proposed solution is to strongly suggest that implementors who
> hope ever to support this call a routine:
> 
>         extern "C" int __cxx_gv_test_and_set ( long long *gv );
> 
> The routine returns "true" to only one caller, and "false" to all
> others after the first has released the lock.  We neglected to note
> that the release also needs specification.  How about:
> 
>         extern "C" void __cxx_gv_release ( long long *gv );
> 

The current HP implementation does not use a release, and has a more specialized
routine. This would be something like:

	extern "C" void __cxa_allocate_static(
		bool *flag,
		void *object_address,
		void (*object_dtor)(void *object));

The calling sequence for:

	static X x

becomes:

	static bool static_x_flag;
	static X x;
	if (!static_x_flag)
		__cxa_allocate_static(&static_x_flag,
				      &x, __addressof(X::~X));

This has the following benefits:

1/ If the static has been initialized already, the flag is set, so we
short-circuit the function call

2/ The function registers the object and its destructor for invokation at exit()
time.


The function itself deals with the flag in a thread-safe way, but this requires
only one mutex inside the function. This is important, since test and set
operations are potentially costly memorywise on IA64 (they are definitely on
PA-RISC, where any mutex / lock / whatever must be 16-bytes aligned)


Regards
Christophe



From loewis at informatik.hu-berlin.de  Thu Jul  6 22:37:25 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 7 Jul 2000 00:37:25 +0200 (MET DST)
Subject: Notes from the meeting
In-Reply-To: <200007062109.OAA05188@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Thu, 6 Jul 2000 14:09:25 -0700 (PDT))
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
Message-ID: <200007062237.AAA23954@pandora.informatik.hu-berlin.de>

>      Upon further thought, though, I don't think this is needed.  The
>      two functions have different definitions, with different
>      hierarchical names.  The result adjustment is determined by which
>      function is called and where it is called from, and there
>      shouldn't be an opportunity to confuse them.
> 
>      Am I missing something?

I think so, yes. What do you mean by "hierarchical names"? Consider

struct A{};struct B:primary,A{};

struct Base{
  virtual A* func(int);  // _ZN4Base4funcEi
};

struct Derived:Base{
  B* func(int);
};

Now, _ZN7Derived4funcEi refers to - what? In the vtable of Derived,
you have two slots - what symbols do you put in there?

The obvious solution would be to have

  _ZN7Derived4funcEP1Ai  // A* Derived::func(int)
  _ZN7Derived4funcEP1Bi  // B* Derived::func(int)

However, that won't work, because e.g. the first one is confused with

  Ret? Derived::func(A*, int)

and the same confusion arises for the second one. Was there any
concrete proposal in the meeting?

If not, here is a strawman proposal: Markup a return type, so you can
tell whether a type in the parameter list is the first parameter or
the return type:

  <return type> ::= _ <type>

With that, we'd get

  _ZN4Base4funcEi         // Ret? Base::func(int)
  _ZN7Derived4funcE_P1Ai  // A* Derived::func(int)
  _ZN7Derived4funcE_P1Bi  // B* Derived::func(int)

Regards,
Martin



From mark at codesourcery.com  Thu Jul  6 23:45:13 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 06 Jul 2000 16:45:13 -0700
Subject: Notes from the meeting
In-Reply-To: <200007062109.OAA05188@baalbek.engr.sgi.com>
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
Message-ID: <20000706164513A.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> 	extern "C" int __cxx_gv_test_and_set ( long long *gv
    Jim> );

    Jim> The routine returns "true" to only one caller, and "false" to
    Jim> all others after the first has released the lock.  We
    Jim> neglected to note that the release also needs specification.
    Jim> How about:

    Jim> 	extern "C" void __cxx_gv_release ( long long *gv );

    Jim> Comments?

I suggest a simpler interface, and make it mandatory:

  extern "C" int __cxx_gv_set_guard_variable (long long *gv);

This function returns true if the caller is the first to call the
function; false otherwise.  The right code to generate would be:

  if (/* low-order byte of guard variable not already set*
      && __cxx_gv_set_guard_variable (&gv)) {
    // Do initialization
  }

This causes you to take the hit of the function call only the first
time through, except that if multiple threads reach this point all at
once the first time, several of them may call the function.  (A
correct compiler can skip the test, but not the call, at the cost of
more function calls) So, the function itself must be thread safe, if
it cares.

A non-thread-safe implementation is:

  int __cxx_gv_set_guard_variable (long long* gv) {
    if (*((char*) gv) == 0) {
      *((char*) gv) = 1;
      return 1;
    } else
      return 0;
  } 

A thread-safe implementation is something like:

  int __cxx_gv_set_guard_variable (long long* gv) {
    static mutex m;			 
    int result;

    lock(m);
    if (*((char*) gv) == 0) {
      *((char*) gv) = 1;
      result = 1;
    } else 
      result = 0;
    unlock(m);
    return result;
  } 

Does that make sense?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Thu Jul  6 23:55:17 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 6 Jul 2000 16:55:17 -0700 (PDT)
Subject: Notes from the meeting
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
Message-ID: <200007062355.QAA05489@baalbek.engr.sgi.com>

> From loewis at informatik.hu-berlin.de Thu Jul  6 15:37:50 2000
> 
> >      Upon further thought, though, I don't think this is needed.  The
> >      two functions have different definitions, with different
> >      hierarchical names.  The result adjustment is determined by which
> >      function is called and where it is called from, and there
> >      shouldn't be an opportunity to confuse them.
> > 
> >      Am I missing something?
> 
> I think so, yes. What do you mean by "hierarchical names"? Consider
> 
> struct A{};struct B:primary,A{};
> 
> struct Base{
>   virtual A* func(int);  // _ZN4Base4funcEi
> };
> 
> struct Derived:Base{
>   B* func(int);
> };
> 
> Now, _ZN7Derived4funcEi refers to - what? In the vtable of Derived,
> you have two slots - what symbols do you put in there?

Well, you're right that I was a bit confused.
Let me try to work through it.

The two slots in the Derived vtable are the shared slot with the Base
vtable, and the unshared one at the end.  In the unshared one goes the
unadorned Derived::func pointer:

	_ZN7Derived4funcEP7Derivedi

(except that the second 7Derived gets substituted).

In the shared slot goes what a Base caller expects to see, which is a
thunk that converts 'this' to Derived, calls Derived::func, and
converts the result back to an A*.  It would be named, by our current
convention:

	_ZTh0_N7Derived4funcEP7Derivedi

This encodes the 'this' adjustment (0) and the target function name.
It works (is distinguishable), but only because the thunk prefix is
there.  So if we add another level of derivation, again as a primary
base, we have a problem.  So I was wrong... (but you knew that
already).

> The obvious solution would be to have
> 
>   _ZN7Derived4funcEP1Ai  // A* Derived::func(int)
>   _ZN7Derived4funcEP1Bi  // B* Derived::func(int)
> 
> However, that won't work, because e.g. the first one is confused with
> 
>   Ret? Derived::func(A*, int)
> 
> and the same confusion arises for the second one.

It isn't really a problem, because you only need to do it for the thunk
names, and we could add the rule that covariant return thunk names,
identified by a different special prefix, encode the result type.

> Was there any
> concrete proposal in the meeting?

Yes.  Observing that the offset encoding is likely shorter than the
return type name, we would encode covariant return thunk names with
the return type adjustment information.  We had agreed to new prefixes
Tc and Td, analogous to Th and Tv, but it occurs to me that the return
type adjustment is independent of the call adjustment, so I suggest the
following:

  Tch <static this adjust>_ <static result adjust>_ <base function>
  Tcv <static this adjust>_ <vcall offset for this adjust>_ \
	<static result adjust>_ <base function>
  Tdh <static this adjust>_ <static result adjust>_ \
	<vbase offset for result adjust>_ <base function>
  Tdv <static this adjust>_ <vcall offset for this adjust>_ \
	<static result adjust>_ <vbase offset for result adjust>_ \
	<base function>

For Tch/Tdh, the static result adjust (a number) is added to the
result pointer in the thunk (to convert B* to A* in our example),
when A is a non-virtual base of B.

For Tcv/Tdv, the vbase pointer at offset given, in B, is added to
the result pointer B* to get the virtual base of B containing A, and
then the static result adjust is added to that to get A*.

Does this match what people thought at the meeting?  Does it sound OK,
Martin?

Regards,
Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Fri Jul  7 00:11:58 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 6 Jul 2000 17:11:58 -0700 (PDT)
Subject: Notes from the meeting
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
Message-ID: <200007070011.RAA05191@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> >>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>     Jim> 	extern "C" int __cxx_gv_test_and_set ( long long *gv
>     Jim> );
> 
>     Jim> The routine returns "true" to only one caller, and "false" to
>     Jim> all others after the first has released the lock.  We
>     Jim> neglected to note that the release also needs specification.
>     Jim> How about:
> 
>     Jim> 	extern "C" void __cxx_gv_release ( long long *gv );
> 
>     Jim> Comments?
> 
> I suggest a simpler interface, and make it mandatory:
> 
>   extern "C" int __cxx_gv_set_guard_variable (long long *gv);
> 
> This function returns true if the caller is the first to call the
> function; false otherwise.  The right code to generate would be:
> 
>   if (/* low-order byte of guard variable not already set*
>       && __cxx_gv_set_guard_variable (&gv)) {
>     // Do initialization
>   }
> 
> This causes you to take the hit of the function call only the first
> time through, except that if multiple threads reach this point all at
> once the first time, several of them may call the function.  (A
> correct compiler can skip the test, but not the call, at the cost of
> more function calls) So, the function itself must be thread safe, if
> it cares.

This is all fine, except that the threads that get here after the first
one, but before it has initialized the object, must wait until the
initialization is complete before proceeding.  That means that they
can't return from __cxx_gv_set_guard_variable (&gv) until the
initialization is done, and the initialization must be completed before
setting the low-order byte of the guard variable.  To accomplish this,
the first thread must have a way of signalling its completion, e.g.:

  if (/* low-order byte of guard variable not already set*
      && __cxx_gv_set_guard_variable (&gv)) {
    // Do initialization
    ...
    __cxx_gv_release (&gv);
  }

and __cxx_gv_set_guard_variable for the non-first waits for the lock
release by the first before returning for the others.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Fri Jul  7 00:22:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 06 Jul 2000 17:22:58 -0700
Subject: Notes from the meeting
In-Reply-To: <200007070011.RAA05191@baalbek.engr.sgi.com>
References: <200007062109.OAA05188@baalbek.engr.sgi.com>
	<200007070011.RAA05191@baalbek.engr.sgi.com>
Message-ID: <20000706172258Y.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> This is all fine, except that the threads that get here after
    Jim> the first one, but before it has initialized the object, must
    Jim> wait until the initialization is complete before proceeding.
    Jim> That means that they can't return from
    Jim> __cxx_gv_set_guard_variable (&gv) until the initialization is
    Jim> done, and the initialization must be completed before setting
    Jim> the low-order byte of the guard variable.  To accomplish
    Jim> this, the first thread must have a way of signalling its
    Jim> completion, e.g.:

Good point!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Fri Jul  7 07:33:23 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 7 Jul 2000 09:33:23 +0200 (MET DST)
Subject: Mangling (Was: Notes from the meeting)
In-Reply-To: <200007062355.QAA05489@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Thu, 6 Jul 2000 16:55:17 -0700 (PDT))
References: <200007062109.OAA05188@baalbek.engr.sgi.com> <200007062355.QAA05489@baalbek.engr.sgi.com>
Message-ID: <200007070733.JAA24587@pandora.informatik.hu-berlin.de>

> Does this match what people thought at the meeting?  Does it sound OK,
> Martin?

That should work. Just as a clarification: Under your proposal, you'd
always had to encode a 'this' adjustment in a covariant return case,
even if none would be needed, right? So in my example, it would be
_ZTch0_12_N7Derived4funcEi (provided the adjustment from B* to A* was
12).

>	_ZN7Derived4funcEP7Derivedi
>
> (except that the second 7Derived gets substituted).

However, this remark is confusing: Where in the document does it say
that the 'this' parameter appears in the mangling? I was under the
impression that the implicit argument of a method is not mangled. If
we can agree that this was the intent, I'd appreciate if that is
clarified in the text. If not, I'd like an issue to be added.

Regards,
Martin




From dehnert at baalbek.engr.sgi.com  Sat Jul  8 02:49:27 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Jul 2000 19:49:27 -0700 (PDT)
Subject: Document updates
Message-ID: <200007080249.TAA03409@baalbek.engr.sgi.com>

I've updated the web pages for most of what happened yesterday,
with the exception of type_info naming and mangling, and new issues.

In particular, the new runtime APIs are there -- please check them
out (especially Mark as the proposer) and let me know of any problems.
I'll close those issues once they're verified.

I also went through the virtual table construction (2.5.3) very
carefully, making changes as required for covariant returns, as
well as fixing a number of inconsistencies.  If those implementing
this could please go through it very carefully as well, you'll
probably catch further errors and save us some trouble later.

Other than that, as usual, check the red text.

I expect to be pretty busy next week, but will try to finish the
missing stuff.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Jul 18 05:49:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 17 Jul 2000 22:49:13 -0700 (PDT)
Subject: Updates and reminder
Message-ID: <200007180549.WAA34879@baalbek.engr.sgi.com>

I've updated the HTML for the draft ABI.  Except for some minor issue
updates in the open list, I think I've got everything from last meeting.
There are some significant, non-straightforward changes, so it would be
very helpful if people took a hard look at the red text.

We will have a meeting Thursday at 10:00 PDT.  I'll get an agenda,
updated open issues, and PDF out in the next couple of days.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Jul 18 05:51:27 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 17 Jul 2000 22:51:27 -0700 (PDT)
Subject: PS
Message-ID: <200007180551.WAA34637@baalbek.engr.sgi.com>

I haven't carefully looked at the mangling examples for quite a while.
It would be very helpful if someone would, both for correctness (some
things like special names have changed) and to construct new examples
of constructs not covered...

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu Jul 20 01:46:55 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 19 Jul 2000 18:46:55 -0700 (PDT)
Subject: Agenda for tomorrow
Message-ID: <200007200146.SAA02845@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web (HTML and PDF) at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

-- (Quite a bit -- see the revisions list at the top)

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.

  1) C-15:  Are the alternate vector allocator/deallocator routines OK?
  2) C-16:  Is the runtime for copy constructors OK?
  3) D-17:  Is the runtime for bad_cast, bad_typeid OK?
  4) B-10:  Is the runtime for pure virtual functions OK?

  5) Promoting covariant return vptrs from virtual base vtables.
     I think I've got this written up now.  Is it OK?

  6) Consistent naming for type_info data members (see Nathan's mail
     of 12 June).  I think I've got this written up now.  Is it OK?

  7) Mangling grammar modifications (see Alex Samuel's mail).
     I think I've got this written up now.  Is it OK?

  8) C-2:  Priority for constructors.  The base ABI group has
     agreed to assign us a section type for this.  I believe it is
     SHT_IA_64_PRIORITY_INIT = 0x79000000 (that is, that's what I've
     proposed, and haven't heard any complaints).

  9) G-4:  Thread-safe data initialization.  See 3.3.2.  Observe that
     Christophe has suggested a more completely contained routine
     that also handles destructor registration.

 10) C-13:  Allocating constructors.

 11) C-17:  Uncatch exception runtime.

 12) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

Please also give some thought to what else (not on our lists) ought to
be considered at this point.

Jim

-		Jim Dehnert  x3-4272



From austern at research.att.com  Thu Jul 20 17:05:28 2000
From: austern at research.att.com (Matthew Austern)
Date: Thu, 20 Jul 2000 10:05:28 -0700
Subject: meeting reminder
Message-ID: <39773158.9CBEB2BA@research.att.com>

The ABI meeting is at 10:00 today.  *Please note* that the phone
number has changed.  The new number is 650-933-7949.

			--Matt



From ddd at cup.hp.com  Thu Jul 20 18:05:41 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 20 Jul 2000 18:05:41 +0000
Subject: Need for __uncatch_exception
Message-ID: <39773F75.1A9269E8@cup.hp.com>

Mark,


I proposed we close C-17 on the basis that __uncatch_exception is an "internal"
routine to lib++ or whatever the support library is, and is never used in
compiler-generated code.

Please ask Jim to reopen the case if there is a case I did not think of.


Regards
Christophe



From mark at codesourcery.com  Fri Jul 21 06:14:33 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 20 Jul 2000 23:14:33 -0700
Subject: Need for __uncatch_exception
In-Reply-To: <39773F75.1A9269E8@cup.hp.com>
References: <39773F75.1A9269E8@cup.hp.com>
Message-ID: <20000720231433Q.mitchell@codesourcery.com>

>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:

    Christophe> I proposed we close C-17 on the basis that
    Christophe> __uncatch_exception is an "internal" routine to lib++
    Christophe> or whatever the support library is, and is never used
    Christophe> in compiler-generated code.

I don't believe I opened this issue, but that's possible.

This function is called from compiler-generated code.  It's called
whenever a rethrow occurs.  In fact, this issue turns out to be bigger
than just __uncatch_exception.  It looks like g++ calls a function
called "__cp_push_exception" right before it throws an exception; then
it calls some more basic "throw" function.  In the case of a rethrow,
it calls "__uncatch_exception" right before the call to the throw
function.

Note that this is not at all what is described in the
exception-handling document.  Then again that document is not at all
finished.  It doesn't say much about the Level 2 or Level 3
exception-handling stuff.  I don't think there's presently enough
there to implement.

I haven't looked much at the exception-handling stuff because we are
not presently planning on doing these bits.  My understanding is that
Red Hat is doing that work under contract from Intel.  It looks like
only the basic personality routine stuff is complete in GCC; it does
not look like any C++-specific stuff is done.  (That's unsurprising
given that the spec doesn't look finished.)

I'm somewhat distressed.  It looks to me like this is still pretty
well wide open.  In practice, I know of three compilers that will be
using the g++ runtime, relatively unchanged.  That means that I think
we should probably considering standardizing its behavior, and perhaps
rationalizing its naming choices, etc., but not making radical changes
to its existing interface.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From ddd at cup.hp.com  Fri Jul 21 17:03:02 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 21 Jul 2000 17:03:02 +0000
Subject: Need for __uncatch_exception
References: <39773F75.1A9269E8@cup.hp.com> <20000720231433Q.mitchell@codesourcery.com>
Message-ID: <39788246.BC6CD35C@cup.hp.com>

Mark Mitchell wrote:
> 
> >>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:
> 
>     Christophe> I proposed we close C-17 on the basis that
>     Christophe> __uncatch_exception is an "internal" routine to lib++
>     Christophe> or whatever the support library is, and is never used
>     Christophe> in compiler-generated code.
> 
> Note that this is not at all what is described in the
> exception-handling document.  Then again that document is not at all
> finished.  It doesn't say much about the Level 2 or Level 3
> exception-handling stuff.  I don't think there's presently enough
> there to implement.

Which document are you talking about? The page Jim has written, or the HP
runtime document. I believe you have to read both to get the complete picture.

> (That's unsurprising
> given that the spec doesn't look finished.)

To me, the spec is finished and was actually implemented at HP. We used
different names at the time, and I haven't finished converting it to the new
names, but short of that. Also, I sent out a while ago the source code for the
C++ specific part.

In our implementation, there is no need for __uncatch_exception in compiler
generated code. There is a need for a special __rethrow entry point (sorry,
__cxa_rethrow). Rather than using __uncatch_exception, we set a special bit on
the exception, but the result should be similar.


Regards
Christophe



From mark at codesourcery.com  Fri Jul 21 17:13:32 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 21 Jul 2000 10:13:32 -0700
Subject: Need for __uncatch_exception
In-Reply-To: <39788246.BC6CD35C@cup.hp.com>
References: <39773F75.1A9269E8@cup.hp.com>
	<20000720231433Q.mitchell@codesourcery.com>
	<39788246.BC6CD35C@cup.hp.com>
Message-ID: <20000721101332A.mitchell@codesourcery.com>

>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:

    Christophe> To me, the spec is finished and was actually
    Christophe> implemented at HP. We used different names at the

I did not realize that the HP document was part of the proposed spec.
I'll look at that.

    Christophe> In our implementation, there is no need for
    Christophe> __uncatch_exception in compiler generated code. There
    Christophe> is a need for a special __rethrow entry point (sorry,
    Christophe> __cxa_rethrow). Rather than using __uncatch_exception,
    Christophe> we set a special bit on the exception, but the result
    Christophe> should be similar.

Right, that's similar.  GCC's uncatch_exception does a little more,
but I'm not sure exactly what.  It looks like it will pop several
exceptions off the stack, if necessary, but I'm not sure why that's
needed.  Jason?

Also, Jason, what are Red Hat's plans, if any, for implementing the HP
proposal?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Fri Jul 21 18:18:21 2000
From: jason at redhat.com (Jason Merrill)
Date: 21 Jul 2000 11:18:21 -0700
Subject: Need for __uncatch_exception
In-Reply-To: Mark Mitchell's message of "Fri, 21 Jul 2000 10:13:32 -0700"
References: <39773F75.1A9269E8@cup.hp.com> <20000720231433Q.mitchell@codesourcery.com> <39788246.BC6CD35C@cup.hp.com> <20000721101332A.mitchell@codesourcery.com>
Message-ID: <u9aefbwdn6.fsf@yorick.soma.redhat.com>

>>>>> Mark Mitchell <mark at codesourcery.com> writes:

>>>>> "Christophe" == Christophe de Dinechin <ddd at cup.hp.com> writes:
 Christophe> To me, the spec is finished and was actually
 Christophe> implemented at HP. We used different names at the

 > I did not realize that the HP document was part of the proposed spec.
 > I'll look at that.

 Christophe> In our implementation, there is no need for
 Christophe> __uncatch_exception in compiler generated code. There
 Christophe> is a need for a special __rethrow entry point (sorry,
 Christophe> __cxa_rethrow). Rather than using __uncatch_exception,
 Christophe> we set a special bit on the exception, but the result
 Christophe> should be similar.

 > Right, that's similar.  GCC's uncatch_exception does a little more,
 > but I'm not sure exactly what.  It looks like it will pop several
 > exceptions off the stack, if necessary, but I'm not sure why that's
 > needed.  Jason?

__uncatch_exception recently became more complicated to properly handle
rethrowing in the presence of other active exceptions.  It isn't popping
anything, just looking further down for a caught exception and moving it to
the top of the stack.

The HP proposal avoids this complexity by not putting active exceptions on
the exception stack, and has other advantages.

 > Also, Jason, what are Red Hat's plans, if any, for implementing the HP
 > proposal?

No immediate plans, though it sounds like Intel may pay us to do so.  SGI
had talked about doing some of the support library, but I don't know how
that's coming along.

Jason



From dehnert at baalbek.engr.sgi.com  Fri Jul 21 19:42:30 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 21 Jul 2000 12:42:30 -0700 (PDT)
Subject: Need for __uncatch_exception
References: <39773F75.1A9269E8@cup.hp.com>
Message-ID: <200007211942.MAA07843@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> Note that this is not at all what is described in the
> exception-handling document.  Then again that document is not at all
> finished.  It doesn't say much about the Level 2 or Level 3
> exception-handling stuff.  I don't think there's presently enough
> there to implement.
> 
> I'm somewhat distressed.  It looks to me like this is still pretty
> well wide open.  In practice, I know of three compilers that will be
> using the g++ runtime, relatively unchanged.  That means that I think
> we should probably considering standardizing its behavior, and perhaps
> rationalizing its naming choices, etc., but not making radical changes
> to its existing interface.

As I think Christophe has tried to explain, this is a misleading
view of the current state of affairs.  The group has agreed to
accept the HP proposal, linked from the main status page, as the
Level II specification.  The confusion arises because that document
contains much more than that, including Level I material now in the
psABI, and Level III material.  This is partially my fault -- I have
volunteered to separate all this into the C++ ABI document, but haven't
yet had time to do so.  But in any case, I believe that we have an
agreed-upon (and fairly complete) standard, subject to the inevitable
details that will arise as it gets written down and compared to
implementations.

I will try harder to get this drafting done, but if anyone else cares
to tackle it, I won't object.

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Jul 25 00:02:29 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 24 Jul 2000 17:02:29 -0700 (PDT)
Subject: New issue -- returning aggregates
Message-ID: <200007250002.RAA19895@baalbek.engr.sgi.com>

I just noticed that the IA-64 psABI requires returning large aggregates
(over 256 bits except for some floating point ones) via a buffer
allocated by the caller and passed in r8.  We have specified in the C++
ABI that class results with non-trivial copy constructors be returned
in a buffer allocated by the caller and passed as an implicit first
parameter (i.e. in out0, not in r8).  I suggest that we make these two
cases consistent, i.e. pass the buffer address in r8 instead of out0.
(This would not affect non-IA-64 compilers.)

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Sat Jul 29 04:23:43 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 28 Jul 2000 21:23:43 -0700 (PDT)
Subject: Updated status pages
Message-ID: <200007290423.VAA35056@baalbek.engr.sgi.com>


I've updated the HTML status pages.  Take a particular look at the
writeup of Priority for constructors, section 3.3.4.4; I filled in some
holes when writing it, so it bears close inspection.

Also, please think over the one-time, multi-threaded initialization
some more.  I think Christophe was going to send us a more complete
description of HP's implementation?

Nathan, have you had a chance to look at the RTTI structure
definitions? And Alex was going to go over the mangling examples.

Remember the meeting, Thursday at 10.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Sat Jul 29 05:10:00 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 28 Jul 2000 22:10:00 -0700 (PDT)
Subject: TAKE -- July 20 meeting updates to C++ ABI
Message-ID: <200007290510.WAA35410@baalbek.engr.sgi.com>


Fri Jul 28 22:09:55 PDT 2000
The following file(s) were checked into tiler.engr:/isms/osprey.src/osprey1.0

owebpages/Design/ABI/cxxABI/abi-mangling.html - 1.9
	- Removed C4. 
owebpages/Design/ABI/cxxABI/abi.html - 1.8
	- Updates from 20 July meeting. Added section on controlling object
	  construction order (3.3.4). 
owebpages/Design/ABI/cxxABI/cxx-closed.html - 1.33
	- Closed C-15, C-16. 
owebpages/Design/ABI/cxxABI/cxx-open.html - 1.52
	- Closed C-15, C-16. Tabled C-17. Additions to C-2. 
owebpages/Design/ABI/cxxABI/cxx-summary.html - 1.59
	- Closed C-15, C-16. 




From samuel at codesourcery.com  Sat Jul 29 05:21:08 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Fri, 28 Jul 2000 22:21:08 -0700 (PDT)
Subject: Updated status pages
In-Reply-To: <200007290423.VAA35056@baalbek.engr.sgi.com>
References: <200007290423.VAA35056@baalbek.engr.sgi.com>
Message-ID: <14722.27076.733608.726717@watercress.indetermi.net>

Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

  Jim> And Alex was going to go over the mangling examples.

OK, sorry about the delay getting this out.  I've marked those that
are different than what's in the spec with an asterisk.  Someone,
please look these over!  Thanks.

  f                             C function or variable "f" 
  _Z1fv                         Ret? f() or Ret? f(void) 
  _Z1fi                         Ret? f(int) 
  _Z3foo3bar                    Ret? foo(bar) 
  _Zrm1XS_                      Ret? operator%(X, X) 
  _ZplR1XS0_                    Ret? operator+(X&, X&) 
  _ZlsRK1XS1_                   Ret? operator<< (X const&, X const&) 
  _ZN3FooIA4_iE3barE            Type? Foo<int[4]>::bar; 
  _Z1fIiEvi                     void f<int>(/*nondependent*/int) 
* _Z5firstI3DuoEvS0_            void first<Duo>(/*nondependent*/Duo) 
  _Z5firstI3DuoEvT_             void first<Duo>(/*T1=*/Duo) 
  _Z3fooIiPFidEiEvv             void foo<int,int(*)(double),int>() 
  _ZN1N1fE                      Type? N::f 
  _ZN6System5Sound4beepEv       Ret? System::Sound::beep() 
  _ZN5Arena5levelE              Type? Arena::level; 
  _ZN5StackIiiE5levelE          Type? Stack<int, int>::level; 
  _Z1fI1XE vPV N1AIT_E1TE       void f<X>(A</*T1=*/X>::T volatile*) 
  _ZngILi42EEvN1AIXplT_Li2EEE1TE
                                void operator-</*int J=*/42>(A<J+2>::T) 
* _Z4makeI7FactoryiET_IT0_E     Factory</*T2=*/int> make<Factory, int>()    
  _Z3foo 5Hello5WorldS0_S_      void foo(Hello,World,World,Hello) 
  _Z3fooPM2ABi                  foo(int AB::**) 
  _ZlsRSoRKSs                   operator<< (std::ostream&,std::string const&) 
* _ZTI7a_class                  typeid(class a_class) 

Regards
Alex



From mark at codesourcery.com  Sat Jul 29 20:05:19 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 29 Jul 2000 13:05:19 -0700
Subject: Indirect primary bases
Message-ID: <20000729130519K.mitchell@codesourcery.com>


Why do we ever pick an indirect primary base as a primary base?

That doesn't save space in the object since the primary base we choose
was some other base's primary base.  Furthermore, we now have to
replicate that bases vtable entries in all the places where it is a
primary base.

What's the benefit?

If we can't think of one, I would suggest removing the last clause of:

  Otherwise, it is a nearly empty virtual base class, the first one in
  (preorder) inheritance graph order which is not an indirect primary
  base class if any exist, or just the first one if they are all
  indirect primaries.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



