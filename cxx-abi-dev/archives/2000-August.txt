From dehnert at baalbek.engr.sgi.com  Tue Aug  1 03:13:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 31 Jul 2000 20:13:35 -0700 (PDT)
Subject: Indirect primary bases
Message-ID: <200008010313.UAA02753@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> Why do we ever pick an indirect primary base as a primary base?
> 
> That doesn't save space in the object since the primary base we choose
> was some other base's primary base.  Furthermore, we now have to
> replicate that bases vtable entries in all the places where it is a
> primary base.
> 
> What's the benefit?

Well, first, its vtable is now at the same address as that of the
derived class, and won't need a distinct vtable pointer load.  Also,
calls to its virtual functions won't require 'this' adjustments.
If I'm mistaken about these, or if you don't think they're adequate
benefits, we can open the issue.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Tue Aug  1 03:40:18 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 31 Jul 2000 20:40:18 -0700
Subject: Indirect primary bases
In-Reply-To: <200008010313.UAA02753@baalbek.engr.sgi.com>
References: <200008010313.UAA02753@baalbek.engr.sgi.com>
Message-ID: <20000731204018P.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    >> From: Mark Mitchell <mark at codesourcery.com>
    >> 
    >> Why do we ever pick an indirect primary base as a primary base?
    >> 
    >> That doesn't save space in the object since the primary base we
    >> choose was some other base's primary base.  Furthermore, we now
    >> have to replicate that bases vtable entries in all the places
    >> where it is a primary base.
    >> 
    >> What's the benefit?

    Jim> Well, first, its vtable is now at the same address as that of
    Jim> the derived class, and won't need a distinct vtable pointer
    Jim> load.  Also, calls to its virtual functions won't require
    Jim> 'this' adjustments.  If I'm mistaken about these, or if you
    Jim> don't think they're adequate benefits, we can open the issue.

No, I buy it.  Let's put a note in the ABI document, though.  I think
it's much easier for people to understand this stuff if there's some
rationale present.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Aug  1 23:26:55 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Aug 2000 16:26:55 -0700 (PDT)
Subject: Agenda for Thursday 3 August
Message-ID: <200008012326.QAA05415@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web (HTML and PDF) at:

      http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

WARNING:  The next meeting (not this one) will likely have a different
phone number and building/conference room.  Look for it in the contact
info page if I forget to emphasize it.

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

  -- Added writeup of initialization priority in 3.3.4.4.
  -- Vague linkage for allocating constructors in 5.2.5.

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.

  1) D-17:  Is the runtime for bad_cast, bad_typeid OK?
     See the exception handling document abi-eh.html

  2) Mangling grammar modifications.  There's an outstanding ambiguity
     question, and the previously suggested solution would eliminate
     substitution for some names, we thought.  Can you look at this
     again, Alex?

  3) C-2:  Priority for constructors.  See the writeup in the
     Draft ABI, 3.3.4.4.  I attempted to fill some holes in our prior
     agreements, so there's new stuff here, and it needs checking.

  4) C-13:  Allocating constructors.  There's a new paragraph in 5.2.5.
     Is that enough?

  5) G-4:  Thread-safe data initialization.  See 3.3.2.  Observe that
     Christophe has suggested a more completely contained routine
     that also handles destructor registration, but what he provided
     was incomplete.  Can we make progress on this?

  6) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

We have the following issues without proposals.  Is there any interest
in pursuing them?

  7) F-5: ILP32 vs. LP64 mangling.  Christophe was going to think about
     whether to propose something specific, as I recall.

  8) G-1: Command line options.  Christophe was interested in
     specifying some common options for consistency.

Please also give some thought to what else (not on our lists) ought to
be considered at this point.

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Aug  2 00:13:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 1 Aug 2000 17:13:05 -0700 (PDT)
Subject: Automatic locking for C++ local static initialization
Message-ID: <200008020013.RAA05688@baalbek.engr.sgi.com>

As was suggested at the last meeting, I contacted Hans Boehm about
initialization locking to try to clarify why he was opposed to
automatic locking.  We (mostly Hans) worked up this example, which
illustrates one point, that it can produce undeserved deadlocks.

Suppose we have a program written for a pthreads environment that
supports recursive locks (common these days, but not necessary if one
goes to a bit more trouble).  It contains a data cluster
(i.e. a number of interconnected components) that the
programmer wishes to initialize the first time it is referenced,
and the first reference may come through a number of different paths.
One of those paths enters through function f, which defines some static
data, one of which is constructed using function g, which is part of
the cluster; others enter elsewhere and eventually call f.

So the conscientious programmer sets up a mutex lock M, and acquires it
at each potential entry to the cluster before proceeding, which
includes g and some other function h.  Now consider the following
execution sequence:

	Thread 1		Thread 2
	--------		--------
	call h
	acquire M
				call f
				call g
				try to acquire M (wait)
	call f
	call g
	acquire M recursively
	finish initialization
	exit g, f
	release M		
	exit h			acquire M
				initialization is done
				release M
				exit g, f

Everything has worked exactly as the programmer intended.

But now we add automatic locking for the static initialization in F,
say using lock L.  What happens?

	Thread 1		Thread 2
	--------		--------
	call h
	acquire M
				call f
				acquire L
				call g
				try to acquire M (wait, holding L)
	call f
	try to acquire L (wait, holding M)

		DEADLOCK

So I think what we have here is reasonably designed initialization
scenario (at least if you believe in recursive locking) that works as
written, but fails when we insert automatic static initialization
locks.

Other reasons raised earlier, and appearing in the G-4 commentary, are:

 1) There are more efficient methods available to a programmer than
    per-object locks, and doing the latter automatically makes it hard
    to optimize this.

 2) Mike Ball objects that interaction with exceptions can't be
    Standard-conforming with automatic locks.

 3) Hans believes that there are complications with certain legal
    optimizations of the function-scope object initialization.

It would be worth people re-familiarizing themselves with the
commentary (in the Open Issues document) before the meeting.

Jim

-		Jim Dehnert  x3-4272



From ddd at cup.hp.com  Wed Aug  2 17:48:27 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 02 Aug 2000 17:48:27 +0000
Subject: Automatic locking for C++ local static initialization
References: <200008020013.RAA05688@baalbek.engr.sgi.com>
Message-ID: <39885EEB.84778196@cup.hp.com>

Jim,


I am sorry, I should have described the HP scheme more in details earlier... As
far as I can tell, we do not lock during the initialization of the object, we
lock only during the manipulation of a global list of objects to destroy. I
believe we don't have the problem Hans indicated.

The calling sequence for initializing a static object is something like:

	// Short circuit for the case where static is initialized
	if (!flag.initialized) {
		// Try to acquire the flag
		if (__checkLocalStatic(&flag)) {
			Ctor();
			__addLocalStatic(&flag);
		}
	}

If we get back to Hans' scenario, we have:

        Thread 1                Thread 2
        --------                --------
        call h
        acquire M
                                call f
				call checkLocalStatic
                                acquire L
				update f static state, "in progress"
				release L
				checkLocalStatic returns 1
                                call g
                                try to acquire M (wait, holding L)
        call f
	call checkLocalStatic
	acquire L
	wait while object state == "in progress"
	timeout: emit error "Recursive initialization".
	checkLocalStatic returns 1
	proceed to "second" initialization.


As Dennis pointed out, I believe this is a correct behavior. The "manual"
locking mechanism causes you to enter static initialization twice from two
different threads, and according to the standard, this is illegal.

Note that this also happens in the situation that Hans considers good, albeit
silently.

>         Thread 1                Thread 2
>         --------                --------
>         call h
>         acquire M
>                                 call f
>                                 call g
>                                 try to acquire M (wait)
>         call f

Here, we are starting to initialize the same object twice. In general, this is
not good.

>         call g
>         acquire M recursively
>         finish initialization
>         exit g, f
>         release M
>         exit h                  acquire M
>                                 initialization is done
>                                 release M
>                                 exit g, f
>

Of course, this is a matter of philosophy, but I believe aCC just identify a
runtime mistake you made. Note that there is a simpler way to run into a similar
problem:

	struct X {
		X(int i) { static X x(1); }
	};

This is considered valid by several compilers. aCC issues an error at runtime,
"recursive initialization of local static".


Best regards
Christophe

Jim Dehnert wrote:
> 
> As was suggested at the last meeting, I contacted Hans Boehm about
> initialization locking to try to clarify why he was opposed to
> automatic locking.  We (mostly Hans) worked up this example, which
> illustrates one point, that it can produce undeserved deadlocks.
> 
> Suppose we have a program written for a pthreads environment that
> supports recursive locks (common these days, but not necessary if one
> goes to a bit more trouble).  It contains a data cluster
> (i.e. a number of interconnected components) that the
> programmer wishes to initialize the first time it is referenced,
> and the first reference may come through a number of different paths.
> One of those paths enters through function f, which defines some static
> data, one of which is constructed using function g, which is part of
> the cluster; others enter elsewhere and eventually call f.
> 
> So the conscientious programmer sets up a mutex lock M, and acquires it
> at each potential entry to the cluster before proceeding, which
> includes g and some other function h.  Now consider the following
> execution sequence:
> 
>         Thread 1                Thread 2
>         --------                --------
>         call h
>         acquire M
>                                 call f
>                                 call g
>                                 try to acquire M (wait)
>         call f
>         call g
>         acquire M recursively
>         finish initialization
>         exit g, f
>         release M
>         exit h                  acquire M
>                                 initialization is done
>                                 release M
>                                 exit g, f
> 
> Everything has worked exactly as the programmer intended.
> 
> But now we add automatic locking for the static initialization in F,
> say using lock L.  What happens?
> 
>         Thread 1                Thread 2
>         --------                --------
>         call h
>         acquire M
>                                 call f
>                                 acquire L
>                                 call g
>                                 try to acquire M (wait, holding L)
>         call f
>         try to acquire L (wait, holding M)
> 
>                 DEADLOCK
> 
> So I think what we have here is reasonably designed initialization
> scenario (at least if you believe in recursive locking) that works as
> written, but fails when we insert automatic static initialization
> locks.
> 
> Other reasons raised earlier, and appearing in the G-4 commentary, are:
> 
>  1) There are more efficient methods available to a programmer than
>     per-object locks, and doing the latter automatically makes it hard
>     to optimize this.
> 
>  2) Mike Ball objects that interaction with exceptions can't be
>     Standard-conforming with automatic locks.
> 
>  3) Hans believes that there are complications with certain legal
>     optimizations of the function-scope object initialization.
> 
> It would be worth people re-familiarizing themselves with the
> commentary (in the Open Issues document) before the meeting.
> 
> Jim
> 
> -               Jim Dehnert  x3-4272



From ddd at cup.hp.com  Wed Aug  2 18:13:52 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 02 Aug 2000 18:13:52 +0000
Subject: Problem with the "CONTINUE_UNWIND" return code
Message-ID: <398864E0.C61BE38A@cup.hp.com>

Jim,


In the description of exception handling, there is the following paragraph:

_UA_SEARCH_PHASE 
     Indicates that the personality routine should check if the current frame
contains a handler, and if so return _URC_HANDLER_FOUND,
     or otherwise return _UA_CONTINUE_UNWIND. _UA_SEARCH_PHASE cannot be set at
the same time as _UA_CLEANUP_PHASE. 

Since we now have a different enum for return codes, I believe this should be
_URC_CONTINUE_UNWIND instead of _UA_CONTINUE_UNWIND, and I propose we give it
the next value, 8.


Regards
Christophe



From ddd at cup.hp.com  Wed Aug  2 22:55:27 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Wed, 02 Aug 2000 22:55:27 +0000
Subject: Automatic locking for C++ local static initialization
References: <140D21516EC2D3119EE700902787664401E3A5BF@hplex1.hpl.hp.com>
Message-ID: <3988A6DF.596AB3C9@cup.hp.com>

"Boehm, Hans" wrote:
> 
> Maybe I'm the only one who's confused, but it seems to me we have at least 3
> possible extreme positions here, and some intermediate ones:
> 
> 1) Local static constructors are just like other code, except that once it
> has been completed it will not be reentered.  Synchronization is the
> programmer's responsibility.  Having the runtime diagnose concurrent
> constructor calls is bad, since sometimes those are benign.

I happen to agree with a position where "synchronization is the programmer's
responsibility". On the other hand, "sometimes those are benign" seems quite
wrong to me. Many constructors do this:

	X::X(): field(0) {
		field = new Data[LARGE_CONSTANT];
	}
	X::~X() {
		delete[] field;
	}

In the multithreaded case, now, this constructor can allocate twenty times the
memory, and leak, _even if protected by the lock mechanism you submitted_ (look
how you reenter the f function in your example.) Worse, consider the following:

	Thread 1		Thread 2
	--------		--------

	X::X()
	field = 0
	field = malloc() = f1				// #0
	start ctors
	f1[0] init
	f1[1] init
	f1[2] init - throws
				X::X
				field = 0
				field = malloc() = f2
				start ctors
	f2[2]->Data::~Data				// #1
				f2[0] init		// #2
	f2[1]->Data::~Data				
				f2[1] init		// #3
	f2[0]->Data::~Data				// #4
	delete f2					// #5
				f2[2] init		// #6

				Proceeds		// #7

If you don't get a nice core dump by doing one of the following, I consider you
lucky:

- calling a dtor on uninitialized data (#1)
- Exiting a constructor (#7) with just destroyed objects (#4), residing in
deleted memory (#5)
- Having a constructor and a destructor executing at the same time on the same
object (#3)
- Having a constructor work on free-d memory (#6)

And, of course, there is still the following:
- Having allocated and initialized memory that will never been freed (#0)
- Having a partially allocated array somewhere in memory (the 'f1' value has
been known to other functions, such as operator new[] and Data::Data.)

So I believe it is fair to say that executing the same constructor twice at the
same time is bad.


The second question is: can we make it so that synchronization is the
programmer's responsibility. I had a discussion a long time back with people who
implemented our scheme, and what I remember from the discussion is that if your
constructor can throw (which is true for 99% of constructors which allocate
memory), you can't do it right manually, except with a convoluted scheme such
as:

	int f() {
		X *ptr = NULL;
		AcquireLock();
		try {
			static X x = initX();
			ptr = &x;
		} catch (...) {
			// init of X failed
			ReleaseLock();
		}
		ReleaseLock();
		// use ptr here.
	}

This is ugly, and roughly equivalent to what we generate anyway. The only case
where static init needs not be protected is if you can ensure for other reasons
that no more than one thread will enter a given function at the same time. But
this doesn't work for the most frequent schemes, such as the singleton pattern.



> 
> 2) It should be illegal to enter a constructor for the same static twice
> concurrently, no matter what the cause.  Having the run-time diagnose this
> error is good.  (It can't easily be diagnosed reliably, since the problem
> may not occur with a different thread schedule.)
> 
> 3) The runtime should try to add locking to prevent reentry, eventhough this
> may add deadlocks to code that assumed (1).
> 
> I read the official HP position as being between 2 and 3, i.e. either try to
> delay a thread to avoid the simultaneous constructor calls, or if that's
> impossible, report an error.

This is no more an "official HP position" than yours ;-). This is what our
compiler implements.

>  I would personally prefer either 1 or a pure
> 2, since I think it makes the programming model easier to state.  If either
> the official HP position or (3) is chosen, it needs to be explicitly
> documented that programming to model (1) is incorrect.

The C++ Standard says so: you are not allowed to enter the same constructor
twice. To me, this is one of the rare statements in the Standard that has an
impact on a threading implementation.

On the other hand, while trying to be compliant, we can also try to accomodate
code written for less compliant platforms, hence the delay. Practically, our
current delay (100s) means that most code that runs on another platform will run
on ours, just more reliably. Adopting (3) would make so much code fail at
runtime that we would get severe complaints. Note that we used to abort, and we
now proceed after emitting an error message.


> If you take position 2, and just want to detect the error, do you really
> need ABI support?  You can just set a volatile flag to one of three states:
> not initialized, in progress, initialized.  If you find the in progress
> state, you report an error.  You will of course not detect all programs with
> races of this kind, but no proposed scheme does that.

This would have been much simpler, but again we also have to take into
consideration satisfaction of customers. On the other hand, I agree that your
model is cleaner, so if everybody implements it, we could go for that and give
our customers a good hint that something goes wrong in their application.


Christophe



From mark at codesourcery.com  Wed Aug  2 22:58:59 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 02 Aug 2000 15:58:59 -0700
Subject: No subject
In-Reply-To: <200008012326.QAA05415@baalbek.engr.sgi.com>
References: <200008012326.QAA05415@baalbek.engr.sgi.com>
Message-ID: <20000802155859P.mitchell@codesourcery.com>

Jeffrey noticed that the ABI specifies that the ABI says that
std::type_info contains a public data member named `type_name'.  (This
is in section 2.9.5.3.)

That's bad, since type_name is in the user namespace and since
the type_info class is in the std namespace.  I think the definition
of type_info should say:

  class type_info {
      private:
       void *virtual_table;
       char *__type_name;
  };

There should probably also be a note that the names of private data
members are non-normative.

Also, I'm curious as to why we've made the data members of the RTTI
classes have names in the user namespace, but the classes themselves
have names not in the user namespace.  The net impact is that users
cannot include cxxabi.h without being careful about the names they
have defined, but they also have to use "__" to talk about the type
info classes.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Aug  2 23:38:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 2 Aug 2000 16:38:40 -0700 (PDT)
Subject: Automatic locking for C++ local static initialization
References: <140D21516EC2D3119EE700902787664401E3A5BF@hplex1.hpl.hp.com>
Message-ID: <200008022338.QAA08514@baalbek.engr.sgi.com>

> From: Christophe de Dinechin <ddd at cup.hp.com>
> 
> The C++ Standard says so: you are not allowed to enter the same constructor
> twice. To me, this is one of the rare statements in the Standard that has an
> impact on a threading implementation.

Without taking a position on the overall question, I think it's
important to comment on this statement.  The Standard does not
contemplate threading, period.  Some threading issues might be impacted
by "reasonable" extensions of what is stated, such as the one you cite,
but that was not the intent of the Standard, and should not be
interpreted that way.  The Standard describes a sequential language.
If it were extended to explicitly encompass threading, many issues
would need to be dealt with, and in that context, many of them might
not come out as pure "extensions" of the current language.  I think,
for instance, that an equally reasonable extension to this case would
be simply to forbid (make undefined) multiple threads from entering a
scope with local statics needing construction at the same time.

This is similar to the issues involved in global object destruction
when a DSO is unloaded early.  The Standard, which doesn't contemplate
DSOs, specifies a destructor order that isn't practical if the DSO goes
away early.  So we do something "reasonable," albeit contrary to the
Standard.

The threading issues are the same.  We don't have guidance from the
Standard -- while we should certainly consider its principles as
guidance, we shouldn't consider its rules as determining choices in
areas to which they weren't intended to apply.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From ddd at cup.hp.com  Thu Aug  3 00:51:39 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 03 Aug 2000 00:51:39 +0000
Subject: Automatic locking for C++ local static initialization
References: <140D21516EC2D3119EE700902787664401E3A5BF@hplex1.hpl.hp.com> <200008022338.QAA08514@baalbek.engr.sgi.com>
Message-ID: <3988C21B.E7D2A33A@cup.hp.com>

Jim,


Violent agreement there. I carefully selected the words "has an impact on a
threading implementation" to mean what you said: that the Standard does not tell
you what to do, but that the set of reasonable extensions is limited. Note that
this is all "undefined behavior" anyway. But my opinion is that it does not
encourage executing the same constructor twice.


Christophe

Jim Dehnert wrote:
> 
> > From: Christophe de Dinechin <ddd at cup.hp.com>
> >
> > The C++ Standard says so: you are not allowed to enter the same constructor
> > twice. To me, this is one of the rare statements in the Standard that has an
> > impact on a threading implementation.
> 
> Without taking a position on the overall question, I think it's
> important to comment on this statement.  The Standard does not
> contemplate threading, period.  Some threading issues might be impacted
> by "reasonable" extensions of what is stated, such as the one you cite,
> but that was not the intent of the Standard, and should not be
> interpreted that way.  The Standard describes a sequential language.
> If it were extended to explicitly encompass threading, many issues
> would need to be dealt with, and in that context, many of them might
> not come out as pure "extensions" of the current language.  I think,
> for instance, that an equally reasonable extension to this case would
> be simply to forbid (make undefined) multiple threads from entering a
> scope with local statics needing construction at the same time.
> 
> This is similar to the issues involved in global object destruction
> when a DSO is unloaded early.  The Standard, which doesn't contemplate
> DSOs, specifies a destructor order that isn't practical if the DSO goes
> away early.  So we do something "reasonable," albeit contrary to the
> Standard.
> 
> The threading issues are the same.  We don't have guidance from the
> Standard -- while we should certainly consider its principles as
> guidance, we shouldn't consider its rules as determining choices in
> areas to which they weren't intended to apply.
> 
> Jim
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272



From dehnert at sgi.com  Thu Aug  3 01:19:00 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 02 Aug 2000 18:19:00 -0700
Subject: Problem with the "CONTINUE_UNWIND" return code
References: <398864E0.C61BE38A@cup.hp.com>
Message-ID: <3988C884.3A8FF825@sgi.com>

This looks right to me.  I'll mention it at the meeting tomorrow before changing
it.  Note that the next paragraph already mentions _URC_CONTINUE_UNWIND.  We'll
need to get it to the Intel psABI maintainer, too.

Jim

Christophe de Dinechin wrote:
> 
> Jim,
> 
> In the description of exception handling, there is the following paragraph:
> 
> _UA_SEARCH_PHASE
>      Indicates that the personality routine should check if the current frame
> contains a handler, and if so return _URC_HANDLER_FOUND,
>      or otherwise return _UA_CONTINUE_UNWIND. _UA_SEARCH_PHASE cannot be set at
> the same time as _UA_CLEANUP_PHASE.
> 
> Since we now have a different enum for return codes, I believe this should be
> _URC_CONTINUE_UNWIND instead of _UA_CONTINUE_UNWIND, and I propose we give it
> the next value, 8.
> 
> Regards
> Christophe



From samuel at codesourcery.com  Thu Aug  3 03:43:37 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Wed, 2 Aug 2000 20:43:37 -0700 (PDT)
Subject: Agenda for Thursday 3 August
In-Reply-To: <200008012326.QAA05415@baalbek.engr.sgi.com>
References: <200008012326.QAA05415@baalbek.engr.sgi.com>
Message-ID: <14728.60009.558300.439914@watercress.indetermi.net>

Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

  Jim>   2) Mangling grammar modifications.  There's an outstanding
  Jim> ambiguity question, and the previously suggested solution would
  Jim> eliminate substitution for some names, we thought.  Can you
  Jim> look at this again, Alex?

I'm a bit confused here.  The current ABI draft has this production (in
red):

    <name> ::= <substitution>  # (problem for name w/o signature)

I don't think this is an open issue anymore; I'm pretty sure we
decided conclusively that, for good reasons, the name of a function
without its parameter types should not be a substitution candidate.

I think the production that's still at issue is

    <encoding> ::= <substitution>

This production was present in my original grammar reformulation, but
I asked that it be removed because of the abiguity with the sequence

    <encoding> ::= <name>
    <name> ::= <unscoped-template-name>
    <unscoped-template-name> ::= <substitution>

I feel that reintroducing the substitution of <encoding>s would
significantly complicate the implementation of demanglers (including
the existing implementation that we've debugged), and make it much
harder to get right.  In fact, I'm not even sure it's possible.  

The only place you're hurt by not having this substitution, I think,
is if you reference the same external name more than once in template
arguments, for instance

    typedef void (*fnptr_t)();
    template<fnptr_t T, fnptr_t U> class Bar {};

    extern void foo();
    template Bar<foo, foo>; 

In this case, foo is mangled twice.  This shouldn't even hurt too
much, because in non-trivial cases significant subcomponents of the
second <encoding> should be substituted away.

So, given that it would complicate both existing demangler
implementations and demangler implementations in principal, without
saving much, I strongly suggest not including this production.

Regards
Alex



From mark at codesourcery.com  Thu Aug  3 07:00:17 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 03 Aug 2000 00:00:17 -0700
Subject: Nits
Message-ID: <20000803000017B.mitchell@codesourcery.com>


Folks --

  Two minor details regarding COMDAT:

  - The ABI should explicitly say that the initialization guards for
    local statics should be COMDAT, if the local statics is COMDAT.

  - Templates and inlines with internal linkage should not be placed
    in COMDAT groups.  Similarly, local statics in such functions.
    Similarly, static data members, vtables, type_info data, and
    function members in local classes, in a function with internal
    linkage.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Fri Aug  4 20:29:57 2000
From: jason at redhat.com (Jason Merrill)
Date: 04 Aug 2000 13:29:57 -0700
Subject: fwd: C++ ABI symbol mangling
Message-ID: <u9ya2cn516.fsf@yorick.soma.redhat.com>

I don't think we want to mess with this now, but I thought I'd send it along.

-------------- next part --------------
An embedded message was scrubbed...
From: "Frank Ch. Eigler" <fche at redhat.com>
Subject: C++ ABI symbol mangling
Date: Sun, 30 Jul 2000 20:16:45 -0400
Size: 1908
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000804/503e9157/attachment.mht>

From mark at codesourcery.com  Sat Aug  5 19:01:14 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 05 Aug 2000 12:01:14 -0700
Subject: Minor nit in bitfield layout
Message-ID: <20000805120114O.mitchell@codesourcery.com>


  In either case, update sizeof(C) and dsize(C) to include the last byte
  containing (part of) the bitfield.

Presumably, the reference to sizeof(C) should really say something
like:

  Update sizeof(C) to max(sizeof(C), dsize(C))

Right?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Mon Aug  7 00:36:33 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 06 Aug 2000 17:36:33 -0700
Subject: Vector construction functions
Message-ID: <20000806173633E.mitchell@codesourcery.com>


The ABI doesn't say whether or not the constructor and destructor
parameters may be NULL for many of the functions.  In some cases, it
does say that the pointers may not be NULL.

I believe that a) the spec should explicitly specify this everywhere,
and b) we should allow NULL pointers whenever it makes sense.  These
are convenience routines; why not make them convenient?

For example, why not allow __cxa_vec_new2 to be used with both NULL
constructors and destructors?  The caller should then pass in zero for
the padding size, of course.  There's no reason to try to make these
routines go fast -- they're just their for convenience, and the memory
allocation/function call indirection overhead will swamp a few
conditionals on NULL parameters.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From loewis at informatik.hu-berlin.de  Mon Aug  7 09:49:55 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Mon, 7 Aug 2000 11:49:55 +0200 (MET DST)
Subject: Automatic locking for C++ local static initialization
In-Reply-To: <200008020013.RAA05688@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Tue, 1 Aug 2000 17:13:05 -0700 (PDT))
References: <200008020013.RAA05688@baalbek.engr.sgi.com>
Message-ID: <200008070949.LAA21861@pandora.informatik.hu-berlin.de>

[...]
> One of those paths enters through function f, which defines some static
> data, one of which is constructed using function g, which is part of
> the cluster; others enter elsewhere and eventually call f.
[...]
> 	Thread 1		Thread 2
> 	--------		--------
> 	call h
> 	acquire M
> 				call f
> 				call g
> 				try to acquire M (wait)
> 	call f
> 	call g
> 	acquire M recursively
> 	finish initialization
> 	exit g, f
> 	release M		
> 	exit h			acquire M
> 				initialization is done
> 				release M
> 				exit g, f
>
> Everything has worked exactly as the programmer intended.

I believe this example is flawed, in that it violates a core C++
principle.

You haven't detailed the exact static variable, but assume it is like

struct A{
  A(int);
  ~A();
};

int g();

void f(){
  static A a(g());
}

which matches the description "constructed through function g". In you
control flow, g is invoked twice. Consequently, A::A(int) is invoked
twice as well. As a result, two constructors have been run to
initialize f()::a. However, at the end of the program, only one
destructor will be run to destroy a.

So this example violates the principle "exactly one destructor call
for each complete constructor call"; I'd claim this is *not* what the
programmer intended.

So it seems that the programmer can chose between a faulty constructor
semantics or a deadlock. Which of these is better is anybody's guess,
but it seems to me that the error is in the program.

Regards,
Martin



From nathan at codesourcery.com  Mon Aug  7 12:13:25 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Mon, 07 Aug 2000 13:13:25 +0100
Subject: Updated status pages
References: <200007290423.VAA35056@baalbek.engr.sgi.com>
Message-ID: <398EA7E5.79170E57@codesourcery.com>

Jim Dehnert wrote:
> Nathan, have you had a chance to look at the RTTI structure
> definitions? And Alex was going to go over the mangling examples.
finally had some time to do that. A few more nits -- pretty tiny in
the big scheme, but we may as well try and get consistency!

1) 2.9.5/6.c The definition of __vmi_class_type_info contains
the base array definition as,
        __base_type_info const base_info[1];
That should be __base_class_type_info. Why is it const qualified?
The other data members are not, and this is not a pointer to a const
object, which would justify a qualification. I beleive that qualifier
should be removed.

2) 2.9.5/6.b has the base pointer called `base_type' 2.9.5/6.c has
__base_class_info's base pointer called `base'. These should have the
same name.

3) 2.9.5/6.c has a `flags' member of __vmi_class_type_info but
an `offset_flags' member of __base_class_info. Again, these should have
the same name, (and so should their associated enumerations).

4) 2.9.5/6.c. The enumeration should include the bit shift to obtain the
offset. I recommend,
        offset_shift = 8

5) 2.9.5/7. The __pbase_type_info has a `qualifier_flags'
member, which now contains more than just type qualifiers. In line
with __vmi_class_type_info, I suggest renaming to simply `flags'.

6) 2.9.5/7 has a `pointee' member, but the text describing the qualifier
flag meanings uses the word `target'. These should be consistent (I have
no preference).

7) 2.9.5/9 The `context_class' member should be a const qualified pointer
        const __class_type_info *context_class;
Maybe shortening the name to simply `context' would be less verbose too.

nathan

-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From mark at codesourcery.com  Mon Aug  7 18:54:01 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 07 Aug 2000 11:54:01 -0700
Subject: Error in structure layout algorithm
Message-ID: <20000807115401E.mitchell@codesourcery.com>


Jeffrey and I noticed today that 2.4.II.2 should be using align, not
nvalign, for data members.  Otherwise, we risk underaligning data
members.  We should align for data members and nvalign for non-empty
bases in that section.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Mon Aug  7 21:46:06 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Aug 2000 14:46:06 -0700 (PDT)
Subject: Updated status pages
References: <200007290423.VAA35056@baalbek.engr.sgi.com>
Message-ID: <200008072146.OAA21665@baalbek.engr.sgi.com>

> From nathan at codesourcery.com Mon Aug  7 05:10:19 2000
> 
> Jim Dehnert wrote:
> > Nathan, have you had a chance to look at the RTTI structure
> > definitions? And Alex was going to go over the mangling examples.
> finally had some time to do that. A few more nits -- pretty tiny in
> the big scheme, but we may as well try and get consistency!
> 
> 1) 2.9.5/6.c The definition of __vmi_class_type_info contains
> the base array definition as,
>         __base_type_info const base_info[1];
> That should be __base_class_type_info. Why is it const qualified?
> The other data members are not, and this is not a pointer to a const
> object, which would justify a qualification. I beleive that qualifier
> should be removed.

Got these.

> 2) 2.9.5/6.b has the base pointer called `base_type' 2.9.5/6.c has
> __base_class_info's base pointer called `base'. These should have the
> same name.

And these.

> 3) 2.9.5/6.c has a `flags' member of __vmi_class_type_info but
> an `offset_flags' member of __base_class_info. Again, these should have
> the same name, (and so should their associated enumerations).

I don't think so.  "flags" contains only flags, whereas "offset_flags"
contains a 56-bit offset as well.

> 4) 2.9.5/6.c. The enumeration should include the bit shift to obtain the
> offset. I recommend,
>         offset_shift = 8

Got it.

> 5) 2.9.5/7. The __pbase_type_info has a `qualifier_flags'
> member, which now contains more than just type qualifiers. In line
> with __vmi_class_type_info, I suggest renaming to simply `flags'.

OK.

> 6) 2.9.5/7 has a `pointee' member, but the text describing the qualifier
> flag meanings uses the word `target'. These should be consistent (I have
> no preference).

Got them.

> 7) 2.9.5/9 The `context_class' member should be a const qualified pointer
>         const __class_type_info *context_class;
> Maybe shortening the name to simply `context' would be less verbose too.

OK.  We also decided at the meeting that we needed to move all the
member and enum constant names to the reserved namespace (for macro
avoidance).  Take another look...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Mon Aug  7 21:55:16 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Aug 2000 14:55:16 -0700 (PDT)
Subject: type_info
References: <200008012326.QAA05415@baalbek.engr.sgi.com>
Message-ID: <200008072155.OAA21641@baalbek.engr.sgi.com>

This should all be taken care of now...

Jim

> From: Mark Mitchell <mark at codesourcery.com>
> 
> Jeffrey noticed that the ABI specifies that the ABI says that
> std::type_info contains a public data member named `type_name'.  (This
> is in section 2.9.5.3.)
> 
> That's bad, since type_name is in the user namespace and since
> the type_info class is in the std namespace.  I think the definition
> of type_info should say:
> 
>   class type_info {
>       private:
>        void *virtual_table;
>        char *__type_name;
>   };
> 
> There should probably also be a note that the names of private data
> members are non-normative.
> 
> Also, I'm curious as to why we've made the data members of the RTTI
> classes have names in the user namespace, but the classes themselves
> have names not in the user namespace.  The net impact is that users
> cannot include cxxabi.h without being careful about the names they
> have defined, but they also have to use "__" to talk about the type
> info classes.
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Mon Aug  7 22:03:21 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Aug 2000 15:03:21 -0700 (PDT)
Subject: Agenda for Thursday 3 August
References: <200008012326.QAA05415@baalbek.engr.sgi.com>
Message-ID: <200008072203.PAA21791@baalbek.engr.sgi.com>

And this is done now, too.

Jim

> From samuel at indetermi.net Wed Aug  2 20:44:19 2000
> 
> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>   Jim>   2) Mangling grammar modifications.  There's an outstanding
>   Jim> ambiguity question, and the previously suggested solution would
>   Jim> eliminate substitution for some names, we thought.  Can you
>   Jim> look at this again, Alex?
> 
> I'm a bit confused here.  The current ABI draft has this production (in
> red):
> 
>     <name> ::= <substitution>  # (problem for name w/o signature)
> 
> I don't think this is an open issue anymore; I'm pretty sure we
> decided conclusively that, for good reasons, the name of a function
> without its parameter types should not be a substitution candidate.
> 
> I think the production that's still at issue is
> 
>     <encoding> ::= <substitution>
> 
> This production was present in my original grammar reformulation, but
> I asked that it be removed because of the abiguity with the sequence
> 
>     <encoding> ::= <name>
>     <name> ::= <unscoped-template-name>
>     <unscoped-template-name> ::= <substitution>
> 
> I feel that reintroducing the substitution of <encoding>s would
> significantly complicate the implementation of demanglers (including
> the existing implementation that we've debugged), and make it much
> harder to get right.  In fact, I'm not even sure it's possible.  
> 
> The only place you're hurt by not having this substitution, I think,
> is if you reference the same external name more than once in template
> arguments, for instance
> 
>     typedef void (*fnptr_t)();
>     template<fnptr_t T, fnptr_t U> class Bar {};
> 
>     extern void foo();
>     template Bar<foo, foo>; 
> 
> In this case, foo is mangled twice.  This shouldn't even hurt too
> much, because in non-trivial cases significant subcomponents of the
> second <encoding> should be substituted away.
> 
> So, given that it would complicate both existing demangler
> implementations and demangler implementations in principal, without
> saving much, I strongly suggest not including this production.
> 
> Regards
> Alex
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Mon Aug  7 22:24:01 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 7 Aug 2000 15:24:01 -0700 (PDT)
Subject: Nits
Message-ID: <200008072224.PAA21955@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
>   Two minor details regarding COMDAT:
> 
>   - The ABI should explicitly say that the initialization guards for
>     local statics should be COMDAT, if the local statics is COMDAT.
> 
>   - Templates and inlines with internal linkage should not be placed
>     in COMDAT groups.  Similarly, local statics in such functions.
>     Similarly, static data members, vtables, type_info data, and
>     function members in local classes, in a function with internal
>     linkage.

Is the new wording in 5.2.2 and 5.2 respectively OK?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Aug 10 02:23:14 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 9 Aug 2000 19:23:14 -0700 (PDT)
Subject: Report from 3 August meeting
Message-ID: <200008100223.TAA27179@baalbek.engr.sgi.com>

Below is an edited version of the agenda, with the significant items
from the meeting noted (most of the real information is in the draft).
There are several things for Christophe to look at, and one for Alex.

WARNING:  The next meeting, on 17 August, will have a different
building/conference room.  Look for it in the contact info page,
which I'll update soon.  It's one freeway exit further north, and
not much harder to find, but you might want to give yourself an extra 5
minutes the first time...

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

  -- Updates to one-time initialization in 3.3.2.
  -- Updates to initialization priority in 3.3.4.

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.

  1) Mangling grammar modifications.  I think we match Alex's now.
     Can you look at this again, Alex?

  2) C-2:  Priority for constructors.  This is modified per our
     discussion in the meeting -- see the Draft ABI, 3.3.4.4.
     Is it OK now?

  3) G-4:  Thread-safe data initialization.  See 3.3.2.  Christophe
     had some ideas for optimization here.  I've updated 3.3.2 a bit,
     but the discussion of potential changes for Christophe's concerns
     is in the open issues page for issue G-4.  Christophe, can you
     take a look at it?

  4) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.

     We decided to table these issues for lack of interest.

We have the following issues without proposals.  Is there any interest
in pursuing them?

  5) F-5: ILP32 vs. LP64 mangling.  Christophe was going to think about
     whether to propose something specific, as I recall.

  6) G-1: Command line options.  Christophe was interested in
     specifying some common options for consistency.

Please also give some thought to what else (not on our lists) ought to
be considered at this point.

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Thu Aug 10 18:21:52 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 10 Aug 2000 11:21:52 -0700
Subject: Nits
In-Reply-To: <200008072224.PAA21955@baalbek.engr.sgi.com>
References: <200008072224.PAA21955@baalbek.engr.sgi.com>
Message-ID: <20000810112152P.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> Is the new wording in 5.2.2 and 5.2 respectively OK?

Almost.  I think that in:

  Note that nothing in this section should be construed to require
  COMDAT usage for objects with internal linkage unless they may in fact
  be referenced outside the translation unit where they appear, for
  instance due to inlining.

the "unless" clause is unnecessary and misleading.  (In other words,
the condition can never be true.)

If a function has internal linkage it cannot be referenced outside the
translation unit.

  static inline void f() { static int x; }

should result in a different `x' everywhere this function is used.

Likewise for:
 
  template <class T>
  static inline void f() { static int x; }
 
I don't think `COMDAT' and `internal linkage' make sense at the same
time.  Am I confused?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Thu Aug 10 18:40:05 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 10 Aug 2000 11:40:05 -0700 (PDT)
Subject: Nits
References: <200008072224.PAA21955@baalbek.engr.sgi.com>
Message-ID: <200008101840.LAA28588@baalbek.engr.sgi.com>

> From mitchell at codesourcery.com Thu Aug 10 11:21:42 2000
> 
> >>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:
> 
>     Jim> Is the new wording in 5.2.2 and 5.2 respectively OK?
> 
> Almost.  I think that in:
> 
>   Note that nothing in this section should be construed to require
>   COMDAT usage for objects with internal linkage unless they may in fact
>   be referenced outside the translation unit where they appear, for
>   instance due to inlining.
> 
> the "unless" clause is unnecessary and misleading.  (In other words,
> the condition can never be true.)
> 
> If a function has internal linkage it cannot be referenced outside the
> translation unit.
> 
>   static inline void f() { static int x; }
> 
> should result in a different `x' everywhere this function is used.

In principle, but not exactly in practice.  The source code semantics
don't necessarily match the object code structure.  Suppose that you
also have:

	[inline] void g() { f(); }

You inline the call to f() into the body of g(), and then, whether
because it's declared inline or because you have an intelligent
compiler with inter-file inlining capabilities, you inline calls to g()
in some number of other files.  Now you have references to the same
static int x in multiple files.  That requires COMDAT, unless we
require that it be emitted in the file where originally defined even if
no references to it remain there (with externs elsewhere).

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Thu Aug 10 18:53:31 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 10 Aug 2000 11:53:31 -0700
Subject: Nits
In-Reply-To: <200008101840.LAA28588@baalbek.engr.sgi.com>
References: <200008072224.PAA21955@baalbek.engr.sgi.com>
	<200008101840.LAA28588@baalbek.engr.sgi.com>
Message-ID: <20000810115331I.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> You inline the call to f() into the body of g(), and then,
    Jim> whether because it's declared inline or because you have an
    Jim> intelligent compiler with inter-file inlining capabilities,
    Jim> you inline calls to g() in some number of other files.  Now
    Jim> you have references to the same static int x in multiple
    Jim> files.  That requires COMDAT, unless we require that it be
    Jim> emitted in the file where originally defined even if no
    Jim> references to it remain there (with externs elsewhere).

But `f' can call other non-inline static functions in its original
module anyhow.  So, you already have the same problem with functions,
right?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Sat Aug 12 03:50:54 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 11 Aug 2000 20:50:54 -0700 (PDT)
Subject: Exception handling
Message-ID: <200008120350.UAA32204@baalbek.engr.sgi.com>

I've made some progress in transferring Christophe's exception handling
specification to the Level II specification in the ABI.  Most of what I
have is taken directly from Christophe, but there are editorial changes,
some organizational changes, and extensive omissions of material that
are implementation (Level III) rather than required interface (Level II).

Please take a look, especially if you're involved in exception handler
implementation.  As with the rest of the document, the new material is
in red to facilitate its identification, and I'll convert it to black
after each meeting has given people a chance to note problems in the
new material.  With luck, Level II will be complete within a couple of
meetings.  I think this is the last major undone piece...

Remember, the next meeting, on the 17th, is in a new building at a new
phone number -- check the contact webpage.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue Aug 15 20:09:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 15 Aug 2000 13:09:47 -0700 (PDT)
Subject: Agenda for Thursday
Message-ID: <200008152009.NAA41024@baalbek.engr.sgi.com>

NOTE:  we have a new location, in SGI building 41 (see directions on
the contact page and give yourself a few extra minutes to find it).
The phone number has also changed, to (650) 933-7976.

Following is an updated agenda.  The status pages are updated and on
the web (HTML and PDF) at:

      http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

WARNING:  The next meeting (not this one) will likely have a different
phone number and building/conference room.  Look for it in the contact
info page if I forget to emphasize it.

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

  -- Added base document section 1.5.
  -- Updates to one-time initialization in 3.3.2.
  -- Updates to initialization priority in 3.3.4.
  -- Miscellaneous cleanup to RTTI and mangling.
  -- Added Level II Exception specification, abi-eh.html Chapter 2.

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.

  1) Mangling grammar modifications.  I think we match Alex's now.
     Can you look at this again, Alex?

  2) C-2:  Priority for constructors.  This is modified per our
     discussion in the meeting -- see the Draft ABI, 3.3.4.4.
     Is it OK now?

  3) C-18:  Where do we pass the address of the result buffer for
     a class with non-trivial copy constructor?

  4) C-19:  Should we uniformly allow NULL ctor/dtor parameters to
     the runtime create/destroy utility routines?  Mark, have you gone
     through the list to identify changes?

  5) G-4:  Thread-safe data initialization.  See 3.3.2.  Christophe
     had some ideas for optimization here.  I've updated 3.3.2 a bit,
     but the discussion of potential changes for Christophe's concerns
     is in the open issues page for issue G-4.  Christophe, can you
     take a look at it?

  6) Exception handling (D-14):  I believe I've captured, in the Level
     II chapter of the ABI exception handling spec, what needs to be
     there from the HP document.  Please look it over carefully from
     that standpoint -- does it include what is necessary to achieve a
     consistent exception runtime library interface, but exclude what
     needs only be agreed between the personality routine, the LSDA,
     and the generated code (which all come from the same
     implementation)?  I will next tackle a description of the LSDA in
     the Level III chapter, but may or may not attempt to transfer the
     rest of the HP document there, as opposed to just referencing it.
     Does anyone think that would be significantly better?

     We'll go over any comments anyone has at the meeting, but given
     how close that is, and how major the subject, I expect that we
     will end up doing it more carefully at the August 31 meeting.
     Since I hope that will be the only significant business at that
     meeting, please let us know if you care about it and won't be
     available that day, so we can plan to deal with it the next time
     and perhaps cancel the 31 August meeting.

We have the following issues without proposals.  Is there any interest
in pursuing them?  If not, we'll close or table them.

  7) F-5: ILP32 vs. LP64 mangling.  Christophe was going to think about
     whether to propose something specific, as I recall.

  8) G-1: Command line options.  Christophe was interested in
     specifying some common options for consistency.

Please also give some thought to what else (not on our lists) ought to
be considered at this point.

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

Jim

-		Jim Dehnert  x3-4272



From oldham at codesourcery.com  Wed Aug 16 15:42:38 2000
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Wed, 16 Aug 2000 08:42:38 -0700
Subject: __cxa_guard_release's Return Value Means ???
Message-ID: <20000816084238R.oldham@codesourcery.com>


In \S 3.3.2 of the C++ ABI for IA-64
(http://reality.sgi.com/dehnert_engr/cxx/abi.html) specifies

  extern "C" int __cxa_guard_release ( long long *guard_object );

  The guard_object argument is the guard variable (see Section 2.8)
  associated with the object being initialized. Set it to indicate
  that initialization is complete, release the associated lock (in
  that order), and return.

What should the integral return value of the function be?  Should the
function be a void function?

Thanks for the informtion,
Jeffrey D. Oldham
oldham at codesourcery.com



From oldham at codesourcery.com  Thu Aug 17 03:48:30 2000
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Wed, 16 Aug 2000 20:48:30 -0700
Subject: abi::__base_class_info's public_mask
Message-ID: <20000816204830U.oldham@codesourcery.com>


\S 2.9.5.6.c of the C++ ABI for IA-64 specifies that
abi::__base_class_info has a __public_mask enumeration constant
implying that __vmi_class_type_info has entries for non-public direct
base classes.  Are these non-public base classes included just for
completeness or are they necessary to implement dynamic_cast or some
other algorithm?

Am I correct in assuming that the \S 2.9.7 dynamic cast algorithm only
looks at public base classes?

Thanks for the information,
Jeffrey D. Oldham
oldham at codesourcery.com



From mark at codesourcery.com  Thu Aug 17 20:09:12 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 17 Aug 2000 13:09:12 -0700
Subject: RTTI data member names
Message-ID: <20000817130912Q.mitchell@codesourcery.com>


I apologize for meeting the meeting this morning.

I think it's odd that the RTTI data member names are now considered
non-normative considering that they are public.  If they are part of
the interface, they should have well-defined names -- otherwise, they
should be private/protected.

Also, I don't see why the NTBS mangled name (as stored in RTTI data
structures) should have to be in COMDAT.  That seems like a good idea
-- but doesn't seem mandatory.  From a sample of three compilers,
doing this is rather hard. It's clearly mandatory that the type_info
objects be in COMDAT, but if the NTBS is duplicated, that only costs
space; there's no correctness issue.

Thoughts?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Fri Aug 18 00:24:48 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 17 Aug 2000 17:24:48 -0700 (PDT)
Subject: Minutes from 17 August meeting
Message-ID: <200008180024.RAA46384@baalbek.engr.sgi.com>

Hi, all,

Since our attendance was, ah, weak, I'll summarize what we did.
And there's homework below, so please read...  Numbers are from the
agenda.

 2) C-2:  We accepted the current version of constructor priority,
    with the additional change (I missed it last time) of the pragma
    name from init_priority to just priority.  I have verified since
    that this won't conflict with anything from OpenMP or pthreads.

 3) C-18:  We accepted the proposal.  That is, in all cases where a
    result class is to be returned in a buffer supplied by the caller,
    whether for long classes (>256 bits) or because of non-trivial copy
    constructors or destructors, the buffer address is passed in r8 on
    IA-64, as specified by the psABI for long structs in C.

 9) H-1:  We will name the C++ runtime library libcxa.so .

Now for the homework:

Our next meeting is scheduled for 31 August, just before Labor Day
weekend.  I would like to go over any issues people have found with the
exception handling draft at the next meeting.  So, if you (a) are
concerned with that subject, and (b) can't come 31 August or can't look
at it carefully by then, please let me know ASAP, and I'll consider
cancelling that meeting.

The following scheduled meeting is 14 September, but I'll be out of
town and intend to cancel it.  So the next one after 31 August will be
28 September.

 1) Alex:  Does the mangling grammar look OK now?

 4) Mark:  We need a specific list of changes for C-19.

 5) Christophe:  Does the proposal at the end of G-4 (open issues page)
    look like it solves your concerns?    Would anyone else have
    problems with it as a resolution of the one-time init interface?
    Note the tradeoff:  It would increase the guard variable size from
    8 to 40 bytes, but would likely eliminate a bunch of instructions
    to gather that data for the destructor registration call.  (But it
    would be a pure loss for no-destructor objects.  So perhaps we
    should modify it to eliminate the extra data for those, and pass a
    parameter to indicate that to the release routine?)

 6) Everyone:  Go over the exception handling material.

 7) Christophe:  I think issue F-5 is dead unless you have something
    specific in mind (mangling ILP32 vs. LP64), and probably even then.
    Do you.

 8) Christophe:  Similarly G-1 on command line options.

I'm on vacation next week, so I won't see or respond to anything
between the 19th and 28th.  I'll try to get updated documents out by
tomorrow.

Jim

-		Jim Dehnert  x3-4272



From nathan at acm.org  Fri Aug 18 17:39:09 2000
From: nathan at acm.org (Nathan Sidwell)
Date: Fri, 18 Aug 2000 18:39:09 +0100
Subject: abi::__base_class_info's public_mask
References: <20000816204830U.oldham@codesourcery.com>
Message-ID: <399D74BD.9ADE5321@acm.org>

"Jeffrey D. Oldham" wrote:
> 
> \S 2.9.5.6.c of the C++ ABI for IA-64 specifies that
> abi::__base_class_info has a __public_mask enumeration constant
> implying that __vmi_class_type_info has entries for non-public direct
> base classes.  Are these non-public base classes included just for
> completeness or are they necessary to implement dynamic_cast or some
> other algorithm?
They are necessary for dynamic_cast. See [5.2.7]/8 in the standard.
If a class has ambiguous base T, a dynamic cast to T can only succeed
if the original starting object is a base of exactly one of those T's.
Ambiguity is determined before access, so even if one of those T's is
private, it can still affect the cast (by making it fail). Private
bases are not of interest to dynamic cast, if it knows there are
no ambiguous bases (hence the diamond-shaped and repeated-bases flags).

> Am I correct in assuming that the \S 2.9.7 dynamic cast algorithm only
> looks at public base classes?
No.

Sorry, I'm about to nip off on holiday for a week -- any followup
will have to wait.

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From mark at codesourcery.com  Sun Aug 20 04:07:50 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 19 Aug 2000 21:07:50 -0700
Subject: Minutes from 17 August meeting
In-Reply-To: <200008180024.RAA46384@baalbek.engr.sgi.com>
References: <200008180024.RAA46384@baalbek.engr.sgi.com>
Message-ID: <20000819210750I.mitchell@codesourcery.com>


  4) Mark:  We need a specific list of changes for C-19.

Overall motiviation: there is every reason to make these functions
convenient for use by compilers and for manual use in various kinds of
specialized reflection-like situations, including use in debuggers.
There is virtually no speed penalty for allowing NULL pointers in
these functions since the tests for NULL can be performed outside of
the loop, and the loop itself will normally function calls.

__cxa_vec_new:

  `constructor' and/or `destructor' may be NULL.

  The destructor may be NULL if and only if the padding_size is zero.

__cxa_vec_new2:
__cxa_vec_new3:

  `constructor' and/or `destructor' may be NULL.

  The destructor may be NULL if and only if the padding_size is zero.

  `alloc' and `dealloc' may not be NULL.
  
__cxa_vec_ctor:

  `constructor' and/or `destructor' may be NULL.

__cxa_vec_dtor:
__cxa_vec_delete:

  `destructor' may be NULL.
  
__cxa_vec_delete2:
__cxa_vec_delete3:
 
  `destructor' may be NULL.

  `dealloc' may not be NULL.

__cxa_vec_cctor:

  `constructor' and/or `destructor' may be NULL.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Tue Aug 22 01:09:54 2000
From: jason at redhat.com (Jason Merrill)
Date: 21 Aug 2000 18:09:54 -0700
Subject: unicode again
Message-ID: <u98ztqp0d9.fsf@yorick.soma.redhat.com>

When a name includes extended characters, what do we put in the name length
in the mangling?  The length in abstract characters, or in bytes?

My inclination would be the latter, but the ABI currently says "character
length".

Jason



From loewis at informatik.hu-berlin.de  Tue Aug 22 11:06:41 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 22 Aug 2000 13:06:41 +0200 (MET DST)
Subject: unicode again
In-Reply-To: <u98ztqp0d9.fsf@yorick.soma.redhat.com> (message from Jason
	Merrill on 21 Aug 2000 18:09:54 -0700)
References: <u98ztqp0d9.fsf@yorick.soma.redhat.com>
Message-ID: <200008221106.NAA24343@pandora.informatik.hu-berlin.de>

> When a name includes extended characters, what do we put in the name length
> in the mangling?  The length in abstract characters, or in bytes?
> 
> My inclination would be the latter, but the ABI currently says "character
> length".

AFAICT, the only discussion of that is still in issue F-8, correct?

If so, I'd be very curious what the underlying C ABI (for IA-64)
actually specifies.

The posted resolution of F-8 only allows for encoding the number of
characters. The reason is that you first have to put the length into
the resulting C symbol, and convert that into a byte sequence only
afterwards.

If you want to revert that, I guess we'd actually have to explicitly
specify the rules for encoding Unicode characters.

Regards,
Martin




From oldham at codesourcery.com  Tue Aug 22 21:45:34 2000
From: oldham at codesourcery.com (Jeffrey D. Oldham)
Date: Tue, 22 Aug 2000 14:45:34 -0700
Subject: Deallocators and Exceptions
Message-ID: <20000822144534E.oldham@codesourcery.com>


In the draft C++ ABI for IA-64, \S 3.3.3, __cxa_vec_new2 (), what is
required if dealloc () throws an exception?

I see three possibilities:

1. The C++ standard prohibits deallocators from throwing exceptions.
   (I could not find such a requirement.)

2. Make the result undefined as what happens when a destructor throws
   an exception.  (See __cxa_new_vec ().)

3. Require calling std::terminate () because we cannot guarantee
   memory will be left in a coherent state.

Thanks for the information,
Jeffrey D. Oldham
oldham at codesourcery.com



From samuel at codesourcery.com  Wed Aug 23 07:46:11 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Wed, 23 Aug 2000 00:46:11 -0700 (PDT)
Subject: mangling of member template constructors
Message-ID: <14755.33091.803633.318812@watercress.indetermi.net>

Folks,

Here's a mangling corner case that needs special treatment and should
be added to the spec.  If you have a member template constructor,
currently we mangle its return type (since return types of all
template functions are mangled).  Since it's a constructor, it should
have a special exemption, and not have a return type encoded.

For instance

    class K {
    public:
	template<typename T> K (T* p) {}
    };

    template K::K<int> (int* p);

should be mangled _ZN1KC2IiEEPT_ rather than _ZN1KC2IiEEvPT_ (or
something else, depending on what you consider its `return type' to
be).

Regards
Alex Samuel



From ddd at cup.hp.com  Thu Aug 24 00:19:25 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 24 Aug 2000 00:19:25 +0000
Subject: Minutes from 17 August meeting
References: <200008180024.RAA46384@baalbek.engr.sgi.com>
Message-ID: <39A46A0D.AB5C61DB@cup.hp.com>

Jim Dehnert wrote:
>
>  5) Christophe:  Does the proposal at the end of G-4 (open issues page)
>     look like it solves your concerns?    Would anyone else have
>     problems with it as a resolution of the one-time init interface?
>     Note the tradeoff:  It would increase the guard variable size from
>     8 to 40 bytes, but would likely eliminate a bunch of instructions
>     to gather that data for the destructor registration call.  (But it
>     would be a pure loss for no-destructor objects.  So perhaps we
>     should modify it to eliminate the extra data for those, and pass a
>     parameter to indicate that to the release routine?)

I just returned from vacation, and I'm looking into this.

>  7) Christophe:  I think issue F-5 is dead unless you have something
>     specific in mind (mangling ILP32 vs. LP64), and probably even then.
>     Do you.

Kill it. 32 and 64 bit .o files are link-time incompatible on HP-UX now.


>  8) Christophe:  Similarly G-1 on command line options.

Kill this one.


Christophe



From alainm at cup.hp.com  Thu Aug 24 16:47:52 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Thu, 24 Aug 2000 16:47:52 +0000
Subject: mangling of member template constructors
References: <14755.33091.803633.318812@watercress.indetermi.net>
Message-ID: <39A551B8.DAB27E78@cup.hp.com>

Alex Samuel wrote:
> 
> Folks,
> 
> Here's a mangling corner case that needs special treatment and should
> be added to the spec.  If you have a member template constructor,
> currently we mangle its return type (since return types of all
> template functions are mangled).  Since it's a constructor, it should
> have a special exemption, and not have a return type encoded.
> 
> For instance
> 
>     class K {
>     public:
>         template<typename T> K (T* p) {}
>     };
> 
>     template K::K<int> (int* p);
> 
> should be mangled _ZN1KC2IiEEPT_ rather than _ZN1KC2IiEEvPT_ (or
> something else, depending on what you consider its `return type' to
> be).

What would be the benefit ? (I am just concerned by having to handle yet
another specific case if I don;t see any advantage to it).

Regards,

Alain



From mark at codesourcery.com  Thu Aug 24 17:44:39 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 24 Aug 2000 10:44:39 -0700
Subject: mangling of member template constructors
In-Reply-To: <39A551B8.DAB27E78@cup.hp.com>
References: <14755.33091.803633.318812@watercress.indetermi.net>
	<39A551B8.DAB27E78@cup.hp.com>
Message-ID: <20000824104439N.mitchell@codesourcery.com>

>>>>> "Alain" == Alain Miniussi <alainm at cup.hp.com> writes:

    Alain> What would be the benefit ? (I am just concerned by having
    Alain> to handle yet another specific case if I don;t see any
    Alain> advantage to it).

It's shorter. :-)

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Thu Aug 24 20:16:51 2000
From: jason at redhat.com (Jason Merrill)
Date: 24 Aug 2000 13:16:51 -0700
Subject: mangling of member template constructors
In-Reply-To: Alain Miniussi's message of "Thu, 24 Aug 2000 16:47:52 +0000"
References: <14755.33091.803633.318812@watercress.indetermi.net>
	<39A551B8.DAB27E78@cup.hp.com>
Message-ID: <u9itsqjtxo.fsf@yorick.soma.redhat.com>

>>>>> Alain Miniussi <alainm at cup.hp.com> writes:

 > Alex Samuel wrote:

 >> Here's a mangling corner case that needs special treatment and should
 >> be added to the spec.  If you have a member template constructor,
 >> currently we mangle its return type (since return types of all
 >> template functions are mangled).  Since it's a constructor, it should
 >> have a special exemption, and not have a return type encoded.

 > What would be the benefit ? (I am just concerned by having to handle yet
 > another specific case if I don;t see any advantage to it).

constructors don't have return types in the language.

Jason



From alainm at cup.hp.com  Thu Aug 24 20:40:07 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Thu, 24 Aug 2000 20:40:07 +0000
Subject: mangling of member template constructors
References: <14755.33091.803633.318812@watercress.indetermi.net>
		<39A551B8.DAB27E78@cup.hp.com> <u9itsqjtxo.fsf@yorick.soma.redhat.com>
Message-ID: <39A58827.11C8D520@cup.hp.com>

Jason Merrill wrote:
> 
> >>>>> Alain Miniussi <alainm at cup.hp.com> writes:
> 
>  > Alex Samuel wrote:
> 
>  >> Here's a mangling corner case that needs special treatment and should
>  >> be added to the spec.  If you have a member template constructor,
>  >> currently we mangle its return type (since return types of all
>  >> template functions are mangled).  Since it's a constructor, it should
>  >> have a special exemption, and not have a return type encoded.
> 
>  > What would be the benefit ? (I am just concerned by having to handle yet
>  > another specific case if I don;t see any advantage to it).
> 
> constructors don't have return types in the language.

They don't have mangled names either :-)

Alain



From cary at cup.hp.com  Thu Aug 24 21:34:09 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Thu, 24 Aug 2000 14:34:09 -0700
Subject: Unwind API for EH
Message-ID: <200008242136.OAA14410@adlmail.cup.hp.com>

I'd like to propose a small change to the Unwind API used for EH.

>void _Unwind_SetGR
>   (struct _Unwind_Context *context,
>    int index,
>    uint64 new_value);
>
>This function sets the 64-bit value of the given register, identified by 
>its index as for _Unwind_GetGR. The NAT bit of the given register is reset.
>
>The behaviour is guaranteed only if the function is called during phase 2 
>of unwinding, and applied to an unwind context representing a handler 
>frame, for which the personality routine will return _URC_INSTALL_CONTEXT. 
>In that case, only registers GR15, GR16, GR17, GR18 should be used. These 
>scratch registers are reserved for passing arguments between the 
>personality routine and the landing pads.

The _Unwind_SetGR function is used to setup the landing pad arguments, 
but I believe this interface is too general. If we don't restrict this 
API to r15-r18, the unwind library needs to be prepared to deal with 
requests to set arbitrary scratch registers in the unwind context record. 
Ordinarily, the unwind context wouldn't need to have scratch registers at 
all. By restricting this API to r15-r18, and to the specific uses 
mentioned, however, we've ended up architecting the landing pad registers 
after all -- which was what we were trying to avoid in defining the 
general interface.

Thus, I believe that the landing pad arguments should be communicated by 
a more specific interface, something like this:

void _Unwind_SetLPArgs
   (struct _Unwind_Context *context,
    int nargs,
    uint64 *args);

Registers 15-18 will be architected to be used for these registers, and 
it will be the unwind library's responsibility to place the landing pad 
arguments in the right registers when it installs the context.

The interface is extensible in case we architect more than 4 registers 
for landing pad arguments, but the implementation doesn't need to support 
more than 4 until such time as the architecture is changed.

I still believe that _Unwind_SetGR has its uses, though -- just not for 
scratch registers, which shouldn't even be kept in the unwind context, 
and not for EH. As such, it doesn't need to be in the C++ EH ABI paper. I 
think this will allow us to provide a much cleaner definition of 
_Unwind_SetGR, though, for debuggers and the like where it is useful as a 
general-purpose routine.

-cary



From eboling at inprise.com  Thu Aug 24 22:30:18 2000
From: eboling at inprise.com (Eli Boling)
Date: Thu, 24 Aug 2000 17:30:18 -0500
Subject: Unwind API for EH
References: <200008242136.OAA14410@adlmail.cup.hp.com>
Message-ID: <39A5A1FA.B1905457@inprise.com>

I actually prefer the SetGR interface.  The reason is this:  The current unwind
ABI can be changed with relative ease to support IA32, as well as IA-64.  This
is helped by the current form of SetGR.

-Eli

Cary Coutant wrote:

> I'd like to propose a small change to the Unwind API used for EH.
>
> >void _Unwind_SetGR
> >   (struct _Unwind_Context *context,
> >    int index,
> >    uint64 new_value);
> >
> >This function sets the 64-bit value of the given register, identified by
> >its index as for _Unwind_GetGR. The NAT bit of the given register is reset.
> >
> >The behaviour is guaranteed only if the function is called during phase 2
> >of unwinding, and applied to an unwind context representing a handler
> >frame, for which the personality routine will return _URC_INSTALL_CONTEXT.
> >In that case, only registers GR15, GR16, GR17, GR18 should be used. These
> >scratch registers are reserved for passing arguments between the
> >personality routine and the landing pads.
>
> The _Unwind_SetGR function is used to setup the landing pad arguments,
> but I believe this interface is too general. If we don't restrict this
> API to r15-r18, the unwind library needs to be prepared to deal with
> requests to set arbitrary scratch registers in the unwind context record.
> Ordinarily, the unwind context wouldn't need to have scratch registers at
> all. By restricting this API to r15-r18, and to the specific uses
> mentioned, however, we've ended up architecting the landing pad registers
> after all -- which was what we were trying to avoid in defining the
> general interface.
>
> Thus, I believe that the landing pad arguments should be communicated by
> a more specific interface, something like this:
>
> void _Unwind_SetLPArgs
>    (struct _Unwind_Context *context,
>     int nargs,
>     uint64 *args);
>
> Registers 15-18 will be architected to be used for these registers, and
> it will be the unwind library's responsibility to place the landing pad
> arguments in the right registers when it installs the context.
>
> The interface is extensible in case we architect more than 4 registers
> for landing pad arguments, but the implementation doesn't need to support
> more than 4 until such time as the architecture is changed.
>
> I still believe that _Unwind_SetGR has its uses, though -- just not for
> scratch registers, which shouldn't even be kept in the unwind context,
> and not for EH. As such, it doesn't need to be in the C++ EH ABI paper. I
> think this will allow us to provide a much cleaner definition of
> _Unwind_SetGR, though, for debuggers and the like where it is useful as a
> general-purpose routine.
>
> -cary




From samuel at codesourcery.com  Fri Aug 25 21:08:10 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Fri, 25 Aug 2000 14:08:10 -0700 (PDT)
Subject: runtime demangler API
Message-ID: <14758.57402.392007.376220@watercress.indetermi.net>

There's something somewhat confusing about the runtime API to the
demangler (abi::__cxa_demangle).  Presumably, the main use of this
function will be to mangle type names from typeinfo structures.  Note
that these aren't quite proper mangled names according to the grammar,
i.e. not productions of <mangled-name>, but rather productions of
<type>.  Particularly, they don't start with _Z.

This leaves open the confusion that, for instance, if I call
__cxa_demangle with the input "i", do I mean the function/variable
`extern "C" i' or the type `int'? 

Does anyone anticipate that this will be a problem?  In any case, the
specification should probably address what the correct behaviour here
is.

Regards
Alex Samuel
CodeSourcery LLC



From drepper at redhat.com  Fri Aug 25 21:20:58 2000
From: drepper at redhat.com (Ulrich Drepper)
Date: 25 Aug 2000 14:20:58 -0700
Subject: runtime demangler API
In-Reply-To: Alex Samuel's message of "Fri, 25 Aug 2000 14:08:10 -0700 (PDT)"
References: <14758.57402.392007.376220@watercress.indetermi.net>
Message-ID: <m33djt9gw5.fsf@otr.mynet.cygnus.com>

Alex Samuel <samuel at codesourcery.com> writes:

> There's something somewhat confusing about the runtime API to the
> demangler (abi::__cxa_demangle).  Presumably, the main use of this
> function will be to mangle type names from typeinfo structures.

Sorry to step in without really follwoing the discussion.  I just want
to make sure you also have a runtime mangler interface.  This is
needed to handle dlsym() + C++.

-- 
---------------.                          ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------



From samuel at codesourcery.com  Fri Aug 25 22:36:45 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Fri, 25 Aug 2000 15:36:45 -0700 (PDT)
Subject: runtime mangling API
Message-ID: <14758.62717.437447.501987@watercress.indetermi.net>

Folks,

Here's some correspondence between Ulrich Drepper and me regarding
runtime mangling.  I forgot to CC the cxx-abi list.

------------------------------------------------------------------------
From: Alex Samuel <samuel at codesourcery.com>
To: drepper at cygnus.com (Ulrich Drepper)
Subject: Re: runtime demangler API

Ulrich Drepper <drepper at redhat.com> writes:

  Ulrich> Sorry to step in without really follwoing the discussion.  I
  Ulrich> just want to make sure you also have a runtime mangler
  Ulrich> interface.  This is needed to handle dlsym() + C++.

I'm not sure what you mean.  Do you mean a text-to-text mangling API?
Is this possible even in principal?

Regards
Alex Samuel

------------------------------------------------------------------------
From: Ulrich Drepper <drepper at redhat.com>
To: Alex Samuel <samuel at codesourcery.com>
Subject: Re: runtime demangler API

Alex Samuel <samuel at codesourcery.com> writes:

> I'm not sure what you mean.  Do you mean a text-to-text mangling API?

Yes.  I'm calling

	char **arr;
	mangle (buf, bufsize, "intfoo(int)", &arr)

and get an array with the possible mangled names back.  Due to the
wide variety of possible mangling schemes it probably should be
allowed to return more than one.

> Is this possible even in principal?

The compiler does it, so why shouldn't it be possible at runtime?

------------------------------------------------------------------------
From: Alex Samuel <samuel at codesourcery.com>
To: drepper at cygnus.com (Ulrich Drepper)
Subject: Re: runtime demangler API

Ulrich Drepper <drepper at redhat.com> writes:

  Ulrich> The compiler does it, so why shouldn't it be possible at
  Ulrich> runtime?

I understand the need for it, but the compiler has a lot more context
that a text-to-text mangling function will not.  

In your example, for instance, you'd need to specify at least the full
scope of all names, as in

    mangle (buf, bufsize, "int ::foo(int)", &arr);

Here's a more insidious example.  In this code,

    template<int I> class C {};
    void foo (C<1>) {}

foo is mangled `_Z3foo1CILi1EE', but in this code,

    template<short I> class C {};
    void foo (C<1>) {}

it's mangled `_Z3foo1CILs1EE'.  Which do you expect to get back from

    mangle (buf, bufsize, "void ::foo(::C<1>)", &arr);

?  There are a lot more examples like this where you'll have to supply
a lot more information in the name than you normally would.
Furthermore, preprocessor macros will not be visible, which can make
things even more confusing.

Even if we can sort all this out, do we want to link most of a C++
parser into programs?

Regards
Alex

------------------------------------------------------------------------
From: Ulrich Drepper <drepper at redhat.com>
To: Alex Samuel <samuel at codesourcery.com>
Subject: Re: runtime demangler API

Alex Samuel <samuel at codesourcery.com> writes:

> ?  There are a lot more examples like this where you'll have to supply
> a lot more information in the name than you normally would.
> Furthermore, preprocessor macros will not be visible, which can make
> things even more confusing.
> 
> Even if we can sort all this out, do we want to link most of a C++
> parser into programs?

Make it a library function which people can use.  I get requests for
things like this since people don't want to know the mangled name.  If
it's not possible: fine.




From mark at codesourcery.com  Sat Aug 26 05:32:45 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 25 Aug 2000 22:32:45 -0700
Subject: runtime demangler API
In-Reply-To: <m33djt9gw5.fsf@otr.mynet.cygnus.com>
References: <14758.57402.392007.376220@watercress.indetermi.net>
	<m33djt9gw5.fsf@otr.mynet.cygnus.com>
Message-ID: <20000825223245X.mitchell@codesourcery.com>

>>>>> "Ulrich" == Ulrich Drepper <drepper at redhat.com> writes:

    Ulrich> Sorry to step in without really follwoing the discussion.
    Ulrich> I just want to make sure you also have a runtime mangler
    Ulrich> interface.  This is needed to handle dlsym() + C++.

We do not.  Providing such an interface would be extremely complex; it
is not simply a string->string conversion the way that demangling is.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From samuel at codesourcery.com  Mon Aug 28 05:01:23 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Sun, 27 Aug 2000 22:01:23 -0700 (PDT)
Subject: problem with local name mangling
Message-ID: <14761.61987.489878.303355@watercress.indetermi.net>

Folks,

I've come across problems while debugging mangling of local names.
Currently,

  <name> ::= <local-name>

and also 

  <component> ::= <local-name>

where

  <local-name> ::= Z <function encoding> E <entity name> [<discriminator>]

This means that the <local-name> and therefore the function's
<encoding> appears twice for each local name, once at the top level,
in <name>, and once when expanding the list of components that makes
up the name.  There should be no need for the <component> production
above; function scope should be handled at the <name> level.

Two other things that should probably be spelled out explicitly:

  - In the case of nested function scopes, the first <local-name>
    evaluated should be the innermost function scope.

  - When invoking <entity name> from <local-name>, the expansion of
    <name> needs to stop at the innermost function scope, to prevent
    an infinite recusion.

Also, if the <component> production above is removed, <component>
is synonymous with <unqualified-name> and therefore can be removed.

Finally, the production

  <class-enum-type> ::= <local-name>

is redundant because of

  <class-enum-type> ::= <name>


Here's an example of a local name expansion, as I understand it:

  void foo () {
    struct C {
      void bar () {
        struct D {
          void baz () {
          }
        };
      }
    };
  }

This requires two levels of <local-name>.  The mangling for baz() is

  _ZZZ3foovEN1C3barEvEN1D3bazEv
     <--local-name--->
    <-------local-name------->


To summarize, the changes I think we need are:

  - Remove: <component>

  - Replace: all uses of <component> with <unqualified-name>

  - Remove: <class-enum-type> ::= <local-name>

     ( one might even imagine removing <class-enum-type> altogether and
       simply using  <type> ::= <class-enum name> )

  - Specify that, in the production <name> ::= <local-name>, the
    innermost local name is handled first.

  - Specify that, in the production for <local-name>, when <name> is
    used the assumption is that local function scopes are subsequently
    ignored.  (One could do this with an alternate production for
    <name>, instead.)


Does this make sense to people?

Regards
Alex



From dehnert at baalbek.engr.sgi.com  Wed Aug 30 05:12:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 29 Aug 2000 22:12:35 -0700 (PDT)
Subject: 31 August meeting
Message-ID: <200008300512.WAA06730@baalbek.engr.sgi.com>

Hi,

Yellowstone was nice.  I've read my email, but not responded to it all.
I am assuming that the absence of "I won't be there" messages means
that we will be ready to deal with the material below, especially
exceptions, Mark's C-19 list, and G-4, as well as the various items
that have come up in email over the past week.  Tomorrow I'll update
the pages some more, create PDF, and send an agenda, but there
shouldn't be major surprises from the current HTML and last week's
mail.  See you tomorrow.

Jim

> Subject: Minutes from 17 August meeting
> Reply-To: Jim Dehnert <dehnert at baalbek.engr.sgi.com>
> 
> Hi, all,
> 
> Since our attendance was, ah, weak, I'll summarize what we did.
> And there's homework below, so please read...  Numbers are from the
> agenda.
> 
>  2) C-2:  We accepted the current version of constructor priority,
>     with the additional change (I missed it last time) of the pragma
>     name from init_priority to just priority.  I have verified since
>     that this won't conflict with anything from OpenMP or pthreads.
> 
>  3) C-18:  We accepted the proposal.  That is, in all cases where a
>     result class is to be returned in a buffer supplied by the caller,
>     whether for long classes (>256 bits) or because of non-trivial copy
>     constructors or destructors, the buffer address is passed in r8 on
>     IA-64, as specified by the psABI for long structs in C.
> 
>  9) H-1:  We will name the C++ runtime library libcxa.so .
> 
> Now for the homework:
> 
> Our next meeting is scheduled for 31 August, just before Labor Day
> weekend.  I would like to go over any issues people have found with the
> exception handling draft at the next meeting.  So, if you (a) are
> concerned with that subject, and (b) can't come 31 August or can't look
> at it carefully by then, please let me know ASAP, and I'll consider
> cancelling that meeting.
> 
> The following scheduled meeting is 14 September, but I'll be out of
> town and intend to cancel it.  So the next one after 31 August will be
> 28 September.
> 
>  1) Alex:  Does the mangling grammar look OK now?
> 
>  4) Mark:  We need a specific list of changes for C-19.
> 
>  5) Christophe:  Does the proposal at the end of G-4 (open issues page)
>     look like it solves your concerns?    Would anyone else have
>     problems with it as a resolution of the one-time init interface?
>     Note the tradeoff:  It would increase the guard variable size from
>     8 to 40 bytes, but would likely eliminate a bunch of instructions
>     to gather that data for the destructor registration call.  (But it
>     would be a pure loss for no-destructor objects.  So perhaps we
>     should modify it to eliminate the extra data for those, and pass a
>     parameter to indicate that to the release routine?)
> 
>  6) Everyone:  Go over the exception handling material.
> 
>  7) Christophe:  I think issue F-5 is dead unless you have something
>     specific in mind (mangling ILP32 vs. LP64), and probably even then.
>     Do you.
> 
>  8) Christophe:  Similarly G-1 on command line options.
> 
> I'm on vacation next week, so I won't see or respond to anything
> between the 19th and 28th.  I'll try to get updated documents out by
> tomorrow.
> 
> Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Aug 30 23:11:22 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Aug 2000 16:11:22 -0700 (PDT)
Subject: RTTI data member names, NTBS COMDAT
Message-ID: <200008302311.QAA08436@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> Date: Thu, 17 Aug 2000 13:09:12 -0700
> 
> I think it's odd that the RTTI data member names are now considered
> non-normative considering that they are public.  If they are part of
> the interface, they should have well-defined names -- otherwise, they
> should be private/protected.

I don't recall what the reason was for adding this (or if one was
expressed carefully).  In my mind, the two attributes (normative,
public) are somewhat independent.  Saying it's non-normative means that
a user program can't depend on it -- its use is restricted to the
implementation.  Saying it's private or public is an implementation
choice (if non-normative) based on how easy or hard the implementation
wants to make access elsewhere in the implementation libraries.

Does anyone else have a comment on this issue?  Who suggested making
RTTI names non-normative?  Why?

> Also, I don't see why the NTBS mangled name (as stored in RTTI data
> structures) should have to be in COMDAT.  That seems like a good idea
> -- but doesn't seem mandatory.  From a sample of three compilers,
> doing this is rather hard. It's clearly mandatory that the type_info
> objects be in COMDAT, but if the NTBS is duplicated, that only costs
> space; there's no correctness issue.

The reason for this was that the NTBS is the unique key for dealing
with incomplete types, and must resolve everywhere to the same address.
I suppose that making it weak would work as well, or even mixing weak
with COMDAT.  Is that true (on all systems)?  If so, I don't mind
making the spec more permissive.  Anyone else have comments?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Aug 30 23:18:41 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Aug 2000 16:18:41 -0700 (PDT)
Subject: C++ ABI for IA-64: Drip, Drip
Message-ID: <200008302318.QAA08471@baalbek.engr.sgi.com>

> From oldham at codesourcery.com Fri Aug 18 15:57:21 2000
> Cc: "Jeffrey D. Oldham" <oldham at codesourcery.com>
>
> In The C++ ABI for IA-64, \S 2.9.5:
>
> Is it permissible to change the type of std::type_info::__type_name to
> const char *?  I see no reason to change its value during its
> lifetime.  It will also match the C++ standard's what () function,
> which returns a const char *.
>
> Should __virtual_table also be changed to const?

I don't feel strongly about these.  Any comments?  Let's talk about it 
tomorrow.

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Aug 30 23:23:37 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Aug 2000 16:23:37 -0700 (PDT)
Subject: Deallocators and Exceptions
Message-ID: <200008302323.QAA08491@baalbek.engr.sgi.com>

> From: "Jeffrey D. Oldham" <oldham at codesourcery.com>
> 
> In the draft C++ ABI for IA-64, \S 3.3.3, __cxa_vec_new2 (), what is
> required if dealloc () throws an exception?
> 
> I see three possibilities:
> 
> 1. The C++ standard prohibits deallocators from throwing exceptions.
>    (I could not find such a requirement.)
> 
> 2. Make the result undefined as what happens when a destructor throws
>    an exception.  (See __cxa_new_vec ().)
> 
> 3. Require calling std::terminate () because we cannot guarantee
>    memory will be left in a coherent state.

(2) would be consistent with what we've specified for throws from the
destructor.  Any other observations?  We'll discuss tomorrow.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Aug 30 23:31:20 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Aug 2000 16:31:20 -0700 (PDT)
Subject: Unwind API for EH
References: <200008242136.OAA14410@adlmail.cup.hp.com>
Message-ID: <200008302331.QAA08550@baalbek.engr.sgi.com>

> Date: Thu, 24 Aug 2000 17:30:18 -0500
> From: "Eli Boling" <eboling at inprise.com>
> 
> I actually prefer the SetGR interface.  The reason is this:  The
> current unwind ABI can be changed with relative ease to support IA32,
> as well as IA-64.  This is helped by the current form of SetGR.

Why isn't that just as true of Cary's suggestion?  Or even more so,
since his doesn't imply specific registers in the interface for landing
pad parameters?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu Aug 31 01:27:49 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 30 Aug 2000 18:27:49 -0700 (PDT)
Subject: Meeting tomorrow (31 August)
Message-ID: <200008310127.SAA08835@baalbek.engr.sgi.com>

NOTE:  we have a new location, in SGI building 41 (see directions on
the contact page and give yourself a few extra minutes to find it).
The phone number has also changed, to (650) 933-7976.

Following is an updated agenda.  The status pages are updated and on
the web (HTML and PDF) at:

      http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in red.
The significant changes from last meeting are:

  -- Added Level II Exception specification, abi-eh.html Chapter 2.

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.
If you see something, please send it by email.  #7 (exceptions) is most
important, and I expect to devote at least half of the meeting to it
unless noone has issues with it.  Please look it over carefully.

  1) Mangling grammar modifications.  I think we match Alex's now.  Is it OK?
     Should we suppress result types for constructors in mangling?
     What should we do about Alex's local-name modification proposal?

  2) RTTI -- should member names be normative or not?
     Must NTBS names be COMDAT?
     Should std::type_info::__type_name be const?
     How about std::type_info::__virtual_table?

  3) Array constructors (__cxa_vec_new2/3):  If dealloc() throws, what
     should the result be?  Undefined, as when the destructor throws?

  4) __cxa_demangle -- Should we specify what this does with
     ambiguities between "C" variable names and builtin type manglings,
     e.g. for "i"?

  5) C-19:  Should we uniformly allow NULL ctor/dtor parameters to
     the runtime create/destroy utility routines?  Mark sent a list of
     potential changes.

  6) G-4:  Thread-safe data initialization.  See 3.3.2.  Christophe
     had some ideas for optimization here.  I've updated 3.3.2 a bit,
     but the discussion of potential changes for Christophe's concerns
     is in the open issues page for issue G-4.  Christophe, can you
     take a look at it?

  7) Exception handling (D-14):  I believe I've captured, in the Level
     II chapter of the ABI exception handling spec, what needs to be
     there from the HP document.  Please look it over carefully from
     that standpoint -- does it include what is necessary to achieve a
     consistent exception runtime library interface, but exclude what
     needs only be agreed between the personality routine, the LSDA,
     and the generated code (which all come from the same
     implementation)?  I will next tackle a description of the LSDA in
     the Level III chapter, but may or may not attempt to transfer the
     rest of the HP document there, as opposed to just referencing it.
     Does anyone think that would be significantly better?

     We'll go over any comments anyone has at the meeting, but given
     how close that is, and how major the subject, I expect that we
     will end up doing it more carefully at the August 31 meeting.
     Since I hope that will be the only significant business at that
     meeting, please let us know if you care about it and won't be
     available that day, so we can plan to deal with it the next time
     and perhaps cancel the 31 August meeting.

Note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

Jim

-		Jim Dehnert  x3-4272



From jason at redhat.com  Thu Aug 31 05:08:28 2000
From: jason at redhat.com (Jason Merrill)
Date: 30 Aug 2000 22:08:28 -0700
Subject: unicode again
In-Reply-To: Martin von Loewis's message of "Tue, 22 Aug 2000 13:06:41 +0200 (MET DST)"
References: <u98ztqp0d9.fsf@yorick.soma.redhat.com>
	<200008221106.NAA24343@pandora.informatik.hu-berlin.de>
Message-ID: <u966oi3tmb.fsf@yorick.soma.redhat.com>

>>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

 >> When a name includes extended characters, what do we put in the name length
 >> in the mangling?  The length in abstract characters, or in bytes?

 > The posted resolution of F-8 only allows for encoding the number of
 > characters. The reason is that you first have to put the length into
 > the resulting C symbol, and convert that into a byte sequence only
 > afterwards.

I suppose it's a question of implementation strategy.  I've been planning
to represent extended characters in UTF-8 internally, so we would need to
jump through hoops to get the number of characters back again.

And, more significantly, the same concern applies to the demangler; if we
count characters, the demangler has to convert names from UTF-8 to UCS-4
one character at a time until it's seen the right number of characters.  If
we count bytes, it can ignore the contents of the name, and just feed the
entire demangled output to iconv at the end.  And we don't have to deal
with UCS-4 at all.

 > If you want to revert that, I guess we'd actually have to explicitly
 > specify the rules for encoding Unicode characters.

Seems to me that we have to do that anyway, so we get compatible
manglings.  Tom Tromey was suggesting that we just use UTF-8 and expect
binutils to deal appropriately, since this is a new platform.

Jason



From jason at cygnus.com  Thu Aug 31 07:29:39 2000
From: jason at cygnus.com (Jason Merrill)
Date: Thu, 31 Aug 2000 00:29:39 -0700
Subject: EH level II
Message-ID: <200008310729.AAA22527@casey.cygnus.com>

Thanks a lot for writing this up.  Some comments follow.

Note that I will be unavailable for the three Thursdays after tomorrow, Sep
14 in particular.

2.2.2 says:

  uncaughtExceptions is a count of exceptions thrown and not yet caught by
  the current thread.

Add:
(this includes rethrown exceptions, which may still have active handlers,
but are not considered caught).

2.3.1 says:

  The interface to the emergency buffer is implementation-defined, and used
  only by the __cxa_allocate_exception runtime library routine specified in
  Section 2.4.2 below.

Shouldn't __cxa_get_globals be able to get space from the emergency buffer?

2.4.1 says:

  Evaluate the thrown expression, and copy it into the buffer returned by
  __cxa_allocate_exception, possibly using a copy constructor (see Section
  2.4.3). If evaluation of the thrown expression or the copy constructor
  itself exits by throwing an exception, that exception will propagate
  instead of the expression itself. Cleanup code must ensure that
  __cxa_free_exception is called on the just allocated exception object. 

But the standard says:
[except.terminate]:

  15.5.1  The terminate() function                    [except.terminate]

1 In the following situations exception handling must be  abandoned  for
  less subtle error handling techniques:
  
  --when  the  exception handling mechanism, after completing evaluation
    of the expression to be thrown but before the  exception  is  caught
    (_except.throw_),  calls  a user function that exits via an uncaught
    exception,134)
  _________________________
  134) For example, if the object being thrown is of a class with a copy
  constructor, terminate() will be called if that copy constructor exits
  with an exception during a throw.

I suggest removing the words "or the copy constructor itself", and adding a
note

  (If the copy constructor itself exits by throwing an exception, terminate
  is called.)

Furthermore, when I was dealing with this stuff in g++, I decided that
rather than try to deal with cleaning up the allocated buffer, I would
wait to allocate the exception until after the thrown expression has been
evaluated.  This means we can't elide the copy, but eliminates a cleanup,
making the code simpler and probably smaller.  If the temporary has a
destructor, that needs a cleanup, but that's handled by the standard
compiler mechanisms.

I don't see why this sequence needs to be part of the ABI, actually.  It
should be a QOI issue.

2.4.2 says:

  although an emergency buffer is available to handle bad_alloc exceptions
  during exception object allocation.

I don't see what this has to do with exception object allocation.  If I
have an infinite loop of new int[5], the emergency buffer will allow me to
throw bad_alloc in that case, too.

Perhaps "...available so the implementation can throw bad_alloc exceptions
under low memory conditions".

Actually, since there is no public interface to the emergency buffer, it
seems like a QOI issue as well.  It should be possible to have a conforming
implementation with no emergency buffer, though I'd leave the current stuff
in as a suggestion.

2.4.3: As mentioned above, this seems like overspecification.  This stuff is
constrained by the language, but that's it.

2.4.4: ***How do we tell the EH code how to destroy the exception?***
  I would think it should be an argument to __cxa_throw.

  "Save the typeinfo argument to __cxa_throw in the __cxa_exception header"
  is unclear; my first reaction was "but there isn't a __cxa_throw in that
  header."  I think we can drop "to __cxa_throw".

2.5: The landing pad stuff seems like part of Level III.  An implementation
  shouldn't need to use landing pads to be able to share exception objects
  with other implementations.

2.5.1 says:

  Some cleanup code generated by the front-end may then execute,
  corresponding to the exit of the try block. For instance, a local variable
  with lifetime limited by the try block enclosing the scope would be
  destroyed here.

The last two lines seem rather awkward.  How about

  an automatic variable local to the try block would be destroyed here.

And similarly,

  an automatic variable local to the outer block of the function would be
  destroyed here.

This should use "handler" rather than "catch clause" in most cases.

This should also note that we loop through the various try blocks on our
way out of the function, trying our switch value at each one.

We should replace [RESX] with "_Unwind_Resume();".

I think we need a "goto X1" at the end of the example.

2.5.2 says:

  If the exception is not a C++ exception, the C++ personality routine must
  ignore it, that is, return _URC_CONTINUE_UNWIND in both phases.

What about running cleanups?
Did we give up on being able to catch foreign exceptions?

2.5.4: Rather than "the current exception object", say "the exception on
    top of the caughtExceptions stack".  Rather than "there is no current
    exception", "the stack is empty".

2.5.5: Needs to say "When unexpected() exits (by throwing) _after being
    entered due to a throw_."

Cases 1 and 3 have the same effect; that should be clearer.

Jason



From jason at redhat.com  Thu Aug 31 07:58:21 2000
From: jason at redhat.com (Jason Merrill)
Date: 31 Aug 2000 00:58:21 -0700
Subject: Page updates, scope section
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Tue, 16 May 2000 00:50:27 -0700 (PDT)"
References: <200005160750.AAA10897@baalbek.engr.sgi.com>
Message-ID: <u9og293lr6.fsf@yorick.soma.redhat.com>

>>>>> Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

 > I've updated the pages, to nearly reflect last week's meeting.
 > I would appreciate feedback especially on the new Section 1.4 on
 > Scope of the ABI, in which I've attempted to capture our deliberations
 > on the library interface and export templates.  It's not overly
 > precise, and perhaps can't be, but I'd like it to be a fair statement
 > of the situation.

I find the use of the term "runtime support library" confusing, as I
consider most of the ABI library to be runtime support (and, indeed, in gcc
this code is in the same library with software divide.

Particularly with EH, we need to define what goes where more specifically.

Jason



From jason at redhat.com  Thu Aug 31 07:59:40 2000
From: jason at redhat.com (Jason Merrill)
Date: 31 Aug 2000 00:59:40 -0700
Subject: Template parameter numbering
In-Reply-To: Daveed Vandevoorde's message of "Thu, 11 May 2000 16:42:17 -0700"
References: <200005112318.QAA51114@baalbek.engr.sgi.com>
	<391B4559.4F9098F7@edg.com>
Message-ID: <u9k8cx3loz.fsf@yorick.soma.redhat.com>

>>>>> Daveed Vandevoorde <daveed at edg.com> writes:

 >> Daveed:  you commented once that your export template scheme required
 >> some mangling adjustments.  Is that an issue for what we have
 >> specified?

 > I don't anticipate it to conflict with what is there now, though we are
 > still working on this.  

 > The basic problem is that an exported template specialization can refer to 
 > entities  with internal linkage coming from different translation units.  
 > That means that one of these entities will need to be promoted to have 
 > external linkage, and a mangling trick will need to ensure that there are 
 > no collisions.

You could just use a weak alias to promote them.  That way, collisions will
be resolved arbitrarily by the linker.

Jason



From loewis at informatik.hu-berlin.de  Thu Aug 31 08:38:13 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 31 Aug 2000 10:38:13 +0200 (MET DST)
Subject: RTTI data member names, NTBS COMDAT
In-Reply-To: <200008302311.QAA08436@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Wed, 30 Aug 2000 16:11:22 -0700 (PDT))
References: <200008302311.QAA08436@baalbek.engr.sgi.com>
Message-ID: <200008310838.KAA09917@pandora.informatik.hu-berlin.de>

> Does anyone else have a comment on this issue?  Who suggested making
> RTTI names non-normative?  Why?

I think the way it is now, the names are quite clumsy to use, due to
the underscore business. So I propose two alternatives:

1. make them non-normative. That leaves implementations the choice to
   expose them under more convenient names, or not to expose them.

2. Review the decision to make use of reserved namespace.

I'd like to argue in favour of option 2. Reserved names are necessary
to avoid conflicts for strict conformance in the following situations:

1. During linking, there may be conflicts with other symbols
2. On the source level, there may be conflicts with other names in the
   same scope.
3. There may be conflicts with preprocessor symbols.

Item 1 and item 2 are a non-issue. The names are already in the ABI
namespace, which has a reserved name in itself. So all names inside
that namespace automatically get a reserverd mangled name, and cannot
interfere with other names.

Item 3 is not a problem, because these names are available only
through cxxabi.h. Programs using that header are not strictly
conforming, and must play by the rules imposed by that header, namely,
not use these names as preprocessor symbols.

In short, my proposal is to remove the __ in all places, then make the
fields public.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Aug 31 08:40:47 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 31 Aug 2000 10:40:47 +0200 (MET DST)
Subject: C++ ABI for IA-64: Drip, Drip
In-Reply-To: <200008302318.QAA08471@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Wed, 30 Aug 2000 16:18:41 -0700 (PDT))
References: <200008302318.QAA08471@baalbek.engr.sgi.com>
Message-ID: <200008310840.KAA10012@pandora.informatik.hu-berlin.de>

> > Should __virtual_table also be changed to const?
> 
> I don't feel strongly about these.  Any comments?  Let's talk about it 
> tomorrow.

I'd assume that the name __virtual_table is for exposition only; I
hope that an implementation that has

struct type_info {
     char *__type_name;
     ~type_info();
};

would be just as conforming.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Aug 31 09:27:40 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 31 Aug 2000 11:27:40 +0200 (MET DST)
Subject: Deallocators and Exceptions
In-Reply-To: <200008302323.QAA08491@baalbek.engr.sgi.com> (message from Jim
	Dehnert on Wed, 30 Aug 2000 16:23:37 -0700 (PDT))
References: <200008302323.QAA08491@baalbek.engr.sgi.com>
Message-ID: <200008310927.LAA11696@pandora.informatik.hu-berlin.de>

> > 1. The C++ standard prohibits deallocators from throwing exceptions.
> >    (I could not find such a requirement.)

There is no such requirement, but there should be one. This is Core
Issue 220

http://www.informatik.hu-berlin.de/~loewis/cwg_closed.html#220

As they point out, replacement functions must already have throw();
they don't see the need to require that for class deallocation
functions.

> > 2. Make the result undefined as what happens when a destructor throws
> >    an exception.  (See __cxa_new_vec ().)

In the light of that being consider ill-defined by some, making it 
undefined seems like a good choice.

> (2) would be consistent with what we've specified for throws from the
> destructor.  Any other observations?  

I think that part of the spec must be revised. It currently says

#  If the destructor throws an exception, the result is undefined. 

This is in violation of 15.5.1, [except.terminate]/1

# In the following situations exception handling must be abandoned for
# less subtle error handling techniques: ...
# - when the destruction of an object during stack unwinding (15.2)
#   exits using an exception, or

So I believe terminate must be called in this case.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Aug 31 09:32:35 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 31 Aug 2000 11:32:35 +0200 (MET DST)
Subject: unicode again
In-Reply-To: <u966oi3tmb.fsf@yorick.soma.redhat.com> (message from Jason
	Merrill on 30 Aug 2000 22:08:28 -0700)
References: <u98ztqp0d9.fsf@yorick.soma.redhat.com>
	<200008221106.NAA24343@pandora.informatik.hu-berlin.de> <u966oi3tmb.fsf@yorick.soma.redhat.com>
Message-ID: <200008310932.LAA11875@pandora.informatik.hu-berlin.de>

>  > If you want to revert that, I guess we'd actually have to explicitly
>  > specify the rules for encoding Unicode characters.
> 
> Seems to me that we have to do that anyway, so we get compatible
> manglings.  Tom Tromey was suggesting that we just use UTF-8 and expect
> binutils to deal appropriately, since this is a new platform.

The decision in F-8 was to use the gABI specification of encoding
universal characters. Since nobody has reported what that
specification specifies, I get the feeling that it has this really
unspecified.

In that case, I'd agree that the C++ ABI should take lead and decide
to use UTF-8. I guess the gABI would eventually follow, for lack of
any clearly-better choice.

Regards,
Martin




From eboling at inprise.com  Thu Aug 31 14:52:56 2000
From: eboling at inprise.com (Eli Boling)
Date: Thu, 31 Aug 2000 09:52:56 -0500
Subject: Unwind API for EH
References: <200008242136.OAA14410@adlmail.cup.hp.com> <200008302331.QAA08550@baalbek.engr.sgi.com>
Message-ID: <39AE7148.125B65C7@inprise.com>

> > Date: Thu, 24 Aug 2000 17:30:18 -0500
> > From: "Eli Boling" <eboling at inprise.com>
> >
> > I actually prefer the SetGR interface.  The reason is this:  The
> > current unwind ABI can be changed with relative ease to support IA32,
> > as well as IA-64.  This is helped by the current form of SetGR.
>
> Why isn't that just as true of Cary's suggestion?  Or even more so,
> since his doesn't imply specific registers in the interface for landing
> pad parameters?

It can be done either way, but I don't think that making the interface more
specific
(to landing pad regs) helps very much.  The idea that Cary had (I think)
was that
a more restricted interface be used to narrow the registers that would be
considered
available to suit a need specific to the IA64 - not stomping on regs that
you're not
supposed to tromp on because the Intel ABI says not to.  I don't think that
this is
true in general, if people want to port the interface around, so I wanted
to keep
that interface as general as possible.  Mostly to me, this is a matter of
aesthetics,
so I don't really care that much.

-Eli





From mark at codesourcery.com  Thu Aug 31 18:28:26 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 31 Aug 2000 11:28:26 -0700
Subject: RTTI data member names, NTBS COMDAT
In-Reply-To: <200008310838.KAA09917@pandora.informatik.hu-berlin.de>
References: <200008302311.QAA08436@baalbek.engr.sgi.com>
	<200008310838.KAA09917@pandora.informatik.hu-berlin.de>
Message-ID: <20000831112826U.mitchell@codesourcery.com>

>>>>> "Martin" == Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

    >> Does anyone else have a comment on this issue?  Who suggested
    >> making RTTI names non-normative?  Why?

    Martin> I think the way it is now, the names are quite clumsy to
    Martin> use, due to the underscore business. So I propose two
    Martin> alternatives:

    Martin> 1. make them non-normative. That leaves implementations
    Martin> the choice to expose them under more convenient names, or
    Martin> not to expose them.

    Martin> 2. Review the decision to make use of reserved namespace.

    Martin> I'd like to argue in favour of option 2. Reserved names
    Martin> are necessary to avoid conflicts for strict conformance in
    Martin> the following situations:

I disagree.  I'd prefer to make them normative, using the current
names.  I think the fields have to be there, so we might as well give
them names.

Although your argument regarding the namespace is technically valid, I
think we should consider cxxabi.h like part of the support library;
why risk breaking a user's program that happens to use one of these
names in some other way?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Thu Aug 31 18:28:39 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 31 Aug 2000 11:28:39 -0700
Subject: C++ ABI for IA-64: Drip, Drip
In-Reply-To: <200008310840.KAA10012@pandora.informatik.hu-berlin.de>
References: <200008302318.QAA08471@baalbek.engr.sgi.com>
	<200008310840.KAA10012@pandora.informatik.hu-berlin.de>
Message-ID: <20000831112839P.mitchell@codesourcery.com>

>>>>> "Martin" == Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

    >> > Should __virtual_table also be changed to const?
    >> 
    >> I don't feel strongly about these.  Any comments?  Let's talk
    >> about it tomorrow.

    Martin> I'd assume that the name __virtual_table is for exposition
    Martin> only; I hope that an implementation that has

Goodness, yes.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Thu Aug 31 19:14:12 2000
From: jason at redhat.com (Jason Merrill)
Date: 31 Aug 2000 12:14:12 -0700
Subject: Unwind API for EH
In-Reply-To: "Eli Boling"'s message of "Thu, 31 Aug 2000 09:52:56 -0500"
References: <200008242136.OAA14410@adlmail.cup.hp.com>
	<200008302331.QAA08550@baalbek.engr.sgi.com>
	<39AE7148.125B65C7@inprise.com>
Message-ID: <u9g0nl2qgr.fsf@yorick.soma.redhat.com>

>>>>> Eli Boling <eboling at inprise.com> writes:

 >> > Date: Thu, 24 Aug 2000 17:30:18 -0500
 >> > From: "Eli Boling" <eboling at inprise.com>
 >> >
 >> > I actually prefer the SetGR interface.  The reason is this:  The
 >> > current unwind ABI can be changed with relative ease to support IA32,
 >> > as well as IA-64.  This is helped by the current form of SetGR.
 >> 
 >> Why isn't that just as true of Cary's suggestion?  Or even more so,
 >> since his doesn't imply specific registers in the interface for landing
 >> pad parameters?

 > It can be done either way, but I don't think that making the interface more
 > specific (to landing pad regs) helps very much.  The idea that Cary had (I
 > think) was that a more restricted interface be used to narrow the registers
 > that would be considered available to suit a need specific to the IA64 -
 > not stomping on regs that you're not supposed to tromp on because the Intel
 > ABI says not to.

I think the idea was more to generalize the interface: there are N values
that you want to communicate to the landing pad.  It doesn't matter which
registers you use to pass these.  For a register-poor architecture like the
ia32, you might even combine the values into a struct and use only a single
register.  Cary's suggestion allows us to leave this decision up to the
unwinder library, so the personality routine can be more general.

Jason



From cary at cup.hp.com  Thu Aug 31 19:33:14 2000
From: cary at cup.hp.com (Cary Coutant)
Date: Thu, 31 Aug 2000 12:33:14 -0700
Subject: Unwind API for EH
Message-ID: <200008311936.MAA18101@adlmail.cup.hp.com>

>I think the idea was more to generalize the interface: there are N values
>that you want to communicate to the landing pad.  It doesn't matter which
>registers you use to pass these.  For a register-poor architecture like the
>ia32, you might even combine the values into a struct and use only a single
>register.  Cary's suggestion allows us to leave this decision up to the
>unwinder library, so the personality routine can be more general.

Thanks, Jason. I've been meaning to respond, but your response states my 
rationale quite eloquently.

-cary



From eboling at inprise.com  Thu Aug 31 19:39:22 2000
From: eboling at inprise.com (Eli Boling)
Date: Thu, 31 Aug 2000 14:39:22 -0500
Subject: Unwind API for EH
References: <200008242136.OAA14410@adlmail.cup.hp.com>
		<200008302331.QAA08550@baalbek.engr.sgi.com>
		<39AE7148.125B65C7@inprise.com> <u9g0nl2qgr.fsf@yorick.soma.redhat.com>
Message-ID: <39AEB46A.CE2C5C65@inprise.com>

>
> I think the idea was more to generalize the interface: there are N values
> that you want to communicate to the landing pad.  It doesn't matter which
> registers you use to pass these.  For a register-poor architecture like the
> ia32, you might even combine the values into a struct and use only a single
> register.  Cary's suggestion allows us to leave this decision up to the
> unwinder library, so the personality routine can be more general.

I don't really like this, either.  The problem here is now the unwinder is given
the
power to choose how to set up the processor for the landing pad.  I'd rather that
this be in the control of the language vendor, since we're making a transfer of
control
to their code, under very special circumstances - they know about their unwind
data
structures, and the unwinder doesn't.  So the implementation should be free to
choose
specifics about the processor here that make for the best transfer of control they
can
manage.  On the IA64, there may be one and only one way to manage this, but that's

not necessarily the case on IA32, and it's dependent on whatever interesting
tricks
the language vendor has come up with.

-Eli





From loewis at informatik.hu-berlin.de  Thu Aug 31 19:47:22 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 31 Aug 2000 21:47:22 +0200 (MET DST)
Subject: RTTI data member names, NTBS COMDAT
In-Reply-To: <20000831112826U.mitchell@codesourcery.com> (message from Mark
	Mitchell on Thu, 31 Aug 2000 11:28:26 -0700)
References: <200008302311.QAA08436@baalbek.engr.sgi.com>
	<200008310838.KAA09917@pandora.informatik.hu-berlin.de> <20000831112826U.mitchell@codesourcery.com>
Message-ID: <200008311947.VAA08684@pandora.informatik.hu-berlin.de>

> Although your argument regarding the namespace is technically valid, I
> think we should consider cxxabi.h like part of the support library;
> why risk breaking a user's program that happens to use one of these
> names in some other way?

Because there is no risk. On the object file (i.e. library) level,
there can't be any conflict. If you think there is a risk, can you
give an example of a program that would break if, say,
__array_type_info was changed to array_type_info?

Regards,
Martin



From jason at redhat.com  Thu Aug 31 21:04:52 2000
From: jason at redhat.com (Jason Merrill)
Date: 31 Aug 2000 14:04:52 -0700
Subject: Unwind API for EH
In-Reply-To: "Eli Boling"'s message of "Thu, 31 Aug 2000 14:39:22 -0500"
References: <200008242136.OAA14410@adlmail.cup.hp.com>
	<200008302331.QAA08550@baalbek.engr.sgi.com>
	<39AE7148.125B65C7@inprise.com>
	<u9g0nl2qgr.fsf@yorick.soma.redhat.com>
	<39AEB46A.CE2C5C65@inprise.com>
Message-ID: <u9vgwh16rv.fsf@yorick.soma.redhat.com>

>>>>> Eli Boling <eboling at inprise.com> writes:

 > I don't really like this, either.  The problem here is now the unwinder
 > is given the power to choose how to set up the processor for the landing
 > pad.  I'd rather that this be in the control of the language vendor,
 > since we're making a transfer of control to their code, under very
 > special circumstances - they know about their unwind data structures,
 > and the unwinder doesn't.

Good point.  I suppose it does make more sense to handle this in the
personality routine, since it is the part that coordinates with the
handler.

Jason



From mark at codesourcery.com  Thu Aug 31 21:18:14 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 31 Aug 2000 14:18:14 -0700
Subject: RTTI data member names, NTBS COMDAT
In-Reply-To: <200008311947.VAA08684@pandora.informatik.hu-berlin.de>
References: <200008310838.KAA09917@pandora.informatik.hu-berlin.de>
	<20000831112826U.mitchell@codesourcery.com>
	<200008311947.VAA08684@pandora.informatik.hu-berlin.de>
Message-ID: <20000831141814I.mitchell@codesourcery.com>

>>>>> "Martin" == Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

    >> Although your argument regarding the namespace is technically
    >> valid, I think we should consider cxxabi.h like part of the
    >> support library; why risk breaking a user's program that
    >> happens to use one of these names in some other way?

    Martin> Because there is no risk. On the object file
    Martin> (i.e. library) level

On the source file level:

  #define array_type_info ...

this is unlikely, but the field names are not so unique.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jason at redhat.com  Thu Aug 31 22:32:52 2000
From: jason at redhat.com (Jason Merrill)
Date: 31 Aug 2000 15:32:52 -0700
Subject: EH library implementations?
Message-ID: <u9itsh12p7.fsf@yorick.soma.redhat.com>

What bits of the EH support library have people implemented that they are
willing to share with the committee?  Christophe mentioned an
implementation at the meeting today.  Is that open source?

Jason



