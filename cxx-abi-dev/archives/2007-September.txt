From jason at redhat.com  Wed Sep  5 16:21:18 2007
From: jason at redhat.com (Jason Merrill)
Date: Wed, 05 Sep 2007 12:21:18 -0400
Subject: ::delete and deleting destructors
Message-ID: <46DED77E.8080904@redhat.com>

http://gcc.gnu.org/bugzilla/show_bug.cgi?id=15097

seems to indicate a problem with the ABI.  The standard requires that 
::delete use the global operator delete, but properly deleting an object 
of a type with a virtual destructor requires that use the deleting 
destructor, which will call the operator delete declared in the class, 
if any.

G++ gets this wrong by always calling the global operator delete, which 
means freeing the wrong pointer in the presence of multiple inheritance.

ICC tries to split the difference by using the deleting destructor if 
the static type doesn't have a user-declared op delete, so they free the 
wrong pointer if the static type of the object has a user-declared op 
delete, and call the wrong op delete if the static type doesn't but the 
dynamic type does.

It seems to me that fixing this would require a change to the ABI, 
either to return the address to be deleted from the non-deleting 
destructor, add an additional deleting destructor, or add a hidden 
parameter to the existing deleting destructor.  The last could probably 
be implemented as a backwards-compatible change.

Jason


From mark at codesourcery.com  Wed Sep  5 17:06:47 2007
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 05 Sep 2007 10:06:47 -0700
Subject: [cxx-abi-dev] ::delete and deleting destructors
In-Reply-To: <46DED77E.8080904@redhat.com>
References: <46DED77E.8080904@redhat.com>
Message-ID: <46DEE227.7030908@codesourcery.com>

Jason Merrill wrote:
> http://gcc.gnu.org/bugzilla/show_bug.cgi?id=15097
> 
> seems to indicate a problem with the ABI.  The standard requires that
> ::delete use the global operator delete, but properly deleting an object
> of a type with a virtual destructor requires that use the deleting
> destructor, which will call the operator delete declared in the class,
> if any.

Ugh.

> It seems to me that fixing this would require a change to the ABI

Why can't the code generated by the compiler for "::delete x", where "x"
 is of type "X", a dynamic class, be:

  // Get the virtual table.
  vtbl = *x;
  // Adjust by the offset-to-top.
  p = x + vtbl[-2];
  // Call the non-deleting, complete object destructor.
  // This is a virtual call, so calls the destructor for
  // most-derived type.
  x->X::~X();
  // Call the global deallocation function
  ::operator delete(p);

?

-- 
Mark Mitchell
CodeSourcery
mark at codesourcery.com
(650) 331-3385 x713


From jason at redhat.com  Wed Sep  5 18:48:12 2007
From: jason at redhat.com (Jason Merrill)
Date: Wed, 05 Sep 2007 14:48:12 -0400
Subject: [cxx-abi-dev] ::delete and deleting destructors
In-Reply-To: <46DEE227.7030908@codesourcery.com>
References: <46DED77E.8080904@redhat.com> <46DEE227.7030908@codesourcery.com>
Message-ID: <46DEF9EC.4000508@redhat.com>

Mark Mitchell wrote:
> Why can't the code generated by the compiler for "::delete x", where "x"
>  is of type "X", a dynamic class, be:
> 
>   // Get the virtual table.
>   vtbl = *x;
>   // Adjust by the offset-to-top.
>   p = x + vtbl[-2];

Good point, I'll do that.

Jason



From dhandly at cup.hp.com  Thu Sep  6 04:27:56 2007
From: dhandly at cup.hp.com (Dennis Handly)
Date: Wed, 5 Sep 2007 21:27:56 -0700 (PDT)
Subject: [cxx-abi-dev] ::delete and deleting destructors
Message-ID: <200709060427.VAA22474@hpcll183.hp.com>

>From: Jason Merrill <jason at redhat.com>
http://gcc.gnu.org/bugzilla/show_bug.cgi?id=15097
>seems to indicate a problem with the ABI.  The standard requires that 
>::delete use the global operator delete, but properly deleting an object 
>of a type with a virtual destructor requires that use the deleting 
>destructor, which will call the operator delete declared in the class, 
>if any.

We would have to skip the class one and only use it for the "delete p" case.

>g++ gets this wrong by always calling the global operator delete, which 
>means freeing the wrong pointer in the presence of multiple inheritance.

aC++ also gets it wrong.
400025d0: ::op new(16)
40002630: ::op new(24)  <<<<
40002638: ctor base
40002640: ctor base2
40002630: ctor derived
40002630: dtor derived
40002640: dtor base2
40002638: dtor base
40002638: ::op delete  <<<<

>It seems to me that fixing this would require a change to the ABI, 
Jason

With Mark's suggestion, do we need to add that as an engineering note??

>From: Mark Mitchell <mark at codesourcery.com>
>Why can't the code generated by the compiler for "::delete x", where "x"
>is of type "X", a dynamic class, be:

>  // This is a virtual call, so calls the destructor for most-derived type.
>  x->X::~X();

By definition X::~X() isn't a virtual call but we need one??
It seems you can't write it in C++, without compiler help to access the
function pointer in the vtable.
(But this is a moot point since this doesn't change.)

>  // Call the global deallocation function
>  ::operator delete(p);
Mark Mitchell

That should do it.  And we have to do it in your order since vtbl pointer
gets changed by ~X.


From jason at redhat.com  Thu Sep  6 20:14:53 2007
From: jason at redhat.com (Jason Merrill)
Date: Thu, 06 Sep 2007 16:14:53 -0400
Subject: [cxx-abi-dev] ::delete and deleting destructors
In-Reply-To: <200709060427.VAA22474@hpcll183.hp.com>
References: <200709060427.VAA22474@hpcll183.hp.com>
Message-ID: <46E05FBD.2010508@redhat.com>

Shorter pseudo-code would be

void *head = dynamic_cast<void*>(x);
x->complete object destructor();
::operator delete(head);

Wouldn't hurt to add this to the document as a note since everyone seems 
to have gotten it wrong...

Jason


