From dehnert at baalbek.engr.sgi.com  Tue May  2 01:24:25 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 1 May 2000 18:24:25 -0700 (PDT)
Subject: Agenda for Thursday
Message-ID: <200005020124.SAA23687@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

A reminder:  At the next two meetings, I'd like to clear away most of
the significant and solvable issues, as I'll be gone for the following
5 Thursdays, and several implementations are far enough along to need
resolution.  That means:

  - Please look over the open issues carefully, and try to sort out
    your ideas/position on them.  Raise issues/clarify things by email
    in advance if possible.

  - These next two weeks are a good time to not miss the meetings if
    you care about the issues.

  - I'd like to try real hard to start on time, and we might go
    overtime if things are moving.

  - Note that the number has changed from the last "real" meeting:
    it's now (650) 933-7952.  (In general, if you're not sure, it's on
    the contact page.)

Also, note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last time are:

 - Clarify ordering of vcall offsets.

 - Further elaboration of the construction vtable.

 - Specify COMDAT RTTI name (proposed resolution of A-28).

 - Derive pointer-to-member RTTI and pointer RTTI from common base.
   (Proposed resolution of A-29.)

 - Clarify substitution in mangled names by changing grammar approach.

 - Updates in Vague Linkage section.

Please take a careful look at the colored text, and raise any issues
you observe.  In particular, be prepared to list other things which
need to be mentioned in the new vague linkage section.

Take a look at the material associated with the following issues.
Many of them are issues we think we've resolved, and all that's missing
is final approval of the descriptions.  If you see something, please
send it by email, and it might get fixed before the meeting.

  1) C-2:  Priority for constructors.  The base ABI group is not
     particularly interested in this, because they are not getting
     pressure from their C++ people to worry about it.  So, if we want
     to standardize this, we need to apply pressure within our
     companies.

     We have three choices:

     - We can press ahead and try to build support for a common
       solution.

     - We can specify the API only (already done, and not strictly
       speaking an ABI issue) so that implementors at least provide a
       common source code mechanism.

     - We can specify nothing.

     I don't think we should pursue the first unless we have vendors
     anxious to support it.

  2) A-29:  pointer-to-member RTTI.  Proposed resolution and writeup OK?

  3) A-28:  incomplete class RTTI and equality testing.  Proposed
     resolution and writeup OK?

  4) C-4:  Construction vtables.  Ready to close?

  5) F-1:  Mangling template parameters.  Daveed has convinced me and
     Matt that this is much simpler than what we were trying to
     attempt.  Does anyone else have residual confusion?

  5) F-7:  Mangling statics.  Is writeup OK?

  6) F-11:  Hash for local strings.  Close with current (non-hash)
     writeup?

  7) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent.
     Matt gave him another set of names to try -- any luck?

  8) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

     Coleen made a proposal for F-3.  Jim updated the SGI interface
     section to handle all three.  Where should we go with this?

     G-2:  ODR violations.  Is there anything we should be trying to
     address besides the above cases?  Can we close this one?

  9) F-6:  Demangler.  We have an updated proposal from Matt.  Is is
     OK?

 10) D-12:  Unwind table location.

     Unfortunately, though I'm not real happy with forcing the unwind
     tables into the text segment being described, and believe that we
     could avoid that restriction without significant complications,
     I think the current scheme is workable for mainstream systems, and
     I suspect that changing it at this point will encounter more
     resistance than we can overcome.  So without a groundswell of
     support for a more general scheme, we should probably close this
     with the current approach.  Comments?

 11) C-3:  Order of ctors/dtors w.r.t. DSOs.  Mark proposed a
     simplification a while back to what we had accepted.  It looks
     good to me.  Comments?

For next week, be prepared to discuss:

 12) G-4, C-14:  Specify form of local-scope single-initialization.

 13) E-*:  Do we go anywhere with templates?  Note that our mangling
     and vague linkage specifications should be sufficient to make
     instantiations play together -- the principal issue is whether to
     attempt to specify how to deal with instantiations that aren't
     produced when the reference occurs, i.e. export templates.

 14) H-*:  Do we go anywhere with the runtime library interface?
     I have been convinced that the extensive use of templates and
     associated helper functions probably makes it impractical in the
     short term to connect all but the simplest objects compiled with
     one vendor's header files with another vendor's libC.

     An intermediate model that might be more tractable is this:
     Suppose that one compiles objects with multiple vendors'
     compilers, but all with the header files for the target system.
     Then the key issue in making them work together will be whether
     the various non-Standard-Library interfaces used by the compilers
     (e.g. internal math functions or some such) play together.  If the
     ABI specifies that such runtime routines be named to avoid
     conflicts (e.g. __cxa_sgi_foo) and be placed in a library separate
     from libC so that each vendor's set could be linked into the end
     program, this seems doable.  Comments?

Jim

-		Jim Dehnert  x3-4272



From mendell at ca.ibm.com  Tue May  2 23:07:59 2000
From: mendell at ca.ibm.com (mendell at ca.ibm.com)
Date: Tue, 2 May 2000 19:07:59 -0400
Subject: 32 bit ABI for IA-64?
Message-ID: <872568D3.007F0F6A.00@d53mta05h.boulder.ibm.com>



It seems that there is no longer a 32 bit ABI in the Unix Design Guide for
IA64, only a 64 bit one.  Is anyone still doing a 32 bit ABI, and if so,
can we discuss C/C++ layout for that?

I have heard that Linux/IA64 and Solaris/IA64 don't support a 32 bit IA-64
ABI, only a 32 bit IA-32 ABI.  Can anyone confirm this?

Mark





From drepper at redhat.com  Tue May  2 23:33:12 2000
From: drepper at redhat.com (Ulrich Drepper)
Date: 02 May 2000 16:33:12 -0700
Subject: 32 bit ABI for IA-64?
In-Reply-To: mendell@ca.ibm.com's message of "Tue, 2 May 2000 19:07:59 -0400"
References: <872568D3.007F0F6A.00@d53mta05h.boulder.ibm.com>
Message-ID: <m3em7kbk93.fsf@localhost.localnet>

mendell at ca.ibm.com writes:

> I have heard that Linux/IA64 and Solaris/IA64 don't support a 32 bit IA-64
> ABI, only a 32 bit IA-32 ABI.  Can anyone confirm this?

This is correct for Linux.

-- 
---------------.      drepper at gnu.org  ,-.   1325 Chesapeake Terrace
Ulrich Drepper  \    ,-------------------'   \  Sunnyvale, CA 94089 USA
Red Hat          `--' drepper at redhat.com   `------------------------



From loewis at informatik.hu-berlin.de  Thu May  4 18:21:59 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 4 May 2000 20:21:59 +0200 (MET DST)
Subject: Demangler interfacd
In-Reply-To: <14600.34829.942823.240052@isolde.engr.sgi.com> (message from
	Matt Austern on Thu, 27 Apr 2000 12:17:45 -0700 (PDT))
References: <200004270035.RAA10739@baalbek.engr.sgi.com>
	<u9g0s7cs6e.fsf@yorick.cygnus.com> <14600.34829.942823.240052@isolde.engr.sgi.com>
Message-ID: <200005041821.UAA04385@pandora>

> namespace abi {
> 
>   char* __cxa_demangle(const char* mangled_name,
>                        char* buf,
>                        size_t* n,
>                        int* status);
> 
> }

Is that an extern "C" function? If so, I'd prefer it to be marked as
such (this actually applies to all functions in the draft). 

If not, it does not need the __cxa_ prefix; it then should not have it
if it is user-callable (which it should, since users want to call it
to pretty-print typeid(foo).name()).

Regards,
Martin




From dehnert at baalbek.engr.sgi.com  Thu May  4 20:31:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 4 May 2000 13:31:47 -0700 (PDT)
Subject: Demangler interfacd
References: <200004270035.RAA10739@baalbek.engr.sgi.com>
    <u9g0s7cs6e.fsf@yorick.cygnus.com>
    <14600.34829.942823.240052@isolde.engr.sgi.com>
Message-ID: <200005042031.NAA30623@baalbek.engr.sgi.com>

> Is that an extern "C" function? 

Yes.  I'll document it as such.  (This proposal was accepted today).

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Thu May  4 23:25:09 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 4 May 2000 16:25:09 -0700 (PDT)
Subject: New issue:  .unwind tables for dynamically-generated code
Message-ID: <200005042325.QAA31111@baalbek.engr.sgi.com>

This issue has arisen from C++ ABI discussions, although it doesn't end
up affecting C++.  I've included some recent ia64-tools discussion to
introduce the question (obliquely) and provide background -- the last
paragraph is the issue statement:

>   Kevin> One of the other problems that I've noticed is that there
>   Kevin> doesn't seem to be a symbol which refers to the unwind info.
>   Kevin> I'm trying to figure out how to find it.  (From gdb, I could
>   Kevin> find it, but the idea is for the kernel to be able to find
>   Kevin> its own unwind info.)
> 
> I didn't check on the symbol name, but some also needs to decide how
> to provide access to the unwind info in shared objects and kernel
> modules.  Any takers?

The Intel/HP assumption is that the unwind tables are in the .text
segment to which they refer.  For each .unwind/.text pair, there should
be a program header entry of type PT_IA_64_UNWIND that gives the
location and size of the .unwind table.  It can be associated with the
right .text segment (if there are more than one) by comparing address
ranges.

For shared user code, HP at least then assumes that the unwind library
obtains the start of the unwind table for the PC of interest by
querying the dynamic linker.  Assuming that the unwind library and the
dynamic linker are both parts of the system implementation, this is an
internal interface and not specified as part of the ABI.

This becomes an issue if a user program generates code and associated
unwind tables dynamically, e.g. a Java JIT compiler.  One way to deal
with this is to provide an interface to the dynamic linker to register
a new text range and its associated unwind table.  That interface
crosses the implementation/user boundary, so should be ABI-specified.

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Fri May  5 01:24:28 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 4 May 2000 18:24:28 -0700 (PDT)
Subject: Mangling issues from today's meeting
Message-ID: <200005050124.SAA31684@baalbek.engr.sgi.com>


In today's C++ ABI meeting, we agreed that it was desirable to make
two changes in the substitution algorithm for mangling.  Since they're
significant, and some key people weren't there, I'll raise them in
email and listen for howls...

 1) To eliminate even the theoretical need to do a full unsubstituted
    mangling to get the length, we want to change the rule that
    substitution only occurs if it shortens the unsubstituted name.
    Instead, we want to say that (a) builtin types, and (b) template
    parameters are never substituted (and don't go into the dictionary
    for numbering), but everything else is always substituted without
    regard to length.

    There is a residual issue that didn't come up at the time:  does
    (a) include qualified builtin types like "const int"?  If sometimes
    but not always, where do we put the line?  I think that at least
    vendor-defined qualifiers should cause substitution.

 2) The numbering of substitution entities is defined as most recent
    first.  The original reason for that was so that a particular
    entity, once mangled as part of one name, could be mangled the
    same way as part of another name.  A month or so ago, we determined
    that this doesn't (and can't) work, and eliminated duplicates in
    the substitution dictionary on this basis.

    Numbering the entities backwards, however, has the effect that even
    within a single name, the substitution for a particular entity is
    always changing.  Although the implementation difference is trivial,
    the names would be easier for a mere human to read and explain if
    the numbering was forwards, i.e. the first one encountered is
    always S_, the second is S0_, etc.

Anyone have comments on either of these changes?  If so, please explain.
Otherwise, I'll make the changes early next week.

Jim

-		Jim Dehnert  x3-4272



From alainm at cup.hp.com  Fri May  5 02:08:24 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Thu, 04 May 2000 19:08:24 -0700
Subject: Mangling issues from today's meeting
References: <200005050124.SAA31684@baalbek.engr.sgi.com>
Message-ID: <39122D18.8F303BF0@cup.hp.com>

Jim Dehnert wrote:
> 
> In today's C++ ABI meeting, we agreed that it was desirable to make
> two changes in the substitution algorithm for mangling.  Since they're
> significant, and some key people weren't there, I'll raise them in
> email and listen for howls...
> 
>  1) To eliminate even the theoretical need to do a full unsubstituted
>     mangling to get the length, we want to change the rule that
>     substitution only occurs if it shortens the unsubstituted name.
>     Instead, we want to say that (a) builtin types, and (b) template
>     parameters are never substituted (and don't go into the dictionary
>     for numbering), but everything else is always substituted without
>     regard to length.

I did that proposal a few time ago, so I am not going to say I am
against 
it :-) Still, I implemented it untill then and it's not really an issue:
you can store the size of the encoding of the entities when you process 
then (and store the suze along with the entity in the indexed structure
you 
use to figure out the later substitution indexes), later, when
processing 
an enclosing entity, you need to look if the subcomponents can be
subsituted,
you have access to the sinze of the full mangling of substituable
subcompnent
and can use it to compute the size of the full mangling of the compound
entity.

Still, assuming that the code contains mostly 1 char name, it only save
one
char per substitution, so the complication is probably not worth the
trouble.
 
>     There is a residual issue that didn't come up at the time:  does
>     (a) include qualified builtin types like "const int"?  If sometimes
>     but not always, where do we put the line?  I think that at least
>     vendor-defined qualifiers should cause substitution.

If we choose to "always" substitute without considering the potential 
one char saving, I don't see the point in trying to save that space here
(especialy since we decided to substitute <cv1>...<cvn><type> and 
<type> but not <cvk>..<cvn><type>).
 
>  2) The numbering of substitution entities is defined as most recent
>     first.  The original reason for that was so that a particular
>     entity, once mangled as part of one name, could be mangled the
>     same way as part of another name.  A month or so ago, we determined
>     that this doesn't (and can't) work, and eliminated duplicates in
>     the substitution dictionary on this basis.
> 
>     Numbering the entities backwards, however, has the effect that even
>     within a single name, the substitution for a particular entity is
>     always changing.  Although the implementation difference is trivial,
>     the names would be easier for a mere human to read and explain if
>     the numbering was forwards, i.e. the first one encountered is
>     always S_, the second is S0_, etc.
> 
> Anyone have comments on either of these changes?  If so, please explain.
> Otherwise, I'll make the changes early next week.
> 
> Jim
> 
> -               Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Fri May  5 11:15:34 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 5 May 2000 13:15:34 +0200 (MET DST)
Subject: Mangling issues from today's meeting
In-Reply-To: <200005050124.SAA31684@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200005050124.SAA31684@baalbek.engr.sgi.com>
Message-ID: <200005051115.NAA12623@pandora>

> Anyone have comments on either of these changes?

I'm in favour of both changes. As for qualified builtin types: Yes,
they should be available for substitution. I couldn't see the point in
substituting, say, Pi (int*), but not substituting VKi. IOW, the
exception should be only for primitive types as such. As a result,
int** introduces two entries into the dictionary instead of three.

Regards,
Martin



From dehnert at baalbek.engr.sgi.com  Sat May  6 05:45:10 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 5 May 2000 22:45:10 -0700 (PDT)
Subject: Updated documents
Message-ID: <200005060545.WAA36484@baalbek.engr.sgi.com>

I've done most of the updates to the documents from the meeting.
The two things missing are fixing the mangling examples for the 
modified substitution ordering (but the description is changed),
and adding the issue C-3 interface for ordering destructors.
Please take a good look, especially Alex and Martin at the once-
again-modified nested name grammar :-).  (HTML only so far)

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue May  9 02:09:34 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 8 May 2000 19:09:34 -0700 (PDT)
Subject: Final updates from last meeting
Message-ID: <200005090209.TAA42496@baalbek.engr.sgi.com>

The HTML files have all been updated from last meeting.  I fixed the
mangling substitution examples, added the destructor/DSO API, and
added a description of instantiated template vague linkage.  Take a
look at them all and send any comments.

Jim
-		Jim Dehnert  x3-4272



From samuel at codesourcery.com  Tue May  9 18:21:23 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 9 May 2000 11:21:23 -0700 (PDT)
Subject: Updated documents
In-Reply-To: <200005060545.WAA36484@baalbek.engr.sgi.com>
References: <200005060545.WAA36484@baalbek.engr.sgi.com>
Message-ID: <14616.22307.223544.768777@coriander.indetermi.net>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

  Jim> Please take a good look at the once-again-modified nested name
  Jim> grammar 

I'm having a hard time wrapping my brain around this one.  For one
thing, there's no way for a <compound-name> to start with a namespace's
<source-name>, I think.  Either one of these productions

    <compound-name> ::= <component-name>
    <unqualified-name> ::= <namespace source-name>

is required.

However, can we dispense with some more of C++ syntax and simplify
this?  For instance, these rules I think generate the manglings we
want (though they also produce more illegal syntax, like two sets of
template args in a row):

    <nested-name>     ::= N [<CV-qualifiers>] <scoped-name> E

    <scoped-name>     ::= <substitution>
		      ::= <scope-component>
		      ::= <scoped-name> <scope-component>
		      ::= <scoped-name> <template-args>

    <scope-component> ::= <source-name>
		      ::= <operator-name>
		      ::= <special-name>
		      ::= <builtin-type>
		      ::= <function-type>
		      ::= <array-type>
		      ::= <pointer-to-member-type>

Thoughts?

Regards
Alex



From samuel at codesourcery.com  Tue May  9 18:33:11 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 9 May 2000 11:33:11 -0700 (PDT)
Subject: mangling examples
Message-ID: <14616.23015.242791.884608@coriander.indetermi.net>

Now that substitutions are unconditional (with regards to length of
the substitued text vs the length of the substitution token), these
two should now exhibit substitutions:

  _Zrm1X1X        Ret? operator%(X, X)
  _ZplR1XR1X      Ret? operator+(X&, X&) 

I think they should be `_Zrm1XS0_' and `_ZplR1XS1_', respectively.



From samuel at codesourcery.com  Tue May  9 19:32:36 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 9 May 2000 12:32:36 -0700 (PDT)
Subject: another mangling example error
Message-ID: <14616.26580.96647.655321@coriander.indetermi.net>

I think 

    void foo(Hello,World,World,Hello) 

should be mangled

    _Z3foo5Hello5WorldS1_S0_

since at the first substitution, the candidates are

  S_  = foo
  S0_ = Hello
  S1_ = World

Am I missing one somewhere?




From dehnert at baalbek.engr.sgi.com  Tue May  9 21:53:58 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 9 May 2000 14:53:58 -0700 (PDT)
Subject: Meeting schedule
Message-ID: <200005092153.OAA44594@baalbek.engr.sgi.com>

As I mentioned last week, I'm about to disappear for 5 meetings (18 May
through 15 June).  Since we're also getting the basic material pretty
well wrapped up, this seems like a good opportunity for a breather.

After talking with Matt, we suggest that the group (a) continue dealing
with minor issues by email, and (b) schedule further meetings as follows:

  11 May - regular meeting (agenda soon)
  18 May - no meeting
  25 May - no meeting
   1 Jun - no meeting
   8 Jun - meeting if email issues warrant -- Matt will organize
  15 Jun - no meeting
  22 Jun - regular meeting
   6 Jul - continue meeting alternate weeks instead of weekly

We can discuss this Thursday if necessary, but please send any
significant concerns by email sooner.

Jim

-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Tue May  9 22:51:56 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 9 May 2000 15:51:56 -0700 (PDT)
Subject: Updated documents
References: <200005060545.WAA36484@baalbek.engr.sgi.com>
Message-ID: <200005092251.PAA44735@baalbek.engr.sgi.com>

> From samuel at indetermi.net  Tue May  9 11:23:47 2000
> 
> dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:
> 
>   Jim> Please take a good look at the once-again-modified nested name
>   Jim> grammar 
> 
> I'm having a hard time wrapping my brain around this one.  For one
> thing, there's no way for a <compound-name> to start with a namespace's
> <source-name>, I think.  Either one of these productions
> 
>     <compound-name> ::= <component-name>
>     <unqualified-name> ::= <namespace source-name>
>
> is required.

Yes.  I added the first.

> However, can we dispense with some more of C++ syntax and simplify
> this?  For instance, these rules I think generate the manglings we
> want (though they also produce more illegal syntax, like two sets of
> template args in a row):
> 
>     <nested-name>     ::= N [<CV-qualifiers>] <scoped-name> E
> 
>     <scoped-name>     ::= <substitution>
> 		      ::= <scope-component>
> 		      ::= <scoped-name> <scope-component>
> 		      ::= <scoped-name> <template-args>
> 
>     <scope-component> ::= <source-name>
> 		      ::= <operator-name>
> 		      ::= <special-name>
> 		      ::= <builtin-type>
> 		      ::= <function-type>
> 		      ::= <array-type>
> 		      ::= <pointer-to-member-type>
> 
> Thoughts?

Well, there's a tradeoff here.  Certainly the simpler grammar is easier
to understand, _until_ the reader starts to worry that he's not
understanding all the cases that need to be dealt with.  My inclination
is to stick with the more precise grammar if we can keep it reasonable,
in the belief that this will yield fewer concerned questions.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From samuel at codesourcery.com  Wed May 10 06:04:20 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 9 May 2000 23:04:20 -0700 (PDT)
Subject: more mangling substitution woes
Message-ID: <14616.64484.149353.741213@coriander.indetermi.net>

I think the new name grammar still doesn't do what we want.  Consider
for instance the example mangling of 

    void first<Duo>(/*nondependent*/Duo); 

The example notes

    (Note: first is S_, Duo is S1_, first is S2_) 

and gives as the mangling

    _Z5firstI3DuoEvS0_

I think the current grammar doesn't obtain all the substitutions we
want.  Here's the tree:

      <mangled-name>                  : void first<Duo> (Duo)
       <encoding>                     : first<Duo>
    *   <name>                        : first<Duo>
	 <unqualified-name>           : first<Duo>
	  <template-name>             : first
	   <source-name>              : first
	    <identifier>              : first
	  <template-args>             : <Duo>
    *      <type>                     : Duo
	    <class-enum-type>         : Duo
	     <unqualified-name>       : Duo
	      <source-name>           : Duo
	       <identifier>           : Duo
	   [done with <type>; S_ := Duo]
	[done with <name>; S0_ := first<Duo>]
	<bare-function-type>          : void () (Duo)
	 <type>                       : void
	 <type>                       : Duo == S_

Productions that are substitution candidates are marked with a `*'.
The template name `first' is never made a substitution candidate (if
it were not in the global namespace, it would have hit
<template-prefix>, which would have created the candidate).  

So what I think we need is something along these lines:

  - Eliminate 

      <unqualified-name> ::= <template-name> <template-args>

  - Add

      <name> ::= <unqualified-template-name> <template-args>

      <unqualifed-template-name> ::= <template-name>
                                 ::= <substitution>

That way top-level template names get substituted.



From samuel at codesourcery.com  Wed May 10 06:21:56 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 9 May 2000 23:21:56 -0700 (PDT)
Subject: name grammar
Message-ID: <14617.4.372732.656687@coriander.indetermi.net>

I forgot to mention... I think that we should have

    <component-name> ::= <source-name>  # types, functions, variables

instaed of just

    <component-name> ::= <namespace source-name>

Otherwise a fully-scoped encoding of a variable using a list of
<component-name>s can't end with the variable's name.



From dehnert at baalbek.engr.sgi.com  Wed May 10 23:46:43 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 10 May 2000 16:46:43 -0700 (PDT)
Subject: PDF files are updated
Message-ID: <200005102346.QAA47991@baalbek.engr.sgi.com>

See the subject.
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Thu May 11 01:30:59 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 10 May 2000 18:30:59 -0700 (PDT)
Subject: Agenda
Message-ID: <200005110130.SAA48186@baalbek.engr.sgi.com>

Sorry, it appears that I did not send this.  My apologies...

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

A reminder:  At this meeting, I'd like to clear away most of
the significant and solvable issues, as I'll be gone for the following
5 Thursdays, and several implementations are far enough along to need
resolution.  That means:

  - Please look over the open issues carefully, and try to sort out
    your ideas/position on them.

  - This is a good time to not miss the meeting if
    you care about the issues.

  - I'd like to try real hard to start on time, and we might go
    overtime.

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Fix ordering of the construction vtable.
 - Add destructor, demangler APIs.
 - Yet another try at substitution grammar in mangled names.
 - Don't substitute builtin types, reverse mangling substitution order.
 - Vague Linkage of template instantiations.
 - Specify location of unwind tables.

Please take a careful look at the colored text, and raise any issues
you observe.  In particular, be prepared to list other things which
need to be mentioned in the vague linkage section.

Take a look at the material associated with the following issues.
Many of them are issues we think we've resolved, and all that's missing
is final approval of the descriptions.  If you see something, please
send it by email, and it might get fixed before the meeting.

  1) C-2:  Priority for constructors.  The base ABI group is not
     particularly interested in this, because they are not getting
     pressure from their C++ people to worry about it.  So, if we want
     to standardize this, we need to apply pressure within our
     companies.  There was substantial interest in pressing ahead at
     the last meeting, and I can raise it again with the base ABI, but
     it won't go anywhere unless the others have heard from their C++
     people!

  2) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent.
     Martin and Alex both plan to try the library's names -- any luck?

  3) F-2:  Substituting
     I notice that we're counting the function name in the substitution
     count before the parameters.  I presume this makes no sense, since
     it's not a real entity without them.  True?  (This may be my
     doing...)

     Also, Alex brings up the question of the nested name grammar, and
     whether 'tis nobler to have a simple grammar or a precise one.
     Any strong opinions?

  4) E-*:  Do we go anywhere with templates?  Note that our mangling
     and vague linkage specifications should be sufficient to make
     instantiations play together -- the principal issue is whether to
     attempt to specify how to deal with instantiations that aren't
     produced when the reference occurs, i.e. export templates.

  5) H-*:  Do we go anywhere with the runtime library interface?
     I have been convinced that the extensive use of templates and
     associated helper functions probably makes it impractical in the
     short term to connect all but the simplest objects compiled with
     one vendor's header files with another vendor's libC.

     An intermediate model that might be more tractable is this:
     Suppose that one compiles objects with multiple vendors'
     compilers, but all with the header files for the target system.
     Then the key issue in making them work together will be whether
     the various non-Standard-Library interfaces used by the compilers
     (e.g. internal math functions or some such) play together.  If the
     ABI specifies that such runtime routines be named to avoid
     conflicts (e.g. __cxa_sgi_foo) and be placed in a library separate
     from libC so that each vendor's set could be linked into the end
     program, this seems doable.  Comments?

  6) G-4, C-14:  Specify form of local-scope single-initialization.

After the hiatus, we will talk about:

  8) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

Also, note that it doesn't usually work to try to contact me by email
or phone the morning of the meeting, as I come directly from home.  If
you come in physically to the meeting, and the receptionist won't let
you come back to the conference room on your own, have her call the
conference room (it has a phone other than the one we use for the
meeting).

Jim

-		Jim Dehnert  x3-4272



From loewis at informatik.hu-berlin.de  Thu May 11 15:11:30 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 11 May 2000 17:11:30 +0200 (MET DST)
Subject: New mangling efficiency
Message-ID: <200005111511.RAA21393@pandora>

I finally managed to remangle the set of names that Matt Austern
kindly provided. Please take my results with a grain of salt:
- I just finished the script that remangles the names, it probably
  still has some errors.
- I currently don't have a demangler that works with the latest
  mangling scheme, to verify my results
- I've started with the pretty-printed (demangled) list of names as
  input, not with the original EDG-mangled names, because I did not
  want to invest time in understanding that scheme. 

  As a result, some of these names come out wrong. In particular, if
  template parameters appear in the signature, I use the substituted
  parameters instead of the formal ones (i.e. I never use
  <template-param>). Also, for the same reason, I never put the return
  type into template functions.

I'll attach the ABI-conforming names below. I've also produced a table
showing how the size of EDG-mangled names relates to the new names.
For each length of an old name, it shows how often a certain new
length appeared. E.g. for

89 : 71(2x) 72(5x)

there were a total of 7 names with 89 characters in Matt's list. Under
the new mangling, 2 of them are now 71 characters, and 5 are 72
characters in size.

In general, all names under the new mangling are shorter than under
EGG's mangling, with a single exception (listed on top). For short
names (<80char), size reduction is small, unless one of the predefined
dictionary entries is used. For longer names (>200 chars), compression
under the new ABI is about 50% better than under the EDG scheme.

If you find errors in my implementation that could be corrected from
looking at the demangled names, please let me know; I can then produce
corrected statistics.

Regards,
Martin

P.S. Of course, bzip2 still compresses all those names from 60k to 6k
:-)

__get_formatted_time__3stdGPCcN31cRCQ2_3std10_Time_InfoRUcP2tm
_ZNSt20__get_formatted_timeEPKcS2_S2_S2_cRKNSt10_Time_InfoERbP2tm
51 : 43(18x) 44(10x) 27
52 : 45(30x) 44(7x) 43(8x) 50(6x)
53 : 47 46(12x) 45(18x) 44(8x) 51(2x) 50(8x)
54 : 47(32x) 46(10x) 45(2x) 53 48
55 : 47(19x) 46(16x) 53 41 48(21x)
56 : 47 48(12x)
57 : 55 44 51 50(10x) 48(4x)
58 : 38 50(7x) 56
59 : 47(2x)
60 : 47 38 51(8x) 59
61 : 55
62 : 54 53(16x) 50 65 INCREASED 56
63 : 51(2x)
64 : 63 52(2x)
65 : 54(2x) 44 50(2x) 52
66 : 55(3x) 65
67 : 57 56
68 : 49 11 58(2x) 57(2x) 56
69 : 47(6x) 12(3x) 59 58(3x) 57 55(4x) 50(4x) 9
70 : 13(2x) 60(2x) 51(3x) 56(2x) 48(3x)
71 : 14(4x) 52(3x) 59(2x) 57 56
72 : 15 14 53(2x) 60(2x) 57
73 : 63 62(2x) 58(2x) 54(7x) 53(2x) 15
74 : 59(6x) 55(6x) 54(3x) 69 66 64(2x)
75 : 63 60(3x) 57(2x) 56(4x) 70 18(2x)
76 : 63 62(2x) 61(2x) 58 57(5x) 55(2x) 64
77 : 59(2x) 62(4x) 66
78 : 63(2x) 68 57 66(2x) 60(2x) 64(2x)
79 : 78 61(3x) 62 67(2x) 65(2x)
80 : 63(2x) 62(11x) 69(2x) 66
81 : 63(3x) 62(2x) 61 58(2x) 23(8x) 54 64(2x)
82 : 23(4x) 69 68 26(2x) 64 24
83 : 71 78 69 27 66(4x) 65(2x)
84 : 55(3x) 73 67(4x) 66 65(2x)
85 : 63(2x) 69(4x) 65(2x)
86 : 68(8x)
87 : 65
88 : 70(2x)
89 : 71(2x) 74 73(4x)
90 : 68 75 74(2x) 73 72(2x)
91 : 24 74 73(2x) 64
92 : 77(2x) 76(6x)
93 : 78(2x) 77(4x) 76(2x) 11 41
94 : 79(4x) 77(2x) 80(2x)
95 : 79(2x) 65(2x)
96 : 75(2x) 73
97 : 67 68(4x)
98 : 14 69(4x) 84 83(2x) 56
99 : 15(4x) 45(2x) 60 27(3x) 83 70(4x) 67
100 : 68(3x)
101 : 17 68(4x) 59 82(2x) 19 49
102 : 63(2x) 70 60(2x) 17
103 : 71(2x) 70(2x) 18 64(3x)
104 : 78(2x) 86(8x) 21 89
105 : 86(8x) 85(2x) 67 90 64
106 : 54 24
107 : 91 88(2x)
108 : 87(4x) 92
109 : 87 74 88(2x)
110 : 94(2x) 27(2x) 26 89(4x)
111 : 95(2x) 28 27 73 89(4x)
112 : 29 97(2x)
113 : 98
114 : 31 30(2x) 93(6x)
115 : 31(4x) 33
116 : 95(8x) 101
117 : 95(8x) 103
118 : 97
119 : 36
120 : 31 95
122 : 38(2x)
124 : 74
125 : 109(2x)
126 : 110 42(2x) 52
128 : 72(2x) 77 108(2x) 44(4x) 112
129 : 33 44(5x) 113(2x) 65 73(2x)
130 : 47 110(4x) 45 75 115(2x) 114(2x)
131 : 51 116 115(3x)
132 : 47 74 56 72 53 116 82(3x) 117(3x)
133 : 83 118 117
134 : 119(3x) 118(3x)
135 : 119(2x) 51 120(4x)
136 : 50 121(3x)
137 : 122(5x) 105
138 : 123(4x) 106(2x)
139 : 124(4x)
140 : 125(5x) 65(2x)
141 : 126(2x)
142 : 127 110 44(2x)
143 : 128
146 : 94
148 : 96
149 : 52
150 : 55 60
152 : 70(2x) 122
154 : 56
157 : 68
160 : 70
162 : 55 69
169 : 126
171 : 130
174 : 72(2x)
176 : 74(2x)
178 : 75(2x)
180 : 78(2x)
185 : 61
186 : 71
187 : 83
188 : 71 70
191 : 74
192 : 75(2x) 89(8x)
193 : 89(8x)
194 : 97(2x) 108
196 : 109
197 : 101(2x)
202 : 95(2x) 150
215 : 106 48
218 : 121
220 : 106
226 : 132
228 : 133
232 : 108
234 : 111 109
235 : 139
240 : 116
242 : 117
243 : 119
250 : 145
251 : 143 128
264 : 111
267 : 163
268 : 133
278 : 88
280 : 98 93(2x) 113
282 : 132
283 : 101 116
285 : 151
288 : 130
303 : 143
305 : 144 100
308 : 148
330 : 159
333 : 133
342 : 133 148
347 : 177
355 : 101
530 : 161

-------------- next part --------------
A non-text attachment was scrubbed...
Name: newmangled.bz2
Type: application/octet-stream
Size: 6039 bytes
Desc: not available
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000511/7f0c74e6/attachment.obj>

From samuel at codesourcery.com  Thu May 11 20:26:23 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Thu, 11 May 2000 13:26:23 -0700 (PDT)
Subject: mangling of function names
Message-ID: <14619.5999.291275.369917@coriander.indetermi.net>

It occurred to me, since we agreed today that since names of functions
are not going to be substituted anyway, why don't we just eliminate
them as substitution candidates?  That way there's no need to rewrite
the name grammar, which pretty much works now.  What I'm proposing is
another exception in the `Compression' section that states that the
<name> of a function shall not be a substitution candidate.

Regards
Alex



From dehnert at baalbek.engr.sgi.com  Thu May 11 23:18:37 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 11 May 2000 16:18:37 -0700 (PDT)
Subject: Template parameter numbering
Message-ID: <200005112318.QAA51114@baalbek.engr.sgi.com>

Hi, folks,

We passed over this quickly today discussing something else.  I see in
reading more closely that we never actually specify the numbering,
though the examples start at 1.  I think we ought to start like the
substitution numbering (i.e. T_, T0_, T1_, ...). We can't go all the
way to base 36, because there are other valid characters after T,
but it should rarely matter.

If I don't hear crys of dismay by the weekend, I'll specify this.

Daveed:  you commented once that your export template scheme required
some mangling adjustments.  Is that an issue for what we have
specified?

Jim

-		Jim Dehnert  x3-4272



From daveed at edg.com  Thu May 11 23:42:17 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 11 May 2000 16:42:17 -0700
Subject: Template parameter numbering
References: <200005112318.QAA51114@baalbek.engr.sgi.com>
Message-ID: <391B4559.4F9098F7@edg.com>


> Daveed:  you commented once that your export template scheme required
> some mangling adjustments.  Is that an issue for what we have
> specified?

I don't anticipate it to conflict with what is there now, though we are
still working on this.  

The basic problem is that an exported template specialization can refer to 
entities  with internal linkage coming from different translation units.  
That means that one of these entities will need to be promoted to have 
external linkage, and a mangling trick will need to ensure that there are 
no collisions.

	Daveed



From loewis at informatik.hu-berlin.de  Fri May 12 17:53:48 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 12 May 2000 19:53:48 +0200 (MET DST)
Subject: mangling of function names
In-Reply-To: <14619.5999.291275.369917@coriander.indetermi.net> (message from
	Alex Samuel on Thu, 11 May 2000 13:26:23 -0700 (PDT))
References: <14619.5999.291275.369917@coriander.indetermi.net>
Message-ID: <200005121753.TAA11991@pandora>

> It occurred to me, since we agreed today that since names of functions
> are not going to be substituted anyway, why don't we just eliminate
> them as substitution candidates?  That way there's no need to rewrite
> the name grammar, which pretty much works now.  What I'm proposing is
> another exception in the `Compression' section that states that the
> <name> of a function shall not be a substitution candidate.

That could be done. But then, this only safes a single slot in the
table. So for simplicity of the spec, I would not introduce that
special case.

Regards,
Martin



From samuel at codesourcery.com  Fri May 12 18:45:43 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Fri, 12 May 2000 11:45:43 -0700 (PDT)
Subject: mangling of function names
In-Reply-To: <200005121753.TAA11991@pandora>
References: <14619.5999.291275.369917@coriander.indetermi.net>
	<200005121753.TAA11991@pandora>
Message-ID: <14620.20823.279926.145826@basil.indetermi.net>

Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

  Alex> It occurred to me, since we agreed today that since names of
  Alex> functions are not going to be substituted anyway, why don't we
  Alex> just eliminate them as substitution candidates?  That way
  Alex> there's no need to rewrite the name grammar, which pretty much
  Alex> works now.  What I'm proposing is another exception in the
  Alex> `Compression' section that states that the <name> of a
  Alex> function shall not be a substitution candidate.

  Martin> That could be done. But then, this only safes a single slot
  Martin> in the table. So for simplicity of the spec, I would not
  Martin> introduce that special case.

Unfortunately, I fear the name grammar would have to be complicated to
accomodate the semantics we want, if this is important.  At the very
least, modifying it again would probably entail several rounds of
back-and-forth to get it right.  Jim, do you have a sense for how
`invasive' this change would be?

However, given that we aren't going to substitute it anyway, we could
just relax our semantic considerations and place the (untyped) name of
the function into the substitution candidate list, expecting that it
would not be substituted later (though I suspect we could invent cases
in which it might).

Regards
Alex Samuel




From loewis at informatik.hu-berlin.de  Fri May 12 18:52:47 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 12 May 2000 20:52:47 +0200 (MET DST)
Subject: mangling of function names
In-Reply-To: <14620.20823.279926.145826@basil.indetermi.net> (message from
	Alex Samuel on Fri, 12 May 2000 11:45:43 -0700 (PDT))
References: <14619.5999.291275.369917@coriander.indetermi.net>
	<200005121753.TAA11991@pandora> <14620.20823.279926.145826@basil.indetermi.net>
Message-ID: <200005121852.UAA14735@pandora>

> However, given that we aren't going to substitute it anyway, we could
> just relax our semantic considerations and place the (untyped) name of
> the function into the substitution candidate list, expecting that it
> would not be substituted later (though I suspect we could invent cases
> in which it might).

That's what I'd prefer - put it in the candidate list, even if you
know it won't be used. There are actually cases where it then would
get substituted:

struct klasse{
  struct methode{};
  void methode(struct methode);
};

void klasse::methode(struct methode){}

Now, if it is considered too difficult for implementations to detect
that substitution is needed here, or if it is unclear from the spec
whether substitution should happen - then that would make a point for
complicating the spec. Otherwise, I think this _ZN6klasse7methodeES0_.

Regards,
Martin




From loewis at informatik.hu-berlin.de  Fri May 12 18:56:29 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Fri, 12 May 2000 20:56:29 +0200 (MET DST)
Subject: Web pages corrections
Message-ID: <200005121856.UAA14900@pandora>

There is a problem with the new mangling examples:

On _Z5firstI3DuoEvS0_ 

Note: first is S_, Duo is S1_, first<Duo> is S2_

should be

Note: first is S_, Duo is S0_, first&lt;Duo&gt; is S1_

Regards,
Martin



From samuel at codesourcery.com  Fri May 12 21:16:14 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Fri, 12 May 2000 14:16:14 -0700 (PDT)
Subject: mangling of function names
In-Reply-To: <200005121852.UAA14735@pandora>
References: <14619.5999.291275.369917@coriander.indetermi.net>
	<200005121753.TAA11991@pandora>
	<14620.20823.279926.145826@basil.indetermi.net>
	<200005121852.UAA14735@pandora>
Message-ID: <14620.29854.805480.838332@coriander.indetermi.net>

Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

  Martin> There are actually cases where it then would get
  Martin> substituted:

    struct klasse{
      struct methode{};
      void methode(struct methode);
    };

    void klasse::methode(struct methode){}

  Martin> Now, if it is considered too difficult for implementations
  Martin> to detect that substitution is needed here, or if it is
  Martin> unclear from the spec whether substitution should happen -
  Martin> then that would make a point for complicating the
  Martin> spec. 

I hadn't even considered this possibility.  I think it argues for
changing the name grammar again.

Here's an attempt to accomplish this.  This grammar replaces
<mangled-name> through <unqualified-name>  I've tried to accomplish
these things:

  - Separate the logic for encoding names in the global scope from
    <unqualfied-name>, which is a name without scope qualification.

  - Add substitution candidates for template names before template-ids
    by forking <unscoped-name> into <unscoped-template-name> and
    <prefix> into <template-prefix>.

  - Add the special compression rule that avoids a <nested-name> for
    names in ::std.

  - Split <special-name> into <special-data-name> and
    <special-function-name>.  

    <special-data-name> for vtables, VTTs, typeinfo, typeinfo names, 
                        guard variables, and thunks [these are mangled as 
			data, right?]

    <special-function-name> for ctors and dtors

I think this is a simplification to the existing grammar that
addresses the function name issue discussed yesterday, and also
corrects some omissions (for instance, in the existing grammar, 
untemplated operator names inside a namespace other than ::std were
not produced).

Regards
Alex


------------------------------------------------------------------------

    <mangled-name>      ::= _Z <name>

    <name>              ::= <unscoped-name>
                        ::= <unscoped-template-name> <template-args>
			::= <nested-name>
                        ::= <local-name>
			::= <substitution>

#
# A non-template or template-id name in :: or ::std scope.
#

    <unscoped-name>     ::= <unqualified-name>
			::= St <unqualified-name>   # ::std::

#
# A template name in :: or ::std scope.  
#

    <unscoped-template-name>    
                        ::= <unqualified-name>
			::= St <unqualified-name>   # ::std::
                        ::= <substitution>

#
# A name not in :: or ::std scope.
#

    <nested-name>       ::= N [<CV-qualifiers>] <prefix> E

#
# A prefix of a scoped name. 
#

    <prefix>            ::= <prefix> <component>
                        ::= <template-prefix> <template-args>
			::= # empty
			::= <substitution>

#
# A scoped template name that occurs in a prefix.  
#

    <template-prefix>   ::= <prefix>
                        ::= <substitution>

#
# A component of a scoped name.  
#

    <component>         ::= <unqualified-name>
                        ::= <builtin-type>
                        ::= <function-type>
			::= <array-type>
			::= <pointer-to-member-type>

#
# A name without scope or template qualifications.
#

    <unqualified-name>  ::= <function-name> <bare-function-type>
			::= <special-data-name>  # vtable, VTT, typeinfo, ...
			::= <source-name>        # namespace, class, data, ...

#
# A name of a function without scope or template qualifications or
# function signature.
#

    <function-name>     ::= <special-function-name>  # ctor, dtor
                        ::= <operator-name>
                        ::= <source-name>



From dehnert at baalbek.engr.sgi.com  Tue May 16 02:08:46 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 15 May 2000 19:08:46 -0700 (PDT)
Subject: mangling of function names
Message-ID: <200005160208.TAA09916@baalbek.engr.sgi.com>


Martin von Loewis wrote:
> (Mark Mitchell wrote:)
> > However, given that we aren't going to substitute it anyway, we could
> > just relax our semantic considerations and place the (untyped) name of
> > the function into the substitution candidate list, expecting that it
> > would not be substituted later (though I suspect we could invent cases
> > in which it might).

I think that if we want different implementations to match, we need to be
much more careful than this.  Putting things in the substitution list without
the intent of substituting them seems pretty dangerous...

> That's what I'd prefer - put it in the candidate list, even if you
> know it won't be used. There are actually cases where it then would
> get substituted:
> 
> struct klasse{
>   struct methode{};
>   void methode(struct methode);
> };
> 
> void klasse::methode(struct methode){}
> 
> Now, if it is considered too difficult for implementations to detect
> that substitution is needed here, or if it is unclear from the spec
> whether substitution should happen - then that would make a point for
> complicating the spec. Otherwise, I think this _ZN6klasse7methodeES0_.

We were specifically attempting to exclude such cases.  The reason is that
a likely implementation is to mark entities from the substitution dictionary
in the symbol table, so that a search for the correct number need only be
done after a match is discovered.  So we specifically exclude substitution
of names that don't refer to the same objects.  So I think your example
should mangle as _ZN6klasse7methodeE7methode .  The example does raise
another question, though.  Is the above definition equivalent to:

void klasse::methode(struct klasse::methode){}

That would mangle as _ZN6klasse7methodeENS_7methodeE.  If both are
legitimate, and both may appear, we need to choose one or the other.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From samuel at codesourcery.com  Tue May 16 02:14:27 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Mon, 15 May 2000 19:14:27 -0700 (PDT)
Subject: mangling of function names
In-Reply-To: <200005160208.TAA09916@baalbek.engr.sgi.com>
References: <200005160208.TAA09916@baalbek.engr.sgi.com>
Message-ID: <14624.44803.408281.855315@coriander.indetermi.net>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

  Jim> void klasse::methode(struct klasse::methode){}

  Jim> That would mangle as _ZN6klasse7methodeENS_7methodeE.  If both
  Jim> are legitimate, and both may appear, we need to choose one or
  Jim> the other.

It has to be the second one (the fully scoped type); otherwise, it's
ambiguous.  There could always be another struct methode in the global
namespace.



From dehnert at baalbek.engr.sgi.com  Tue May 16 07:50:27 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 16 May 2000 00:50:27 -0700 (PDT)
Subject: Page updates, scope section
Message-ID: <200005160750.AAA10897@baalbek.engr.sgi.com>

I've updated the pages, to nearly reflect last week's meeting.
I would appreciate feedback especially on the new Section 1.4 on
Scope of the ABI, in which I've attempted to capture our deliberations
on the library interface and export templates.  It's not overly
precise, and perhaps can't be, but I'd like it to be a fair statement
of the situation.

Jim
-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Tue May 16 16:48:31 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 16 May 2000 09:48:31 -0700
Subject: Vcall offsets
Message-ID: <20000516094831Y.mitchell@codesourcery.com>


I apologize to everyone for being confusing via proxy last week.

Here was the example I was trying to get at:

  class A { virtual void f (); };
  class B1 : public A {};
  class B2 : public A {};
  class D : public B1, public B2 {};

Now, suppose that `D' is used as a virtual base.  The question is
whether or not there should be vcall offsets for both instances of
`f', even though they have the same signature.  This paragraph:

  If the above listing of vcall offsets includes more than one for a
  particular virtual function signature, only the first one (closest
  to the vtable address point) is allocated. That is, an offset from
  primary base P (and its non-virtual bases) eliminates any from A or
  its other bases, an offset from A eliminates any from the
  non-primary bases, and an offset from a non-primary base B of A
  eliminates any from the bases of B.

implies that there should be only one such offset, which I believe to
be reasonable.  But, what about:

  class A { virtual void f (); };
  class B1 : public A { virtual void f (); };
  class B2 : public A {};
  class D : public B1, public B2 {};

Here, do we get two offsets (for B1::f and A::f) or just one?

Frankly, I think we should just drop the paragraph quoted above.  I
challenge anyone to present a real-world program that suffers any
significant space or time penalty because of wasting a few extra vcall
offset entries in the vtable.  The implementation complexity, and the
time we have to spend thinking about the issues, is not worth it.  I
suggest we just replace that paragraph with:

  (Note: there may be more than one vcall offset entry for the same
   virtual function if that virtual function appears more than once
   in the various vtables considered.)

Thoughts?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Wed May 17 20:59:23 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 17 May 2000 13:59:23 -0700
Subject: VTT typo
Message-ID: <20000517135923Z.mitchell@codesourcery.com>


  Virtual VTTs: The sub-VTTs for each virtual subobject in inheritance
  graph preorder), i.e. the sub-VTT for virtual base W of virtual base
  V of D comes before the sub-VTT for V.

That's not preorder.  Preorder is derived-before-base, i.e., V before
W.  I think we agreed on preorder so that sentence needs changing.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From coleen at zko.dec.com  Wed May 17 21:16:26 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Wed, 17 May 2000 17:16:26 -0400
Subject: VTT typo
References: <20000517135923Z.mitchell@codesourcery.com>
Message-ID: <39230C2A.1DE60E9D@zko.dec.com>

Mark Mitchell wrote:
> 
>   Virtual VTTs: The sub-VTTs for each virtual subobject in inheritance
>   graph preorder), i.e. the sub-VTT for virtual base W of virtual base
>   V of D comes before the sub-VTT for V.
> 
> That's not preorder.  Preorder is derived-before-base, i.e., V before
> W.  I think we agreed on preorder so that sentence needs changing.
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com


True, that was left over from when it was postorder.  Thanks for catching
it.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From mark at codesourcery.com  Wed May 17 21:45:54 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 17 May 2000 14:45:54 -0700
Subject: VTT clarification
Message-ID: <20000517144554R.mitchell@codesourcery.com>


The VTT description is slightly confusing:

  - The description for `secondary virtual pointers' specifies which
    subobjects get secondary virtual pointers.  As written, it
    suggests that even secondary virtual pointers for primary base
    classes are included.

  - The note before the example says:

    secondary virtual pointers are present for all bases with either
    virtual bases or virtual function declarations overridden along a
    virtual path. The only exception is that a primary non-virtual
    base class does not require a secondary virtual pointer.

If there are not supposed to be secondary virtual pointers for primary
bases (and I think that there should not be), then that should go in
the description of secondary virtual pointers; the notes should be
informational, rather than normative.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at sgi.com  Wed May 17 23:54:07 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Wed, 17 May 2000 16:54:07 -0700
Subject: VTT clarification
References: <20000517144554R.mitchell@codesourcery.com>
Message-ID: <3923311F.A3BF6A8E@sgi.com>

A virtual primary base may move in a further-derived type.  Does that
matter, i.e. would it change the VTT layout when embedded in a VTT for
a more-derived type?

Jim

Mark Mitchell wrote:
> 
> The VTT description is slightly confusing:
> 
>   - The description for `secondary virtual pointers' specifies which
>     subobjects get secondary virtual pointers.  As written, it
>     suggests that even secondary virtual pointers for primary base
>     classes are included.
> 
>   - The note before the example says:
> 
>     secondary virtual pointers are present for all bases with either
>     virtual bases or virtual function declarations overridden along a
>     virtual path. The only exception is that a primary non-virtual
>     base class does not require a secondary virtual pointer.
> 
> If there are not supposed to be secondary virtual pointers for primary
> bases (and I think that there should not be), then that should go in
> the description of secondary virtual pointers; the notes should be
> informational, rather than normative.
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Thu May 18 00:20:45 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 17 May 2000 17:20:45 -0700
Subject: VTT clarification
In-Reply-To: <3923311F.A3BF6A8E@sgi.com>
References: <20000517144554R.mitchell@codesourcery.com>
	<3923311F.A3BF6A8E@sgi.com>
Message-ID: <20000517172045W.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at sgi.com> writes:

    Jim> A virtual primary base may move in a further-derived type.
    Jim> Does that matter, i.e. would it change the VTT layout when
    Jim> embedded in a VTT for a more-derived type?

I think that's why the note talks about non-virtual primary bases.  I
think it's precisely the non-virtual primary bases for which we could
(or should) elide secondary vptrs.

Again, I'm afraid we're optimizing rather prematurely.  In particular,
the bit:

    For each subobject X with either (a) virtual bases or (b) virtual
    function declarations overridden along a virtual path between the
    declaration and D, the address of the secondary vtable for X-in-D.

seems a little extreme.  The calculation of how a function is
overridden is non-trivial, increasing the potential for errors and
incompatibilities, all to save a few words in the VTT.  I'm not
confident that's a good tradeoff.

On the one hand, we need to implement this stuff now and see that it
works.  On the other hand, if we're going to simplify these things,
then there's little point in doing the implementation only to remove
it later.  So, it would be good if we resolve this, and the vcall
offset issue I raised yesterday, ASAP.

I apologize for missing last week's meeting -- I know that was a more
appropriate forum for this kind of discussion.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Thu May 18 00:33:23 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Wed, 17 May 2000 17:33:23 -0700
Subject: VTTs, yet again
Message-ID: <20000517173323R.mitchell@codesourcery.com>


The description of the VTT (in VTT order) doesn't specify which vptrs
point into the main vtable group and which into construction vtable
groups.  It should.

I think the rule is:

  o If this VTT is a primary VTT, then the primary and secondary
    vptrs point into the main vtable group.

  o Otherwise, this VTT is a secondary VTT for a base B that itself
    uses virtual bases.  In that case, use vptrs that point into the
    construction vtable for B-in-D.

Right?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From alainm at cup.hp.com  Sat May  6 23:08:34 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Sat, 06 May 2000 16:08:34 -0700
Subject: typo ?
Message-ID: <3914A5F2.52898D58@cup.hp.com>


I think there is a missing 'E' in the mangling example :

void operator-</*int J=*/42>(A<J+2>::T); 
_ZngILi42EE vN1AIXplT1_Li2EE1TE 

_Z
 ng // operator-
  I  // start temp args
    Li42E // literal (int)42
  E  // end temp args
  v // return void
  N  // start nesting
   1A 
   I // start temp args
     X // start expr
       pl // +
         T1_ // J
         Li2E // literal int(2) 
     E // end expr
      // end temp arg <---- missing 'E' ?
   1T  // nested T
  E // end nesting 

 
Alain



From coleen at zko.dec.com  Thu May 18 16:58:23 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 18 May 2000 12:58:23 -0400
Subject: VTT clarification
Message-ID: <3924212F.5B1C5C84@zko.dec.com>


-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
An embedded message was scrubbed...
From: Coleen Phillimore <coleen at zko.dec.com>
Subject: Re: VTT clarification
Date: Thu, 18 May 2000 12:57:20 -0400
Size: 4014
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000518/c0f18e22/attachment.mht>

From alainm at cup.hp.com  Sun May  7 20:18:45 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Sun, 07 May 2000 13:18:45 -0700
Subject: mangling
Message-ID: <3915CFA5.660D509A@cup.hp.com>


I beleive that it was decided that template param would be
encoded starting from "" (ie T_ T0_ T1_) and that function
name would not be considered as potential candidates. If
true, I think the following changes are neded in the examples:

_Z1fI1XEvPVN1AIT1_E1TE -> 
_Z1fI1XEvPVN1AIT_E1TE   ( T_: T1 )

_Z5firstI3DuoEvS0_ -> 
_Z5firstI3DuoEvS_ ( S_: Duo )

_Z5firstI3DuoEvT1_ -> 
_Z5firstI3DuoEvT_  (T_ : T1)


_ZngILi42EEvN1AIXplT1_Li2EEE1TE.o ->
_ZngILi42EEvN1AIXplT_Li2EEE1TE  (T_: J (42))
 
I also think that there is a problem with the manglng
of Ret? operator+(X&, X&), the following change should be made:

_ZplR1XRS0_ -> _ZplR1XS0_ 

Thanks,

Alain



From dehnert at baalbek.engr.sgi.com  Sun May 21 07:29:26 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 00:29:26 -0700 (PDT)
Subject: Vcall offsets
Message-ID: <200005210729.AAA23267@baalbek.engr.sgi.com>

Sorry for the delay in responding.

> From: Mark Mitchell <mark at codesourcery.com>
> Date: Tue, 16 May 2000 09:48:31 -0700
> 
> I apologize to everyone for being confusing via proxy last week.
> 
> Here was the example I was trying to get at:
> 
>   class A { virtual void f (); };
>   class B1 : public A {};
>   class B2 : public A {};
>   class D : public B1, public B2 {};
> 
> Now, suppose that `D' is used as a virtual base.  The question is
> whether or not there should be vcall offsets for both instances of
> `f', even though they have the same signature.  This paragraph:
> 
>   If the above listing of vcall offsets includes more than one for a
>   particular virtual function signature, only the first one (closest
>   to the vtable address point) is allocated. That is, an offset from
>   primary base P (and its non-virtual bases) eliminates any from A or
>   its other bases, an offset from A eliminates any from the
>   non-primary bases, and an offset from a non-primary base B of A
>   eliminates any from the bases of B.
> 
> implies that there should be only one such offset, which I believe to
> be reasonable.

Correct.

> But, what about:
> 
>   class A { virtual void f (); };
>   class B1 : public A { virtual void f (); };
>   class B2 : public A {};
>   class D : public B1, public B2 {};
> 
> Here, do we get two offsets (for B1::f and A::f) or just one?

Just one, for the same reason.  And since the base visit order is B1,
A, B2, you get it in the position implied by the B1 instance.  And you
shouldn't need more.  Either of them will correct the invocation class
pointer (B1 or A) to the virtual base pointer (D), and then use the
unique vcall offset in D to get to whatever the class with the
overriding definition is.

> Frankly, I think we should just drop the paragraph quoted above.  I
> challenge anyone to present a real-world program that suffers any
> significant space or time penalty because of wasting a few extra vcall
> offset entries in the vtable.  The implementation complexity, and the
> time we have to spend thinking about the issues, is not worth it.  I
> suggest we just replace that paragraph with:
> 
>   (Note: there may be more than one vcall offset entry for the same
>    virtual function if that virtual function appears more than once
>    in the various vtables considered.)

I guess I don't think this is a problem as it stands.  Am I missing
something?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sun May 21 07:45:25 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 00:45:25 -0700 (PDT)
Subject: VTT clarification
Message-ID: <200005210745.AAA22301@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> The VTT description is slightly confusing:
> 
>   - The description for `secondary virtual pointers' specifies which
>     subobjects get secondary virtual pointers.  As written, it
>     suggests that even secondary virtual pointers for primary base
>     classes are included.
> 
>   - The note before the example says:
> 
>     secondary virtual pointers are present for all bases with either
>     virtual bases or virtual function declarations overridden along a
>     virtual path. The only exception is that a primary non-virtual
>     base class does not require a secondary virtual pointer.
> 
> If there are not supposed to be secondary virtual pointers for primary
> bases (and I think that there should not be), then that should go in
> the description of secondary virtual pointers; the notes should be
> informational, rather than normative.

I fixed this (the description of secondary virtual pointers), I think.
Does it look OK now?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sun May 21 08:06:27 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 01:06:27 -0700 (PDT)
Subject: VTT clarification
References: <20000517144554R.mitchell@codesourcery.com>
    <3923311F.A3BF6A8E@sgi.com>
Message-ID: <200005210806.BAA23074@baalbek.engr.sgi.com>

> To: dehnert at sgi.com
> 
> ...
> 
> Again, I'm afraid we're optimizing rather prematurely.  In particular,
> the bit:
> 
>     For each subobject X with either (a) virtual bases or (b) virtual
>     function declarations overridden along a virtual path between the
>     declaration and D, the address of the secondary vtable for X-in-D.
> 
> seems a little extreme.  The calculation of how a function is
> overridden is non-trivial, increasing the potential for errors and
> incompatibilities, all to save a few words in the VTT.  I'm not
> confident that's a good tradeoff.

At the risk of exhibiting my ignorance (but then you all knew about
that anyway), this doesn't seem so bad.  Each time you process such an
overriding function, you need to know it because you need to generate
the thunk, which references the vcall offset in the virtual base.  If
you simply attach a note to the current class of the virtual base being
overridden (you don't need to remember the function), then the
identification above is done by checking the subobjects for (a) having
virtual bases, or (b) being noted by one of the non-virtual subobjects.

> On the one hand, we need to implement this stuff now and see that it
> works.  On the other hand, if we're going to simplify these things,
> then there's little point in doing the implementation only to remove
> it later.  So, it would be good if we resolve this, and the vcall
> offset issue I raised yesterday, ASAP.

Sorry -- not as ASAP as I hoped, but does the above work?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sun May 21 08:11:45 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 01:11:45 -0700 (PDT)
Subject: VTTs, yet again
Message-ID: <200005210811.BAA23351@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> The description of the VTT (in VTT order) doesn't specify which vptrs
> point into the main vtable group and which into construction vtable
> groups.  It should.

I don't think it needs to.  The VTT is the interface, and we describe
how it is used.  You are free to make a construction vtable for every
subobject if you like -- it will just be often suboptimal.

> I think the rule is:
> 
>   o If this VTT is a primary VTT, then the primary and secondary
>     vptrs point into the main vtable group.
> 
>   o Otherwise, this VTT is a secondary VTT for a base B that itself
>     uses virtual bases.  In that case, use vptrs that point into the
>     construction vtable for B-in-D.
> 
> Right?

That sounds right to me, but you could move all the first set into the
second set without being incorrect -- just suboptimal.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sun May 21 08:34:26 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 01:34:26 -0700 (PDT)
Subject: mangling
Message-ID: <200005210834.BAA23388@baalbek.engr.sgi.com>

> I beleive that it was decided that template param would be
> encoded starting from "" (ie T_ T0_ T1_) and that function
> name would not be considered as potential candidates. If
> true, I think the following changes are neded in the examples:
> 
> _Z1fI1XEvPVN1AIT1_E1TE -> 
> _Z1fI1XEvPVN1AIT_E1TE   ( T_: T1 )
> 
> _Z5firstI3DuoEvS0_ -> 
> _Z5firstI3DuoEvS_ ( S_: Duo )
> 
> _Z5firstI3DuoEvT1_ -> 
> _Z5firstI3DuoEvT_  (T_ : T1)
> 
> 
> _ZngILi42EEvN1AIXplT1_Li2EEE1TE.o ->
> _ZngILi42EEvN1AIXplT_Li2EEE1TE  (T_: J (42))
>  
> I also think that there is a problem with the manglng
> of Ret? operator+(X&, X&), the following change should be made:
> 
> _ZplR1XRS0_ -> _ZplR1XS0_ 

These are all fixed now.  Thanks.

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sun May 21 09:01:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Sun, 21 May 2000 02:01:13 -0700 (PDT)
Subject: Updates and outstanding questions
Message-ID: <200005210901.CAA23238@baalbek.engr.sgi.com>

As you might gather from the flurry of messages, I've finished integrating
the last meeting, along with much of the email, into the HTML pages on
the web (PDF tomorrow, perhaps).  If possible take a quick look.  I'll be
in Monday PM and might integrate further _minor_ fixes then.  After that,
getting the main site updated might be tricky before I return on 19 June.

There appear to be a couple of questions that ought to be resolved by
email soon, rather than by a meeting in a month if possible:

1) Mark's question about whether it's really worth attempting to avoid
   duplicate vcall offsets for multiple instances of a function with the
   same signature in different bases.

2) Mark's question about identifying which subobjects need secondary
   vtable pointers in the VTT.

3) Alex's suggestion that we allow the ::std:: abbreviation outside
   the N...E nested name delimiters.

4) Alex's suggested alternate (partial) mangling grammar.  (Note that
   this is intended as further clarification, not as a change in the
   agreed definition, except for (3) above.)

In the absence of concensus via email, I think we ought to assume that
the current definitions hold, but I can live with any resolutions that
achieve concensus.  (In the case of (4), you can assume that there will
be further grammar modifications -- I didn't attempt that just because
I didn't want to further destabilize things just before taking off.  I
hope the parties working on this understand the intent well enough now
to be able to tell the difference between the intent and the grammar.)

Again, quick fixes could go in Monday, others will wait until mid-June.

Til then,
Jim

-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Sun May 21 16:42:07 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 21 May 2000 09:42:07 -0700
Subject: VTT clarification
In-Reply-To: <200005210745.AAA22301@baalbek.engr.sgi.com>
References: <200005210745.AAA22301@baalbek.engr.sgi.com>
Message-ID: <20000521094207Z.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I fixed this (the description of secondary virtual pointers),
    Jim> I think.  Does it look OK now?

Yes, thank you!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Sun May 21 16:44:26 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 21 May 2000 09:44:26 -0700
Subject: VTTs, yet again
In-Reply-To: <200005210811.BAA23351@baalbek.engr.sgi.com>
References: <200005210811.BAA23351@baalbek.engr.sgi.com>
Message-ID: <20000521094426I.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    >> From: Mark Mitchell <mark at codesourcery.com>
    >> 
    >> The description of the VTT (in VTT order) doesn't specify which
    >> vptrs point into the main vtable group and which into
    >> construction vtable groups.  It should.

    Jim> I don't think it needs to.  The VTT is the interface, and we
    Jim> describe how it is used.  You are free to make a construction
    Jim> vtable for every subobject if you like -- it will just be
    Jim> often suboptimal.

Fair enough.  

But, I think we should add the rule I gave in a non-normative note;
it's good to have concrete suggestions for implementors.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From samuel at codesourcery.com  Sun May 21 17:50:14 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Sun, 21 May 2000 10:50:14 -0700 (PDT)
Subject: Updates and outstanding questions
In-Reply-To: <200005210901.CAA23238@baalbek.engr.sgi.com>
References: <200005210901.CAA23238@baalbek.engr.sgi.com>
Message-ID: <14632.8662.406384.794633@coriander.indetermi.net>

dehnert at baalbek.engr.sgi.com (Jim Dehnert) writes:

  Jim> 3) Alex's suggestion that we allow the ::std:: abbreviation
  Jim> outside the N...E nested name delimiters.

Just to clarify, this is not a new suggestion on my part.  It already
appears all the way at the end of the `Compression' section (5.1.7).
The <name> production for this special case is easy to miss hidden
there, though, so I think it should be included with the rest of the
<name> productions for whichever grammar wins out in the end.

Here's the current text:

    The abbreviation St is always an initial qualifier, i.e. appearing
    as the first element of a compound name. It does not require N...E
    delimiters unless either followed by more than one additional
    composite name component, or preceded by CV-qualifiers for a
    member function. This adds the case:

       <name> ::= St <unqualified-name> # ::std::

    For example: 

       "_ZSt5state": ::std::state
       "_ZNSt3_In4wardE": ::std::_In::ward

Regards
Alex




From alainm at cup.hp.com  Fri May 26 17:54:36 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 26 May 2000 10:54:36 -0700
Subject: mangling type_info for local related types
Message-ID: <392EBA5C.34D9933F@cup.hp.com>


Hi,

By reading the spec, I'am not sure to understand how 
local types and type_info mangling interfere. It seems that,
with the current mangling, we have:

struct a_class {};

typeid(a_class) -> _ZN6a_classTIE

void a_func() {
  struct a_class {};
  typeid(a_class);   -> _ZZ5a_funcvEN6a_classTIE // local name
  typeid(a_class*);  -> _ZNPZ5a_funcvE6a_classTIE // non local
};

Is that the intended mangling ?

Alain



From alainm at cup.hp.com  Fri May 26 21:48:14 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 26 May 2000 14:48:14 -0700
Subject: mangling type_info for local related types
References: <392EBA5C.34D9933F@cup.hp.com>
Message-ID: <392EF11E.E9932A93@cup.hp.com>

Alain Miniussi wrote:
> 
> Hi,
> 
> By reading the spec, I'am not sure to understand how
> local types and type_info mangling interfere. It seems that,
> with the current mangling, we have:
> 
> struct a_class {};
> 
> typeid(a_class) -> _ZN6a_classTIE
> 
> void a_func() {
>   struct a_class {};
>   typeid(a_class);   -> _ZZ5a_funcvEN6a_classTIE // local name
>   typeid(a_class*);  -> _ZNPZ5a_funcvE6a_classTIE // non local

By the way, I am not sure the current mangling allow to
form a pointer to a local struct, only <name> can be local,
not <type>, maybe we need a <local-class-enum> production ?

<class-enum> ::= <local-class-enum>
             ::= ...
<local-class-enum> :: Z<function encoding>E<class-enum>[<discriminator>]

Also, pointer type are not mentionned in <component-name>.

> };
> 
> Is that the intended mangling ?
>
> Alain



