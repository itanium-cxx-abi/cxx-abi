<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> New issue:  __int64 and friends
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20New%20issue%3A%20%20__int64%20and%20friends&In-Reply-To=%3C200003100009.QAA52081%40baalbek.engr.sgi.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000736.html">
   <LINK REL="Next"  HREF="000732.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>New issue:  __int64 and friends</H1>
    <B>Jim Dehnert</B> 
    <A HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20New%20issue%3A%20%20__int64%20and%20friends&In-Reply-To=%3C200003100009.QAA52081%40baalbek.engr.sgi.com%3E"
       TITLE="New issue:  __int64 and friends">dehnert at baalbek.engr.sgi.com
       </A><BR>
    <I>Fri Mar 10 00:09:12 UTC 2000</I>
    <P><UL>
        <LI>Previous message: <A HREF="000736.html">runtime mangling
</A></li>
        <LI>Next message: <A HREF="000732.html">New issue:  __int64 and friends
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#731">[ date ]</a>
              <a href="thread.html#731">[ thread ]</a>
              <a href="subject.html#731">[ subject ]</a>
              <a href="author.html#731">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>The IA-64 software conventions define a number of implementation
types:  __int64, __int128 (and unsigned versions), __float80, and
__float128.  For those that match builtin types, i.e. __int64 and
__float80, this raises the question of whether they are intended
to be treated as typedefs of builtin types, or as new types.

In C, the significance is limited.  When matching function declarations
(prototypes and definitions), typedefs match but distinct types don't.
I can't think of any other place where default conversions and
identical representation won't hide the difference.

In C++, the effects are more dramatic.  Most important, perhaps, is
that distinct types will cause different mangling.  So the C++ ABI
group needs to know the choice.

My preference would be the typedef treatment, specifically:

	__int64 == long long (because it can be the same for both
				32-bit and 64-bit ABIs)
	__float80 == long double

On a related note, the SW Conventions document says (in a footnote)
that it is defining the __float128 so that everyone implementing it
will have matching representations, but it doesn't specify the
representation.

Jim

-		Jim Dehnert  x3-4272


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000736.html">runtime mangling
</A></li>
	<LI>Next message: <A HREF="000732.html">New issue:  __int64 and friends
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#731">[ date ]</a>
              <a href="thread.html#731">[ thread ]</a>
              <a href="subject.html#731">[ subject ]</a>
              <a href="author.html#731">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">More information about the cxx-abi-dev
mailing list</a><br>
</body></html>
