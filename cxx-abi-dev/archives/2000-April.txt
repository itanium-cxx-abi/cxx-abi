From mark at codesourcery.com  Sun Apr  2 03:18:58 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sat, 01 Apr 2000 19:18:58 -0800
Subject: Typo in data layout document
Message-ID: <20000401191858H.mitchell@codesourcery.com>


Under virtual base allocation:

  Any indirect primary base class E of the current class C, has been
  chosen as the primary base class of some other base class (direct or
  indirect, virtual or non-virtual) of C, will be allocated as part of
  that other base class, and is not allocated here.

That's not a sentence. :-) There should be a `that' before `has been
chosen'.

I think it would be useful to note the following example near that
paragraph.  (The C++ standard contains examples intermixed with the
rules, and it makes it much easier to read.)

  Consider:

    struct R { virtual void r (); };
    struct S { virtual void s (); };
    struct T : virtual public S { virtual void t (); };
    struct U : public R, virtual public T { virtual void u (); };

  R is the primary base class for U since it is the first direct
  non-virtual dynamic base.  Then, since an inheritance-order walk of
  U is { U, R, T, S } the T base is allocated next.  Since S is a 
  primary base of T, there is no need to allocate it separately.
  However, given:

    struct V : public R, virtual public S, virtual public T { 
      virtual void v ();
    };

  the inheritance-order walk of V is { V, R, S, T } so S is allocated
  first as a virtual base.  Then, T is allocated separately.  Thus
  sizeof (V) > sizeof (U).

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jfw at sgi.com  Mon Apr  3 18:07:35 2000
From: jfw at sgi.com (John Wilkinson)
Date: Mon, 03 Apr 2000 11:07:35 -0700
Subject: Mangling of local names
Message-ID: <38E8DDE7.970D3C26@sgi.com>

A correction to my recent proposal:

  <discriminator> := <number>_

won't do, since the discriminator is optional.  This makes it too hard
to distinguish a discriminator from the start of a name.  Let's add an
underscore at the beginning:

  <discriminator> := _<number>_



-- 
John Wilkinson



From mark at codesourcery.com  Mon Apr  3 19:38:52 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 12:38:52 -0700
Subject: vcall offset description ...
Message-ID: <20000403123852U.mitchell@codesourcery.com>


... is still a little unclear:

  the vtable for a virtual base A also includes a vcall offset entry
  for each virtual function represented in A's primary vtable and the
  secondary vtables from A's non-virtual bases.  The vcall offset
  entries are allocated from the inside out, in the same order as the
  functions appear in A's vtables.

We need to make sure we agree on the order.  How about this:

  The vcall offset entries corresponding to a single base of A are
  ordered in the same was the virtual functions in the bases vtable.
  For example, if the vtable contains entries for `f', and `g', 
  respectively, then the vcall offset for `f' precedes the vcall
  offset for `g'.  The vcall offsets for the various bases, however,
  are allocated in reverse inheritance graph order.  (So, for example,
  the vcall offsets for `A' will be located closer to the point where
  the vptr points than those for any base of `A'.)

I don't think it can matter *what* order we pick; we just need one.  I
think what I wrote is most consistent with the original wording.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Mon Apr  3 22:57:24 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 3 Apr 2000 15:57:24 -0700 (PDT)
Subject: incomplete rtti
References: <200003282311.PAA23050@baalbek.engr.sgi.com>
Message-ID: <200004032257.PAA36253@baalbek.engr.sgi.com>

> From: Nathan Sidwell <nathan at codesourcery.com>
> 
> >This assumption is untrue.  The problem is that weak types don't work
> >like you assume on most systems.  With the exception of Linux and Irix,
> >most systems do not distinguish between weak and "strong" symbols once
> >an object is linked.  Therefore, given a weak RTTI in the main
> >executable and a strong RTTI in a DSO, they would preempt the latter
> >with the former.  As a result, it is necessary to make our incomplete
> >class RTTI not just weak, but distinct.  Once it is distinct, the
> >pointer RTTI referencing it must be distinct from one referencing the
> >complete version, and so on up the pointer chain, and it is not
> >possible to compare them at any level.
> 
> Ok, thanks for the clarification about that. Let me just see if I
> understand DSO linking properly. If we have a loaded object file which
> refered to a non-defined weakly declared symbol, that object file will
> have resolved the symbol to zero. Loading a DSO which defines that
> symbol will not affect the already loaded object file, which remains
> having the value zero. Ok?

That's correct on some of the Unix implementations.  On others (e.g.
Irix), it will be "fixed" by the DSO.

> >Our solution is to use the ABI-defined external mangled RTTI name only
> >for complete types.  RTTI generated for pointer-to-incomplete-type must
> >be different.  We leave it to the implementation to decide how, but two
> >workable approaches are (a) make it a local static, or (b) mangle it
> >differently and use COMDAT to remove duplicates; but at least one
> >incomplete RTTI would remain, and it would not be the same as the
> >complete one even after preemption.
> 
> Ok, this needs more documentation. There are three uses for the rtti
> information, which we _don't_ have to solve with the same rtti object.
> We have attempted to use a single type_info for all three uses, but
> that is not necessary, and in some cases we have separate objects (of
> the same type, __pointer_type_info) for the same type (T *...*, for
> incomplete T).
> 
> 1) A distinct lvalue for the typeid operator
> 2) A class heirarchy descriptor for dynamic_cast
> 3) A class heirarchy and pointer qualification descriptor for catch
> matching.
> 
> Consider a source file `foo' consisting of these snippets
>         struct A;
>         typeid (A *); //1
>         catch (A **); //2
> 1 would produce a __pointer_type_info of the following shape
> tf_P1A: comdat  ; call this foo.tf_P1A
>         name = "P1A"
>         flags = 0
>         target = weak tf_1A
> 
> The TU would not need to emit the (incomplete) type_info for A itself,
> but leave a dangling weak reference. That will become zero, unless
> another TU is linked in which provides it.
> 
> 2 must produce information about the entire pointer chain, from the
> layout doc that would be
> _tf_PP1A: static
>         name = "PP1A"
>         flags = 8
>         target = _tf_P1A
> _tf_P1A: static
>         name = "P1A"
>         flags = 8
>         target = _tf_1A
> _tf_1A: static
>         name = "1A"
> 
> Ok?
> 
> Now, if we another source `baz' with a definition of A,
>         struct B {};
>         struct A : B {};
>         typeid (A *); //1a
>         catch (A **); //2a
>         throw (A *)NULL;  //3a
> 
> 1a would produce the same __pointer_type_info as before, but this time
> we would emit comdat typeinfo for the catch clause 2a, and throw 3a is
> also permitted.
> tf_PP1A: comdat
>         name = "PP1A"
>         flags = 0
>         target = tf_P1A
> tf_P1A: comdat  ; call this baz.tf_P1A
>         name = "P1A"
>         flags = 0
>         target = tf_1A
> tf_1A: comdat
>         name = "1A"
>         base = tf_1B
> tf_1B: comdat
>         name = "1B"
> 
> of course tf_P1A is the same object that 1a forced us to emit.
> 
> Now the $BIGNUM dollar question. What if `foo' is our executable and
> `baz' is the DSO? foo.tf_P1A will be the `active' definition of tf_P1A,
> and it will have a NULL target value. Therefore baz.tf_P1A is not
> selected and baz.tf_PP1A's target will resolve to foo.tf_P1A. Also the
> throw 3a will refer to tf_P1A, which will be resolved by foo.tf_P1A.
> That has an incomplete target type, so 3a won't have information about
> A being derived from B, and thus won't match a catch (B *) clause.

Right, which is why foo can't emit a global comdat for P1A with the
ABI mangled name and a weak pointer to nothing.  It must behave like
the low levels of your PP1a chain -- static, pointing to an
incomplete-type class_type_info, and it should have the incomplete
target flag set.  I think the rule in the document is clear:

    If the target type of the pointer is an incomplete class type,
    directly or indirectly,
    a dummy class RTTI is generated for the incomplete type
    that will not resolve to the final complete class RTTI
    (because the latter need not exist),
    possibly by making it a local static object,
    and the incomplete target type flag is set
    in each pointer RTTI that references it directly or indirectly.

> Perhaps I'm being dense, and there's still something about comdat
> linkage I don't understand. But to my understanding the previous
> paragraph is the same problem with DSO's I originally raised before
> this incomplete type info was addressed.

It is.  That's why we are NOT depending on weak linkage.  Only
complete-type RTTI are specified to have the defined mangled global
names, and everything else (i.e. the pointers to incomplete class types
and the target types themselves) is specified to be static or otherwise
conflict-free.  Such things are always accessed via pointers with the
incomplete-target flag set, which is the signal to do comparisons using
the mangled names in the ultimate target RTTI instead of comparing
addresses.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at sgi.com  Mon Apr  3 23:48:09 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Mon, 03 Apr 2000 16:48:09 -0700
Subject: Virtual base allocation (was: Typo ...)
References: <20000401191858H.mitchell@codesourcery.com>
Message-ID: <38E92DB9.D25C52FA@sgi.com>

I believe this is not correct.  We ultimately decided not to make
separate allocation of primary bases dependent on whether they
occurred earlier than their derived class in the hierarchy.  Is
this what others recall?  (That's what the document says now.)

(I did add the example, suitably modified.)

Jim

Mark Mitchell wrote:
> I think it would be useful to note the following example near that
> paragraph.  (The C++ standard contains examples intermixed with the
> rules, and it makes it much easier to read.)
> 
>   Consider:
> 
>     struct R { virtual void r (); };
>     struct S { virtual void s (); };
>     struct T : virtual public S { virtual void t (); };
>     struct U : public R, virtual public T { virtual void u (); };
> 
>   R is the primary base class for U since it is the first direct
>   non-virtual dynamic base.  Then, since an inheritance-order walk of
>   U is { U, R, T, S } the T base is allocated next.  Since S is a
>   primary base of T, there is no need to allocate it separately.
>   However, given:
> 
>     struct V : public R, virtual public S, virtual public T {
>       virtual void v ();
>     };
> 
>   the inheritance-order walk of V is { V, R, S, T } so S is allocated
>   first as a virtual base.  Then, T is allocated separately.  Thus
>   sizeof (V) > sizeof (U).
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Apr  4 00:22:59 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 17:22:59 -0700
Subject: Virtual base allocation (was: Typo ...)
In-Reply-To: <38E92DB9.D25C52FA@sgi.com>
References: <20000401191858H.mitchell@codesourcery.com>
	<38E92DB9.D25C52FA@sgi.com>
Message-ID: <20000403172259Q.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at sgi.com> writes:

    Jim> I believe this is not correct.  We ultimately decided not to
    Jim> make separate allocation of primary bases dependent on
    Jim> whether they occurred earlier than their derived class in the
    Jim> hierarchy.  Is this what others recall?  (That's what the
    Jim> document says now.)

That's not what the layout said to me when I read it. :-)

I can see how it could mean either thing:

  Finally allocate any direct or indirect virtual base classes (except
  the primary base class or any indirect primary base classes) as we did
  non-virtual base classes in step II-2 (if empty) or II-3 (if
  non-empty), in inheritance graph order. Update sizeof(C) to max
  (sizeof(C), offset(D)+nvsize(D)). If non-empty, also update align(C)
  and dsize(C) as in II-2.

It's unclear how the looping is going here:

  for each virtual base
    if not already primary
      allocate

or:

  let vbs = not already primary virtual bases
  for each base in vbs
    allocate

English is just not a great language for describing algorithms. :-)

It seems to me that the first loop is not particularly harder to
implement and makes for somewhat smaller classes, so that's what I had
assumed we wanted -- but I don't recall what the decision was.  I'd
prefer alternative 1, but not if it means reopening the issue;
clarification works for me.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Apr  4 00:26:54 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 17:26:54 -0700
Subject: Virtual base allocation (was: Typo ...)
In-Reply-To: <38E92DB9.D25C52FA@sgi.com>
References: <20000401191858H.mitchell@codesourcery.com>
	<38E92DB9.D25C52FA@sgi.com>
Message-ID: <20000403172654D.mitchell@codesourcery.com>


Oh, I see -- we seem to have settled a third alternative -- the one
that tries to smush things as much as possible.  That seems
reasonable.

Thanks.  And thanks for modifying the example -- that's a helpful
case.  You left out, however, the bit where I tried to give a C
equivalent for the structure -- which I think would be useful, too.

Both structures are layout-equivalent, roughly to:

  struct X {
    R r;
    T t;
  };

Maybe adding something like that would be helpful, too?

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Apr  4 03:35:08 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 20:35:08 -0700
Subject: Vbase offsets
Message-ID: <20000403203508T.mitchell@codesourcery.com>


We have:

  There is one virtual base offset entry for each direct virtual base
  class, and one for each indirect virtual base class inherited via a
  direct virtual base class. (Indirect virtual base classes inherited
  via direct non-virtual base classes may be accessed via the the offset
  stored in the base's vtable.) If an indirect virtual base class is
  inherited via both virtual and non-virtual direct base classes, no
  virtual base offset entry is included for it.

That seems to imply that a *direct* virtual base gets a new vbase
offset, even it is also a direct virtual vbase of a direct non-virtual
base. 

Example:

  struct S {};
  struct T : virtual public S {};
  struct U : public T, virtual public S {};

The language quoted seems to imply that `U' gets a vbase offset for
`S'.  But, that seems unncessary: we already have one in `T's vtable.
(Even if T were not the primary base, because it is a non-virtual
base, we know where to find the offset, give a `U*'.)

Am I missing something?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Tue Apr  4 03:45:10 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 20:45:10 -0700
Subject: Vbase offsets
In-Reply-To: <20000403203508T.mitchell@codesourcery.com>
References: <20000403203508T.mitchell@codesourcery.com>
Message-ID: <20000403204510R.mitchell@codesourcery.com>

>>>>> "Mark" == Mark Mitchell <mark at codesourcery.com> writes:

    Mark> Am I missing something?

Yes -- I guess we're trying to avoid one extra add: the add required
to adjust the result of looking up the vbase offset by the offset to
the secondary base?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Apr  4 04:06:33 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 3 Apr 2000 21:06:33 -0700 (PDT)
Subject: Vbase offsets
Message-ID: <200004040406.VAA37109@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> We have:
> 
>   There is one virtual base offset entry for each direct virtual base
>   class, and one for each indirect virtual base class inherited via a
>   direct virtual base class. (Indirect virtual base classes inherited
>   via direct non-virtual base classes may be accessed via the the offset
>   stored in the base's vtable.) If an indirect virtual base class is
>   inherited via both virtual and non-virtual direct base classes, no
>   virtual base offset entry is included for it.
> 
> That seems to imply that a *direct* virtual base gets a new vbase
> offset, even it is also a direct virtual vbase of a direct non-virtual
> base. 
> 
> Example:
> 
>   struct S {};
>   struct T : virtual public S {};
>   struct U : public T, virtual public S {};
> 
> The language quoted seems to imply that `U' gets a vbase offset for
> `S'.  But, that seems unncessary: we already have one in `T's vtable.
> (Even if T were not the primary base, because it is a non-virtual
> base, we know where to find the offset, give a `U*'.)
> 
> Am I missing something?

I don't know about you, but we are.  This paragraph didn't get fixed
when we decided to always include vbase offsets for all virtual bases.
I've fixed it now (with the example) -- everyone please verify that it
matches our decisions.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Tue Apr  4 04:48:18 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 03 Apr 2000 21:48:18 -0700
Subject: Vbase offsets
In-Reply-To: <200004040406.VAA37109@baalbek.engr.sgi.com>
References: <200004040406.VAA37109@baalbek.engr.sgi.com>
Message-ID: <20000403214818P.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> I don't know about you, but we are.  This paragraph didn't
    Jim> get fixed when we decided to always include vbase offsets for
    Jim> all virtual bases.  I've fixed it now (with the example) --
    Jim> everyone please verify that it matches our decisions.

OK.  But, given:

  struct S {
    virtual void f();
  };
  struct T : virtual public S {};
  struct U : public T {};
  
Are there two vbase offsets for `S' in the vtable for `U'?  Here `T'
is the primary base for `U', so the vtable for `U' already has an `S'
entry.  I assume we don't want to add an extra one.  Maybe that
example would be helpful, too?  What if `T' is inherited virtually?
Then, `T' is still the primary base of `U', so I don't think we need
an extra offset here either?  If I'm right, that's probably worth
mentioning too.  So, I think the rule is:

  If there is no primary base class, then there is a vbase offset for
  every direct or indirect virtual base.  Otherwise, a vbase offset is
  present in the derived class for every virtual base that does not
  already have a vbase offset in the primary base class vtable.  In
  either case, the vbase offsets are allocated in reverse inheritance
  graph order.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From nathan at codesourcery.com  Tue Apr  4 13:33:54 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Tue, 04 Apr 2000 14:33:54 +0100
Subject: incomplete rtti
References: <200003282311.PAA23050@baalbek.engr.sgi.com> <200004032257.PAA36253@baalbek.engr.sgi.com>
Message-ID: <38E9EF42.2F9CEDED@codesourcery.com>

Jim Dehnert wrote:
> [stuff]
Ah, got it, thanks for taking the time to go through this with me.

> conflict-free.  Such things are always accessed via pointers with the
> incomplete-target flag set, which is the signal to do comparisons using
> the mangled names in the ultimate target RTTI instead of comparing
> addresses.
	After linking and loading, only one type_info structure is accessible
	via the external name defined by this ABI for any particular complete
	type symbol.

That sentance _must_ be changed. In the language of the standard an 'A *' is
a complete type, regardless of A. That sentance, and its effect on the equality
operator was causing all my confusion. The subsequent paragraph on type_info::before
is also incorrect. I suggest the following wording for those paragraphs,

 For any particular complete type symbol, which is not a direct or indirect pointer
 to an incomplete type, only one std::type_info structure is accessible via the external
 name defined by this ABI, after linking and loading. Therefore, the equality and
 inequality operators can be implemented as address comparisons when operating on
 those type_info objects: two type_info structures describe the same type if and
 only if they are the same structure (at the same address). In the case of pointer
 types, directly or indirectly pointing to incomplete class types, a more complex
 comparison is required, described below with the RTTI layout of pointer types. 

 In a flat address space (such as that of the IA-64 architecture), the before()
 member is also easily written in terms of an address comparison, when neither
 type_info object is a direct or indirect pointer to an incomplete class type.

 The only additional piece of information that is required is the NTBS that
 encodes the name. The type_info structure itself can hold a pointer into a
 read-only segment that contains the text bytes. 

In addition, the __pointer_type_info docs need amending -- it's not at all clear
that the abi::__pointer_type_info themselves must be local static. I suggest

 When the abi::__pointer_type_info is for a direct or indirect pointer to an incomplete
 class type, the incomplete target type flag is set. In addition, it is prevented
 from resolving to the equivalent abi::__pointer_type_info which directly or indirectly
 points to the complete class type, possibly by making it a local static object.
 If the target type is the incomplete class type itself, a dummy class RTTI is
 generated for the incomplete type that also is prevented from resolving to the
 final complete class RTTI (because the latter need not exist).

The paragraph descriping pointer equality seems to describe a rather long winded
algorithm -- and it's incomplete as it doesn't say the cv quals must be compared.
Why not just compare the NTBS's of the pointer types themselves? I suggest

 When abi::__pointer_type_info objects are compared for equality, if either has the
 incomplete flag set the NTBS of the std::type_info bases must be compared. When
 neither incomplete flag is set, the addresses of the abi::__pointer_type_info objects
 can be compared as with the other types. The implementation of before() behaves
 similarly.

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From mark at codesourcery.com  Tue Apr  4 18:32:23 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 04 Apr 2000 11:32:23 -0700
Subject: vcall offset description
Message-ID: <20000404113223H.mitchell@codesourcery.com>


I noticed some red ink in the vcall offset description:

  Virtual call (vcall) offsets are used to perform pointer adjustment
  for virtual functions defined in a virtual base class or its
  subobjects, and overridden in a class derived from it.

I think we need the vcall offsets even if the function is not
overridden.  Otherwise, when the same base appears as a virtual base
in two different hierarchies, its vtable layout might be different.
Then, if a single hierarchy combines both uses, everything will get
confused.  So, I think the last clause (`and overridden ...') should
go.  Sound right?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Tue Apr  4 19:52:37 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 4 Apr 2000 12:52:37 -0700 (PDT)
Subject: vcall offset description
Message-ID: <200004041952.MAA38446@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> I noticed some red ink in the vcall offset description:
> 
>   Virtual call (vcall) offsets are used to perform pointer adjustment
>   for virtual functions defined in a virtual base class or its
>   subobjects, and overridden in a class derived from it.
> 
> I think we need the vcall offsets even if the function is not
> overridden.  Otherwise, when the same base appears as a virtual base
> in two different hierarchies, its vtable layout might be different.
> Then, if a single hierarchy combines both uses, everything will get
> confused.  So, I think the last clause (`and overridden ...') should
> go.  Sound right?

Yes and no.  This sentence describes what vcall offsets are and how
they are used, and is correct -- they are not used unless the virtual
function is actually overridden.  Later, the virtual table layout
description for Category 3 describes what entries are present:

  ... the vtable for a virtual base A also includes a
  vcall offset entry for each virtual function represented in A's
  primary vtable and the secondary vtables from A's non-virtual bases.
  The vcall offset entries are allocated from the inside out, in the
  same order as the functions appear in A's vtables.

So the vcall offsets are present, as you understood, for all vptrs,
whether or not overridden (and therefore used).

The confusion stems from our separation of the description of vtable
components and order from the description of exactly what is contained
in various vtables.  I'm reluctant to remove that separation, because I
think it allows each part to be clearer -- but it certainly means that
you can't read just one section and understand.  I'll try to clarify
that in the introductory paragraph.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Apr  4 21:02:57 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 4 Apr 2000 14:02:57 -0700 (PDT)
Subject: [ia64-abi] Issue 82:  Initializer priorities
References: <200003292308.PAA25863@baalbek.engr.sgi.com>
    <200003310020.QAA29143@baalbek.engr.sgi.com>
Message-ID: <200004042102.OAA38672@baalbek.engr.sgi.com>

> From: Mike Walker <msw at eng.sun.com>
> 
> > On a system where the linker does no more than this, the C++
> > implementation must do the following:
> > 
> >         In bracketing files for the link (e.g. crt1.o and crtn.o),
> >         emit delimiting labels in the SHT_CXX_PRIORITY_INIT section,
> >         and entries in INITARRAY that call an initialization
> >         routine that passes the labels (all STV_HIDDEN to avoid
> >         conflicts between DSOs).  The call at the beginning would
> >         sort the SHT_CXX_PRIORITY_INIT vector by priority and invoke
> >         the negative-priority initializers, and the one at the end
> >         would invoke the positive-priority initializers.
> 
> I think it's worth hi-lighting that one of the main motivations 
> for us introducing the DT_INITARRAY & DT_FINIARRAY was so that
> we could move away from the requirement of having crt*.o
> modules when a final link is performed.  Ideally - they are no
> longer required for the ia64 development environment.
> 
> This proposal introduces a new dependency on the crt*.o modules
> which we were trying to move away from.  Is that an issue
> for others?
> 
> I know that we at Sun are a long way from being crt'less so
> it's not that big of an issue for us - but it's worth bringing up
> for discussion.

Two points to make here:

- I agree that an objective of *ARRAY was to eliminate initialization
  code patched together in crt* modules.  But this proposal doesn't
  require that -- it requires labels and INITARRAY section entries.

- More importantly, please don't take the above paragraph for more
  than was intended.  I was asked to describe the minimum linker
  requirements imposed by the the proposal, and that's what it
  presents.  I think a more reasonable implementation from someone
  serious about the feature would do the sorting in the linker and
  implicitly add the initialization calls to INITARRAY without any
  involvement from crt* files.  But one of the objectives of the design
  was not to require linker involvement, while allowing the improved
  results that can be obtained by linker sorting.

=====

> From: Cary Coutant <cary at cup.hp.com>
>
> I agree with Ulrich that "CXX" does not belong in the name.

I prefer that, too.

> But I also  believe that you don't even need a special section type.
> I don't see any 
> special treatment required of this section beyond SHT_PROGBITS.
> Your  bracketing files provide the necessary labels so that the
> initialization routine can find the section.
> 
> I understand the argument that the special section type might allow a 
> linker to do the sorting if it chose to do so, but you can do that with
> a vendor-specific section type, and the compatibility rules ensure that 
> other linkers will treat that section type properly.

Both points are correct, but the combination is deadly.  I can do
without the special section type if I choose to give up on the linker
sorting, but as I said, I think that's the preferable implementation if
one is serious about this.  And I can do linker sorting with a
vendor-specific section type, but that prevents cross-vendor
interoperability, which is the ultimate objective of this exercise.
Objects from two vendors would go in two special sections, and the
linker would sort only one of them.  Or, if you use a compiler from one
vendor and a linker from another, the linker doesn't process anything.

Personally, my objective here is not to force support of this on
anyone.  But there are already multiple vendors supporting the feature,
including Cygnus and IBM, and I'd like to see it done compatibly when
it's done, for the benefit of users.  So making this an optional
supplementary specification with a pre-assigned section type is a fine
solution from my point of view.

> This description sounds like it affects the initializer order only
> within a DSO. How does it address reordering of initializers across DSOs?

It doesn't.  We explicitly decided that attempting to intermix
initializers from different DSOs was an invitation to chaos, miserable
to implement (especially with potential delay loading), and generally
to be avoided.

=====

> From: Mark Mitchell <mark at codesourcery.com>
> ...
> So, I'm not even sure this is a great language feature, let alone
> something that we should mandate support for in the ABI.  Furthermore,
> we haven't provided a syntax for doing this, so programs using these
> features will only be portable at the object-file level anyhow -- not
> at the compiler level.

Actually, we've specified the semantics of a pragma, and have simply
postponed completing that definition until the underlying ELF issue is
resolved.  So this concern will not remain valid.

> Vendors who do not support this feature in
> their compilers may well "forget" to implement it in their linkers as
> well, rendering it a non-standard anyhow.

My understanding is that the vendors who currently have this feature
intend to carry it over to IA-64 -- they have found it to be useful (or
their customers have).  As I said above, I'd rather have a consistent
implementation from those who support it than total incompatibility.
If other vendors choose to do nothing, I don't care -- that's a quality
of implementation choice for those vendors.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Apr  4 23:24:41 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 4 Apr 2000 16:24:41 -0700 (PDT)
Subject: incomplete rtti
References: <200003282311.PAA23050@baalbek.engr.sgi.com>
    <200004032257.PAA36253@baalbek.engr.sgi.com>
Message-ID: <200004042324.QAA39370@baalbek.engr.sgi.com>

I'll try to make this clearer.  However, the sentence you complain about
is correct:

> 	After linking and loading, only one type_info structure is accessible
> 	via the external name defined by this ABI for any particular complete
> 	type symbol.

It does NOT say that no other type_info structures are accessible, only
that there's only one with the ABI-defined name.  This is true for all
types, including pointers.  Your problem is that some "complete"
pointers may reference other type_info structures.  Anyway, I've fixed
this paragraph and the next one you mention -- see what you think.

> That sentance _must_ be changed. In the language of the standard an 'A *' is
> a complete type, regardless of A.
...
> The paragraph descriping pointer equality seems to describe a rather long winded
> algorithm -- and it's incomplete as it doesn't say the cv quals must be compared.
> Why not just compare the NTBS's of the pointer types themselves? I suggest
> 
>  When abi::__pointer_type_info objects are compared for equality, if either has the
>  incomplete flag set the NTBS of the std::type_info bases must be compared. When
>  neither incomplete flag is set, the addresses of the abi::__pointer_type_info objects
>  can be compared as with the other types. The implementation of before() behaves
>  similarly.

I think the reason you can't just check the NTBS of the pointer is
precisely because of intervening CV-qualifiers.  Or do they always have
to match?  Anyway, I haven't changed this paragraph, pending better
understanding.

Jim
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From alainm at cup.hp.com  Wed Apr  5 00:38:25 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Tue, 04 Apr 2000 17:38:25 -0700
Subject: typo in data layout (html)
Message-ID: <38EA8B01.74D84AAD@cup.hp.com>


In the mangling examples, I see:

_ZN3FooIA4_iE3barE  Type? Foo::bar; 

instead of Type? Foo<int[4]>::bar.

this is due to the fact that the '<' is unprotected in
the html source:

<tr class=small><td> _ZN3FooIA4_iE3barE </td>
<td> Type? Foo<int[4]>::bar; </td></tr>

Alain



From dehnert at baalbek.engr.sgi.com  Wed Apr  5 00:46:07 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 4 Apr 2000 17:46:07 -0700 (PDT)
Subject: Vbase offsets
References: <200004040406.VAA37109@baalbek.engr.sgi.com>
Message-ID: <200004050046.RAA39542@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> OK.  But, given:
> 
>   struct S {
>     virtual void f();
>   };
>   struct T : virtual public S {};
>   struct U : public T {};
>   
> Are there two vbase offsets for `S' in the vtable for `U'?  Here `T'
> is the primary base for `U', so the vtable for `U' already has an `S'
> entry.  I assume we don't want to add an extra one.  Maybe that
> example would be helpful, too?  What if `T' is inherited virtually?
> Then, `T' is still the primary base of `U', so I don't think we need
> an extra offset here either?  If I'm right, that's probably worth
> mentioning too.  So, I think the rule is:
> 
>   If there is no primary base class, then there is a vbase offset for
>   every direct or indirect virtual base.  Otherwise, a vbase offset is
>   present in the derived class for every virtual base that does not
>   already have a vbase offset in the primary base class vtable.  In
>   either case, the vbase offsets are allocated in reverse inheritance
>   graph order.

No, we shouldn't replicate vcall or vbase offsets from primary bases.
I've updated it, though not with exactly your language, and added
your example.  Take a look.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Wed Apr  5 01:13:35 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 04 Apr 2000 18:13:35 -0700
Subject: Vbase offsets
In-Reply-To: <200004050046.RAA39542@baalbek.engr.sgi.com>
References: <200004040406.VAA37109@baalbek.engr.sgi.com>
	<200004050046.RAA39542@baalbek.engr.sgi.com>
Message-ID: <20000404181335B.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    Jim> No, we shouldn't replicate vcall or vbase offsets from
    Jim> primary bases.  I've updated it, though not with exactly your
    Jim> language, and added your example.  Take a look.

Thanks -- looks good.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Apr  5 07:03:50 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Apr 2000 00:03:50 -0700 (PDT)
Subject: Web status updates
Message-ID: <200004050703.AAA40695@baalbek.engr.sgi.com>

The web pages are all updated with last week's meeting results, as well
as email discussions.  Take a look.  I'll send an agenda later today
(Wednesday).

Jim
-		Jim Dehnert  x3-4272



From alainm at cup.hp.com  Wed Apr  5 21:28:57 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Wed, 05 Apr 2000 14:28:57 -0700
Subject: mangling example
Message-ID: <38EBB019.B0D63872@cup.hp.com>


I have a problem with a mangling example:

_Z5firstI3DuoEvS0_  -> first<Duo>(/*nondependent*/Duo)

If I understang correctly the mangling, we have:

<encoding>
 <name> // potential source for substitution 1
   <unqualified name>
      <source name>"first"
      <template-args>
         <template arg>
            <type> // potential source for substitution 2
               <class-enum-type>
                  <lass-enum-name>
                     <source name>"Duo"
 <bare-function-type>
   <type> // potential source for substitution 3
     <builtin type>"void"
   <type>
     <substitution>0 (ie, the second last encoded)

   
So, at the point where S0_ appears:

S_ = void
S0_ = first<Duo> (1)
S1_ = Duo(2)

So I guess it should be _Z5firstI3DuoEvS1_, or
did I missed something ?

Alain



From nathan at codesourcery.com  Wed Apr  5 21:34:35 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Wed, 05 Apr 2000 22:34:35 +0100
Subject: incomplete rtti
References: <200003282311.PAA23050@baalbek.engr.sgi.com> <200004032257.PAA36253@baalbek.engr.sgi.com> <200004042324.QAA39370@baalbek.engr.sgi.com>
Message-ID: <38EBB16B.1A50F6C4@codesourcery.com>

Jim Dehnert wrote:

> It does NOT say that no other type_info structures are accessible, only
> that there's only one with the ABI-defined name.  This is true for all
Doh!

> types, including pointers.  Your problem is that some "complete"
> pointers may reference other type_info structures.  Anyway, I've fixed
> this paragraph and the next one you mention -- see what you think.
Looks good. I'd add `direct or indirect' into
  Therefore, except for _direct or indirect_ pointers to incomplete types, the
  equality and inequality operators ...
just like you've got for the before() description.
 
> >  When abi::__pointer_type_info objects are compared for equality, if either has the
> >  incomplete flag set the NTBS of the std::type_info bases must be compared. When
> >  neither incomplete flag is set, the addresses of the abi::__pointer_type_info objects
> >  can be compared as with the other types. The implementation of before() behaves
> >  similarly.
> 
> I think the reason you can't just check the NTBS of the pointer is
> precisely because of intervening CV-qualifiers.  Or do they always have
> to match?  Anyway, I haven't changed this paragraph, pending better
> understanding.
When you're testing for equality, all the cv qualifiers must match. Think about
how `typeid (A *) == random_type_info' would behave. Assume random_type_info
doesn't involve incomplete types.

If A is complete, we'll do a pointer comparison on the type_info objects themselves.
If A is incomplete, we just need to compare the top level NTBS's.

It's in catch matching that we have to follow the pointer chain, and then it is
permissible for the cv qualifiers to differ (but only such that it is a
qualification conversion). In those cases we have to follow the chain regardless
of the completeness of the final non-pointer type.

BTW. I've realised there is another scheme which would allow type_info equality
to be pointer equality in all cases. The scheme we have at the moment essentially
forces operator== to involve a virtual function call. If we have separate objects
for the result of typeid to that used by dynamic_cast and catch matching then this
problem goes away. The cost is an extra vtable entry and the inability to provide
`augmented' type information via typeid (which we don't do at the moment anyway).
I know it's a little late in the day, but I've only just realized that we had lost
this address equivalence property. If there's interest I can write that up in
short order.

nathan

-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From dehnert at baalbek.engr.sgi.com  Wed Apr  5 23:28:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 5 Apr 2000 16:28:13 -0700 (PDT)
Subject: Agenda for tomorrow
Message-ID: <200004052328.QAA43044@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Cleanup of vcall offset descriptions.

 - Further editorial revision of Coleen's alternate construction vtable
   proposal, but the example is still probably wrong.

 - Some cleanup of the incomplete type RTTI writeup.

 - Adoption with further additions/changes to the mangling writeup,
   including virtual base thunks, empty parameter lists, and local
   scope mangling.

Please take a careful look at the colored text, and raise any issues
you observe.

Take a look at the material associated with the following issues.

  1) C-4:  Construction vtables.  Are my editorial elaborations
     correct?  The example?  (I doubt it.)  Does everyone now
     understand the proposals?

  2) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent -- does
     anyone else have some examples for him?

  3) F-3:  Consistency checks.
     F-4:  Empty throw specifications.
     F-10: Mangling function return types.

     How much further should we take this?  I haven't had time to
     update it for throw specifications, but I did put the SGI/MIPS
     definition of our interface specification section (in ELF) on the
     web site to show another approach to achieving link-time
     checking.

  4) F-6:  Demangler.  Proposed simplification from Matt, HP interface
     from Christophe.

  5) F-7:  Mangling statics.

  6) D-12:  Unwind table location.

Jim

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Thu Apr  6 00:43:57 2000
From: jason at cygnus.com (Jason Merrill)
Date: 05 Apr 2000 17:43:57 -0700
Subject: universal character names
In-Reply-To: Martin von Loewis's message of "Thu, 23 Mar 2000 08:53:05 +0100"
References: <200003230753.IAA11057@pandora>
Message-ID: <u91z4kxdma.fsf@yorick.cygnus.com>

>>>>> Martin von Loewis <loewis at informatik.hu-berlin.de> writes:

 > A) External names for identifiers containing unicode letters; e.g.

 >    namespace newmath{
 >       const long double \u03A0 = 3.14159265358979;
 >    }

 >    This is also an issue for C99, so it may be that the base ABI has a
 >    specification; we'd have to follow that at least for extern "C"
 >    names. If not, I propose that such names are encoded in UTF-8.

UTF-8 is inappropriate for mangled names, as it uses values > 127 to encode
non-ASCII characters.

GNU Java encodes names in UTF-8 internally.  For the mangled name, if there
are non-ASCII characters, it adds a 'U' to the beginning and encodes each
such UCS-2 character as _%04x.  See gcc/java/mangle.c.

This assumes that all interesting characters fall within the Basic
Multilingual Plane (the low 16 bits); that is a valid assumption for us,
since all the extended characters valid for use in C++ identifiers are part
of the BMP.

 > B) Object file representation of narrow and wide string literals
 >    containing such characters, eg.

 >       wchar_t MvL[]=L"Martin von L\u00F6wis";

 >    First, what is sizeof(wchar_t) in the base ABI? I'll assume 4 for
 >    the moment. Then, the question comes down to: What is the execution
 >    character set, and the wide execution character set? 2.2/3 says
 >    they are implementation-defined, so I guess we must define
 >    them. Typically, people expect this to be a run-time setting (which
 >    is a reasonable assumption), but it kind-of breaks for string
 >    literals.

 >    Proposal: The wide execution character set is UCS-4. The
 >    execution-character-set is "as-is", i.e. bytes from the source
 >    character set are copied unmodified to the object
 >    file. Universal-character-names appearing in narrow (ie. char)
 >    strings are not portable in this ABI (the other alternatives would
 >    be to say they are Latin-1, or encoded as UTF-8, I guess).

I have been told that it is inappropriate to assume that wchar_t is always
UCS-4; a suggestion was to convert from UCS-4 to the host locale character
set using iconv(), and then if we're in a wide string, convert to wchar_t
with mbtowc().  This makes sense to me, though of course it requires iconv
to know about UCS-4.

Jason



From nathan at codesourcery.com  Thu Apr  6 11:44:03 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Thu, 06 Apr 2000 12:44:03 +0100
Subject: Alternative rtti proposals
Message-ID: <38EC7883.82F9F7A6@codesourcery.com>

Hi,
The current RTTI proposal loses the property that all type_info objects
can be compared for equality and orderability by address comparison.
Instead, type_info::operator== must involve a virtual function call
or unconditionaly strcmp. (An alternative of testing the typeid of the
polymorphic type_info objects results in infinite recursion!)

Here are two proposals which reinstate the address equality property.
The first is rather different to the current scheme, but when I was
done documenting it, I realised there was a minor modification to the
current scheme, which partially reinstates the address equality. I
present both for consideration. Feel free to shot them down ...

Proposal A

1) The typeid operator produces a std::type_info object for all types.
No subclassing of std::type_info is done. The object has comdat linkage,
and hence after linking and loading, only one object of that name is
active. For typeid(X) it does not matter whether X is incomplete, or
direct or indirect pointer to incomplete. The functionality required
of typeid is to produce objects which can test for type equality and
(implementation defined) type orderability. No information about the
internal structure of the type is required.

2) Dynamic_cast and catch matching require more information. Primarily
the heirarchy of a class type, and the target of pointer types. To do
this, a separate class heirarchy is used. These objects are also emitted
with comdat linkage, and with a different name to the std::type_info
objects produced by typeid. (It is not _necessary_ for these to have
comdat linkage, but that will reduce overall program size.)

The base class of these is,

class abi::__type_info
{
  std::type_info const *type; // pointer to typeid(foo) object.
  virtual ~__type_info ();
  ... other implementation defined member functions
};

This contains a pointer to the type_info object produced by the typeid
operator, for whatever type this is describing. That will be a unique
object.

There are a number of necessary derivations of this type, which can
be taken largely unaltered from the current proposal. 

It is necessary to distinguish function types, so that catch matching
can distinguish a data pointer object from a function pointer object.
Other types (fundamental, enum, array) need not be distinguished, and
can be represented by an abi::__type_info object. (Or we could keep the
current proposal of having separate derivations for these.)

class abi::__function_type_info
  : public abi::__type_info
{
  virtual ~__function_type_info ();
  ... other implementation defined member functions
};

Pointers are as they currently are, other than the base
class change. We still need the incomplete target flag.

class abi::__pointer_type_info
  : public abi::__type_info 
{
  abi::__type_info const *target;   // target type of the pointer
  unsigned flags;  		    // flags, as currently specified
  virtual ~__pointer_type_info ();
  ... other implementation defined member functions
};

Pointers to member could be a sibling class of non member pointers,
however, they do share common functionality, and IMO it makes sense
to derive from __pointer_type_info.

class abi::__pointer_to_member_type_info
  : public abi::__pointer_type_info
{
  abi::__class_type_info const *klass;  // class of the member
  virtual ~__pointer_to_member_type_info ();
  ... other implementation defined member functions
};

The __class_type_info, __si_class_type_info and __vmi_class_type_info
are unchanged, other than the change to __class_type_info's base.

class abi::__class_type_info
  : public abi::__type_info
{
  ... as currently defined
}

The vtable slot -1, (which currently holds a pointer to the
std::type_info object for a class), points to the
abi::__class_type_info object. To implement typeid(X), where X is
polymorphic, involves an additional indirection through the
abi::__type_info base to return the `type' member.

dynamic_cast uses the abi::__class_type_info object pointed to in the
vtable. throwing and catch matching use the abi::__type_info object
for the type being thrown or caught.

As with the current proposal, an incomplete type is represented by an
abi::__class_type_info object. Note that its abi::__type_info base
will point to the unique std::type_info object for that type, regardless
of whether a DSO completes the type. This incomplete type is prevented
from preempting the complete type information.

Also direct or indirect pointers to incomplete have their incomplete flag
set, and are also prevented from preempting the equivalent pointer to
complete object.

During catch matching, comparison of pointers can compare the
abi::__pointer_type_info addresses, unless either has the incomplete flag
set, in which case the std::type_info objects pointed to must be compared.
(The std::type_info objects could be compared even when the incomplete
flags are clear.)

There are two or three naming schemes with this proposal.
1) The naming of the std::type_info object produced by typeid.
2) The naming of the abi::__type_info object required for dynamic cast and
catch matching
3) Optionally, the naming of the incomplete abi::__class_type_info and
direct or indirect pointers to it. If that mangling is specified, we can
emit those as comdat objects too, rather than forcing them to be statics.

Advantages of this proposal are,
*) Address equivalence of std::type_info objects is maintained in all
cases.
*) Generating the std::type_info of a pointer type does not force the
emission of the std::type_info objects for the pointer chain.
*) Generating the std::type_info of a type is always 16 bytes, additional
information is only produced when necessary.
*) When address equivalence of abi::__type_info objects is not possible,
the type's std::type_info object is available for that purpose. There
is no requirement to compare the NTBS's of the types.
*) We do not have to expose any implementation hooks in the
<typeinfo> header file.

The cost of this proposal is
*) Producing the std::type_info for a polymorphic type involves an
additional indirection.
*) The std::type_info and abi::__type_info derivative for a particular
type occupies an additional 16bytes (The size of std::type_info).


Proposal B

The first proposal is essentially using the std::type_info objects as
unique objects, via which incomplete types can be compared. We already
have such a unique object candidate -- the NTBS name member of
std::type_info. Currently we've not said anything about that. If, however,
we give that NTBS comdat linkage, a unique name, and prevent it being
commonized with other strings, we have a proxy. These features can be
obtained by treating it as a `const char []' rather than a string constant.
type_info equality and orderability can now use the address of this array,
rather than the type_info objects themselves. We can do this in all cases,
even though it is only necessary for the pointer to incomplete case, as
that avoids a virtual function call. Here is an implementaion of
type_info::operator==

bool type_info::operator== (type_info const &other) throw ()
{
  return name == other.name;
}

We need to specify the naming scheme for the NTBS.

The advantages of this are
*) Minimal change from the current scheme.
*) type_info orderability is a pointer comparison

The costs over proposal A are
*) type_info orderability involves indirecting on the type_infos.

nathan

-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From coleen at zko.dec.com  Thu Apr  6 18:39:58 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Thu, 06 Apr 2000 14:39:58 -0400
Subject: [Fwd: Name hashing algorithm(s).]
Message-ID: <38ECD9FE.46F7FD6D@zko.dec.com>


Marks name hashing algorithm, re: mangling string literals.  I reattached
the source files in case they don't attach in the forward.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------
-------------- next part --------------
An embedded message was scrubbed...
From: Mark Mitchell <mark at codesourcery.com>
Subject: Re: Name hashing algorithm(s).
Date: Fri, 19 Nov 1999 17:30:23 -0800
Size: 80058
URL: <http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20000406/d4b8053c/attachment.mht>
-------------- next part --------------
/***********************************************************************

 File:   fingerprint.h
 Author: Mark Mitchell
 Date:   05/31/1998

 Contents: A port of the Modula-3 fingerpinting module to C.

 Copyright (c) 1998 Mark Mitchell.  All rights reserved.

 Redistribution and use in source and binary forms are permitted
 provided that the above copyright notice and this paragraph are
 duplicated in all such forms and that any documentation, advertising
 materials, and other materials related to such distribution and use
 acknowledge that the software was developed by Mark Mitchell.  The
 name Mark Mitchell may not be used to endorse or promote products
 derived from this software without specific prior written permission.
 THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT EXPRESS OR IMPLIED
 WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
 MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

***********************************************************************/

#ifndef FINGERPRINT_H
#define FINGERPRINT_H

#ifdef __cplusplus
extern "C" {
#endif /* ifdef __cplusplus */

/***********************************************************************
  Notes									
***********************************************************************/

/* Origins
   -------

   The contents of this module are derived from the fingerprinting
   routines provided in the Digital Equipment Corporation Modula-3
   sources.  The entire contents of the source distribution are
   available at:

     http://www.research.digital.com/SRC/m3sources/html/INDEX.html

   The fingerprinting algorithm is just a hashing algorithm, but it is
   a very good one: the probability of collisions is provably
   negligible.  There is a precise description of this property at the
   above URL.  

   Implementation
   --------------

   The code below contains two variants: one for machines which have a
   native 64-bit little-endian integral type, and one for all other
   systems.  (Actually, the "portable" code will not work on those
   systems which have bytes containing more than 8 bits.  In addition,
   neither version of the code will work if there is no integer type
   with the same number of bits as all pointer values.  This may occur
   either if some pointer types have more or less bits than others, or
   if there are no integer types with the right number of bits.) 

   Configuration
   -------------

   Before including this file, you may define the following macros:

     FINGERPRINT_INTEGRAL_TYPE

       If this macro is defined, it must be the name of a signed,
       64-bit, little-endian integral type.  If your system has such a
       type, you should use this macro, as it will result in faster
       code. 

     FINGERPRINT_INT_32_TYPE
     
       This macro may be defined to the name of a signed 32-bit
       integral type.  If this macro is not defined, `int' is used
       instead.  

     FINGERPRINT_POINTER_INT_TYPE 

       This macro may be defined to the name of a signed integral type
       with the same number of bits as pointer values.  If this macro
       is not defined, `int' is used instead.  

     FINGERPRINT_LITTLE_ENDIAN

       If this macro is defined to 1, the system is little-endian.  If
       this macro is defined to 0, the system is big-endian.  This
       macro may be left undefined, in which case the fingerprinting
       routines will determine the endianness at run-time.  If
       FINGERPRINT_INTEGRAL_TYPE is defined, it is assumed that the
       system is little-endian; you must not set this flag in that
       case.  

   Testing
   -------

   When the fingerprint module is initialized, if will perform some
   basic consistency checking, unless NDEBUG is defined.  In addition,
   you can build fingerprint.c, defining FINGERPRINT_TEST, to build a
   small program which tests the basic functionality of the
   fingerprint module.  You should undertake this procedure if running
   the fingerprint module in a configuration you have not used 
   before.  */

/***********************************************************************
  Macros								
***********************************************************************/

/* FINGERPRINT_USE_INTEGRAL_TYPE is defined if we have a 64-bit
   integral type to use for fingerprints.  */

#ifdef FINGERPRINT_INTEGRAL_TYPE
#define FINGERPRINT_USE_INTEGRAL_TYPE 1
#else /* ifndef FINGERPRINT_USE_INTEGRAL_TYPE */
#define FINGERPRINT_USE_INTEGRAL_TYPE 0
#endif /* ifdef FINGERPRINT_USE_INTEGRAL_TYPE */

/***********************************************************************
  Types									
***********************************************************************/

/* A fingerprint_byte_t is an unsigned 8-bit integral type:

     TYPE Byte = BITS 8 FOR [0..255];  */

typedef unsigned char fingerprint_byte_t;

/* A fingerprint_word_t w represents a sequence of Word.Size bits
   w(0), ..., w(Word.Size - 1).  It also represents the  unsigned
   number sum of 2^(i) * w(i) for i in 0, ..., Word.Size - 1.  

   The idea is that this type will occupy the natural word size of the
   machine.  */

typedef unsigned int fingerprint_word_t;

#if !FINGERPRINT_USE_INTEGRAL_TYPE
/* A fingerprint_t is a 64-bit checksum:
 
     TYPE T = RECORD
	 byte: ARRAY [0..7] OF BITS 8 FOR [0..255]
       END;  */

typedef struct fingerprint_t {
  fingerprint_byte_t
                byte[8];
			/* Externally, a fingerprint is an opaque
			   object of 64 bits.  */
} fingerprint_t;

/* Returns the address of the first byte of the fingerprint.  Use this
   macro to access the bytes in a configuration-independent manner.  */

#define FINGERPRINT_BYTE(fp) (&((fp).byte[0]))

#else /* FINGERPRINT_USE_INTEGRAL_TYPE */
typedef FINGERPRINT_INTEGRAL_TYPE fingerprint_t;
#define FINGERPRINT_BYTE(fp) ((fingerprint_byte_t*) &(fp))
#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

/***********************************************************************
  Variables
***********************************************************************/

#if !FINGERPRINT_USE_INTEGRAL_TYPE
extern const fingerprint_t 
                fingerprint_zero;
                        /* This value is not the fingerprint of any
			   text.  */
#else /* FINGERPRINT_USE_INTEGRAL_TYPE */
#define fingerprint_zero ((fingerprint_t) 0)
#endif /* FINGERPRINT_USE_INTEGRAL_TYPE */

extern /*const*/ fingerprint_t 
                fingerprint_of_empty;
			/*  The fingerprint of the empty text.  This
			    value should be thought of as const, but
			    cannot be, since it must be dynamically
			    initialized.   */

/***********************************************************************
  Functions
***********************************************************************/

/* Initialize the fingerprint module.  This routine must be called
   before any other routine in this module.  */
extern void fingerprint_init (void);

/* Return the fingerprint of TEXT.  */
extern fingerprint_t fingerprint_from_text (const char* text);

/* Return the fingerprint of the ordered pair (FP1, FP2).  */
extern fingerprint_t fingerprint_combine (fingerprint_t fp1,
					  fingerprint_t fp2);

/* Return of the fingerprint of T and TEXT where T is the text whose
   fingerprint is FP.  */
extern fingerprint_t fingerprint_from_chars (const char*   text,
					     fingerprint_t fp);

/* Return FP1 == FP2.  */
#if !FINGERPRINT_USE_INTEGRAL_TYPE
extern int fingerprint_equal (fingerprint_t fp1,
			      fingerprint_t fp2);
#else /* FINGERPRINT_USE_INTEGRAL_TYPE */
#define fingerprint_equal(fp1, fp2) ((fp1) == (fp2))
#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

/* Return FP1 == FP2.  This function is provided for use by
   applications which use pointers to functions when creating
   container objects, or other such data structures.  Unlike
   fingerprint_equal, fingerprint_equal_f is always a function.  */
extern int fingerprint_equal_f (fingerprint_t fp1,
				fingerprint_t fp2);

/* Return a hash code for FP.  */
extern fingerprint_word_t fingerprint_hash (fingerprint_t fp);

#ifdef __cplusplus
}
#endif /* ifdef __cplusplus */

#endif /* FINGERPRINT_H */
-------------- next part --------------
/***********************************************************************

 File:   fingerprint.c
 Author: Mark Mitchell
 Date:   05/31/1998

 Contents: A port of the Modula-3 fingerpinting module to C.

 Copyright (c) 1998 by Mark Mitchell.  All rights reserved.

 Redistribution and use in source and binary forms are permitted
 provided that the above copyright notice and this paragraph are
 duplicated in all such forms and that any documentation, advertising
 materials, and other materials related to such distribution and use
 acknowledge that the software was developed by Mark Mitchell.  The
 name Mark Mitchell may not be used to endorse or promote products
 derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT AND EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

***********************************************************************/

/***********************************************************************
  Included Files
***********************************************************************/

#include <assert.h>
#include <limits.h>
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include "fingerprint.h"

/***********************************************************************
  Macros
***********************************************************************/

/* FINGERPRINT_INT_32_TYPE is a 32-bit signed integral type.  */

#ifndef FINGERPRINT_INT_32_TYPE 
#define FINGERPRINT_INT_32_TYPE int
#endif /* ifndef FINGERPRINT_INT_32_TYPE */

/* FINGERPRINT_POINTER_INT_TYPE is an integral type with the same
   number of bits as pointers.  */

#ifndef FINGERPRINT_POINTER_INT_TYPE
#define FINGERPRINT_POINTER_INT_TYPE int
#endif /* ifndef FINGERPRINT_POINTER_INT_TYPE */

/* FINGERPRINT_LITTLE_ENDIAN is 1 if the target is little-endian, 0 if
   it is big-endian, and undefined otherwise.  */

#if FINGERPRINT_USE_INTEGRAL_TYPE
#ifdef FINGERPRINT_LITTLE_ENDIAN
#error "You must not define FINGERPRINT_LITTLE_ENDIAN if you define FINGERPRINT_INTEGRAL_TYPE"
#else /* ifndef FINGERPRINT_LITTLE_ENDIAN */
#define FINGERPRINT_LITTLE_ENDIAN 1
#endif /* ifdef FINGERPRINT_LITTLE_ENDIAN */
#endif /* FINGERPRINT_USE_INTEGRAL_TYPE */

/* MAY_BE_LITTLE_ENDIAN is non-zero if the target might be
   little-endian.  */

#if !defined(FINGERPRINT_LITTLE_ENDIAN) || FINGERPRINT_LITTLE_ENDIAN
#define MAY_BE_LITTLE_ENDIAN 1
#else /* !(!defined(FINGERPRINT_LITTLE_ENDIAN)
	   || FINGERPRINT_LITTLE_ENDIAN) */
#define MAY_BE_LITTLE_ENDIAN 0
#endif /* (!defined(FINGERPRINT_LITTLE_ENDIAN)
	   || FINGERPRINT_LITTLE_ENDIAN) */

/* MAY_BE_LITTLE_ENDIAN is non-zero if the target might be
   big-endian.  */

#if !defined(FINGERPRINT_LITTLE_ENDIAN) || !FINGERPRINT_LITTLE_ENDIAN
#define MAY_BE_BIG_ENDIAN 1
#else /* !(!defined(FINGERPRINT_LITTLE_ENDIAN)
	   || 1FINGERPRINT_LITTLE_ENDIAN) */
#define MAY_BE_BIG_ENDIAN 0
#endif /* (!defined(FINGERPRINT_LITTLE_ENDIAN)
           || FINGERPRINT_LITTLE_ENDIAN) */

/***********************************************************************
  Types
***********************************************************************/

/* The Modula-3 INTEGER type is the type of all integers represented
   by the implementation.  Implicit in the Modula-3 fingerprinting
   algorithm is the idea that this type has the same size as a
   pointer as the code contains:

     LOOPHOLE (addr, INTEGER) 

   at one point.  */

typedef FINGERPRINT_POINTER_INT_TYPE integer_t;

/* A fingerprint_int_32_t is a 32-bit integral type:

     TYPE Int32 = [-16_7fffffff - 1 .. 16_7fffffff].  */

typedef FINGERPRINT_INT_32_TYPE 
                int_32_t;

#if !FINGERPRINT_USE_INTEGRAL_TYPE
/* A fingerprint_poly_t is a polynomial of degree [0..63] with
   coefficients in the field Z[2]:

     TYPE T = ARRAY [0..1] OF Int32;

   Because arrays are not first-class types in C, we enclose the array
   in a structure type. 

   The coefficients of a polynomial are in reverse (VAX) order: P(x) =
   x^64 + c[0] * x^63 + c[1] * x^62 + ... + c[63].

   The leading coefficient is not stored in the 64-bit representation
   of the basis polynomial.  All other polynomials are residues MOD the
   basis, hence they don't have an x^64 term.  */

typedef struct poly_t {
  int_32_t      array[2];
} poly_t;
#else /* FINGERPRINT_USE_INTEGRAL_TYPE */
typedef FINGERPRINT_INTEGRAL_TYPE poly_t;
#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

/* We carefully use only names beginning with "fingerprint" in the
   external interface, but there is no reason to be so careful
   internally.  */

typedef fingerprint_byte_t byte_t;
typedef fingerprint_word_t word_t;

/***********************************************************************
  Static Function Definitions
***********************************************************************/

/* The Modula-3 `MOD' operator is such that `X MOD Y' is non-negative
   if Y is positive and non-positive if Y is negative.  C's `%'
   operator makes no such guarantee.  This function computes the
   Modula-3 MOD operation.  If your C compiler explicitly ensures a
   Modula-3-like `%' operator, you might be able to improve
   performance by replacing this function with a macro.  */

static integer_t mod (integer_t x, integer_t y)
{
  const int positive = (y > 0);
  /* We cannot use the library function `abs' to do these conversions
     since we don't know that integer_t is `int' which is the type of
     `abs'.  */
  if (x < 0)
    x = -x;
  if (y < 0)
    y = -y;
  return positive ? (x % y) : - (x % y);
}

/***********************************************************************
  Modula-3 `Word' Module
***********************************************************************/

/* (x + y) MOD 2^[Word.Size] */
#define word_plus(x, y) (((word_t) (x)) + ((word_t) (y)))

/* (x * y) MOD 2^[Word.Size] */
#define word_times(x, y) (((word_t) (x)) * ((word_t) (y)))

/* Bitwise AND of X and Y.  */
#define word_and(x, y) (((word_t) (x)) & ((word_t) (y)))

/* Bitwise OR of X and Y.  */
#define word_or(x, y) (((word_t) (x)) | ((word_t) (y)))

/* Bitwise XOR of X and Y.  */
#define word_xor(x, y) (((word_t) (x)) ^ ((word_t) (y)))

/* Bitwise complement of X.  */
#define word_not(x) (~((word_t) (x)))

/* The Modula-3 versions of word_left_shift and word_right_shift are
   in terms of Word.Shift.  Here, we code them directly.  Note that
   C's right-shift operator does not necessarily behave as desired,
   unless the operand is unsigned.  */
#define word_left_shift(x, n) (((word_t) (x)) << n)
#define word_right_shift(x, n) (((word_t) (x)) >> n)

/* Take N bits from X, with bit I as the least significant bit, and
   return them as the least significant N bits of a word whose other
   bits are 0.  */
#define word_extract(x, i, n) \
  ((((word_t) (x)) >> i) & ~(((word_t) -1) << n))

/***********************************************************************
  Modula-3 `Poly' Module
***********************************************************************/

/* Mask to grab 32 significant bits.  */

#define POLY_SIG_BITS 0xffffffff 

#if !FINGERPRINT_USE_INTEGRAL_TYPE

/* Return the Ith half of T.  */

#define POLY_HALF(t, i) ((t).array[i])

/* Form an initialization expression for the polynomial whose first
   word is T0 and whose second is T1.  */

#define POLY_INIT(t0, t1) { (t0), (t1) }

/* Construct in T the polynomial whose first word is T0 and whose
   second is T1.  */

#define POLY_FORM(t, t0, t1) \
  (POLY_HALF (t, 0) = t0, POLY_HALF (t, 1) = t1)

#else /* FINGERPRINT_USE_INTEGRAL_TYPE */

#define POLY_HALF(t, i) (((int_32_t*) &(t))[i])
#define POLY_INIT(t0, t1) \
  ((((poly_t) (t1)) << 32) | (((poly_t) (t0)) & POLY_SIG_BITS))
#define POLY_FORM(t, t0, t1) ((t) = POLY_INIT ((t0), (t1)))

#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

/***********************************************************************
  Types
***********************************************************************/

/* TYPE IntPtr = UNTRACED REF Int32 */

typedef int_32_t* 
                int_ptr_t;

/* TYPE IntBytes = RECORD b0, b1, b2, b2: Byte END;

   The Modula-3 code assumes that it can treat these bytes as an Int32
   as well.  We therefore use a union; that guarantees that
   Int32-accesses will not be misaligned.  Note: this use of unions
   (to preform "type punning") results in implementation-defined
   behavior in ANSI/ISO C.  */

typedef union int_bytes_t {
  int_32_t      w;
  byte_t        b[4];
} int_bytes_t;

/***********************************************************************
  Variables
***********************************************************************/

#ifndef FINGERPRINT_LITTLE_ENDIAN
static int poly_little_endian;
static int poly_big_endian;
static int poly_init_done;
#else /* ifdef FINGERPRINT_LITTLE_ENDIAN */
#define poly_little_endian FINGERPRINT_LITTLE_ENDIAN
#endif /* ifndef FINGERPRINT_LITTLE_ENDIAN */

/* ONE = T { 0, FIRST (Int32) }; */

static const poly_t
                POLY_ONE = POLY_INIT (0, (-0x7fffffff - 1));

static const poly_t   
                poly64[256]
			/* poly64[i] = i(x) * x^64 MOD P */
			= {POLY_INIT (0, 0),          
			   POLY_INIT (36728807, 152935311),
			   POLY_INIT (73457614, 305870622),
			   POLY_INIT (105951273, 455519377),
			   POLY_INIT (85802743, 386180924),
			   POLY_INIT (120410384, 504970419),
			   POLY_INIT (25026873, 88051746),       
			   POLY_INIT (55414494, 203557805),
			   POLY_INIT (132578437, 494634872),    
			   POLY_INIT (97948514, 342236407),
			   POLY_INIT (59122507, 255897702),     
			   POLY_INIT (28724396, 106769385),
			   POLY_INIT (50053746, 176103492),     
			   POLY_INIT (13348245, 56802251),
			   POLY_INIT (110828988, 407115610),    
			   POLY_INIT (78344795, 291081429),
			   POLY_INIT (34699361, 159762416),     
			   POLY_INIT (2168710, 9985151),
			   POLY_INIT (108111791, 465498350),    
			   POLY_INIT (71419976, 312699745),
			   POLY_INIT (118245014, 511795404),    
			   POLY_INIT (87828849, 396163907),
			   POLY_INIT (57448792, 213538770),     
			   POLY_INIT (22869695, 94882909),
			   POLY_INIT (100107492, 352206984),    
			   POLY_INIT (130542339, 501472007),
			   POLY_INIT (26696490, 113604502),     
			   POLY_INIT (61289677, 265874457),
			   POLY_INIT (15383059, 66774964),      
			   POLY_INIT (47896052, 182942779),
			   POLY_INIT (76178909, 297914538),     
			   POLY_INIT (112855610, 417090341),
			   POLY_INIT (69398722, 319524832),     
			   POLY_INIT (101883685, 437654639),
			   POLY_INIT (4337420, 19970302),       
			   POLY_INIT (41042155, 137175921),
			   POLY_INIT (20958773, 68102364),      
			   POLY_INIT (51356114, 219329363),
			   POLY_INIT (90116603, 372514754),     
			   POLY_INIT (124747292, 522814541),
			   POLY_INIT (63179847, 242223256),     
			   POLY_INIT (32793504, 124621591),
			   POLY_INIT (128242569, 474693510),    
			   POLY_INIT (93633646, 357999625),
			   POLY_INIT (114897584, 427077540),    
			   POLY_INIT (82402647, 275330091),
			   POLY_INIT (45739390, 189765818),     
			   POLY_INIT (9011865, 38929205),
			   POLY_INIT (104040611, 445532176),    
			   POLY_INIT (67364676, 328455071),
			   POLY_INIT (39016301, 146112270),     
			   POLY_INIT (6502538, 27845761),
			   POLY_INIT (53392980, 227209004),     
			   POLY_INIT (18799027, 77034659),
			   POLY_INIT (122579354, 531748914),    
			   POLY_INIT (92145277, 380388285),
			   POLY_INIT (30766118, 133549928),     
			   POLY_INIT (65346497, 250107111),
			   POLY_INIT (95792104, 365885558),     
			   POLY_INIT (126206991, 483615737),
			   POLY_INIT (80235217, 284256340),     
			   POLY_INIT (116925750, 434959323),
			   POLY_INIT (11048223, 46817098),      
			   POLY_INIT (43580152, 198689989),
			   POLY_INIT (93937903, 358995648),     
			   POLY_INIT (128519944, 477646159),
			   POLY_INIT (33144609, 123658718),     
			   POLY_INIT (63557830, 239303249),
			   POLY_INIT (8674840, 39940604),       
			   POLY_INIT (45363711, 192735859),
			   POLY_INIT (82084310, 274351842),     
			   POLY_INIT (114617905, 424140141),
			   POLY_INIT (41917546, 136204728),     
			   POLY_INIT (5239693, 17025591),
			   POLY_INIT (102712228, 438658726),    
			   POLY_INIT (70200387, 322501929),
			   POLY_INIT (123904669, 521860740),    
			   POLY_INIT (89312634, 369585419),
			   POLY_INIT (50494803, 220316058),     
			   POLY_INIT (20058804, 71064085),
			   POLY_INIT (126359694, 484446512),    
			   POLY_INIT (95975273, 368937663),
			   POLY_INIT (65587008, 249243182),     
			   POLY_INIT (30976167, 130465185),
			   POLY_INIT (43329145, 199538188),     
			   POLY_INIT (10832286, 49884547),
			   POLY_INIT (116783543, 434077970),    
			   POLY_INIT (80057936, 281156253),
			   POLY_INIT (7267339, 26973768),       
			   POLY_INIT (39750636, 143003079),
			   POLY_INIT (68041669, 329294166),     
			   POLY_INIT (104748066, 448608985),
			   POLY_INIT (91478780, 379531636),     
			   POLY_INIT (121877787, 528657147),
			   POLY_INIT (18023730, 77858410),      
			   POLY_INIT (52652757, 230268389),
			   POLY_INIT (29069357, 107895072),     
			   POLY_INIT (59506634, 259244719),
			   POLY_INIT (98258915, 341143102),     
			   POLY_INIT (132849668, 491320753),
			   POLY_INIT (78032602, 292224540),     
			   POLY_INIT (110543165, 410477971),
			   POLY_INIT (13005076, 55691522),      
			   POLY_INIT (49684211, 172774029),
			   POLY_INIT (106785960, 454418008),    
			   POLY_INIT (74253135, 302532055),
			   POLY_INIT (37598054, 154069318),     
			   POLY_INIT (908417, 3371721),
			   POLY_INIT (54547039, 202471780),     
			   POLY_INIT (24133048, 84730603),
			   POLY_INIT (119573905, 506089082),    
			   POLY_INIT (84992630, 389535221),
			   POLY_INIT (61532236, 267099856),     
			   POLY_INIT (26904491, 116786527),
			   POLY_INIT (130692994, 500214222),    
			   POLY_INIT (100292709, 348992065),
			   POLY_INIT (112711355, 418331116),    
			   POLY_INIT (76003676, 301113955),
			   POLY_INIT (47647093, 181669618),     
			   POLY_INIT (15165074, 63542653),
			   POLY_INIT (72094921, 311433640),     
			   POLY_INIT (108821294, 462258727),
			   POLY_INIT (2935559, 11218614),       
			   POLY_INIT (35431648, 162968889),
			   POLY_INIT (22096446, 93634196),      
			   POLY_INIT (56706521, 210314523),
			   POLY_INIT (87160304, 397379978),     
			   POLY_INIT (117545495, 514986501),
			   POLY_INIT (116277429, 431580288),    
			   POLY_INIT (81669970, 279248655),
			   POLY_INIT (42901371, 193090462),     
			   POLY_INIT (12513436, 44025873),
			   POLY_INIT (66289218, 247317436),     
			   POLY_INIT (29561253, 127948851),
			   POLY_INIT (127115660, 478606498),    
			   POLY_INIT (94621291, 362508077),
			   POLY_INIT (17349680, 79881208),      
			   POLY_INIT (54055895, 232749175),
			   POLY_INIT (90727422, 385471718),     
			   POLY_INIT (123210777, 535056233),
			   POLY_INIT (68518599, 331760836),     
			   POLY_INIT (103148832, 450617163),
			   POLY_INIT (7691529, 33387482),       
			   POLY_INIT (38089454, 148957269),
			   POLY_INIT (83835092, 272409456),     
			   POLY_INIT (114251571, 421607679),
			   POLY_INIT (10479386, 34051182),      
			   POLY_INIT (45058301, 186257377),
			   POLY_INIT (31589923, 121111628),     
			   POLY_INIT (64121284, 237346755),
			   POLY_INIT (92461549, 352531282),     
			   POLY_INIT (129152522, 471771357),
			   POLY_INIT (52020305, 222766088),     
			   POLY_INIT (19508150, 73056135),
			   POLY_INIT (125377439, 528225046),    
			   POLY_INIT (88700024, 375490713),
			   POLY_INIT (100989606, 440632116),    
			   POLY_INIT (70554945, 324933819),
			   POLY_INIT (40117608, 142128170),     
			   POLY_INIT (5524111, 23408549),
			   POLY_INIT (46968951, 179497824),     
			   POLY_INIT (16572304, 61829359),
			   POLY_INIT (111964089, 411688062),    
			   POLY_INIT (77332574, 294930417),
			   POLY_INIT (131174016, 498486364),    
			   POLY_INIT (98689383, 346806227),
			   POLY_INIT (61952334, 260930370),     
			   POLY_INIT (25247401, 110158029),
			   POLY_INIT (86658290, 399076376),     
			   POLY_INIT (119153429, 517273495),
			   POLY_INIT (21664572, 99769094),      
			   POLY_INIT (58391771, 217038985),
			   POLY_INIT (3633669, 13486884),       
			   POLY_INIT (34020834, 164647083),
			   POLY_INIT (72854987, 318176314),     
			   POLY_INIT (107463212, 468412341),
			   POLY_INIT (14534678, 53947536),      
			   POLY_INIT (49129457, 170571551),
			   POLY_INIT (79501272, 286006158),     
			   POLY_INIT (109934655, 403800065),
			   POLY_INIT (96532193, 338922412),     
			   POLY_INIT (133208326, 489558051),
			   POLY_INIT (27273519, 101235890),     
			   POLY_INIT (59786952, 253044541),
			   POLY_INIT (121320595, 508341224),    
			   POLY_INIT (84630388, 391196775),
			   POLY_INIT (56355677, 209165558),     
			   POLY_INIT (23823546, 90834809),
			   POLY_INIT (36047460, 155716820),     
			   POLY_INIT (1467779, 5609307),
			   POLY_INIT (105305514, 460536778),    
			   POLY_INIT (74889805, 309239877),
			   POLY_INIT (58138714, 215790144),     
			   POLY_INIT (21450685, 96545231),
			   POLY_INIT (119013268, 518489438),    
			   POLY_INIT (86478963, 402267857),
			   POLY_INIT (107617965, 467146108),    
			   POLY_INIT (73036106, 314937075),
			   POLY_INIT (34259299, 165880418),     
			   POLY_INIT (3845764, 16693741),
			   POLY_INIT (76668127, 296170808),     
			   POLY_INIT (111260472, 414887607),
			   POLY_INIT (15794961, 60555814),      
			   POLY_INIT (46230774, 176265641),
			   POLY_INIT (26010152, 111383044),     
			   POLY_INIT (62688719, 264112523),
			   POLY_INIT (99368422, 345548058),     
			   POLY_INIT (131879425, 495271573),
			   POLY_INIT (23484475, 89748912),      
			   POLY_INIT (55982044, 205844031),
			   POLY_INIT (84314101, 392315566),     
			   POLY_INIT (121038866, 511695137),
			   POLY_INIT (75196108, 308138636),     
			   POLY_INIT (105580843, 457197827),
			   POLY_INIT (1816834, 6743442),        
			   POLY_INIT (36427493, 159088157),
			   POLY_INIT (109094078, 404943560),    
			   POLY_INIT (78695257, 289368391),
			   POLY_INIT (48266096, 169461206),     
			   POLY_INIT (13636759, 50617945),
			   POLY_INIT (60660297, 254170612),     
			   POLY_INIT (28177838, 104582779),
			   POLY_INIT (134038919, 488465130),    
			   POLY_INIT (97331808, 335608165),
			   POLY_INIT (123064472, 534199712),    
			   POLY_INIT (90554239, 382379567),
			   POLY_INIT (53808982, 233573054),     
			   POLY_INIT (17129649, 82940209),
			   POLY_INIT (38334063, 148085404),     
			   POLY_INIT (7897480, 30277907),
			   POLY_INIT (103297441, 451456386),    
			   POLY_INIT (68705862, 334837261),
			   POLY_INIT (11742237, 44874456),      
			   POLY_INIT (42157050, 196157783),
			   POLY_INIT (80999379, 278367686),     
			   POLY_INIT (115579956, 428480073),
			   POLY_INIT (95294186, 363339236),     
			   POLY_INIT (127827213, 481658475),
			   POLY_INIT (30330148, 127085306),     
			   POLY_INIT (67019459, 244232565),
			   POLY_INIT (88385785, 374536784),     
			   POLY_INIT (125093662, 525296095),
			   POLY_INIT (19167031, 74042702),      
			   POLY_INIT (51648720, 225728193),
			   POLY_INIT (5871118, 22437228),       
			   POLY_INIT (40499689, 139183843),
			   POLY_INIT (70863296, 325937778),     
			   POLY_INIT (101262887, 443609597),
			   POLY_INIT (44192892, 187268392),     
			   POLY_INIT (9583515, 37021351),
			   POLY_INIT (113413042, 420629046),    
			   POLY_INIT (83027029, 269472185),
			   POLY_INIT (129985163, 472766996),    
			   POLY_INIT (93259116, 355484059),
			   POLY_INIT (64992581, 236383498),     
			   POLY_INIT (32496290, 118191749)
			};

static const poly_t   
                poly72[256]
			/* poly72[i] = i(x) * x^72 MOD P */
			= {POLY_INIT (0, 0),                    
			   POLY_INIT (-1961202135, 335293334),
			   POLY_INIT (468213049, 344628781),    
			   POLY_INIT (-1863175408, 125220283),
			   POLY_INIT (973880089, 443020634),    
			   POLY_INIT (-1323936464, 161210060),
			   POLY_INIT (568616480, 250440567),    
			   POLY_INIT (-1426192375, 487669985),
			   POLY_INIT (2042951513, 129835956),   
			   POLY_INIT (-220292752, 339806242),
			   POLY_INIT (1647094368, 322420121),   
			   POLY_INIT (-382286775, 13342223),
			   POLY_INIT (1137232960, 500881134),   
			   POLY_INIT (-925719959, 237436280),
			   POLY_INIT (1478529401, 156256451),   
			   POLY_INIT (-751108272, 447505237),
			   POLY_INIT (-209064270, 259671912),   
			   POLY_INIT (2022932635, 478571774),
			   POLY_INIT (-396250229, 468769093),   
			   POLY_INIT (1669062050, 135066323),
			   POLY_INIT (-913975893, 354267698),   
			   POLY_INIT (1117764482, 115448228),
			   POLY_INIT (-764573550, 26684447),    
			   POLY_INIT (1501030075, 309004169),
			   POLY_INIT (-1974658581, 147285212),  
			   POLY_INIT (22509506, 456871754),
			   POLY_INIT (-1851439918, 474872561),  
			   POLY_INIT (448735995, 263311719),
			   POLY_INIT (-1337908494, 312512902),  
			   POLY_INIT (995839195, 22854160),
			   POLY_INIT (-1414955061, 103419819),  
			   POLY_INIT (548606434, 366355517),
			   POLY_INIT (-418128540, 519343825),   
			   POLY_INIT (1812575053, 218670407),
			   POLY_INIT (-50626467, 176034044),    
			   POLY_INIT (2011295348, 427965290),
			   POLY_INIT (-585111939, 76774283),    
			   POLY_INIT (1443203156, 393170973),
			   POLY_INIT (-956843196, 270132646),   
			   POLY_INIT (1307432301, 65392176),
			   POLY_INIT (-1630066115, 424258917),  
			   POLY_INIT (365773844, 179668723),
			   POLY_INIT (-2059438332, 230896456),  
			   POLY_INIT (237312301, 507451614),
			   POLY_INIT (-1529147100, 53368895),   
			   POLY_INIT (801210125, 282227625),
			   POLY_INIT (-1087157219, 396674578),  
			   POLY_INIT (875110964, 72936836),
			   POLY_INIT (345650134, 294570425),    
			   POLY_INIT (-1618977281, 41083439),
			   POLY_INIT (259157743, 84170644),     
			   POLY_INIT (-2073558842, 385383426),
			   POLY_INIT (781584591, 199834851),    
			   POLY_INIT (-1517525274, 404035445),
			   POLY_INIT (897471990, 526623438),    
			   POLY_INIT (-1100727329, 211781976),
			   POLY_INIT (1834927247, 372501005),   
			   POLY_INIT (-431707482, 97501595),
			   POLY_INIT (1991678390, 45708320),    
			   POLY_INIT (-38996065, 289759158),
			   POLY_INIT (1465057174, 206839639),   
			   POLY_INIT (-599223873, 531117249),
			   POLY_INIT (1287299759, 417235322),   
			   POLY_INIT (-945763194, 186821356),
			   POLY_INIT (-1006945373, 245093539),  
			   POLY_INIT (1222727050, 493354805),
			   POLY_INIT (-669817190, 437340814),   
			   POLY_INIT (1393100979, 166551832),
			   POLY_INIT (-101252934, 352068089),   
			   POLY_INIT (1928162963, 117443183),
			   POLY_INIT (-501260925, 7782356),     
			   POLY_INIT (1761948586, 327849026),
			   POLY_INIT (-1170223878, 153548567),  
			   POLY_INIT (824550099, 450550913),
			   POLY_INIT (-1579707965, 497838394),  
			   POLY_INIT (718143466, 240140972),
			   POLY_INIT (-2144077853, 323027533),  
			   POLY_INIT (187275722, 12397019),
			   POLY_INIT (-1680102694, 130784352),  
			   POLY_INIT (281134323, 339195894),
			   POLY_INIT (812832017, 31560651),     
			   POLY_INIT (-1150764232, 303937629),
			   POLY_INIT (731547688, 359337446),    
			   POLY_INIT (-1602165247, 110569072),
			   POLY_INIT (176090632, 461792913),    
			   POLY_INIT (-2124120031, 142232839),
			   POLY_INIT (295088945, 252508348),    
			   POLY_INIT (-1702044392, 485544746),
			   POLY_INIT (1236673096, 106737791),   
			   POLY_INIT (-1028895647, 362847209),
			   POLY_INIT (1381924721, 316026450),   
			   POLY_INIT (-649850536, 19531204),
			   POLY_INIT (1941576017, 473646373),   
			   POLY_INIT (-123701384, 264728243),
			   POLY_INIT (1750221928, 145873672),   
			   POLY_INIT (-481809855, 458092702),
			   POLY_INIT (619243207, 275733106),    
			   POLY_INIT (-1343059730, 59994596),
			   POLY_INIT (1057012734, 82166879),    
			   POLY_INIT (-1273309737, 387575753),
			   POLY_INIT (518315486, 168341288),    
			   POLY_INIT (-1778469897, 435455166),
			   POLY_INIT (84705511, 511848709),     
			   POLY_INIT (-1911099698, 226368147),
			   POLY_INIT (1563169182, 399669702),   
			   POLY_INIT (-701071433, 70144592),
			   POLY_INIT (1187269799, 56158187),    
			   POLY_INIT (-841080178, 279235709),
			   POLY_INIT (1730161287, 230001820),   
			   POLY_INIT (-331725650, 508143370),
			   POLY_INIT (2093512638, 423563953),   
			   POLY_INIT (-137225833, 180566311),
			   POLY_INIT (-681506699, 521477402),   
			   POLY_INIT (1551591004, 216610444),
			   POLY_INIT (-863414964, 195003191),   
			   POLY_INIT (1200831333, 409184417),
			   POLY_INIT (-311610516, 91416640),    
			   POLY_INIT (1719098693, 378454998),
			   POLY_INIT (-159027627, 301495917),   
			   POLY_INIT (2107572348, 33840635),
			   POLY_INIT (-1364852948, 413679278),  
			   POLY_INIT (633311493, 190059832),
			   POLY_INIT (-1253203435, 203595907),  
			   POLY_INIT (1045941308, 534678293),
			   POLY_INIT (-1800813515, 47172596),   
			   POLY_INIT (531868188, 288612450),
			   POLY_INIT (-1891526388, 373642713),  
			   POLY_INIT (73135909, 96042575),
			   POLY_INIT (-2013890746, 490187079),  
			   POLY_INIT (216799599, 248218321),
			   POLY_INIT (-1675744641, 163395434),  
			   POLY_INIT (386155606, 440474876),
			   POLY_INIT (-1107669921, 122706973),  
			   POLY_INIT (920658550, 346847115),
			   POLY_INIT (-1508765338, 333103664),  
			   POLY_INIT (755531599, 2550182),
			   POLY_INIT (-30244833, 445287155),    
			   POLY_INIT (1965616694, 158769509),
			   POLY_INIT (-438641370, 234886366),   
			   POLY_INIT (1858122511, 503070536),
			   POLY_INIT (-1002521850, 15564713),   
			   POLY_INIT (1327813935, 319902783),
			   POLY_INIT (-539564481, 342352260),   
			   POLY_INIT (1422690326, 127650322),
			   POLY_INIT (1954519540, 307097135),   
			   POLY_INIT (-10094627, 28427705),
			   POLY_INIT (1872217293, 113733634),   
			   POLY_INIT (-460477724, 356211604),
			   POLY_INIT (1316201197, 136977269),   
			   POLY_INIT (-982922044, 467022051),
			   POLY_INIT (1436286932, 480281944),   
			   POLY_INIT (-561933827, 257732302),
			   POLY_INIT (230387373, 368102811),    
			   POLY_INIT (-2036268924, 101508621),
			   POLY_INIT (374551444, 24794038),     
			   POLY_INIT (-1656136259, 310802464),
			   POLY_INIT (934761908, 261568705),    
			   POLY_INIT (-1129497699, 476779351),
			   POLY_INIT (744425613, 454928108),    
			   POLY_INIT (-1488623964, 148999546),
			   POLY_INIT (1625664034, 63121302),    
			   POLY_INIT (-335559669, 272567296),
			   POLY_INIT (2064512795, 390707643),   
			   POLY_INIT (-266888910, 79008301),
			   POLY_INIT (1525256507, 430232268),   
			   POLY_INIT (-772538606, 173603162),
			   POLY_INIT (1090636802, 221138145),   
			   POLY_INIT (-904158677, 517105527),
			   POLY_INIT (421617019, 75367458),     
			   POLY_INIT (-1841613998, 394407860),
			   POLY_INIT (46727234, 284465679),     
			   POLY_INIT (-1982632341, 50901401),
			   POLY_INIT (590177890, 505016696),    
			   POLY_INIT (-1472788405, 233167598),
			   POLY_INIT (952449883, 177434453),    
			   POLY_INIT (-1277209230, 426722499),
			   POLY_INIT (-1821621104, 213475582),  
			   POLY_INIT (410397369, 524634984),
			   POLY_INIT (-2004608599, 406060755),  
			   POLY_INIT (60716928, 198169925),
			   POLY_INIT (-1453293687, 383686052),  
			   POLY_INIT (578425248, 86162994),
			   POLY_INIT (-1299701072, 39062409),   
			   POLY_INIT (965889177, 296230943),
			   POLY_INIT (-358042679, 184828746),   
			   POLY_INIT (1639112160, 418932956),
			   POLY_INIT (-247402768, 529456487),   
			   POLY_INIT (2052751577, 208860913),
			   POLY_INIT (-794523440, 291747344),   
			   POLY_INIT (1539237625, 44014982),
			   POLY_INIT (-884156951, 99166269),    
			   POLY_INIT (1079425984, 370475947),
			   POLY_INIT (1141722341, 330071524),   
			   POLY_INIT (-820567348, 5265010),
			   POLY_INIT (1608847836, 119989193),   
			   POLY_INIT (-721453067, 349882463),
			   POLY_INIT (2114025468, 164333758),   
			   POLY_INIT (-182773291, 439853864),
			   POLY_INIT (1709779653, 490804883),   
			   POLY_INIT (-286046996, 247282949),
			   POLY_INIT (1036630972, 336682576),   
			   POLY_INIT (-1227631211, 133002694),
			   POLY_INIT (639755909, 10207357),     
			   POLY_INIT (-1388607316, 325577707),
			   POLY_INIT (130384037, 242658058),    
			   POLY_INIT (-1931481460, 495616156),
			   POLY_INIT (472767900, 452736295),    
			   POLY_INIT (-1757957195, 151002801),
			   POLY_INIT (-1216044457, 483801740),  
			   POLY_INIT (1017039998, 254415130),
			   POLY_INIT (-1402142866, 140289185),  
			   POLY_INIT (662081863, 463507255),
			   POLY_INIT (-1920427698, 112316374),  
			   POLY_INIT (110294887, 357426240),
			   POLY_INIT (-1772043145, 305877499),  
			   POLY_INIT (494578270, 29850221),
			   POLY_INIT (-834644722, 460003640),   
			   POLY_INIT (1163541287, 144126638),
			   POLY_INIT (-710408137, 266438421),   
			   POLY_INIT (1588749854, 471706755),
			   POLY_INIT (-196317673, 17624162),    
			   POLY_INIT (2136342590, 317769716),
			   POLY_INIT (-274451666, 361132623),   
			   POLY_INIT (1690197255, 108681689),
			   POLY_INIT (-1558277759, 223933237),  
			   POLY_INIT (671416232, 514119843),
			   POLY_INIT (-1191785288, 433220888),  
			   POLY_INIT (871146129, 170804878),
			   POLY_INIT (-1726829928, 390006383),  
			   POLY_INIT (302564529, 79900153),
			   POLY_INIT (-2097481823, 62232642),   
			   POLY_INIT (165714312, 273265620),
			   POLY_INIT (-623221032, 182833281),   
			   POLY_INIT (1371539697, 421133079),
			   POLY_INIT (-1053672479, 510611116),  
			   POLY_INIT (1244157384, 227763514),
			   POLY_INIT (-522822207, 276964827),   
			   POLY_INIT (1808544744, 58592845),
			   POLY_INIT (-79822600, 67681270),     
			   POLY_INIT (1881435857, 401903712),
			   POLY_INIT (1352105779, 35828829),    
			   POLY_INIT (-611512038, 299802571),
			   POLY_INIT (1266622986, 380119664),   
			   POLY_INIT (-1067103197, 89391590),
			   POLY_INIT (1788560426, 407191815),   
			   POLY_INIT (-511628797, 196700817),
			   POLY_INIT (1903368467, 214949674),   
			   POLY_INIT (-93751494, 523498684),
			   POLY_INIT (693340266, 94345193),     
			   POLY_INIT (-1572215229, 375635071),
			   POLY_INIT (851170643, 286591428),    
			   POLY_INIT (-1180583046, 48833106),
			   POLY_INIT (325038963, 536371891),    
			   POLY_INIT (-1740251814, 201607461),
			   POLY_INIT (146271818, 192085150),    
			   POLY_INIT (-2085781405, 412014344)
			};

static const poly_t   
                poly80[256]
                        /* poly80[i] = i(x) * X^80 MOD P */
			= {POLY_INIT (0, 0),                    
			   POLY_INIT (-1753253426, 125726524),
			   POLY_INIT (788460444, 251453049),    
			   POLY_INIT (-1182692782, 159560005),
			   POLY_INIT (1576920888, 502906098),   
			   POLY_INIT (-897409290, 445109198),
			   POLY_INIT (1929581732, 319120011),   
			   POLY_INIT (-461607574, 343608759),
			   POLY_INIT (-1238937829, 142717156),  
			   POLY_INIT (559429333, 268427224),
			   POLY_INIT (-1730560889, 108883613),  
			   POLY_INIT (262587721, 16974241),
			   POLY_INIT (-337991645, 360188950),   
			   POLY_INIT (2091241965, 302408490),
			   POLY_INIT (-987472961, 461689455),   
			   POLY_INIT (1381704305, 486194515),
			   POLY_INIT (1817091638, 285434313),   
			   POLY_INIT (-80615432, 377294581),
			   POLY_INIT (1118858666, 536854448),   
			   POLY_INIT (-707849116, 411160716),
			   POLY_INIT (833845518, 217767227),    
			   POLY_INIT (-1496579904, 193245703),
			   POLY_INIT (525175442, 33948482),     
			   POLY_INIT (-2009926820, 91778174),
			   POLY_INIT (-630599379, 428003629),   
			   POLY_INIT (1293330659, 519880209),
			   POLY_INIT (-191421775, 394137428),   
			   POLY_INIT (1676172159, 268460136),
			   POLY_INIT (-2020329963, 75197919),   
			   POLY_INIT (283856859, 50660067),
			   POLY_INIT (-1452620407, 176665510),  
			   POLY_INIT (1041611847, 234478746),
			   POLY_INIT (-717112057, 292817554),   
			   POLY_INIT (1111409865, 369780142),
			   POLY_INIT (-71348581, 529061099),    
			   POLY_INIT (1824536405, 418823127),
			   POLY_INIT (-2000922049, 210613856),  
			   POLY_INIT (532882417, 200530268),
			   POLY_INIT (-1505580637, 40986649),   
			   POLY_INIT (826134637, 84870949),
			   POLY_INIT (1667691036, 435534454),   
			   POLY_INIT (-199652398, 512480586),
			   POLY_INIT (1301807488, 386491407),   
			   POLY_INIT (-622364594, 276237107),
			   POLY_INIT (1050350884, 67896964),    
			   POLY_INIT (-1444647702, 57829816),
			   POLY_INIT (275113656, 183556349),    
			   POLY_INIT (-2028298378, 227456961),
			   POLY_INIT (-1190190287, 7826267),    
			   POLY_INIT (779115263, 118031463),
			   POLY_INIT (-1745760083, 244036898),  
			   POLY_INIT (9349475, 167107102),
			   POLY_INIT (-453852151, 495900585),   
			   POLY_INIT (1938668999, 451983509),
			   POLY_INIT (-905169003, 326240720),   
			   POLY_INIT (1567837787, 336357100),
			   POLY_INIT (254307370, 150395839),    
			   POLY_INIT (-1739123228, 260617347),
			   POLY_INIT (567713718, 101320134),    
			   POLY_INIT (-1230379400, 24406778),
			   POLY_INIT (1389726482, 353331021),   
			   POLY_INIT (-978652452, 309397617),
			   POLY_INIT (2083223694, 468957492),   
			   POLY_INIT (-346816192, 479057416),
			   POLY_INIT (-1486881947, 295361573),  
			   POLY_INIT (807436971, 384086809),
			   POLY_INIT (-1985935111, 526778972),  
			   POLY_INIT (517894455, 404254048),
			   POLY_INIT (-90039203, 207839447),    
			   POLY_INIT (1843226003, 186453995),
			   POLY_INIT (-732106815, 44023470),    
			   POLY_INIT (1126405647, 98685330),
			   POLY_INIT (293123198, 421227713),    
			   POLY_INIT (-2046308944, 509936637),
			   POLY_INIT (1065764834, 401060536),   
			   POLY_INIT (-1460060628, 278519172),
			   POLY_INIT (1283806022, 81973299),    
			   POLY_INIT (-604362104, 60604175),
			   POLY_INIT (1652269274, 169741898),   
			   POLY_INIT (-184231660, 224420214),
			   POLY_INIT (-888052397, 10075628),    
			   POLY_INIT (1550720157, 132633296),
			   POLY_INIT (-437283121, 241525653),   
			   POLY_INIT (1922100993, 152767657),
			   POLY_INIT (-1762885013, 492831006),  
			   POLY_INIT (26475429, 438201890),
			   POLY_INIT (-1206750729, 329047911),  
			   POLY_INIT (795674681, 350400603),
			   POLY_INIT (2100701768, 135793928),   
			   POLY_INIT (-364293242, 258368052),
			   POLY_INIT (1405671892, 115659633),   
			   POLY_INIT (-994598886, 26917965),
			   POLY_INIT (550227312, 367112698),    
			   POLY_INIT (-1212894018, 312467142),
			   POLY_INIT (238370540, 454913923),    
			   POLY_INIT (-1723185374, 476250303),
			   POLY_INIT (1914586722, 15652535),    
			   POLY_INIT (-446611540, 126925195),
			   POLY_INIT (1558230526, 236062926),   
			   POLY_INIT (-878719952, 158099442),
			   POLY_INIT (803447130, 488073797),    
			   POLY_INIT (-1197680492, 443090297),
			   POLY_INIT (18698950, 334214204),     
			   POLY_INIT (-1771951352, 345365248),
			   POLY_INIT (-1002894983, 141518419),  
			   POLY_INIT (1397125303, 252774767),
			   POLY_INIT (-355992859, 110344234),   
			   POLY_INIT (2109244203, 32364310),
			   POLY_INIT (-1715147199, 362207905),  
			   POLY_INIT (247175055, 317240733),
			   POLY_INIT (-1220928035, 459932888),  
			   POLY_INIT (541418515, 471100388),
			   POLY_INIT (508614740, 300791678),    
			   POLY_INIT (-1993367142, 378787906),
			   POLY_INIT (816720840, 521234695),    
			   POLY_INIT (-1479454202, 409929275),
			   POLY_INIT (1135427436, 202640268),   
			   POLY_INIT (-724416862, 191521968),
			   POLY_INIT (1834208496, 48813557),    
			   POLY_INIT (-97733314, 93764297),
			   POLY_INIT (-1468557489, 426510234),  
			   POLY_INIT (1057549953, 504522918),
			   POLY_INIT (-2037816109, 395368931),  
			   POLY_INIT (301341981, 284079839),
			   POLY_INIT (-175476617, 76921704),    
			   POLY_INIT (1660225977, 65786964),
			   POLY_INIT (-613121045, 174679313),   
			   POLY_INIT (1275853349, 219613741),
			   POLY_INIT (1130592161, 273117515),   
			   POLY_INIT (-736358801, 389619319),
			   POLY_INIT (1839039549, 515616562),   
			   POLY_INIT (-85787149, 432390158),
			   POLY_INIT (513708185, 230608313),    
			   POLY_INIT (-1981683369, 180396677),
			   POLY_INIT (811623173, 54662080),     
			   POLY_INIT (-1491133749, 71073020),
			   POLY_INIT (-180078406, 415678895),   
			   POLY_INIT (1648050548, 532197011),
			   POLY_INIT (-608515290, 372907990),   
			   POLY_INIT (1288024808, 289698026),
			   POLY_INIT (-1464213630, 88046941),   
			   POLY_INIT (1069983308, 37818977),
			   POLY_INIT (-2042156002, 197370660),  
			   POLY_INIT (288904656, 213765144),
			   POLY_INIT (791538071, 21237890),     
			   POLY_INIT (-1202548647, 104497086),
			   POLY_INIT (30611979, 263769851),     
			   POLY_INIT (-1767087163, 147235271),
			   POLY_INIT (1926237871, 482192496),   
			   POLY_INIT (-441485471, 465814348),
			   POLY_INIT (1546583347, 306278921),   
			   POLY_INIT (-883849987, 356457781),
			   POLY_INIT (-1727355252, 163946598),  
			   POLY_INIT (242605890, 247189338),
			   POLY_INIT (-1208724208, 121208351),  
			   POLY_INIT (545991902, 4657443),
			   POLY_INIT (-990428748, 339483796),   
			   POLY_INIT (1401436282, 323122088),
			   POLY_INIT (-368463320, 448840429),   
			   POLY_INIT (2104937446, 499035601),
			   POLY_INIT (-1776104794, 20151257),   
			   POLY_INIT (22917992, 105714917),
			   POLY_INIT (-1193526982, 265266592),  
			   POLY_INIT (799228148, 145869468),
			   POLY_INIT (-874566242, 483051307),   
			   POLY_INIT (1554011216, 464824343),
			   POLY_INIT (-450765310, 305535314),   
			   POLY_INIT (1918805964, 357070446),
			   POLY_INIT (537232829, 162712381),    
			   POLY_INIT (-1216676749, 248292353),
			   POLY_INIT (251360801, 122557764),    
			   POLY_INIT (-1719398417, 3177080),
			   POLY_INIT (2113430149, 340490191),   
			   POLY_INIT (-360244405, 322246899),
			   POLY_INIT (1392939289, 448244150),   
			   POLY_INIT (-998643497, 499762826),
			   POLY_INIT (-93563760, 271587856),    
			   POLY_INIT (1829973342, 391017772),
			   POLY_INIT (-728586484, 516736105),   
			   POLY_INIT (1139662530, 431139669),
			   POLY_INIT (-1483623512, 231319266),  
			   POLY_INIT (820955750, 179816926),
			   POLY_INIT (-1989197772, 53835931),   
			   POLY_INIT (504379898, 72030119),
			   POLY_INIT (1279990667, 414296820),   
			   POLY_INIT (-617323963, 533710280),
			   POLY_INIT (1656088599, 374174861),   
			   POLY_INIT (-171273767, 288562097),
			   POLY_INIT (297204915, 88610310),     
			   POLY_INIT (-2033613443, 37124410),
			   POLY_INIT (1061687087, 196397183),   
			   POLY_INIT (-1472760095, 214607683),
			   POLY_INIT (-465793852, 31305070),    
			   POLY_INIT (1933833482, 111395410),
			   POLY_INIT (-893223080, 253850391),   
			   POLY_INIT (1572669078, 140450859),
			   POLY_INIT (-1178506244, 472125852),  
			   POLY_INIT (784208434, 458915488),
			   POLY_INIT (-1757439904, 316198885),  
			   POLY_INIT (4252078, 363241689),
			   POLY_INIT (1377551327, 157031818),   
			   POLY_INIT (-983254511, 237138614),
			   POLY_INIT (2095394883, 127976435),   
			   POLY_INIT (-342210163, 14593231),
			   POLY_INIT (266740967, 346399096),    
			   POLY_INIT (-1734779607, 333172292),
			   POLY_INIT (555276155, 442072833),    
			   POLY_INIT (-1234719051, 489099325),
			   POLY_INIT (-2005789966, 283036839),  
			   POLY_INIT (520973116, 396403611),
			   POLY_INIT (-1500716690, 505549534),  
			   POLY_INIT (838047904, 425491938),
			   POLY_INIT (-711985718, 220688469),   
			   POLY_INIT (1123060740, 173612905),
			   POLY_INIT (-76478890, 64728620),     
			   POLY_INIT (1812889496, 77971728),
			   POLY_INIT (1045781993, 408910915),   
			   POLY_INIT (-1456856025, 522261375),
			   POLY_INIT (279686773, 379822650),    
			   POLY_INIT (-2016094277, 299748614),
			   POLY_INIT (1672002257, 94814385),    
			   POLY_INIT (-187186401, 47755149),
			   POLY_INIT (1297500493, 190455496),   
			   POLY_INIT (-634834813, 203715060),
			   POLY_INIT (830288323, 279554044),    
			   POLY_INIT (-1509799923, 400017600),
			   POLY_INIT (528728671, 508918149),    
			   POLY_INIT (-1996702831, 422254265),
			   POLY_INIT (1820382971, 223353614),   
			   POLY_INIT (-67129547, 170816562),
			   POLY_INIT (1115563367, 61654391),    
			   POLY_INIT (-721331031, 80915019),
			   POLY_INIT (-2024112424, 405280536),  
			   POLY_INIT (270862102, 525760548),
			   POLY_INIT (-1448833724, 383043937),  
			   POLY_INIT (1054602378, 296396381),
			   POLY_INIT (-626550304, 97627114),    
			   POLY_INIT (1306058798, 45073622),
			   POLY_INIT (-195466628, 187528595),   
			   POLY_INIT (1663439794, 206772911),
			   POLY_INIT (1563668469, 27969077),    
			   POLY_INIT (-900934085, 114600201),
			   POLY_INIT (1942838377, 257300556),   
			   POLY_INIT (-458087001, 136869744),
			   POLY_INIT (13519053, 475232967),     
			   POLY_INIT (-1749995261, 455939579),
			   POLY_INIT (774945617, 313500862),    
			   POLY_INIT (-1185955169, 366070658),
			   POLY_INIT (-350953234, 153843409),   
			   POLY_INIT (2087426336, 240458221),
			   POLY_INIT (-974515342, 131573928),   
			   POLY_INIT (1385523900, 11126676),
			   POLY_INIT (-1226242090, 349358627),  
			   POLY_INIT (563510808, 330081567),
			   POLY_INIT (-1743260598, 439227482),  
			   POLY_INIT (258510212, 491813734)
};

static const poly_t   
                poly88[256]
                        /* poly80[i] = i(x) * X^80 MOD P */
			= {POLY_INIT (0, 0),                    
			   POLY_INIT (964379295, 346020725),
			   POLY_INIT (2133460053, 441286634),   
			   POLY_INIT (1179731658, 248685727),
			   POLY_INIT (-209155647, 132658900),   
			   POLY_INIT (-889992354, 326626721),
			   POLY_INIT (-1935503980, 497371454),  
			   POLY_INIT (-1244016885, 154833483),
			   POLY_INIT (-418311294, 265317801),   
			   POLY_INIT (-563457763, 458208988),
			   POLY_INIT (-1740957737, 362615363),  
			   POLY_INIT (-1589619384, 16959798),
			   POLY_INIT (345610819, 137911165),    
			   POLY_INIT (769841372, 480739336),
			   POLY_INIT (1806933526, 309666967),   
			   POLY_INIT (1388895369, 116064226),
			   POLY_INIT (-836622588, 530635603),   
			   POLY_INIT (-145136229, 188678182),
			   POLY_INIT (-1324866735, 99460281),   
			   POLY_INIT (-2005704242, 292716492),
			   POLY_INIT (1034596037, 407432583),   
			   POLY_INIT (80866394, 215430898),
			   POLY_INIT (1115728528, 33919597),    
			   POLY_INIT (2080106511, 379210008),
			   POLY_INIT (691221638, 275822330),    
			   POLY_INIT (273184281, 82800015),
			   POLY_INIT (1444491475, 171821328),   
			   POLY_INIT (1868722764, 513938021),
			   POLY_INIT (-625230521, 395870254),   
			   POLY_INIT (-473890856, 50813787),
			   POLY_INIT (-1517176558, 232128452),  
			   POLY_INIT (-1662321779, 424289457),
			   POLY_INIT (-1852256413, 204701607),  
			   POLY_INIT (-1461481988, 413967570),
			   POLY_INIT (-290272458, 377356365),   
			   POLY_INIT (-674657879, 48356152),
			   POLY_INIT (1645233826, 198920563),   
			   POLY_INIT (1533740093, 524587526),
			   POLY_INIT (490357495, 295057049),    
			   POLY_INIT (608239720, 84536812),
			   POLY_INIT (1988746465, 65212942),    
			   POLY_INIT (1341300350, 394054011),
			   POLY_INIT (161732788, 430861796),    
			   POLY_INIT (819501611, 221361809),
			   POLY_INIT (-2063510240, 67839194),   
			   POLY_INIT (-1132849217, 278200239),
			   POLY_INIT (-97824395, 507927344),    
			   POLY_INIT (-1018162198, 182026309),
			   POLY_INIT (1606084711, 328443124),   
			   POLY_INIT (1723968248, 118259585),
			   POLY_INIT (546368562, 165600030),    
			   POLY_INIT (434876077, 490799211),
			   POLY_INIT (-1405984346, 343642656),  
			   POLY_INIT (-1790368967, 14960981),
			   POLY_INIT (-753375757, 238480842),   
			   POLY_INIT (-362600596, 447297215),
			   POLY_INIT (-1196688411, 474204509),  
			   POLY_INIT (-2117027462, 148640296),
			   POLY_INIT (-947781712, 101627575),   
			   POLY_INIT (-17122001, 311520706),
			   POLY_INIT (1260614180, 464256905),   
			   POLY_INIT (1918382267, 255075580),
			   POLY_INIT (873035377, 31883363),     
			   POLY_INIT (225588462, 360274710),
			   POLY_INIT (590454470, 409403215),    
			   POLY_INIT (441113689, 217654330),
			   POLY_INIT (1545312915, 36405413),    
			   POLY_INIT (1700845580, 380918736),
			   POLY_INIT (-793176313, 529451419),   
			   POLY_INIT (-373140072, 185668334),
			   POLY_INIT (-1349315758, 96712305),   
			   POLY_INIT (-1763159603, 291269892),
			   POLY_INIT (-1004499644, 397841126),  
			   POLY_INIT (-44314661, 53037459),
			   POLY_INIT (-1156937455, 234614028),  
			   POLY_INIT (-2106471538, 425997945),
			   POLY_INIT (933758085, 274637874),    
			   POLY_INIT (248727066, 79789895),
			   POLY_INIT (1216479440, 169073624),   
			   POLY_INIT (1912160847, 512491693),
			   POLY_INIT (-317474366, 130425884),   
			   POLY_INIT (-731317411, 324665193),
			   POLY_INIT (-1841709673, 495672310),  
			   POLY_INIT (-1421672696, 152338563),
			   POLY_INIT (513486851, 3019464),      
			   POLY_INIT (669020828, 347195837),
			   POLY_INIT (1639003222, 442723618),   
			   POLY_INIT (1489663689, 251442775),
			   POLY_INIT (167946816, 135678389),    
			   POLY_INIT (863627487, 478778048),
			   POLY_INIT (1965600277, 307967583),   
			   POLY_INIT (1280568458, 113569066),
			   POLY_INIT (-108387455, 268336993),   
			   POLY_INIT (-1057922786, 459383828),
			   POLY_INIT (-2036324396, 364052619),  
			   POLY_INIT (-1076140725, 19717118),
			   POLY_INIT (-1297526363, 341147880),  
			   POLY_INIT (-1949166790, 13261725),
			   POLY_INIT (-847030800, 236519170),   
			   POLY_INIT (-185067665, 445064311),
			   POLY_INIT (1092737124, 331200060),   
			   POLY_INIT (2019203835, 119696713),
			   POLY_INIT (1040964657, 166775254),   
			   POLY_INIT (124821166, 493818531),
			   POLY_INIT (1438138919, 461761857),   
			   POLY_INIT (1824719032, 253376052),
			   POLY_INIT (714229362, 29921963),     
			   POLY_INIT (334038253, 358042078),
			   POLY_INIT (-1506751514, 476961685),  
			   POLY_INIT (-1622439559, 150077664),
			   POLY_INIT (-652554317, 102802559),   
			   POLY_INIT (-530477780, 314539786),
			   POLY_INIT (2089514657, 200629179),   
			   POLY_INIT (1173369918, 527073486),
			   POLY_INIT (60912372, 297280593),     
			   POLY_INIT (987377771, 86507300),
			   POLY_INIT (-1895563424, 203255151),  
			   POLY_INIT (-1233601025, 411219482),
			   POLY_INIT (-265684171, 374346373),   
			   POLY_INIT (-917325398, 47172080),
			   POLY_INIT (-1684380381, 69547538),   
			   POLY_INIT (-1562302532, 280685927),
			   POLY_INIT (-458202762, 510151160),   
			   POLY_INIT (-573889559, 183997069),
			   POLY_INIT (1746070754, 63766726),    
			   POLY_INIT (1365880445, 391306163),
			   POLY_INIT (389605559, 427851564),    
			   POLY_INIT (776186408, 220177497),
			   POLY_INIT (1270856935, 62863262),    
			   POLY_INIT (1925512824, 388033771),
			   POLY_INIT (882227378, 435308660),    
			   POLY_INIT (233765421, 225284865),
			   POLY_INIT (-1204341466, 72810826),   
			   POLY_INIT (-2125695047, 281598527),
			   POLY_INIT (-954388109, 505052832),   
			   POLY_INIT (-26840084, 176530901),
			   POLY_INIT (-1397837979, 208624183),  
			   POLY_INIT (-1781142022, 418414914),
			   POLY_INIT (-746280144, 371336669),   
			   POLY_INIT (-352327249, 46005928),
			   POLY_INIT (1596335780, 193424611),   
			   POLY_INIT (1717396539, 521713558),
			   POLY_INIT (537666289, 298455817),    
			   POLY_INIT (427253870, 89507964),
			   POLY_INIT (-2053268509, 471854285),  
			   POLY_INIT (-1125721732, 142620600),
			   POLY_INIT (-88629322, 106074919),    
			   POLY_INIT (-1009984215, 315443282),
			   POLY_INIT (1981092386, 469228057),   
			   POLY_INIT (1332629693, 258474348),
			   POLY_INIT (155129463, 29009395),     
			   POLY_INIT (809784552, 354778758),
			   POLY_INIT (1653377121, 332366180),   
			   POLY_INIT (1542966014, 122706449),
			   POLY_INIT (497454132, 159579790),    
			   POLY_INIT (618516139, 488449531),
			   POLY_INIT (-1862008416, 338147248),  
			   POLY_INIT (-1468054721, 12086469),
			   POLY_INIT (-298973707, 241879130),   
			   POLY_INIT (-682277014, 452268847),
			   POLY_INIT (-634948732, 260851769),   
			   POLY_INIT (-480497381, 454267724),
			   POLY_INIT (-1525844015, 364984275),  
			   POLY_INIT (-1669974706, 22998182),
			   POLY_INIT (699398725, 140803821),    
			   POLY_INIT (282376410, 486253976),
			   POLY_INIT (1451621904, 304677127),   
			   POLY_INIT (1878965391, 112646770),
			   POLY_INIT (1026973702, 6038928),     
			   POLY_INIT (72163993, 348389093),
			   POLY_INIT (1109156947, 437344890),   
			   POLY_INIT (2070357708, 244220175),
			   POLY_INIT (-826349113, 129241924),   
			   POLY_INIT (-138040488, 321636401),
			   POLY_INIT (-1315639918, 502885550),  
			   POLY_INIT (-1997558003, 157726683),
			   POLY_INIT (335893632, 271356778),    
			   POLY_INIT (763237919, 78858271),
			   POLY_INIT (1798262997, 174189696),   
			   POLY_INIT (1381241418, 519976949),
			   POLY_INIT (-410133183, 398763454),   
			   POLY_INIT (-554262562, 56327883),
			   POLY_INIT (-1733830380, 227138132),  
			   POLY_INIT (-1579377781, 420872481),
			   POLY_INIT (-216774910, 536673987),   
			   POLY_INIT (-898693731, 191047094),
			   POLY_INIT (-1942076585, 95519017),   
			   POLY_INIT (-1253768760, 288250460),
			   POLY_INIT (10276547, 404015127),     
			   POLY_INIT (971476060, 210441058),
			   POLY_INIT (2142685846, 39434237),    
			   POLY_INIT (1187874825, 382102664),
			   POLY_INIT (1754145313, 467257553),   
			   POLY_INIT (1375035582, 256250788),
			   POLY_INIT (396633716, 26523451),     
			   POLY_INIT (786392299, 353070158),
			   POLY_INIT (-1694061600, 473038341),  
			   POLY_INIT (-1568806529, 145630576),
			   POLY_INIT (-466833483, 108823023),   
			   POLY_INIT (-581440214, 316889754),
			   POLY_INIT (-1885392477, 336176504),  
			   POLY_INIT (-1226542276, 9862669),
			   POLY_INIT (-256559626, 239393426),   
			   POLY_INIT (-909215895, 450560487),
			   POLY_INIT (2081929314, 333550508),   
			   POLY_INIT (1164770045, 125716697),
			   POLY_INIT (54377527, 162327622),     
			   POLY_INIT (977731240, 489895731),
			   POLY_INIT (-1498675931, 75043714),   
			   POLY_INIT (-1613281350, 283560183),
			   POLY_INIT (-645529232, 506752104),   
			   POLY_INIT (-520272913, 179025693),
			   POLY_INIT (1428458724, 59843926),    
			   POLY_INIT (1818218107, 386858531),
			   POLY_INIT (705595569, 433871548),    
			   POLY_INIT (326486574, 222527945),
			   POLY_INIT (1102911143, 195657259),   
			   POLY_INIT (2026263608, 523674974),
			   POLY_INIT (1050088178, 300155329),   
			   POLY_INIT (132927597, 92002996),
			   POLY_INIT (-1305108634, 205605119),  
			   POLY_INIT (-1957765639, 417239946),
			   POLY_INIT (-853566669, 369899285),   
			   POLY_INIT (-194717268, 43248736),
			   POLY_INIT (-115937982, 401258358),   
			   POLY_INIT (-1066553379, 58027011),
			   POLY_INIT (-2042828521, 229099676),  
			   POLY_INIT (-1085822072, 423105513),
			   POLY_INIT (178152579, 268599714),    
			   POLY_INIT (870655516, 77421271),
			   POLY_INIT (1974755542, 173014600),   
			   POLY_INIT (1288643145, 516957501),
			   POLY_INIT (503840448, 406510303),    
			   POLY_INIT (662486111, 212140458),
			   POLY_INIT (1630403221, 41395509),    
			   POLY_INIT (1482078218, 384335424),
			   POLY_INIT (-309364991, 533916683),   
			   POLY_INIT (-722192994, 189609854),
			   POLY_INIT (-1834650796, 94344161),   
			   POLY_INIT (-1411501621, 285231252),
			   POLY_INIT (926206534, 139095077),    
			   POLY_INIT (240093401, 483768144),
			   POLY_INIT (1209978387, 302453711),   
			   POLY_INIT (1902480524, 110676154),
			   POLY_INIT (-994294905, 262298353),   
			   POLY_INIT (-37289704, 457015684),
			   POLY_INIT (-1147779118, 367994139),  
			   POLY_INIT (-2098395827, 24182382),
			   POLY_INIT (-802825788, 127533452),   
			   POLY_INIT (-379675813, 319150841),
			   POLY_INIT (-1357914735, 500661862),  
			   POLY_INIT (-1770742002, 155755795),
			   POLY_INIT (598560773, 7485272),      
			   POLY_INIT (450237082, 351136813),
			   POLY_INIT (1552372816, 440354994),   
			   POLY_INIT (1711019727, 245404615)
			};

#ifndef FINGERPRINT_LITTLE_ENDIAN
static void poly_find_byte_order (void)
{
  int_32_t    i = 0x12345678;
  int_bytes_t x = { i };
  word_t      a0 = word_extract (i, 0, 8);
  word_t      a1 = word_extract (i, 8, 8);
  word_t      a2 = word_extract (i, 16, 8);
  word_t      a3 = word_extract (i, 24, 8);

  if (a0 == x.b[0] && a1 == x.b[1] && a2 == x.b[2] && a3 == x.b[3]) {
    poly_little_endian = 1;
  } else if (a0 == x.b[3] && a1 == x.b[2] && a2 == x.b[1] && a3 == x.b[0]) {
    poly_big_endian = 1;
  } else {
    /* Unsupported byte ordering ...  */
    assert (0);
  }

  poly_init_done = 1;
}
#endif /* FINGERPRINT_LITTLE_ENDIAN */

/* Return the sign-extended bottom 32 bits of X.  */

static int_32_t poly_fix_32 (word_t x)
{
  if (sizeof (word_t) == sizeof (int_32_t))
    /* Sign-extension is trivial; the types are the same size.
       Hopefully, this branch will reduce the function to the
       identity, and compilers will be clever enough to inline it.  */
    return x;
  else 
    {
      const integer_t sign = 0x80000000;
      const integer_t sign_extend = word_left_shift (word_not (0), 31);
      
      if (word_and (x, sign) == 0)
	return word_and (x, POLY_SIG_BITS);
      else
	return word_or (sign_extend, word_and (x, POLY_SIG_BITS));
    }
}

#if MAY_BE_LITTLE_ENDIAN
static poly_t poly_extend_words_le (const poly_t  p,
				    const byte_t* source,
				    int           len)
{
  int_ptr_t   ip = (int_ptr_t) source;
  int_bytes_t tmp;
  /* Curiously, the Modula-3 sources use INTEGER for the type of the
     next two variables, rather than int_32_t.  */
  integer_t   p0 = POLY_HALF (p, 0);
  integer_t   p1 = POLY_HALF (p, 1);
  poly_t      result;

  while (len > 0) {
    /* Split the low-order bytes.  */
    tmp.w = p0;

    /* Compute the new result.  */
    p0 = word_xor (p1, 
		   word_xor (word_xor (POLY_HALF (poly88[tmp.b[0]], 0),
				       POLY_HALF (poly80[tmp.b[1]], 0)),
			     word_xor (POLY_HALF (poly72[tmp.b[2]], 0),
				       POLY_HALF (poly64[tmp.b[3]], 0))));
    p1 = word_xor (*ip, 
		   word_xor (word_xor (POLY_HALF (poly88[tmp.b[0]], 1),
				       POLY_HALF (poly80[tmp.b[1]], 1)),
			     word_xor (POLY_HALF (poly72[tmp.b[2]], 1),
				       POLY_HALF (poly64[tmp.b[3]], 1))));
    len -= sizeof (int_32_t);
    ++ip; /* The Modula-3 source is INC (ip, ADRSIZE (ip^)), but C's
	     pointer arithmetic behaves differently.  */
  }
  POLY_FORM (result, p0, p1);
  return result;
}
#endif /* MAY_BE_LITTLE_ENDIAN */

#if MAY_BE_BIG_ENDIAN 
static poly_t poly_extend_words_be (const poly_t  p,
				    const byte_t* source,
				    int           len)
{
  int_ptr_t   ip = (int_ptr_t) source;
  int_bytes_t tmp;
  int_32_t    p0 = POLY_HALF (p, 0);
  int_32_t    p1 = POLY_HALF (p, 1);
  int_bytes_t x;
  int_bytes_t y;
  poly_t      result;

  while (len > 0) {
    /* Byte swap the input word -- inline.  */
    y.w = *ip;
    x.b[0] = y.b[3];
    x.b[1] = y.b[2];
    x.b[2] = y.b[1];
    x.b[3] = y.b[0];

    /* Split the low-order bytes.  */
    tmp.w = p0;

    /* Compute the new result.  */
    p0 = word_xor (p1, 
		   word_xor (word_xor (POLY_HALF (poly88[tmp.b[3]], 0),
				       POLY_HALF (poly80[tmp.b[2]], 0)),
			     word_xor (POLY_HALF (poly72[tmp.b[1]], 0),
				       POLY_HALF (poly64[tmp.b[0]], 0))));
    p1 = word_xor (x.w, 
		   word_xor (word_xor (POLY_HALF (poly88[tmp.b[3]], 1),
				       POLY_HALF (poly80[tmp.b[2]], 1)),
			     word_xor (POLY_HALF (poly72[tmp.b[1]], 1),
				       POLY_HALF (poly64[tmp.b[0]], 1))));

    len -= sizeof (int_32_t);
    ++ip; /* The Modula-3 source is INC (ip, ADRSIZE (ip^)), but C's
	     pointer arithmetic behaves differently.  */
  }
  POLY_FORM (result, p0, p1);
  return result;
}
#endif /* MAY_BE_BIG_ENDIAN */

static poly_t poly_extend_bytes (const poly_t t, 
				 const byte_t* addr, 
				 int len)
{
  const byte_t* cp = addr;
  integer_t     n_bits = 8 * len;
  integer_t     x_bits = 32 - n_bits;
  integer_t     t0 = word_and (POLY_HALF (t, 0), POLY_SIG_BITS);
  integer_t     t0_x = word_left_shift (t0, x_bits);
  integer_t     t0_n = word_right_shift (t0, n_bits);
  integer_t     t1 = word_and (POLY_HALF (t, 1), POLY_SIG_BITS);
  integer_t     t1_x = word_left_shift (t1, x_bits);
  integer_t     t1_n = word_right_shift (t1, n_bits);
  char          tmp[4];
  poly_t        result;

  POLY_HALF (result, 0) = poly_fix_32 (t0_x);
  POLY_HALF (result, 1) = poly_fix_32 (word_xor (t0_n, t1_x));

  switch (len) {
  case 1:
    tmp[0] = word_extract (t1_n, 0, 8);
    tmp[1] = word_extract (t1_n, 8, 8);
    tmp[2] = word_extract (t1_n, 16, 8);
    tmp[3] = cp[0];
    break;

  case 2:
    tmp[0] = word_extract (t1_n, 0, 8);
    tmp[1] = word_extract (t1_n, 8, 8);
    tmp[2] = cp[0];
    tmp[3] = cp[1];
    break;

  case 3:
    tmp[0] = word_extract (t1_n, 0, 8);
    tmp[1] = cp[0];
    tmp[2] = cp[1];
    tmp[3] = cp[2];
    break;

  default:
    assert (0);
  }

  if (poly_little_endian) {
#if MAY_BE_LITTLE_ENDIAN 
    return poly_extend_words_le (result, tmp, 4);
#else /* MAY_BE_LITTLE_ENDIAN */
    ;
#endif /* MAY_BE_LITTLE_ENDIAN */
  } else {
#if MAY_BE_BIG_ENDIAN 
    return poly_extend_words_be (result, tmp, 4);
#else /* MAY_BE_BIG_ENDIAN */
    ;
#endif /* MAY_BE_BIG_ENDIAN */
  }
}
			    
/* This procedure assumes that the LEN bytes beginning at address ADDR
   define a polynomial, A(x) of degree 8 * LEN.  The procedure returns
   (INIT * x ^ (8 * LEN) + A(x)) % PolyBasis.P.  */

static poly_t poly_compute_mod (poly_t        init,
				const byte_t* addr,
				integer_t     len)
{
  integer_t j;
  integer_t k;
  poly_t    result = init;

#ifndef FINGERPRINT_LITTLE_ENDIAN
  /* We don't need to do this if we already know the endianness.  */
  if (!poly_init_done) 
    poly_find_byte_order ();
#endif /* FINGERPRINT_LITTLE_ENDIAN */

  /* Word align the source pointer.  */
  j = mod ((word_t) addr, 4);
  if (len >= 4 && j != 0) {
    j = 4 - j;
    result = poly_extend_bytes (result, addr, j);
    addr += j;
    len -= j;
  }

  /* Compute the bulk of the result a word at a time.  */
  if (len >= 4) {
    j = mod ((word_t) len, 4);
    k = len - j;
    if (poly_little_endian) {
#if MAY_BE_LITTLE_ENDIAN 
      result = poly_extend_words_le (result, addr, k);
#else /* MAY_BE_LITTLE_ENDIAN */
      ;
#endif /* MAY_BE_LITTLE_ENDIAN */
    } else {
#if MAY_BE_BIG_ENDIAN 
      result = poly_extend_words_be (result, addr, k);
#else /* MAY_BE_BIG_ENDIAN */
      ;
#endif /* MAY_BE_BIG_ENDIAN */
    }
    addr += k;
    len = j;
  }

  /* Finish up the last few bytes.  */
  if (len > 0)
    result = poly_extend_bytes (result, addr, len);

  return result;
}

#if !FINGERPRINT_USE_INTEGRAL_TYPE
static void poly_to_bytes (poly_t t, byte_t* b)
{
  /* Generate the bytes in little-endian order.  */
  b[0] = word_extract (POLY_HALF (t, 0), 0, 8);
  b[1] = word_extract (POLY_HALF (t, 0), 8, 8);
  b[2] = word_extract (POLY_HALF (t, 0), 16, 8);
  b[3] = word_extract (POLY_HALF (t, 0), 24, 8);
  b[4] = word_extract (POLY_HALF (t, 1), 0, 8);
  b[5] = word_extract (POLY_HALF (t, 1), 8, 8);
  b[6] = word_extract (POLY_HALF (t, 1), 16, 8);
  b[7] = word_extract (POLY_HALF (t, 1), 24, 8);
}

static void poly_from_bytes (byte_t* b, poly_t* t)
{
  /* Assume the bytes are in little-endian order.  */
  POLY_HALF (*t, 0) = 
    poly_fix_32 (word_or (word_or (                 b[0],
				   word_left_shift (b[1], 8)),
			  word_or (word_left_shift (b[2], 16),
				   word_left_shift (b[3], 24))));
  POLY_HALF (*t, 1) = 
    poly_fix_32 (word_or (word_or (                 b[4],
				   word_left_shift (b[5], 8)),
			  word_or (word_left_shift (b[6], 16),
				   word_left_shift (b[7], 24))));
}
#else /* FINGERPRINT_USE_INTEGRAL_TYPE */
#define poly_to_bytes(t, b) (*((fingerprint_t*) (b)) = t)
#define poly_from_bytes(b, t) (*(t) = (*((poly_t*) b)))
#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

/***********************************************************************
  Modula-3 `Fingerprint' Module
***********************************************************************/

/***********************************************************************
  Macros
***********************************************************************/

#define FINGERPRINT_A 0xff208489
#define FINGERPRINT_B 0xf4872e10
#define FINGERPRINT_C 0x402d619b
#define FINGERPRINT_D 0x0bf359a7

/***********************************************************************
  Variables
***********************************************************************/

#if !FINGERPRINT_USE_INTEGRAL_TYPE
const fingerprint_t 
                fingerprint_zero;
#endif /* FINGERPRINT_USE_INTEGRAL_TYPE */

/* const */ fingerprint_t 
                fingerprint_of_empty;
                       
static const byte_t fingerprint_perm[256] 
                        = { 55, 254, 252, 251, 250, 248, 240, 245, 
			    246, 238, 237, 244, 7, 189, 214, 236, 
			    235, 20, 33, 8, 227, 14, 233, 178, 
			    172, 60, 229, 133, 152, 19, 210, 203, 
			    221, 208, 76, 18, 13, 199, 113, 62, 
			    40, 190, 213, 194, 43, 181, 21, 15, 
			    201, 162, 90, 186, 71, 117, 107, 70, 
			    191, 5, 173, 44, 39, 12, 174, 183, 
			    99, 11, 176, 163, 161, 72, 86, 105, 
			    2, 83, 42, 52, 179, 135, 103, 110, 
			    151, 58, 108, 96, 166, 25, 115, 66, 
			    142, 10, 141, 48, 104, 34, 159, 120, 
			    22, 140, 64, 82, 78, 68, 207, 125, 
			    123, 150, 144, 138, 128, 139, 136, 114, 
			    119, 53, 148, 185, 41, 124, 216, 143,
			    49, 92, 98, 51, 112, 73, 50, 63, 
			    16, 46, 158, 126, 206, 122, 94, 132, 
			    88, 184, 28, 84, 127, 156, 167, 223, 
			    118, 89, 116, 17, 111, 121, 109, 77, 
			    146, 61, 224, 101, 81, 218, 97, 188, 
			    243, 155, 57, 102, 54, 129, 93, 192, 
			    153, 106, 36, 145, 79, 31, 137, 26, 
			    67, 85, 175, 80, 168, 65, 91, 1, 
			    147, 149, 6, 29, 37, 69, 182, 165, 
			    4, 74, 55, 47, 171, 169, 75, 134, 
			    193, 195, 198, 131, 38, 180, 56, 196, 
			    23, 154, 177, 200, 205, 27, 209, 95, 
			    204, 160, 3, 30, 157, 32, 9, 212, 
			    211, 45, 202, 170, 0, 219, 187, 87, 
			    35, 100, 217, 232, 164, 228, 220, 197, 
			    231, 215, 226, 130, 225, 234, 241, 239, 
			    59, 230, 247, 24, 249, 242, 222, 253
			};

/***********************************************************************
  Function Definitions
***********************************************************************/

void fingerprint_init (void)
{
  /* Make sure that the configuration was correct.  */
#if UCHAR_MAX != 255
#error "The fingerprint module requires 8-bit characters."
#endif /* UCHAR_MAX != 255 */
  assert (sizeof (int_32_t) == 4);
  assert (sizeof (poly_t) == 8);
  assert (sizeof (fingerprint_t) == 8);
  assert (sizeof (void*) == sizeof (integer_t));

  /* Intialize.  */
  poly_to_bytes (POLY_ONE, FINGERPRINT_BYTE (fingerprint_of_empty));
}

fingerprint_t fingerprint_from_text (const char* text)
{
  fingerprint_t result;
  poly_t        poly;

  poly = poly_compute_mod (POLY_ONE, 
			   (const byte_t*) text, 
			   (integer_t) strlen (text));
  poly_to_bytes (poly, FINGERPRINT_BYTE (result));

  return result;
} 

fingerprint_t fingerprint_combine (fingerprint_t fp1,
				   fingerprint_t fp2)
{
  poly_t        poly1;
  poly_t        poly2;
  fingerprint_t buf[2];
  fingerprint_t res;
  int           i;

  buf[0] = fp1;
  buf[1] = fp2;

  poly1 = poly_compute_mod (POLY_ONE, 
			    (const byte_t*) &buf[0], 
			    sizeof (buf));

  POLY_HALF (poly2, 0) = 
    poly_fix_32 (word_plus (word_times (POLY_HALF (poly1, 0), 
					FINGERPRINT_A),
			    word_times (POLY_HALF (poly1, 1), 
					FINGERPRINT_B)));
  POLY_HALF (poly2, 1) = 
    poly_fix_32 (word_plus (word_times (POLY_HALF (poly1, 0), 
					FINGERPRINT_C),
			    word_times (POLY_HALF (poly1, 1), 
					FINGERPRINT_D)));
  poly_to_bytes (poly2, FINGERPRINT_BYTE (res));

  for (i = 0; i < 8; ++i) 
    FINGERPRINT_BYTE (res)[i] = 
      fingerprint_perm [FINGERPRINT_BYTE (res)[i]]; 

  return res;
}

fingerprint_t fingerprint_from_chars (const char*   text,
				      fingerprint_t fp)
{
  integer_t     n = (integer_t) strlen (text);
  fingerprint_t result;
  poly_t        init;
  poly_t        poly;

  if (n == 0) 
    return fp;

  poly_from_bytes (FINGERPRINT_BYTE (fp), &init);
  poly = poly_compute_mod (init, (const byte_t*) text, n);
  poly_to_bytes (poly, FINGERPRINT_BYTE (result));
  
  return result;
}

#if !FINGERPRINT_USE_INTEGRAL_TYPE
int fingerprint_equal (fingerprint_t fp1,
		       fingerprint_t fp2)
{
  return memcmp (&fp1, &fp2, sizeof (fingerprint_t)) == 0;
}
#endif /* !FINGERPRINT_USE_INTEGRAL_TYPE */

int fingerprint_equal_f (fingerprint_t fp1,
			 fingerprint_t fp2)
{
  return fingerprint_equal (fp1, fp2);
}

word_t fingerprint_hash (fingerprint_t fp)
{
  poly_t x;
  poly_from_bytes (FINGERPRINT_BYTE (fp), &x);
  return word_xor (POLY_HALF (x, 0), POLY_HALF (x, 1));
}

/***********************************************************************
  Unit Test
***********************************************************************/

#ifdef FINGERPRINT_TEST
#include <stdio.h>

static void fingerprint_print (fingerprint_t fp, byte_t* buffer)
{
  int i;

  buffer += sprintf (buffer, "{");
  for (i = 0; i < 8; ++i) {
    buffer += 
      sprintf (buffer, "%s%x", i != 0 ? ", " : "", 
	       (unsigned int) (FINGERPRINT_BYTE (fp))[i]);
  }
  buffer += sprintf (buffer, "}");
}

static fingerprint_t fingerprint_print_with_text (const char* text)
{
  char buffer[64];
  fingerprint_t fp;
  
  fp = fingerprint_from_text (text);
  fingerprint_print (fp, buffer);
  printf ("The fingerprint of:\n  %s\nis:\n  %s\n",
	  text, buffer);
  return fp;
}

static int fingerprint_compare (fingerprint_t fp, 
				unsigned      bytes[])
{
  int i;
  for (i = 0; i < 8; ++i) {
    if (FINGERPRINT_BYTE (fp)[i] != bytes[i]) 
      return 0;
  }

  return 1;
}

int main()
{
  char          buffer[64];
  fingerprint_t fp1;
  fingerprint_t fp2;
  fingerprint_t fp3;
  fingerprint_t fp4;

  unsigned      fp_of_good_men [] = { 0x79, 0x62, 0xbf, 0x45, 0xa3,
				      0x53, 0xb2, 0x2b };
  unsigned      fp_of_quick_fox [] = { 0x53, 0x3e, 0x7b, 0x88, 0x6,
				       0x19, 0xba, 0x38 };
  unsigned      fp_of_combine [] = { 0xd4, 0x18, 0x54, 0x6, 0xa7,
				     0x68, 0x8c, 0x35 };

#define XSTR(X) #X
#define STR(X) XSTR(X)

  printf ("Configuration\n"
	  "-------------\n"
	  "FINGERPRINT_INTEGRAL_TYPE:    %s\n"
	  "FINGERPRINT_INT_32_TYPE:      %s\n"
	  "FINGERPRINT_POINTER_INT_TYPE: %s\n"
	  "FINGERPRINT_LITTLE_ENDIAN:    %s\n\n"
	  "Tests\n"
	  "-----\n",
#ifdef FINGERPRINT_INTEGRAL_TYPE
	  STR(FINGERPRINT_INTEGRAL_TYPE),
#else /* ifndef FINGERPRINT_INTEGRAL_TYPE */
	  "undefined",
#endif /* ifdef FINGERPRINT_INTEGRAL_TYPE */
	  STR(FINGERPRINT_INT_32_TYPE),
	  STR(FINGERPRINT_POINTER_INT_TYPE),
#ifdef FINGERPRINT_LITTLE_ENDIAN
	  STR(FINGERPRINT_LITTLE_ENDIAN)
#else /* ifndef FINGERPRINT_LITTLE_ENDIAN */
	  "undefined"
#endif /* ifdef FINGERPRINT_INTEGRAL_TYPE */
	  );

  fingerprint_init ();

  fp1 = fingerprint_print_with_text ("");
  fp2 = fingerprint_print_with_text ("Now is the time for all good men "
				     "to come to the aid of their country.");
  fp3 = fingerprint_print_with_text ("The quick brown fox jumped over the "
				     "lazy dog.");

  fp4 = fingerprint_combine (fp2, fp3);
  fingerprint_print (fp4, buffer);
  printf ("The fingerprint of (\"Now...\", \"The quick...\") is:\n  %s\n",
	  buffer);
  fflush (stdin);

  assert (fingerprint_equal (fp1, fingerprint_of_empty));
  assert (fingerprint_compare (fp2, fp_of_good_men));
  assert (fingerprint_compare (fp3, fp_of_quick_fox));

  assert (fingerprint_compare (fp4, fp_of_combine));

  return 0;
}
#endif /* ifdef FINGERPRINT TEST */

From ddd at cup.hp.com  Thu Apr  6 18:42:45 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 06 Apr 2000 18:42:45 +0000
Subject: Proposal for demangling:
Message-ID: <38ECDAA5.5D5AF5D6@cup.hp.com>

Interface:

namespace abi
{

struct demangler
{
	// Provide name to demangle
	void demangle(char *);
protected:
	// Output demangled characters
	// I don't know whether it is better to output
	// on char or a string... It seems there are
	// many cases where the demangler can put
	// multiple chars at the same time, but they
	// are not zero-terminated (we know the length)
	virtual void output(char c);
};


}


Implementation:

#include <abi> // Forgot the name we settled on...
#include <iostream>

using namespace std;

void abi::demangler::output(char c)
{
	cout << c;
}



Regards,
Christophe



From austern at sgi.com  Thu Apr  6 20:33:07 2000
From: austern at sgi.com (Matt Austern)
Date: Thu,  6 Apr 2000 13:33:07 -0700 (PDT)
Subject: Demangler interface proposal
Message-ID: <14572.59202.333329.586821@isolde.engr.sgi.com>


We need to return multiple return values: a status code, and a buffer
pointer.  We can use an extra level of indirection on one, both, or
neither.  If neither, we need to return a pair or the moral
equivalent.

ALTERNATIVE A

namespace abi {
    extern "C" 
    char* __cxa_demangle(const char* mangled_name, char* buf, size_t n,
                         int* status);
}

mangled_name is a null-terminated string with the mangled name.  buf
is a pointer to a user-provided buffer of at least n characters.  If
buf is a null pointer then n is ignored, and demangle allocates its
own buffer with malloc.  The user is responsible for freeing it.

If the return value is non-null, it points to a null-terminated string
with the demangled name.  If the return value is null, an error has
occurred.  *status == 0 means the demangling failed because the buffer
wasn't long enough (or because malloc failed.)  *status == -1 means
the demangling failed because mangled_name is invalid.

Users may pass a null pointer as the last argument to __cxa_demangle.
All that means is that, if the demangling fails, they won't be able
to find out why.

ALTERNATIVE B

namespace abi {
    struct dm {
      char* name;
      enum { buffer_too_small, invalid_name } status;
    };
    dm demangle(const char* mangled_name, char* buf, size_t n);
}

mangled_name is a null-terminated string with the mangled name.  buf
is a pointer to a user-provided buffer of at least n characters.  If
buf is a null pointer then n is ignored, and demangle allocates its
own buffer with malloc.  The user is responsible for freeing it.

If result.name is non-null, it points to a null-terminated string with
the demangled name.  If result.name is null, demangling has failed and
result.status gives the type of failure.

DISCUSSION

I prefer alternative A, even though the error indication is clumsier,
because it's callable from C.  Having a C-callable demangling
interface could come in handy, e.g. for linkers.  If we decide that's
unimportant, we should go with alternative B.  



                        --Matt 




From daveed at edg.com  Thu Apr  6 20:47:50 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Thu, 06 Apr 2000 13:47:50 -0700
Subject: Demangler interface proposal
References: <14572.59202.333329.586821@isolde.engr.sgi.com>
Message-ID: <38ECF7F6.AC0A2882@edg.com>

Matt Austern wrote:
[...]
> I prefer alternative A, even though the error indication is clumsier,
> because it's callable from C.

I'll second that.

	Daveed



From austern at sgi.com  Thu Apr  6 21:15:27 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 6 Apr 2000 14:15:27 -0700 (PDT)
Subject: Test cases for mangling
Message-ID: <200004062115.OAA61033@isolde.engr.sgi.com>

If anyone wants to test our new mangling scheme, here are about a
thousand names from SGI's I/O library.  The average length is about
a hundred characters each.

I'm providing a uuencoded, gzipped tar file, with the unmangled names
and the (EDG) mangled names.  

                        --Matt


begin 644 names.tar.gz
M'XL(""G^[#@"`VYA;65S+G1A<@#M?5MOW#C2]ESG5_ at J<`(OT.>V!X.Y,?;-
M#N`W\)>D@;T3U&JVS3=JJ4=26_9<Y+=_)'66*(DL4J?)&+L3NUOUU,,B52R>
MBB?3>;+1X9<N?V:SV6:UNOIEMEELYILK^O=LOHC^G2TVF^5J?C7;SK;+^7:S
MV:ZO9O/E<C'_Y6KV2P\_%S\P/4+%)+\@SZE]SKE<K'-S(<G/5?KO1'Z,_S5,
MVW8M,T#&_G(\(L\WC/^W,)9^<%@O]J:/+>.(;42^,XQS8!C+N6'%WR]FUK/I
M&8%GXL"/OET8UJ='"[^#P(9-L.&GQS""/9^1<XA!4\S;>83I!QYVGE+4]6T+
MV?C+^6W,UO72K^X_O5!]EGM^B[6A@\&>_O18*@DF:I%Y$C10*KU*.1-A<0-_
M6R1?KXU'S_T_9`4+8A'V]=9XO+?(_Y(G[HQ[UR$MW`F,BV-Z;\;QXL1JC#W>
M?]N,O(CKC?'5,AWC2"J&/?ABVC'&S!"IV>UZCYT#\E(+D281?[6Z-?[]9T&L
M#9-OKY*E7"E+?5(VU3RE='%&VD[;6N%Z]$70W(SX!1Y#0SH at W=W!"Q"VI3N(
M83U$C>=8R#`OKQGF+<Z*CTF_GGGV5L+W*M#-I!-HUWA"@7&T73.(F[D&WM_F
M7Y+.$+N^08R*ONRL+P>K=Y7'_E5Z2BJ;:ZW.L&'O*H_]J_3R*K$3H"<:=46N
M^;ZN-AXL at -`.)H5!4C9(RH=(@0B"^#70Z^[->QA"Z6X8K7 at 0K?8 at 6@=I3(,8
M>!#[JIH7Y,P?P@&4[H;1B@?1:@^BU1]"ZR`&'L2^J7G/E\#8NZZ=#@;FM\[E
MQ#YF$"LRXB3CAT>K`F/MZR!N5P6(S5WJ3]:WKL(@1 at .(4BE"(0)MXR4-()52
MA/E2<*-HG28[]*G,4U$F:\9#G\KR):MY[W4:\J%?=;N^]=G]ZE-4)]M8'OI5
MM^M;7\_F9.K0GQ?3UCC)]N5>`PR$6%N7(TBL&881>\6T>F at EG=P#TC*/*HLI
M,HE*9&R"Z2,OR`*;Q=T+LM+RSN<K(YE?WBR,_YC^<V#N;60XC`13=I=.>M^=
M39P(;HU[G`C2"6`;Q7\M%Z4EM_G:*#[XZ5&7RAW^<J\+J]9BZV7!8LO;U&+;
M-5?E>I$N(2PRE<N9<9\MX,TWV3=KX_%EE[!9+<LKEANC5B:SI%8J>;-J!:ZS
M\>TJ;^+MC%AXF:^;]=&T4)`TL+NRA1;\YZEU.!]'I>-\P=BYWLD,`G1@`Q%#
M:9&*C!>T0WYAD!2(QN4ZEM*^/&A'?'S1#KG3SS)JCGHA;?V0OG;(O7;$@W;$
MHW9$_;6MO[(][8BL]3R;SH%X;_1JH7.`7<?(EKAC4-<7=4`[YH#PD^-Z:%Q[
M2Y(.ZS;:BN"@)[HJ75W4_\,W0O],'+[4?A,"D6Y8<=Q`"B+>%S!&HR5AQWQU
MPLXE_1R+[?!HWZ^T_[:=:-&W=Z6=(9M%UG?3G2%D@":U.R017F<-B4((;WR:
M@"G)@VES(=8KM)>5@?'/U*Q$;3'R=C:RC5L=.?G]M]5XRZSFH^.]C9,LFO9W
M8Q+&T.1%_U9E[:PEL"DWY'FNIV4>3P9/9`ZO-%&2SJ#QYB^^%#]<X$,.(3^/
MNKW-;ZI7WU'_Z=&RY%0U%[U>%3TM$$:J7MSOR"#EM/>F]3W;=9K.;G^*K9%^
ML$8OR&&3/.XET%OK4H`BU7YV_0`[EJ=M7AX,*\26E)U]J[C3V4K`'#?$!^0H
M[YR^SQ!K!]1RF`^Z`1_O7W1#[K23C.:U="+N=0,>=`-J+[*7`.INVQ%>X94&
M8[)9,B)S&-F at ZM'2-G3\O-B.O9#K96X`XUQL&S3RDY:?@FFT'MA1/HQ6L-C8
M0FS1=X848C/^0@#?B6D43N\QM+C(/D+?2:",`]48=R^'UA(R9F@>"BZ>H\HN
M.C(@`]A",`$,+F?#<@_(>E&V8+KW)+?90$Y!"V>N at N_X;(3/)*2/9\+4EIZC
M>G/0:V`5 at PU@ZX_&#E*`(H,1/\2!]6P$KNXM.B!@.<;Q.+(#RC+((IR#9\\-
M#1LY3\%S:=R[NC.^1J-].NJ.Y>Y$CN3+ at S9-%11`2?D-]VAXIO.$-#"]4&=]
MM`DP+^R&5)4<HD at 571S_&1\#3>S$L$1XO?JD)3J6NO^(!BOB<"WD0BY<!PDH
M&/&O)-*\.-^C;!I9BUP;Q@$=S8L=Q-\$Z'2VTS6.^=+X[_W^83[_[SU^F,^^
M?MKA+Q$8/7..R:/EJ<*O:8PS7Q@/["/VW)Y*T80;1P\AJ'Z*P>1MTI>H@#PC
M\VSX^"\E)FQW6F9N\N]W%3C7/1FG8O4LMT;R$0]D:V350A$\Q#:[*50N1:%Y
M;`+%:B+MPWFA<[/1?OXDR4IV[O0Q3".(^<H*WLXH?3%")DZ:UP$_L19>/:VJ
M>T*9IBS at Z-1Z:D\W9S8A`R4M>GQ)/^FT=J.685*/P!IM5LL:3@[L,+;8J*11
M5RBHJ]E:1%>8T_7DN9<S&?#UV7JM]&72C4TW[S64:^QOR+ at -,^!;&/9 at F.1$
M2?4=QUI>\6^+_#M>JRW$6E[R;XO\6^[C)Z>/=]NB&T4J*D?]VBE0'NJ%""/*
M^6,K^=@UF^TH?EZ2*<8Q='DC7A*>SZ)OZ*AO=3+][WL::15DMR?D^^83RN]\
MQ8_S3:(N^;I-+!016RY.KH/>SA>'?+A_<\Q3S)J8D,5Q,]JHRQQ;I>:24B%(
M5UBO"["]6'5*59G`2SM"^R`WCP`?=HN@`+E(KPON?"U(-7QPOQG1Q$BTI:U4
MG&_ at DW#'8`EW4$LLX^K0T$B!4"\U,,-63LS"U6<75]$NT(F[QUN#.3+#CP;Z
M at 9:UA#Q.%[-VG47HY>KI at GQ%QRJO(]\,)F*C;OA7U*RSOF&:=NJH`'5ZW*D;
MRNW:4!L626M/#/2I''SS%.G(W9-35-I at NSV:V+YXJ+M*(XH/6B+K at Y;(^J`E
M'CXHQ\."*+`2N5JXN&I<%`*Y at WH@5P/CJK'IHILOJ^BFEZQHH5MD67*#BD-3
MV['>K"74M(&]JD6[<V[5HL4SE[5TU/?7J'$[5M-5QRF at 1UOM'+%S8*ONZ53U
MYV6RYK78[/$!>\BB1_1-.\,/S*=O:_!N0**5OC1LAPL!^PMY;JS]BY9IZQU=
MV5NI:FF;:=[1-;U$2Y91)<!T(C)GRVR!:3XSOM%O_W".[I>=];@(3DWB6FQ!
MEQZ6W5)H,Q2C$`I02-9GV')94E=L[01_>>ANG>[;<B]`8#<\`SPX`WMP!O[0
M#`:OA,'K8+ at JT.(1A_0EF at JPFWX)\.1+8$^^!)-_D2??B";?AD;>A-I"T]'W
M!>T%V$V_!'CR);`G7X+)O\B3;T23;T.]-B''[61DT)>B77^:<&^:[-XT^7UI
MZLUXO=E.D^D$(JN^%.WZTX1[TV3WIJFW!M&;\7JS7<YT=(4FH'DL7DS[@CAG
ME>;S#4T+EF0D*VJ[O>TJ$5K=&3K+PE\FS/W;NMO3*;5FT>*%)]HD_MYE'W>3
M:G-&6LP*SH%8?U(7_\QE[Z-)^<\N*2P[7$YP#V9\$B9W[HRW\)I;=6T"T'.*
MK&L"K6?"I`B0=AH\JQFQ##&`&4$4E`T9-VZ-VQ?(T!\,WKHQ(63 at +(-4ZIVB
M?1!^&BDFY_.B+3AL4^F9[I/P''92`"Z</X,7RR=X=`<&)J8MA:L%JV?G#.G3
ML20V;9JQ at IJ+G35.FG"A[DINJBJ:OV&QG,7IB_5YO>CLU+$E22;LDDQD&=:7
ML,%#UOH>\Z^C]L.QGQ<K/)#J!KUAAWK#FB*SO$/#63RGOH_2VWYY>`K:[YR]
MZ!O+/9UM])I\=>A#R;$/)5X'2CHX&6#[(SA-6<@.1#,(17<O>;(IA!@4S=V6
MS]'3W81_S^H><4FAIMV7?=EG['1A]FW?6CHJ^PY(E]FW?#WVHZ4E?5'UFMYR
M(/9YL>[2CU8O'WXD??:\$@YV%B#L,*:7<W"):,E&-:FBM+26OHH2YHN2WW;?
M3958"IKD+$8''AYZ09[/4;38>*3_)MVX:5G(]PMG,JA<750D>4MC4PS9M8YC
M#SJ\6,?@:3]\['PW+L[%1P<C-#V'O1J?]%TAW:)`\V7*-=J&G?1OHZ7B)=2P
M6[.0M&!G%;#:&(\U]PM5NF]LO+"JBLP;N/PY%NTSUH<!=!X'T$E=RXMIXT-Y
M#J6[[5%T)C+T2/.J.8AF\4^`/=[3N5OS?&;G_SJ[BBNWDKR8$8*D(1^*_5;G
M%`9GL,.6H`Z%B\ARZ4J5B at FGL,/A.]./DOIUVIXZU\(J3$B'8H6]LVR4NZAL
M,5\^IQURU*W?K05[^_3N2 at 91OKIRO36^(A+'!G,_D`PCTF2"Z,^+:5-76L)>
M+DK%FZ_+%P2^E`NZ6I<*NEAL(5%'[KM55NZED5UE,BL7'!;>Q-WKRC`^S]?H
M3](,$I!EN7(W1BT*,X3K:[A.00RF]0QX#8QL)HD2##@_!A]'/K,%32]Z/"EE
M7DP[37G9=U&N7]+;IBUA=FO\#PU`J.^P\2E]^G9E'.D4ZV*Q8C.M&_K?E3-?
MK.DOR_GBEOWK++?LJ>5MDD@]?2NCN(8$&\2U^\&;C<C7'`+S90V!.^/`H-=+
M]L^<*5X[\]F"I6M?D5]6$:GEC)%8+F=P%BL^B[N9X44%GL4%G0O3F$G36-V1
M""B:_<B3("_N/D%,L]7/HT^J(,2-<$'N:+I3BX%8#\O%FMESX40X'#+K-1=G
MN3!V!&@7(>W$H+9\J)6Q\PF&'T'Y#^O->KUL!;OE@]';W/Y[_]5BK?26_4::
MZ;8-C6_RY<8 at S/R'C;-<;#>W]-<U_:T-;K/BPJWFQ at Z3(N*HI/0?8[6X6]UM
MMHN[-1S3)F!VA&E+86Z77,SUS,!1ZS*<Q7RU7=TN-ZO;:*G%2#_8 at L$)7[L"
M;FL"#_]['U;`0SEPOJG7Q-0/Q,8/D:D?'A8S8WZ[6FVVJ]5LN]S.[M;K^6;>
M9O2[.1=]<VL0<`;JW"T6R^5V,5MN;M>K[79]2WT)47MG5+_A%F9 at SSX&OSX*
MKZ[!I^OQZ-K\N49OKM.7:_7D^OVX?B_>H0_OT(-WZ+^[]-Y]^6[7,.W0?/,-
MQZ57$&7CT75R\6$^F_S*""UVQ1J1HTL(II>-319+R[791HF\!+N2+4K])",4
M4J$P$;IXGN&_G?:NG>.72WA?S,6?\).2FDM*A2!=8:NN]JL&5(2!FD,5S<4R
MDS:%3Z9MG%WL!+G9#^=RJ at K']_G)BX7-8JUM1U9N+BT7`O6)6%.X#0'%P=I#
M->W%LA\]TS)*SK*]9N6D9'6%(%WMY1*N49`P4'.HHKE89I8UM/YJE_M/.+_!
M1?N*:"N#4(P!>.Z[PN"ND$MUS>[FNB_>G)0N8'[9T?,O)83%/-IES\?8<T%Z
M,F\WZ6CO]5[RU&S=;G+=WNN]]*FE")M2`QE7/0S;0CFV&5$%0VRCYIK2E7O9
M_DA><@Z0#,$ZB]T0SE8WY[?IQ>^Y@<\7ZD._+6CNQ\?PV_K+8U at 2:QPVU4C[
M=3>B18.@;_/'NFO16L7K!,N*%_/X`<X at 3%Q_+4HCC?@Z<1D+[C`5/)FO4L*L
MBAWT%.\*D0@:I83F<D(A1%-8UF0&^`49A?5YH6))R<GK"X'Z1,HG[(.`XF#M
MH9KV8MG=,W*:0^/NMFZ5-N(*T`G[IG,)!#QVR'QN^&A1GVN5Y5H=3E7\3+I=
M:2<B)327$PHAFL*R)@QQ(K)R\OI"H#Z1\@D[$:`X6'NHIKU4]GQSGY6N3UC1
MD\:DI[>J8:75Z9`[SZJKRR/N=>QJ'IMA=-QV<:]C2_:^X2Q4%^,0WS(=6,#+
MO#@/0CIF+2(Y;J#,)H\!IQ,\NQ??=`Z^X:.S^,2ZI%C8+-;:6\C*S:7E0J"^
M4$"?<&\!%`=K#]6TE\KNF8Y/XP?!I;UO<SFI9%A)I2Z._XR/XL$8&SY;[XB7
MRNV*_-MN$OYRC\M%_5FW":?]RF*=/Z-5[+!^#EN\.V+;3LZRZ#H:1S-Z:#MF
MQR.H]6A=GJW>,WM%ZLM\L=9'TT)!I)KS14%4PYFT7(X5I:-MC):CN[WLL.[V
MXG3:8O)\.V at Q3F.;B937MAFGG%4!/E2AFBSMJ$#0YEB?4 at VUH\:@N1O\6+*B
M4.2\>%Z,95BR9*5D=74TB&1A&?&2BZ[56*S]$Q5'[)&ND8YDW&-?Q>I)9ZF,
M5%?U;DC`M8\\S$1BFR0\*+;^E1$G_K&^+;4I[J>R\)&727FVOC at T4R";)$^&
M(VD8O%WOB2CR%K0-QWS`Q19^*;E,5_,JT<7<R`=TVS]\@X[(U10E9<XBS<'*
M/"+S;^]*5#:+W!YU0H7N(.N#CJ;ZSDXFKQ:<AK4H-*S;4(NF]:RJB9HIIVF^
MCD?=JAH[QE2Q2"Y)S<;X3#J/$`?/V.FZ]8SFM1+K8B;AH*6*TF=M2Q$;QHBV
MV7N\UH_*-%QCZGHI77[K&#1UDH4M'3A?%%,PZ2&A!>6%@MC805IL^VSZQ@$Y
M^?GIO@\J\B@,<5B1RV.(`XL<(L2_?;Z<D$=J.:;!;JR/)V2_6O(RNP>`#$0/
M!LC8`!D_+V.[OC^&!EWD,7"K+I$9N&D7V"SNZNMV83P`Y?9`.0LH=P#*'8%R
M&"AG`^4\H)P/E`MKY63\H83@[@$J"-:(H8(V5#"J#>P<Z1T*;X-ZR2J)H5PD
MA\E0_K%"1<0Y2 at KM(4(61.@`$3I"A#!$R(8(>1`A'R(4\H6$W)^DU.X!)`73
MA4%2-D at J,OR?%TS&7I_-SX,Z/`Z+H3P>C\I0+J_*1<3GR4KM05(62.H`DCJ"
MI#!(R at 9)>2`I'R05UD@)>3]9L=T#3`RH#</$;)A89'^Z2=ZTZ<L]M!NL83*4
M*ZRC,Y0[Y/,1<8D0R3U8T@)+'L"21[`D!DO:8$D/+.F#)<,&22'7"1'=/<!%
M%;1BN*@-%_7?X4/':1N:->@X=%_5H/N04;,&':=U"AK6+)=]IQ515:&])B(5
MG59%587VNN at HB4:;#NVUT='QNS8=>NKCR7$]Y55"K`OGVUP3TLL[3.R!M*3L
M3G9:MR.V)$AO001F;P>B*G(%KI%S<.DUQ0K5I'QQ4BN!%DNU$VA[!Z,[C-(A
M17H=,SZ=[4\UF^+W%;$[X]X,3-LEXY#X+FCS_`ES[%T0Z^""E,^+EJM#NJ?`
M,IT,38+>^Q%KN3CXSPL]+^$AGUY'_1.<OA,\OM)FH)_^S)[4>9KZ\]W)<=/Z
M?$1$=D^G&=!AL&D?'H4AYGNX/(:8Z.$0:1V=2\N08;F\#$0/!LC8`!F?)P-)
MZ<Z!`:9UYR&!4[OSP!32N_/@5%*\\_"4TKQS`#6D>I=#%4WWSD'5F?)="EX^
M[;L4O'SJ=QZ\SO3O'/QN4\`3A>C5M`)5+U,$@?N8$HZ*ARE!J?F7$IBB=RFA
MJ?J6(IP>SR*,*>%7BIB:O8HH.,BGB(*#/$H)7+,_*:)W[DTPLM:D00\8@)<9
M#!1_5V@,%'ZG%]M+A-]R,E'X+2D#T8,!,C9`QN?)`#O&, at R\:ZP at J72.%3"U
M[K$"I]A!5O!4N\@RH)Y.4@)5HILLHVKN*,7A05VE.#RHLZS`:^XNR_B==Y at G
M]W"Q754W4T*!>YDRD(J3*6.I^9 at RFJ*+*<.I>I at 2GAX'(PXJX5]*H)K=BS`Z
MR+L(HX.<2QE=LV\IP7?N6 at KYNL&765>`P-=9UR&Y$"2ZIVG8F?XR at X$&&A4:
M`PTT2CR`'5D)!=Z1E8%4.K(REEI'5D93[,C*<*H=60E/3T<F#BK1D95`-7=D
MPNB at CDP8'=21E=$U=V0E^,X[,O^,+&S:^*^!'3Z/QE!>G\ME*-?/(=.VD1\D
MMH>)63"Q`TSL"!/#,#$;)N;!Q'R86%@G)C(;*2^W>P#*0?5AH)P-E*NM!FC4
MQ8%2"+UX:$KQ%P]0,0CC0:I&8CQ,Y7",`ZHI)I-#E at G,.,BZHS,I%;`034H%
M+$[CJ=`=K'%T=!NQT;OYT.O9=9`3D/(/%;'5T1 at B8JOE,D3$5D.F+6(#B>UA
M8A9,[``3.\+$,$S,AHEY,#$?)A;6B;5&;""YW0-0#JH/`^5LH%RQ&D;A$\?C
M$4?D#T'>$.0+09X0Y`=!7A#D`T$>$.3_0-X/Y/M at G@_F]V!>#^;S8!Y/PM]A
M9Q118`V-07Q>'9=!O!Z?3*O?@XCM86(63.P`$SO"Q#!,S(:)>3`Q'R86UHFU
M^T*(W.X!*`?5AX%R-E"N6`VC\(GC\8 at C\H<@;PCRA2!/"/*#("\(\H$@#PCR
M?R#O!_)],,\'\WLPKP?S>3"/)^/O_),96,_E2][@Z5&^S1\M$&QS%@,"&[YS
MSJ[?V8EZ(73X%=G\W5YRJ3CHI1:^/B1;"Q060VG)<E&'(GF=!,=`P/UP#5`N
M#.H%>:1G"S786Q2IQ>8V!PF:=X7#ZG:>?X52+*6L%_C=>6]:WX\FMM7M*`[5
M:D at .%-R25;".3(G0=_5$2.?+OJO</2P=58F?*\?/HB#4GJH%M=YYY@&_#C8H
M*&D?8C10IC#$,*#(`;*?HH@`W$91`@'OGBCA*&R:*"&I[)4H02EMD2AB:=@9
M(0PHNB&B"*AS'X0HLOSV!U%D^5T/)62=FQV*T-WN<?`.K-\9,.U;.X.N\[Z1
MQP\:[F=C.+Y[0GJPGH at 4J7/2O]N%;OF6FH:.3C\]?HIS2*4?K=$+&=5^*3^)
MC1>*>+9-"W6:<&[9DG"N!P[%FZ6'Y$'3SGG(1]Y+AXIV6%0'>$0>Z_ at ITN71
MHO9TJ[W7P[7VN9APN'B<QV&0J)Q+9)#8G,.D;89>7F8/D+$`,@>`S!$@@P$R
M-D#&`\CX`)F0*],Z+R\OM'N`"($T88B0#1'RW_F6Z1B-B3;K4FRRK+21/+W*
M&0R`3"^=NB]''O+77A?Q1*[?SN(MD#;T_4DU5'W8:0)*@X+CV2V1=(]'U2E,
M0I,V&$&PEO%&#1AT,H\/U\5$9J8I7<#Y^NF/Q8P\C]T<<3:XX%=(69ZER2:2
MJ;"X'+`JE?%;:E<<'UKAPAJZ:`,-RH/\.!RZ7$:&KH)(;:/ZL(H$M3B'51>V
M96J>W?!D.F^6JB5?)*!:3,F%@MJ2@`5>IV9,5S>T+US[;XZ.>A%!::\2'HKT
MFE(1!5ZG`;+M)W4Z9!CUYB"?A&KHF+\\I.\Q9RV/(<:=]62&&'O6L6D;?\+D
M]D`Y"RAW`,H=@7(8*&<#Y3R at G`^4"VOE6L>I,,'=`U00K!%#!6VH(*D-SSS[
MP[G'HO9!G&*)PA"N\*)G1\]+":B+F(CH<`YZMD7)0+5&,1PH!3-6P+HR);N&
M3C78"3T<(-5M-X_W9-#PZA-"CIYQCC"6P/CKU3]?M/"*"BD(UD;LOLJLD]$<
M)?U/_3=B'1`953[9Z/!+=S^SV6RS6EW],MLL-O/-%?U[-E]$_\Z6B^5RO;J:
M;6?;Y7R[V2[([_/E9K'\Y6KV2P\_%S\P/4+%O-#%>J?V.>=RL<[-A20_5^F_
M$_DAC>+77PM=QV^T,=VPSW/-BGWZ^]7OO_YJ_*\1OVO(((\?D>=?TR\_WF`G
M^/".`QA&.%7,^(M:V/C[*G+J)9K(1A^G?J%8 at O,9D4`B4G3]XN+#ARO+=?P@
MTD*>L-SS6_P].ESG=,>]3+.9/MX4V49O6V<RQJ/G_A^R at H5S^(T5XRJJD=SO
ML3F,>_J1Z=![XDSOS3A>G-_VKFM3$_]^PWZC__DP43M\I2M"))`WV#,OIOU;
MG42L!-.(A9HMDD^78&KEKJI6*G0;`J]/K4F[-%"I1B_.9.H4U&*G4[[AFB#?
M1CTT0MG^YH`J70-SV2J=33,FY_26$$\/47LZ%C+,RVNU7^'!BA-N`:?/N.Q^
M;C96OH85Y$9)+-ZN^/[FXD2I65GG\_[FX%[V-OF8_O5A_'09H\FPM5WGZ4K%
MP@)-\$:#<%OCB`4FQCYN*],D7V at Z=46(;R*YKHDL1530_]2T337T],^>U!"8
M[LO1K0;_V?6Z*417QNG,)B*F&)VG%[#&F#A+OZ&C)-_>M$=K\RGRGMJ+.:WF
M,;%6H=08QA!@1?9N"Z_&6 at 2>`Y]\6=@+^[>HD;]!,>(7?*KEF'1;FG83XK8<
MYW(RSI<@ZG.BQ8^D3#3-!ITVO>:.#I@`FU7-SZL5X- at GKFP'=U4E``.28URP
MKPNK`!GJ@/I,1"IER'3F9E#TV"N:[_C0N9[<Y(JL, at 5+]JZPJ9@%_Z'1JO0_
M?2BKQCZ]:^W+IO)Z5-M,[UIUU*8N];V;6VEE*SJ03Y>=HLDU&-1[;8MAPGP$
M`(NL9-<FT2NF=4=K\.0>D/K"9`/@"[)HF:*&\Y\T?8-#'HL^I-D5X at T@I#E%
MJJ*\"-F*;;8AIO at U4T[(VD2YC[RXKP"H^5 at 89=T`8:X^LF_>`XI.[1F+WV3?
M43L6J;'HAF^5)@F8H>1(06PHI:'!O%$5_/KKT;10T-1HDD=J;5)\C%>FPA,E
M3A);-B+UKG<R at P`=Z, at E"O"U(;W/W#4=%I$`&["M))L_T8'&*E8+$F>"1RLL
M'1]KYZD7,1I'ZH"D`QDM0/&JK`ZH:(E:!Y*NJM16 at _D%;!UXA8:0)C(3\!G/
MIG, at GAF]6N@<8->Y+LQ49-3(9_2<T1"[TZ+]<PYZ,H.X]S#^\(W0/Q/GV[39
MK+2UDB;<:!'B;<L;IN!I3W/"SL7_C>T9%-A6*+ZK=OPEY6PP)%\*;#(LU3L5
M:MQ1.SY39)5,C)#4,OTV_O_?OBT(&F`$3628#;M0ESBB<@`]W!1*`&Z68RR<
M%E\TX8)IJTS9&9IH+ at 5YGNNIS\[4@"7C6/9$W0"X..3%A_><,TW0`TV1UFA&
M+.J8LJBS at -]:T+*6B@%21>GQK.+R6S+]&#_^XGY':0Y<_[KT"$MW"ZQ8]Q)H
MK-DZ--B$Z=GU`^Q87K957WW2LPY3]O`'+2;]^[K21N0P'#?$!^3D]UYF;HD]
M4!R"N9+3)#K`(FYLKD0'7-,*@B94'8#%'@*.4U[54ZM4;8VC0`O2<NO:+1 at K
MMQ11/@M+'F/IR0?HGG.;'+0/<4IM;`Q%3"-WTK;LMI.?T:!%Z/D1EQET>%#Z
MJ&RC`08)/(5;]KBIB[;849="[0"K2F1/TVV2"!,'U[4 at HK&5`)0@'P\%%\^Y
M3 at .$:B0.XB8.*\(SN)P-RST at ZR7(KZ!'8Y/WBFPEP,77Y/SO^&R$SR1H9B],
MM9H$FV\$YJ#7P.+'T1F.<(D;T"0J)<3T&LG`U;J;0`Y5AF4\7M)-LP;6^!JE
M$*6CQAQ-_F`X>/;<T+"1\Q0\YP=TA?V%><`"S=JAKS2L&$]28L,]&I[I/*$J
MH&P%92FX&MNC:,4(PHGP\I_Q,=#!J`9(Q@%$>9$L- at +F99>1]``)7/*\]GPU
M-7P-XX".YL4.HMPY1H!.9YM.9<=^ESG)^<UUNLGFPXSB?24QW\7Y'@E=%W9E
MY!9XTSFMKU&Z"$RPX[TN#^PK]DEQL`GE0Y/Q'#V$%&$HA&'C]&6$XCPC\VS0
M^W(4<>@^'2/+3$;^_9X at GB(H/F`.PG5/\;.%BE(UN(?H;AVMD#215E"H1?+(
M"YTLC'(WQLF6ZD[JIK.)N9"!7=J0OFR58PI1NSS@)_(.-9\`5IQB?7_#F>,J
M:!_ at O-QP9>KGT(>F\B7MJEC$J$F:U.W0]Z"Q\<COL2Z[U)OT*$KA%&,#E=+;
MD/ZIM#NX0BL1*OU;Y/?DN9<S.O3^GL7VRKR!,GAA;Q:W<!-_C4=ELDEZB?15
MZ-B(\6Y_O@=*EU8[]CPU)/)I%X=P.%2F:S?#-PC3/$D?`"G/1%[0FK:2&X,4
M_\K/.>4_3][`**AD\(4_KLN!9[Q$3:\+BT8Y-YQP^81\WWQ"?@)8_+LXN$K8
M),]\+&,DMN-\)(CD.NCM?'$L$FZ_.>8IGH/(A^XT6A=ZK/`*\DK>#C+_7?`Q
M>5U)JV at O&O])/1KGOXL_V:91>+>QX(/7J at D:-5*I3-90$:'9%:G'P1-4$@\K
MSF!)BW#TB4V:2SS,;YIL+WS7FJLM0T:'T,/J+T*L1:;!BHM<0Z<>0;L6)!Y6
MMILK;S>W=[MAJ4:-M;Y/G>CF^5H9+3VU#:FBNUK-WHEN^'J$U./7!NL\#/_C
M3?I;'VIYQ5-8TU#'N-8Y0F]H+(.7LY5;>_,4H@>&Z;<F!B]MDS_71!%/I$9&
M4]XF9Z^)HSN1.AE->;D<V6!91SHM34#7=4-_K0FT="/R6&=G*HXFMB]>]HO.
ME@<97/_H;W3]H[_A]8\^1KD_9(:YM4ID3"<S<(6>0?DA,PBM52)3*E>E5%BN
M170]3/LA-4ZKFD^N-`JC'X6P^8>&N+F&DD+'^$-/`)DC1C,U/J%\'X8AG>$/
M+3@\8H47!L-[P!]Z`<M4-004/[3@\(CIBB)^Z`7D]Q=:WA"L\171%=7^T!36
MYJAI"V9_Z(IFN>2TM3_M86Q^@S<)VIP#W0A:N_3?O"4`'["'+)IZQ[13'D9@
M/HE]+W!L)65*TPNQZ\`)P%_(<X%;!M[?0.4*:\$U.SS$28KD2+Q1DRX0;ML$
MPJY-2E.P!?B$I)M$>1^4\8V@&'\X1[>20CHX?6S2W.]ND`'+T_END):-O\#B
M)7N8V*ZT?#LI;(QC2=K+U^=HW>-%\0L[X67)U=V3,U*6Z8TG([;BJ`GF;C49
M%\.1UNQ8*W3`>NP[[!B!#QVBR&/QS(.6?3"O,'B-_X3%_LE\VD_5MG^N)CW&
MEMS#>'O,/75/Q1]]K]VW'<;GY89H"3^Y"7YB?_C3MO^?M]D/TMH==Q2C\]%R
MY'7,XR?+O,<T;#H%GO&;.5JBXZ[ND=>RELKM?Y0T";[ZO><@XY#IV7IJG*?T
M$DZG24RH)30U`+J3)Z#9<E],^X+:DFU8WY.T_RD+'7%TNB>@G)8ACM at 3YN^G
M2;WC7#P<6PR2N63,C>-G,\B(FEQ?R66$K*UPZ0G/[)6$A(JM\>>S5?=9MJC]
M60]HL,2;SI-Q,%EVEI:]A)7]9^4-9WS0(;8)ZJ;:TPY`2=KD)0J>]5=<!CN!
MJA, at .YK*8R]PWT9--\G*D>G<:.6T at AD]>M=`UD%$FW3C9(K1-OOH+.>9;MWU
MG'@\P/M&/V*672P&*[&F^X at QJ?SK2F-(!.D312%LVO at OQ"J%Y8VL7![6E/>W
M#HEE3N5<,7`3;15N_J^^Q'L?I?G%)9/\16LZO3QI%A*P02M]6W(OD];^N7A.
MH9#%O%<*38H;6Z7N3(8WU73Q%4:E&_V&JA'N?7]]&\<]QY[W-^F+P]X7O(M[
M.MOH];?H&K'4O>B&9V]_9^BYB]"TZ]":)$#P5#.?NV1J*=&T^L7':(K]Z/IV
M+X,)K&>1@%/15%JQ/DR:/7W1RT48+#0?<;7^8Q/9QM+GT&B*#>=GM4^Q$=%;
MI^*`/1=N*:4_+^3E><^;]"H-"+J8%RL4,%ZC*D:4Y5XA'47I#C6YR>E;^0$S
MX4^P0)+O4A?%2BC49>XO%"XZFMU-594-*:X+:,5R`3WT at CR?H],CH2*)&$W+
M0KY?R"10"L-__UWZ0LYXD-\R0E$'YH]-U'%YHQ*IA%=\*N+#`,/PL?/=N#@7
M'QV,T/2<=`+0^(_I/P<FH<;NY8J6/LXF]GY+1P<WN1:AC$=)77UDO]]DW[&K
MR`NO%ULX:5;5X:)BHU[I5UD:3>!E;<1,;7IU_?'#=2D1'GF#DSK->F$Z"&1W
M`Z=O>F0]>OED9<).V9]&[\+[7G0QQ'Y4Y=[S3.&+:>-#;A)/9V_;03P4>J05
M5A*-M*;;B#[.ECT4^9"/SN>FK#=,C+`DS?[`ZVVTZ2_W<SWHK.2QX>$K+$B7
MC-MXJ9IH<770X:7#T69:O^G^),U:>JC`?'%J*C!6^ISTQZU=>W:S%97YC=T4
M'U_?BVQD!7,_$`@/HC_1GQ?3)EXVAY*5I"A`2F\CT\NGO:KG+!$^5/T%*Q;[
MN[U at 4G%*C&9\GM.2DPKFEK@)@6,$J6RRENWZJC=.UV&(Q:@UTEA-W%74WGY9
M#[T2['CB!`*MLFFG^3\TDJ!1A8U/]'L66>3O at EVL\G]M\G_\:[Y8Y_^>+VX+
M7R^W^3^7MS?<"V<C7\VNS"2!AG, at 3N;-1NPBINA"POFLAFL4KN1UK)<%/NLB
MV]FB<,LM^7M5Y#LK$IYI9YR+LHI,BHKG6GG/Y'G_$>]\CFFSJ]*XD-6[@^>5
M"[R:L?-WA['^9E;X:[$N56+EMJYF^$*RL42V\&&FL/BQ-LULYT]%1Y1#?5;S
M^6:]7JJIK]CU7[G7DWTP7VR5-!3*%='^UW*QW=P6/Z,?;?58DO;897NQ)4#N
MIZO%W>INLUW<::I'^O)6%-$/.?K9QYH(Y$K-Y!?SU79UN]RL"MXV_53-UOE"
MLD)PU+'/->DKW:R7A,X<K<E7FA17CUUQ*[&I at J/OYK>KU6:[6LVVR^WL;KV>
M;^9KY2JX*M=#7!EWB\5RN5W,EIO;]6J[7=_.;JM/51^2--4$@H*IA033#`BZ
M"P<Z#0:&"@4&#02Z#@-Z"@*&#`$&#@!Z[/[[[?P'ZOK'VO&/K-N/+]%V#\AZ
MJ=QXG&XFI8^[AFF'YIMO."Y!>HGF+*X8:`)BT^UY^7NA(SFZG&AZTFF_F\"S
MJ[4K^'73PLUSCGE=V170_/NVJ<J+YQG^VVGOVE5#-,G/Y>3K[L56A)!CT7CY
MN`88&!MUT[1=!=Z&Y%Q.E8)%8N1MPB?3-LXN>?G:!0NMN456H'$J(,QE$1IJ
M00U$EDE;(U4'@C+282*!IJK>;HZ>:47G>7Q0JQ&5;S"("H0<B[;VH at H#8Z-N
M&H&6THR$?-]\0G[.FSVAX#K9.,96!C4NWW-5%_RAJ':%=<GW9>^<W;Z5BT<R
M.HV+^]G>E-)=%]&)YDJM`76Q<7BS0OTUI.F"L[AH`^1SD*@<W7>FM16ZG[0!
M\-8YL>H>Y/W(3/:W:34 at .VKSQ>+]=;I13:&SEL%HZ*E585K9Q,/UNG$Z=J[C
MH]'M@^SWU4/MZ2_O>4I;Y@@ZTETX01XI\D6V at 3'!>/_HR?2_?Q2`Y0JF^[HJ
M\MQ!G#9V=>@2)(7JS4;.4_#<4G>%Z55Y'2?S-=$#&9XXZ"G>WPD:G0B*-[S7
M"@ASM2)D!,P`OR"#;:(#&D$0H=D."B"R3-H<OSH0E)$.$PGT`VU8U0&;>T9.
M5QNVXP,V`@.WOEFT](KN)2BX-[&)X?<WE<-UD&ZQ(^4"/N-,HC8%KRDHWO`J
M*"#,U8J0$<!J7E,<H=D.6-EK"H.T>4UU("@C'282\)HB6-D5S;E)E_,E.3/,
M&_KHSLG81`I^`W5<#.`!S@'+K>MRZS8#0$>^;2>ZM0U\.4,3WS*=^M!??'FS
M?ERA50,'VG&#KMGK4%&_KA<\NQ??=`Z^X:.SY+I>BZQ`1Z:`,)=%:/#2:B"R
M3-HZ,G4@*",=)A+HR%JP:G==$,?C^#1LNE;=7U%&$GI-A<+BB^,_XV,:&C<'
MNQ,X$$9Z%Q]EVV[>_\3'PO*F*!^P+QYZ_PG,D32$([9M</J"N)A]2L8FDJ<O
MERU!D-_PH+7VB"Q&/C$M%"2JVS^LQ5-(A/#Q1ATA]]HJX.2+93@*[;ZP`5A?
M4Q;E)-ONY.FJ-L*D).465V72UOP2)/E18_'P>%HL/>`P3)%1'H=VDJ)7HY8&
M\-9\!D4YP:Q%$6XE(UANP58,HBY+K"0=Y0P%.3M5UZ+J%Z8TZ2UG!].OPSAB
MSP_H\-5PCT,5M$2BL=2YYTN$17Z/O.*__TRXU6<@XBB+FER4T"OG0'*[IVX$
M'M%$3:?A037/Y/&Q>5/:Q:%9Y-E*4MS[[(D8\A;.X3?1`F>AL)#K`'"*0NP_
M?(-.V&C5%94V'0D(E5:_?CEK=ZR?M*-^.11J%P3<N)FBKCF%2NT)I#*:]#`Z
MU,S5TY4:*'XY!97QF70L(0Z>L=/6\E15]?"^Z>F%AO3.&DO07=5J)-EAH]`3
M!=CF\"%@@4,/<2_3IU!>P4RD;"L]`^?F-I-`D4]D^EY)7W[`*RU<32PE+&MC
M!_%--NX4$<^F;QR0XWJGZ:2):.4\VE01%>:?+R?DD886$6=3 at LFBE-"SU;/6
MTI(@=71V#4)16HCE1!"I\Y&^58;M^OX47ZTFXA-XO_+T>0V,_[ZT25$B4@*5
MEZM-(,X?+B,2Y3.7D2B_O2+&DK<NH"C5M[U-(EMZ[[!26KRLL#A<L6R-U3M=
M8<GFNAB]^\7.D=Y(^#8MW]O">M2.M\1=Q.L*B.1<KL#3N3=,X.F"AQ)X/N]I
M!1[/7EI!TT@:4I9^_HT6>+SH6K4;O]:IRL@"54K5#,^7RH at UF'WT7O3/"T:!
M\=G\/"TWVD9[U'ZT3%[$D8K(Y#RIR..Y5TOD\8(S$A'(.U.1Y[-W5M1`LO:4
M+D+^S19YONA1.ZB$6I\J)0Q5*E=#/+<J)==D_=$[5EH&TZ8,)^=<1:B/VL'R
M"B#B9$7E<HY65"3WRHF*%+R5J%#>Z8K*9*^UC.$@M at 85*>\&1&6*CKC#2JIU
MR-(`*LKE:Y#GG*5E6VI&4WHD?. at F`U$>5\,APS*<KK-["2Z]P4NG.5,\W?9D
MP!H-FN+IMJBVC$Y50-TVU784M at JHVZI2"ZO$:;@>H at GM/BA)WZ at A0"X<PL1*
MA1,]21*&,H[0I4U":(*72$EAZ6,GN/PO8;DV'`<'L(M40354JTU`/+V)^X$5
MU<"GLTTAZ:6GO+,*Q3T?+/B-`>[-P+1=$H='0"?SG.*4TD'6U!%T>TJLI'JY
M=N?W*18U#W639(%%W=6`$SB4&=^T>W'PGQ=Z_L9#/OZK\#HV:/R9CW!*&4Z"
M76+3*$U`/`Q(,Z;5M/3F7&GCGA[!9!Q!/T*'Z<R+M'(>[81(A7G#R%?H6>Z0
M5TX2I"X:Y,I3E!9*AK45*:UW_[2A*]__TZ:@RSN`A'5W=0^0M'4!=P&UZ=!X
M'Y"P/3NZ$TA8?W?W`K51T'PW4)LZ_?<#M6GL\(X at J>KM^9X at D8KH^:Z at SCL&
M]&I:07?=0 at -\QYV"B.8.NP09N\(ZA`8->KL#$4MVUQF(:.^T*V@@H+\C:%#6
M23?0H*_;3D"T6OOO`EJJH/\.($]H[*-MC*SU^FY2@^U&RF,>:Q>(-P^U<=2.
M`4-M"4F0NG2H+4E16B at WU"Y*Z8ZH&M%UQ%2-"CJ.JL1T=QA7R5D7%EDUZM`;
M6XG9L[OH2DQ_I_%5(P7]$5:CNDYBK$:-W499XM7;?YS56A']1UK==@PG]W"Q
MW>[ZA2;\CKL%(=4=]@I2IH5U"DTJ]/8)0L;LKDL04M]IC]#$0'^'T*2MD_Z@
M26&WW8%PU?;?&[350O^=09Y1O)%)<*>7']W`4]WJI0K at P@%&/W,0M:-)S1PT
M4A[SS$&!N.XPIPE<1YC3A-]QF".DNL,P1\JTL#"G287>,$?(F-V%.4+J.PUS
MFACH#W.:M'42YC0I[#;,$:[:_L.<MEKH/\QI[,1&%R2<D85-&_\UM4BAE?>H
MPX4*^[8CCL)"\?E&X>>S-0:QY]-C@,(2R;%&88%T!4/<3-)FE2]&;KE#3"`[
MQ]A99=2M,4E*@]5*UA1GO4E2L+$2M,?=;1JT!-]M2KJ.P(7U=QF&2UL:&(NW
MZ=$<D`O;ML.H7)A#MZ%Y&XT.XO,VE=T$Z6U:.X[4I:I[@'!=I%(&B-E;P\E1
M!>XG\]5`KV?704XPGTTG<!?B/=K`G<N^+7`7%HH#=^'GXZ!-^/DTXA662`)W
M88$H')0RD[19Y8N1Q(S"`EG at WEEE<`-W>6FP6LF:*@?N\H*-E3`97SM-3SME
M/POPLG(^5NZEEO6ODMY5RK?*>5:07Y7TJM(^59OQ6_TIT)O"?"G0DT+]Z"2\
M*':F&;&*\!ZO)^6Q;_6EHD*)-Q5]/GF_1)_/7)*H1.I3107B=U?&3-)FE2]&
M^I*+"N2\:U>5P?>PTM)@M9(U5?&STH*-E3`97SM-3SME/POPLG(^5NZEEO6O
MDMY5RK?*>5:07Y7TJM(^59OQ6_TIT)O"?"G0DT+]:)S'$/LG,[">KV'9&X%)
M'Z/,9Q]$*8A<B:XDG%Q3JBO7F7-V?0Y4*Y4R8#Y_7AE3,)DAVS++O0TQ6D;3
M#WG#E@"@N.5$E%)Y%OD(8MN+90R%.\!T.\`4-?P+\DC'$BH:/T&IU+]P9LM:
M(M$+U()0^SJVEJ^%UGEO6M^/)K;5#)3!P"U43T7-1/6X at IE@SPA]K^[M%R_7
M92^4UM059'.),DV"2G()J#&N)W-%J6<>\.MT!AE-=$<[NLB3UKK'J0%8>6M3
M`W:7.YI$U':UD4G&G(#]2PWP&K<MB1BPH]U*(JJ[VZ34H%WSWJ0&3?JW)#4H
MZW`GDFA5]KP!J<7R/>\[RK$1SION'4A`TU_B]`9U$IG3I4(@\LPANZP=BN"[
M)U1!(<6.TRY[Z(F`D=HG49[-(BX:/EY=?_QP77H2O:`DCW;RX7L&><,/@D$1
ML(?.MFDA3H+VGA*D<PD,E:V=1Z8N:;L&93[R7M!UH<O2/7_2H&0"6>?C9.EM
M%@)9_XB=`W]&@5(OJ,PG2=>EF$K6*AGYR"O[>T+CKU;2XQV%5:BW+?&(2<0K
M/&(/QQ/^8@^G"R1BCR?+.V)/1VL(XD:1LZ`D]62-0>SI;&6G`Z-SUW4D16$*
M96JDO*@C*55K[\(]&+YE.B1FN^9>>E$77A0\<!7.<0,%/!^9GO4L'N48__XS
MZ4[JPLT/!63VNT=B1L]'N?6H##?ND7I[1+P$4B&VC]#WI^MLS%2<I@$#1N[W
M'`^#?H?,EU,@]WBLXR:R8B$T,E+0(SPQK:9#849>5O'73W\0H>"`W:QP\;M)
MH4B%EJN6SYT(I_*2HM*-!(@LW#@D\:4:A3RV8F/HJAH".KW`'^Q+&IPA)6OI
MO+&YJ'4;**G:4:"T;?2>W?!D.F]6=;E+SE[U..*F:L10,53 at Y<-QQ;$>Z!I&
M_\U1-C$70K0[Y`J+5XV*[@#9]M-T,IT18F\.\DF(BHZN-Z&QL!CQT8Z'^?3;
MQL3B4O&X6%P@'B:("Z2#3'&19(PL+A&-RN2,)6]=0%&2,9RX1#9N[K!2N.-G
M@#A<L6R-E<?2`,GFNABW^_7,LS\AI]M`=[RN-B,M&0A<V-8SS?%9#:A@:$7O
MWO*:$83BJP8<<?,T8JB8J!Y8,`J[.$\HX"2L%9,./1R at PKH*>$3TZA,BSG4;
MBE"=Q5CJP[17_WP)',$""E++(3815&@5=:S_J?\JJ5_^^?GGYY^??W[^^?DI
+?_X_(,G`G``@`P`)
`
end



From ddd at cup.hp.com  Thu Apr  6 22:49:17 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Thu, 06 Apr 2000 22:49:17 +0000
Subject: Location of unwind tables
Message-ID: <38ED146D.179AD360@cup.hp.com>

Cary,


An interesting observation was raised at todays C++ ABI meeting. Can we
dynamically generate unwind tables for instance from a JIT? We are back to the
question of whether the IP->UnwindInfo translation can be done just by looking
up tables, or whether we need an API to do it.

I had a discussion with Laurent Morichetti a few minutes ago. It is unclear at
that point whether their unwinding would be based on the unwind library at all
(there are alternatives, such as encoding unwind information themselves). But
assuming they want to leverage all the code that deals with the RSE and all that
magic, they need to have a way to be compatible with the unwind library.

Today, the unwind library uses dlmodinfo to find the start of the code segment
for the current IP (and a predefined symbol in the case of archive-bound
executables). From there, it can find the start of the unwind table, and from
there do a binary search on the IP to find the unwind info block.

The JVM could be compatible with this black magic by having a way to tell dld
what to return for the newly created code segment. I don't think there is a
public dld interface to do that, and it creates a rather obscure and difficult
to document dependency between the JVM, the unwind library and dld.

Alternatively, we could have a couple of APIs to do IP->UnwindInfo translation,
and to register a new range of text and provide the corresponding unwind info
pointer. In that scheme, the actual location of the unwind table would become
irrelevant.

Also note that in addition to Java support, an implementation of Dynamo for IA64
would probably have a similar problem.


What is your opinion?
Christophe



From mark at codesourcery.com  Fri Apr  7 08:44:06 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Fri, 07 Apr 2000 01:44:06 -0700
Subject: Mangling constructors
Message-ID: <20000407014406Z.mitchell@codesourcery.com>


There's an inconsistency in the mangling spec vs. the closed issues
list.  The closed issues list says constructors never do allocation,
but the mangling document has:

  ::= C3 # complete object (in-charge) allocating constructor
  ::= C4 # base object (not-in-charge) allocating constructor

Presumably these aren't needed?

-- 
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From nathan at codesourcery.com  Fri Apr  7 18:00:31 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Fri, 07 Apr 2000 19:00:31 +0100
Subject: pointer_to_member_type_info
Message-ID: <38EE223F.C43D577E@codesourcery.com>

Hi,
__pointer_to_member_type info is derived from type_info. I strongly
recommend it be derived from __pointer_type_info, as it requires much
of the same functionality, and has the same meanings of its flags.
By subclassing __pointer_type_info, much code could be reused.

Thus point 8 of the rtti classes would become
8.The abi::__pointer_to_member_type_info type adds one field to
abi::__pointer_type_info:
              a pointer to a abi::__class_type_info
		(e.g., the "A" in "int A::*") 

nathan
-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From alainm at cup.hp.com  Sat Apr  8 00:42:14 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 07 Apr 2000 17:42:14 -0700
Subject: CV qualifier and substitutions
Message-ID: <38EE8066.75F54C24@cup.hp.com>


CV-qualifiers appears in two productions of the mangling grammar:
<type> ::= <CV-qualifier> <type> (actually, the <type> is missing 
                                  in the html document)
<qualified-name> = <CV-qualifier> <qualified-name>

It raise a question wrt substitution, consider the declaration:
     int* volatile const restrict p 
Those mangled type is:
     rVKPi

If i am correct, at the end of this mangled sample, we have:

<type> S3_
  <cv>
    "restrict"
  <type> s2_
     <cv>
        "volatile"
     <type> S1_
        <cv>
          "const"
        <type> S0_
           "pointer to"
           <type> S_
             <builtin>
                 "int"

IOW, the CV qualification is decomposed and "int*" "int* const" 
"int* const volatile" "int* const volatile restrict" are all
possible sources for future substitution.

Now, my question is: since a possible (widely used ?) implementation
for cv qualified name is to associate a cv-mask with a type (ie, we
don't systematicaly have a representation for each possible source
of substitution), maybe it would be better to only allow (just to 
give the idea):

<type> ::= <CV-qualifier>* <type>

<type> S1_
  <cv>
    "restrict"
  <cv>
    "volatile"
  <cv>
    "const"
  <type> s0_
     "pointer to"
      <type> S_
        <builtin>
          "int"

Any opinion ?

Alain



From alainm at cup.hp.com  Sat Apr  8 00:46:00 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 07 Apr 2000 17:46:00 -0700
Subject: <function source-name>
Message-ID: <38EE8148.46C8913B@cup.hp.com>


In the following rule, "function" is just a coemment:
 <unqualified-name> ::= <function source-name>
                       ::= <function source-name> <template-args>

But I think it's an incorrect comment, since <unqualified-name> 
can appears as the last component of a nested name and that a 
nested name can encode a class-enum-type.

Or maybe not ?

Alain



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 04:00:17 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 21:00:17 -0700 (PDT)
Subject: mangling example
Message-ID: <200004080400.VAA48649@baalbek.engr.sgi.com>

> From: Alain Miniussi <alainm at cup.hp.com>
> 
> I have a problem with a mangling example:
> 
> _Z5firstI3DuoEvS0_  -> first<Duo>(/*nondependent*/Duo)
> 
> If I understang correctly the mangling, we have:
> 
> <encoding>
>  <name> // potential source for substitution 1
>    <unqualified name>
>       <source name>"first"
>       <template-args>
>          <template arg>
>             <type> // potential source for substitution 2
>                <class-enum-type>
>                   <lass-enum-name>
>                      <source name>"Duo"
>  <bare-function-type>
>    <type> // potential source for substitution 3
>      <builtin type>"void"
>    <type>
>      <substitution>0 (ie, the second last encoded)
> 
>    
> So, at the point where S0_ appears:
> 
> S_ = void
> S0_ = first<Duo> (1)
> S1_ = Duo(2)
> 
> So I guess it should be _Z5firstI3DuoEvS1_, or
> did I missed something ?

I think you're right.

You raise another issue.  I believe that our intent was that
the candidates at this point include:

  S_	void
  S0_	first<Duo>
  S1_	Duo
  S2_	first

But I don't see the substitution of first in the grammar.
Is this what the others had in mind, too?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 04:13:42 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 21:13:42 -0700 (PDT)
Subject: Mangling constructors
Message-ID: <200004080413.VAA48750@baalbek.engr.sgi.com>

> From: Mark Mitchell <mark at codesourcery.com>
> 
> There's an inconsistency in the mangling spec vs. the closed issues
> list.  The closed issues list says constructors never do allocation,
> but the mangling document has:
> 
>   ::= C3 # complete object (in-charge) allocating constructor
>   ::= C4 # base object (not-in-charge) allocating constructor
> 
> Presumably these aren't needed?

We have decided not to specify allocating constructors (although we
have a low-priority issue C-13 to reconsider this).  However, we
specified the mangling in case implementations choose to implement
them.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 04:50:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 21:50:35 -0700 (PDT)
Subject: pointer_to_member_type_info
Message-ID: <200004080450.VAA31916@baalbek.engr.sgi.com>

> From: Nathan Sidwell <nathan at codesourcery.com>
> 
> __pointer_to_member_type info is derived from type_info. I strongly
> recommend it be derived from __pointer_type_info, as it requires much
> of the same functionality, and has the same meanings of its flags.
> By subclassing __pointer_type_info, much code could be reused.
> 
> Thus point 8 of the rtti classes would become
> 8.The abi::__pointer_to_member_type_info type adds one field to
> abi::__pointer_type_info:
>               a pointer to a abi::__class_type_info
> 		(e.g., the "A" in "int A::*") 

This looks reasonable to me.  Does anyone else have a problem with it?
If not, I'll just make the change.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 05:03:32 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 22:03:32 -0700 (PDT)
Subject: CV qualifier and substitutions
Message-ID: <200004080503.WAA48738@baalbek.engr.sgi.com>

So, to restate Alain's note, the issue is this:

- The current definition treats the intermediately-qualified types to
  be substituted, maximizing substitutability in some sense.

- But some implementations don't maintain internal symbol table entries
  for the intermediate types.  So this probably violates our principle
  of only mangling things with a convenient symbol table handle, for
  those implementations at least.

Should we eliminate substitution for the intermediates, losing some
opportunities but maybe easing some implementations?

Can we get people's reactions to this issue?

Jim

> Date: Fri, 07 Apr 2000 17:42:14 -0700
> From: Alain Miniussi <alainm at cup.hp.com>
> 
> CV-qualifiers appears in two productions of the mangling grammar:
> <type> ::= <CV-qualifier> <type> (actually, the <type> is missing 
>                                   in the html document)

It's there, in the <CV-qualifier> production -- not highly intuitive
naming, I suppose.

> <qualified-name> = <CV-qualifier> <qualified-name>
> 
> It raise a question wrt substitution, consider the declaration:
>      int* volatile const restrict p 
> Those mangled type is:
>      rVKPi
> 
> If i am correct, at the end of this mangled sample, we have:
> 
> <type> S3_
>   <cv>
>     "restrict"
>   <type> s2_
>      <cv>
>         "volatile"
>      <type> S1_
>         <cv>
>           "const"
>         <type> S0_
>            "pointer to"
>            <type> S_
>              <builtin>
>                  "int"
> 
> IOW, the CV qualification is decomposed and "int*" "int* const" 
> "int* const volatile" "int* const volatile restrict" are all
> possible sources for future substitution.
> 
> Now, my question is: since a possible (widely used ?) implementation
> for cv qualified name is to associate a cv-mask with a type (ie, we
> don't systematicaly have a representation for each possible source
> of substitution), maybe it would be better to only allow (just to 
> give the idea):
> 
> <type> ::= <CV-qualifier>* <type>
> 
> <type> S1_
>   <cv>
>     "restrict"
>   <cv>
>     "volatile"
>   <cv>
>     "const"
>   <type> s0_
>      "pointer to"
>       <type> S_
>         <builtin>
>           "int"
> 
> Any opinion ?
> 
> Alain
> 
-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 05:08:58 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 22:08:58 -0700 (PDT)
Subject: <function source-name>
Message-ID: <200004080508.WAA48478@baalbek.engr.sgi.com>

> Date: Fri, 07 Apr 2000 17:46:00 -0700
> From: Alain Miniussi <alainm at cup.hp.com>
> 
> In the following rule, "function" is just a coemment:
>  <unqualified-name> ::= <function source-name>
>                        ::= <function source-name> <template-args>
> 
> But I think it's an incorrect comment, since <unqualified-name> 
> can appears as the last component of a nested name and that a 
> nested name can encode a class-enum-type.

Right.  I'll fix it.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr  8 05:33:13 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 7 Apr 2000 22:33:13 -0700 (PDT)
Subject: Updated pages
Message-ID: <200004080533.WAA48905@baalbek.engr.sgi.com>

The status pages are updated from the meeting and most of the email.
(Not PDF yet, though.)  Please comment on the questions that were
raised.

Jim
-		Jim Dehnert  x3-4272



From mark at codesourcery.com  Sun Apr  9 19:26:37 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Sun, 09 Apr 2000 12:26:37 -0700
Subject: In-charge constructors/destructors
Message-ID: <20000409122637S.mitchell@codesourcery.com>


There are two bits I noticed regarding constructors/destructors:

  o The ABI doesn't actually specify that when a compiler puts out
    one variant that it should put out the others as well, unless the
    function was declared inline, or has internal linkage.  For example,
    if the constructor is defined in some `.C' file, then we need to
    write out both the in-charge and not-in-charge versions in the
    corresponding .o file.  Maybe this is so obvious that it can
    remain unsaid.

  o Also, as written, the ABI seems to say that you need both
    in-charge and not in-charge variants, even if the type has no
    virtual bases.  We should say that when there are no virtual 
    bases, you don't need the not-in-charge variant, I think.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From alainm at cup.hp.com  Mon Apr 10 18:20:21 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Mon, 10 Apr 2000 11:20:21 -0700
Subject: CV qualifier and substitutions
References: <200004080503.WAA48738@baalbek.engr.sgi.com>
Message-ID: <38F21B65.DF0083B0@cup.hp.com>

Jim Dehnert wrote:
> 
> So, to restate Alain's note, the issue is this:
> 
> - The current definition treats the intermediately-qualified types to
>   be substituted, maximizing substitutability in some sense.
> 
> - But some implementations don't maintain internal symbol table entries
>   for the intermediate types.  So this probably violates our principle
>   of only mangling things with a convenient symbol table handle, for
>   those implementations at least.
> 
> Should we eliminate substitution for the intermediates, losing some
> opportunities but maybe easing some implementations?

Note that we don't lose a lot of opportunities, we are still able to
substitute the type and the cv-qualified type as long as the
cv qualification is the same (probably the most common case).
Basicaly, if we consider  V K r, we loose at most 2 charaters in
a given mangled name (ie, the loose is not repeated) and only if 
the second qualification is a suffix of the first one. 

> Can we get people's reactions to this issue?
> 
> Jim
> 
> > Date: Fri, 07 Apr 2000 17:42:14 -0700
> > From: Alain Miniussi <alainm at cup.hp.com>
> >
> > CV-qualifiers appears in two productions of the mangling grammar:
> > <type> ::= <CV-qualifier> <type> (actually, the <type> is missing
> >                                   in the html document)
> 
> It's there, in the  production -- not highly intuitive
> naming, I suppose.

You are right, but then, I am not sure how <CV-qualifier> fits in the 
<qualified-name> production (but I didn't had a close look).
 
> > <qualified-name> = <CV-qualifier> <qualified-name>
> >
> > It raise a question wrt substitution, consider the declaration:
> >      int* volatile const restrict p
> > Those mangled type is:
> >      rVKPi
> >
> > If i am correct, at the end of this mangled sample, we have:
> >
> > <type> S3_
> >   <cv>
> >     "restrict"
> >   <type> s2_
> >      <cv>
> >         "volatile"
> >      <type> S1_
> >         <cv>
> >           "const"
> >         <type> S0_
> >            "pointer to"
> >            <type> S_
> >              <builtin>
> >                  "int"
> >
> > IOW, the CV qualification is decomposed and "int*" "int* const"
> > "int* const volatile" "int* const volatile restrict" are all
> > possible sources for future substitution.
> >
> > Now, my question is: since a possible (widely used ?) implementation
> > for cv qualified name is to associate a cv-mask with a type (ie, we
> > don't systematicaly have a representation for each possible source
> > of substitution), maybe it would be better to only allow (just to
> > give the idea):
> >
> > <type> ::= <CV-qualifier>* <type>
> >
> > <type> S1_
> >   <cv>
> >     "restrict"
> >   <cv>
> >     "volatile"
> >   <cv>
> >     "const"
> >   <type> s0_
> >      "pointer to"
> >       <type> S_
> >         <builtin>
> >           "int"
> >
> > Any opinion ?
> >
> > Alain
> >
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272



From samuel at codesourcery.com  Tue Apr 11 07:29:33 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Tue, 11 Apr 2000 00:29:33 -0700 (PDT)
Subject: mangling template args with C linkage
Message-ID: <14578.54365.870970.777946@basil.indetermi.net>

Mangling question.  Suppose you have:

    template<void (* P) (void)> class TemplateClass {};

    extern "C" void foo (void);

    TemplateClass<&foo> x;

Does the template argument foo get mangled as "foo" or "3foov"?  The
production

    <template-arg> ::= LZ <encoding> E

would seem to imply the second, but it seems odd to mangle the name of
a function with C linkage.

Alex Samuel
CodeSourcery, LLC



From nathan at codesourcery.com  Tue Apr 11 08:19:13 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Tue, 11 Apr 2000 09:19:13 +0100
Subject: More rtti woes
Message-ID: <38F2E001.B1173F20@codesourcery.com>

Hi,
More rtti woes I'm afraid.

Issue 1)

It is permissible in a pointer to member of X, for X to be an incomplete
type [8.3.3]/2. This means that we need more that a single incomplete
flag. The presence of such a ptr to member, will mean that it, and all
pointers to it will have their incomplete flag set, but its target
might not be an incomplete chain. In implementing G++'s rtti runtime I
found the following three flags useful, (this is with
__pointer_to_member_type_info derived from __pointer_type_info)

incomplete_mask       = 0x8
incomplete_chain_mask = 0x10
incomplete_klass_mask = 0x20

incomplete_mask is an inclusive or of the other two flags.
incomplete_klass_mask is only used by __pointer_to_member_type_info,
and __pointer_type_info knows nothing about it (it simply examines the
other two).

A __pointer_type_info or __pointer_to_member_type_info sets the
incomplete_mask and incomplete_chain_mask, if the target is an incomplete
type, or has its incomplete_mask set.

A __pointer_to_member_type_info sets the incomplete_mask and the
incomplete_klass_mask, if the class of the member is incomplete.

Issue 2)

The algorithm for collation order of type_infos, cannot simply compare
addresses for non-pointer types, and complete pointer types. Using
string collation only when one of the types is a pointer with the
incomplete_mask set. There are two difficulties. Firstly, we might be
comparing a non-pointer type_info with a pointer type_info. We need to
determine this and DTRT WRT the incomplete flag of the pointer
type_info. to do that will require dynamic_cast or typeid'ing the
type_infos. Secondly, assume we are just comparing pointer type_info's.
We have two pointers to complete, Aptr and Bptr, and a third pointer to
incomplete, Cptr.

1) Aptr.before (Bptr) can just compare addresses.
2) Bptr.before (Cptr) will compare names.
3) Cptr.before (Aptr) will compare names.

There is nothing maintaining the consistency of the results of these
three tests -- result 1 is uncorrelated with results 2 & 3.

Therefore type_info::before must be implemented as string compare on the
type's names. We lose any advantage of commonizing the type_infos.

Issue 3)

17.4.4.4 prevents an implementation adding member functions to one
of the std classes, except in particular circumstance. About the only
leeway given is whether a particular non-virtual function is inline or
not. So I presume we're not permitted to add virtual member functions
to std::type_info (18.5.1). The rules given in 17.4.4.4 specifying what
member functions can be added look like applications of the as-if rule,
but there must be something deeper going on, as if that was all, it
wouldn't be mentioned. I'm not sure how a conforming program could tell
whether additional functions had been added.

The abi requires us to add virtual functions to type_info. 
For instance the implementation of operator== will require it to
deal with pointers to incomplete. G++ needs several for catch matching.

Issue 4)

5.2.8 talks about typeid returning something derived from type_info,
but the footnote mentioning extended_type_info implies to me that
typeid always returns objects of the same type. Again, I'm not sure
how a conforming program could tell.

The two proposals I made last week (`Alternative rtti proposals') resolve
these issues. Proposal A resolves issues 2,3 &4, whilst proposal B
resolves issue 2 only, and will leave us (slightly) non-conformant.

nathan

-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From loewis at informatik.hu-berlin.de  Tue Apr 11 17:28:12 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Tue, 11 Apr 2000 19:28:12 +0200
Subject: universal character names
In-Reply-To: <u91z4kxdma.fsf@yorick.cygnus.com> (message from Jason Merrill on
	05 Apr 2000 17:43:57 -0700)
References: <200003230753.IAA11057@pandora> <u91z4kxdma.fsf@yorick.cygnus.com>
Message-ID: <200004111728.TAA27908@pandora>

> UTF-8 is inappropriate for mangled names, as it uses values > 127 to
> encode non-ASCII characters.

Why is it not appropriate? AFAICT, the gABI has no restriction in that
respect. ch4.strtab.html says 

# String table sections hold null-terminated character sequences,
# commonly called strings.

I can see there are a number of alternatives. I think it is important
that there is agreement on the rules, in a way that is also
interoperable with C99 implementations. What those rules are is not
that important.

> GNU Java encodes names in UTF-8 internally.  For the mangled name, if there
> are non-ASCII characters, it adds a 'U' to the beginning and encodes each
> such UCS-2 character as _%04x.  See gcc/java/mangle.c.

In the C++ ABI, the natural adaptation of that approach would be to
mangle non-ASCII-containing identifiers as _U instead of _Z, right?
Unfortunately, that does not give a solution for C names. I believe
the GNU Java approach also cannot be extended to C99.

Regards,
Martin



From mark at codesourcery.com  Wed Apr 12 01:14:49 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 11 Apr 2000 18:14:49 -0700
Subject: Position of destructor entries in vtables
Message-ID: <20000411181449V.mitchell@codesourcery.com>


I don't see that we've yet specified where destructors go in the
vtable.  Currently, we say that vtable entries for functions are in
declaration order -- but destructors are sometimes implicitly
declared.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From alainm at cup.hp.com  Wed Apr 12 01:22:49 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Tue, 11 Apr 2000 18:22:49 -0700
Subject: cv-qualification
Message-ID: <38F3CFE9.E0C4369A@cup.hp.com>



<qualified-name> ::= <CV-qualifier> <qualified-name>
                 ::= <substitution>

As explained in the preceding paragraph, the only purpose of 
the CV-qualifier is to encode the cv qualification of a
method. I think it is a way to encode the cv-qualification of
this (since this's type is not represented in the signature).

then, I have two questions:
	1) We don't need to encode the type of this, only it's
pointed value cv-qualification. Still:
	<CV-qualifier> ::= K <type> 
Is the intent to encode the <type> ?

If the answer is no, maybe we should have something like:
        <type> ::= <CV-qualifier> <type>
and
        <CV-qualifier> ::= K | V | r


	2) if we have two functions with the same name used in a mangling,
do we want to substitute the second occurence because it's the same name
or
to keed two different encoding since they do not represent the same
entity ?
(I am not sure how to interpret:
"Note that substitutable components are the represented symbolic
constructs, 
not their associated mangling character strings." in that situation.)

Any idea ?

Alain



From dehnert at baalbek.engr.sgi.com  Wed Apr 12 01:31:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 11 Apr 2000 18:31:47 -0700 (PDT)
Subject: mangling template args with C linkage
Message-ID: <200004120131.SAA58419@baalbek.engr.sgi.com>

> From: Alex Samuel <samuel at codesourcery.com>
> 
> Mangling question.  Suppose you have:
> 
>     template<void (* P) (void)> class TemplateClass {};
> 
>     extern "C" void foo (void);
> 
>     TemplateClass<&foo> x;
> 
> Does the template argument foo get mangled as "foo" or "3foov"?  The
> production
> 
>     <template-arg> ::= LZ <encoding> E
> 
> would seem to imply the second, but it seems odd to mangle the name of
> a function with C linkage.

We haven't explicitly decided, but I think the answer is neither.
It serves no purpose to do a full mangling, so I don't like 3foov.
But it can't be unmangled, since we have to be able to find the end
(think about extern "C" bool IsEmpty (void), as LZIsEmptyE...).

So I think the answer is to treat it like a global data object, and
mangle it as its <source-name>, i.e. LZ7IsEmptyE.  I've put this
specification in the document -- object if you don't like it.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Apr 12 02:13:09 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 11 Apr 2000 19:13:09 -0700 (PDT)
Subject: cv-qualification
Message-ID: <200004120213.TAA58745@baalbek.engr.sgi.com>

> From: Alain Miniussi <alainm at cup.hp.com>
> 
> <qualified-name> ::= <CV-qualifier> <qualified-name>
>                  ::= <substitution>
> 
> As explained in the preceding paragraph, the only purpose of 
> the CV-qualifier is to encode the cv qualification of a
> method. I think it is a way to encode the cv-qualification of
> this (since this's type is not represented in the signature).
> 
> then, I have two questions:
> 	1) We don't need to encode the type of this, only it's
> pointed value cv-qualification. Still:
> 	<CV-qualifier> ::= K <type> 
> Is the intent to encode the <type> ?

No.

> If the answer is no, maybe we should have something like:
>         <type> ::= <CV-qualifier> <type>
> and
>         <CV-qualifier> ::= K | V | r

I've fixed it, and also added a tentative move towards your earlier
suggestion of not substituting intermediate types (with a subset of the
qualifiers).

> 	2) if we have two functions with the same name used in a mangling,
> do we want to substitute the second occurence because it's the same name
> or to keed two different encoding since they do not represent the same
> entity ?
> (I am not sure how to interpret:
> "Note that substitutable components are the represented symbolic
> constructs, not their associated mangling character strings."
> in that situation.)

It means that two functions are two distinct names for mangling
purposes, even if they are spelled the same.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Wed Apr 12 03:21:47 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 11 Apr 2000 20:21:47 -0700 (PDT)
Subject: Status page updates
Message-ID: <200004120321.UAA59155@baalbek.engr.sgi.com>

The web status pages are updated, HTML and PDF.
I'll send an agenda tomorrow, but a good approximation would be to
look at the recent mail, new issues from it, and red stuff in the
layout document.  Also, think a bit about what needs to be done in
the template area, and what can be done in the library interface
area.

Jim
-		Jim Dehnert  x3-4272



From samuel at codesourcery.com  Wed Apr 12 17:41:58 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Wed, 12 Apr 2000 10:41:58 -0700 (PDT)
Subject: mangling enum literals
Message-ID: <14580.46438.87690.890669@coriander.indetermi.net>

The paragraph discussing literal template arguments doesn't mention
enumeral values.  Do we use the value's <source-name>, or numerical
representation in the underlying type?



From daveed at edg.com  Wed Apr 12 17:57:14 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Wed, 12 Apr 2000 10:57:14 -0700
Subject: mangling enum literals
References: <14580.46438.87690.890669@coriander.indetermi.net>
Message-ID: <38F4B8FA.C6806532@edg.com>

Alex Samuel wrote:
> 
> The paragraph discussing literal template arguments doesn't mention
> enumeral values.  Do we use the value's <source-name>, or numerical
> representation in the underlying type?

I think you need to use the numerical value, because some valid enum
values may not have a name.  E.g., I believe that with:

	enum E { e1 = 1, e2 = 100 };

((E)3) is a valid constant-expression of type E.

(From memory; I didn't check the standard.)

	Daveed



From samuel at codesourcery.com  Wed Apr 12 17:59:26 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Wed, 12 Apr 2000 10:59:26 -0700 (PDT)
Subject: mangling enum literals
In-Reply-To: <38F4B8FA.C6806532@edg.com>
References: <14580.46438.87690.890669@coriander.indetermi.net>
	<38F4B8FA.C6806532@edg.com>
Message-ID: <14580.47486.886657.174253@coriander.indetermi.net>

Daveed Vandevoorde <daveed at edg.com> writes:

  Alex> The paragraph discussing literal template arguments doesn't
  Alex> mention enumeral values.  Do we use the value's <source-name>,
  Alex> or numerical representation in the underlying type?

  Daveed> I think you need to use the numerical value, because some
  Daveed> valid enum values may not have a name.  E.g., I believe that
  Daveed> with:

  Daveed> 	enum E { e1 = 1, e2 = 100 };

  Daveed> ((E)3) is a valid constant-expression of type E.

Yes, I think that's right.  Could this be spelled out in the ABI
standard?



From alainm at cup.hp.com  Wed Apr 12 18:09:02 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Wed, 12 Apr 2000 11:09:02 -0700
Subject: mangling enum literals
References: <14580.46438.87690.890669@coriander.indetermi.net> <38F4B8FA.C6806532@edg.com>
Message-ID: <38F4BBBE.6E476B01@cup.hp.com>

Daveed Vandevoorde wrote:
> 
> Alex Samuel wrote:
> >
> > The paragraph discussing literal template arguments doesn't mention
> > enumeral values.  Do we use the value's <source-name>, or numerical
> > representation in the underlying type?
> 
> I think you need to use the numerical value, because some valid enum
> values may not have a name.  E.g., I believe that with:
> 
>         enum E { e1 = 1, e2 = 100 };
> 
> ((E)3) is a valid constant-expression of type E.
> 
> (From memory; I didn't check the standard.)

7.2 - Enumeration declarations [dcl.enum]
6- For an enumeration where emin is the smallest enumerator 
and emax is the largest, the values of the enumeration 
are the values of the underlying type in the range bmin 
to bmax, where bmin and bmax are, respectively, the 
smallest and largest values of the smallest bit-field 
that can store emin and emax.

-9- An expression of arithmetic or enumeration type 
can be converted to an enumeration type explicitly. 
The value is unchanged if it is in the range of enumeration 
values of the enumeration type; otherwise the resulting 
enumeration value is unspecified. 

5.2.9 - Static cast [expr.static.cast]
-7- A value of integral type can be explicitly converted 
to an enumeration type. The value is unchanged if the 
integral value is within the range of the enumeration 
values (dcl.enum). Otherwise, the resulting enumeration 
value is unspecified. 

Alain



From dehnert at baalbek.engr.sgi.com  Thu Apr 13 00:33:32 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 12 Apr 2000 17:33:32 -0700 (PDT)
Subject: Agenda for 13 April
Message-ID: <200004130033.RAA61482@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Specify preorder/postorder for inheritance graph orders in various
   places.

 - Specify location of undeclared virtual destructors in vtable.

 - Further clarify the construction vtable description and example.
   The example may still have problems.

 - Derive pointer-to-member RTTI from pointer RTTI.  Add flag for
   incomplete pointer-to-member class in all pointers.  (All as
   proposed resolution of A-29.)

 - Further adjustments to the mangling writeup, including CV
   qualification, template argument encoding of extern "C" funcs.

 - Added a vague linkage section.

Please take a careful look at the colored text, and raise any issues
you observe.  In particular, be prepared to list other things which
need to be mentioned in the new vague linkage section.

Take a look at the material associated with the following issues.

  1) A-29:  pointer-to-member RTTI.

  2) A-28:  incomplete class RTTI and equality testing.

  3) F-1:  mangling of enum types.

  4) C-4:  Construction vtables.  Are my editorial elaborations
     correct?  The example?  (I doubt it.)  Does everyone now
     understand the proposals?

  5) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent.
     Matt gave him another set of names to try -- any luck?

  6) F-4:  Empty throw specifications.

     How much further should we take this?  I haven't had time to
     update it for throw specifications, but I did put the SGI/MIPS
     definition of our interface specification section (in ELF) on the
     web site to show another approach to achieving link-time
     checking.

  7) F-6:  Demangler.  Proposed simplification from Matt, HP interface
     from Christophe.

  8) F-7:  Mangling statics.  Should we adopt fingerprint algorithm
     from Mark?

  9) D-12:  Unwind table location.

Jim

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Thu Apr 13 17:19:54 2000
From: jason at cygnus.com (Jason Merrill)
Date: 13 Apr 2000 10:19:54 -0700
Subject: More rtti woes
In-Reply-To: Nathan Sidwell's message of "Tue, 11 Apr 2000 09:19:13 +0100"
References: <38F2E001.B1173F20@codesourcery.com>
Message-ID: <u9k8i1q5ol.fsf@yorick.cygnus.com>

>>>>> Nathan Sidwell <nathan at codesourcery.com> writes:

 > Issue 1)

 > It is permissible in a pointer to member of X, for X to be an incomplete
 > type [8.3.3]/2. This means that we need more that a single incomplete
 > flag.

Yup.

 > The presence of such a ptr to member, will mean that it, and all
 > pointers to it will have their incomplete flag set, but its target
 > might not be an incomplete chain. In implementing G++'s rtti runtime I
 > found the following three flags useful, (this is with
 > __pointer_to_member_type_info derived from __pointer_type_info)

I don't think it's proper to make that derivation; a pointer to member is
not a pointer.  This matters to the EH type matching code, which does a
dynamic_cast to _pti*.

 > Issue 2)

 > The algorithm for collation order of type_infos, cannot simply compare
 > addresses for non-pointer types, and complete pointer types.  Using
 > string collation only when one of the types is a pointer with the
 > incomplete_mask set. There are two difficulties. Firstly, we might be
 > comparing a non-pointer type_info with a pointer type_info. We need to
 > determine this and DTRT WRT the incomplete flag of the pointer
 > type_info. to do that will require dynamic_cast or typeid'ing the
 > type_infos. Secondly, assume we are just comparing pointer type_info's.
 > We have two pointers to complete, Aptr and Bptr, and a third pointer to
 > incomplete, Cptr.

 > 1) Aptr.before (Bptr) can just compare addresses.
 > 2) Bptr.before (Cptr) will compare names.
 > 3) Cptr.before (Aptr) will compare names.

 > There is nothing maintaining the consistency of the results of these
 > three tests -- result 1 is uncorrelated with results 2 & 3....
 > Therefore type_info::before must be implemented as string compare on the
 > type's names. We lose any advantage of commonizing the type_infos.

What if we put the incomplete flag in type_info and decide that all
incomplete type_infos are "before" all the complete type_infos?

 > Issue 3)

 > 17.4.4.4 prevents an implementation adding member functions to one
 > of the std classes, except in particular circumstance. About the only
 > leeway given is whether a particular non-virtual function is inline or
 > not. So I presume we're not permitted to add virtual member functions
 > to std::type_info (18.5.1). The rules given in 17.4.4.4 specifying what
 > member functions can be added look like applications of the as-if rule,
 > but there must be something deeper going on, as if that was all, it
 > wouldn't be mentioned. I'm not sure how a conforming program could tell
 > whether additional functions had been added.

17.4.4.4 specifies that you can add overloads to member functions in
certain ways that *can* be detected by a conforming program.  There are no
restrictions on adding member functions with other names, by the as-if rule.

 > Issue 4)

 > 5.2.8 talks about typeid returning something derived from type_info,
 > but the footnote mentioning extended_type_info implies to me that
 > typeid always returns objects of the same type. Again, I'm not sure
 > how a conforming program could tell.

I disagree with your interpretation.

Jason



From loewis at informatik.hu-berlin.de  Thu Apr 13 18:12:32 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 13 Apr 2000 20:12:32 +0200
Subject: mangling example
In-Reply-To: <200004080400.VAA48649@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200004080400.VAA48649@baalbek.engr.sgi.com>
Message-ID: <200004131812.UAA14560@pandora>

> You raise another issue.  I believe that our intent was that
> the candidates at this point include:
> 
>   S_	void
>   S0_	first<Duo>
>   S1_	Duo
>   S2_	first
> 
> But I don't see the substitution of first in the grammar.
> Is this what the others had in mind, too?

It would be certainly desirably to have first as a candidate as well.

Regards,
Marting



From loewis at informatik.hu-berlin.de  Thu Apr 13 18:13:26 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 13 Apr 2000 20:13:26 +0200
Subject: CV qualifier and substitutions
In-Reply-To: <200004080503.WAA48738@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200004080503.WAA48738@baalbek.engr.sgi.com>
Message-ID: <200004131813.UAA14564@pandora>

> So, to restate Alain's note, the issue is this:
> 
> - The current definition treats the intermediately-qualified types to
>   be substituted, maximizing substitutability in some sense.
> 
> - But some implementations don't maintain internal symbol table entries
>   for the intermediate types.  So this probably violates our principle
>   of only mangling things with a convenient symbol table handle, for
>   those implementations at least.
> 
> Should we eliminate substitution for the intermediates, losing some
> opportunities but maybe easing some implementations?
> 
> Can we get people's reactions to this issue?

The savings of recycling a partially-qualified type are minimal, so
I agree this is a good idea.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Apr 13 18:17:27 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 13 Apr 2000 20:17:27 +0200
Subject: Agenda for 13 April
In-Reply-To: <200004130033.RAA61482@baalbek.engr.sgi.com>
	(dehnert@baalbek.engr.sgi.com)
References: <200004130033.RAA61482@baalbek.engr.sgi.com>
Message-ID: <200004131817.UAA14583@pandora>

>      Matt gave him another set of names to try -- any luck?

Not yet, no. I'll look into that RSN; I'll have to catch up with the
latest spec, first.

Regards,
Martin



From loewis at informatik.hu-berlin.de  Thu Apr 13 18:33:38 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Thu, 13 Apr 2000 20:33:38 +0200
Subject: Vague linkage
Message-ID: <200004131833.UAA14662@pandora>

The vague linkage proposal suggests to emit the default constructor
together with virtual table. I believe this does not work.

The standard says that a default constructor is implicitly defined
only if it is used, and that definition of that constructor may cause
an error in the program (e.g. because one of the member constructors
is not public). So when we emit the virtual table group, we'd also
need to define the default constructor, which may give an error - even
though the program is correct.

Regards,
Martin




From jason at cygnus.com  Thu Apr 13 20:05:33 2000
From: jason at cygnus.com (Jason Merrill)
Date: 13 Apr 2000 13:05:33 -0700
Subject: More rtti woes
In-Reply-To: Jason Merrill's message of "13 Apr 2000 10:19:54 -0700"
References: <38F2E001.B1173F20@codesourcery.com> <u9k8i1q5ol.fsf@yorick.cygnus.com>
Message-ID: <u9bt3dpy0i.fsf@yorick.cygnus.com>

>>>>> Jason Merrill <jason at cygnus.com> writes:

 >> The presence of such a ptr to member, will mean that it, and all
 >> pointers to it will have their incomplete flag set, but its target
 >> might not be an incomplete chain. In implementing G++'s rtti runtime I
 >> found the following three flags useful, (this is with
 >> __pointer_to_member_type_info derived from __pointer_type_info)

 > I don't think it's proper to make that derivation; a pointer to member is
 > not a pointer.  This matters to the EH type matching code, which does a
 > dynamic_cast to _pti*.

It was suggested in the meeting today that both _pti and _ptmti be derived
from a common base instead; this makes sense to me.

 >> Issue 2)

 >> The algorithm for collation order of type_infos, cannot simply compare
 >> addresses for non-pointer types, and complete pointer types.  Using
 >> string collation only when one of the types is a pointer with the
 >> incomplete_mask set. There are two difficulties. Firstly, we might be
 >> comparing a non-pointer type_info with a pointer type_info. We need to
 >> determine this and DTRT WRT the incomplete flag of the pointer
 >> type_info. to do that will require dynamic_cast or typeid'ing the
 >> type_infos. Secondly, assume we are just comparing pointer type_info's.
 >> We have two pointers to complete, Aptr and Bptr, and a third pointer to
 >> incomplete, Cptr.

 >> 1) Aptr.before (Bptr) can just compare addresses.
 >> 2) Bptr.before (Cptr) will compare names.
 >> 3) Cptr.before (Aptr) will compare names.

 >> There is nothing maintaining the consistency of the results of these
 >> three tests -- result 1 is uncorrelated with results 2 & 3....
 >> Therefore type_info::before must be implemented as string compare on the
 >> type's names. We lose any advantage of commonizing the type_infos.

 > What if we put the incomplete flag in type_info and decide that all
 > incomplete type_infos are "before" all the complete type_infos?

Never mind; this won't work, of course.  In the meeting we liked your
proposal B, and deferred a decision on A.  Thinking about it now, I'd
prefer to just go with B; splitting up the type_infos seems unnecessary.

Jason



From jason at cygnus.com  Thu Apr 13 20:05:33 2000
From: jason at cygnus.com (Jason Merrill)
Date: 13 Apr 2000 13:05:33 -0700
Subject: More rtti woes
In-Reply-To: Jason Merrill's message of "13 Apr 2000 10:19:54 -0700"
References: <38F2E001.B1173F20@codesourcery.com> <u9k8i1q5ol.fsf@yorick.cygnus.com>
Message-ID: <u9bt3dpy0i.fsf@yorick.cygnus.com>

>>>>> Jason Merrill <jason at cygnus.com> writes:

 >> The presence of such a ptr to member, will mean that it, and all
 >> pointers to it will have their incomplete flag set, but its target
 >> might not be an incomplete chain. In implementing G++'s rtti runtime I
 >> found the following three flags useful, (this is with
 >> __pointer_to_member_type_info derived from __pointer_type_info)

 > I don't think it's proper to make that derivation; a pointer to member is
 > not a pointer.  This matters to the EH type matching code, which does a
 > dynamic_cast to _pti*.

It was suggested in the meeting today that both _pti and _ptmti be derived
from a common base instead; this makes sense to me.

 >> Issue 2)

 >> The algorithm for collation order of type_infos, cannot simply compare
 >> addresses for non-pointer types, and complete pointer types.  Using
 >> string collation only when one of the types is a pointer with the
 >> incomplete_mask set. There are two difficulties. Firstly, we might be
 >> comparing a non-pointer type_info with a pointer type_info. We need to
 >> determine this and DTRT WRT the incomplete flag of the pointer
 >> type_info. to do that will require dynamic_cast or typeid'ing the
 >> type_infos. Secondly, assume we are just comparing pointer type_info's.
 >> We have two pointers to complete, Aptr and Bptr, and a third pointer to
 >> incomplete, Cptr.

 >> 1) Aptr.before (Bptr) can just compare addresses.
 >> 2) Bptr.before (Cptr) will compare names.
 >> 3) Cptr.before (Aptr) will compare names.

 >> There is nothing maintaining the consistency of the results of these
 >> three tests -- result 1 is uncorrelated with results 2 & 3....
 >> Therefore type_info::before must be implemented as string compare on the
 >> type's names. We lose any advantage of commonizing the type_infos.

 > What if we put the incomplete flag in type_info and decide that all
 > incomplete type_infos are "before" all the complete type_infos?

Never mind; this won't work, of course.  In the meeting we liked your
proposal B, and deferred a decision on A.  Thinking about it now, I'd
prefer to just go with B; splitting up the type_infos seems unnecessary.

Jason



From alainm at cup.hp.com  Thu Apr 13 22:02:19 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Thu, 13 Apr 2000 15:02:19 -0700
Subject: mangling example
References: <200004080400.VAA48649@baalbek.engr.sgi.com> <200004131812.UAA14560@pandora>
Message-ID: <38F643EB.ABE1F386@cup.hp.com>

Martin von Loewis wrote:
> 
> > You raise another issue.  I believe that our intent was that
> > the candidates at this point include:
> >
> >   S_  void
> >   S0_ first<Duo>
> >   S1_ Duo
> >   S2_ first
> >
> > But I don't see the substitution of first in the grammar.
> > Is this what the others had in mind, too?

The following example seems to indicate that the intent was to allow
the substitution for "first" too (from "compression"):

   "S_" == N::T<int, int>::mf
   "S0_" == N::T<int, int>
   "S1_" == int
   "S2_" == N::T (template is less recent than template-id)
   "S3_" == N (qualifier is less recent than qualified entity)
 
> It would be certainly desirably to have first as a candidate as well.

Yes, basicaly, if we have an instantiated name, it would be desirable
to have the name, then the name+<template args> as candidates.
But the surrent grammar factorise <template-args> on unqualified name 
and class name (in order to have a more compact representation ?), 
which prohibit these substitution, if we have the name:

N1<T1>::N2<T2>

we have the candidates:

N1<T1>
N1<T1>::N2<T2>

instead of 

N1
N1<T1>
N1<T1>::N2
N1<T1>::N2<T2>

I think the following modification fix the problem (the grammar is a 
little bit permissive, but this is probably not an issue):
  
    <name> ::= <nested-name>
           ::= <unqualified-name>
           ::= <unqualified-name><template-args>
           ::= <local-name>     # See Scope Encoding below
           ::= <substitution> # See Compression below

    <nested-name> ::= N <qualified-name> E
    <qualified-name> ::= <method-name>
                     ::= <compound-name>
                     ::= <substitution>

// unrelated issue, but since CV only apply to method...:
    <method-name>    ::= <CV-qualifier>+<compound-name>

    <compound-name> ::= <compound-base-name><template-args>
                    ::= <compound-base-name>
                    ::= <substitution>

    <compound-base-name> ::= <nesting-preffix><unqualified-name>
                         ::= <substitution>

    <nesting-prefix> ::= <nesting-prefix><component>
                     ::= <component>
                     ::= <substitution>

    <component> ::= <source-name>
                ::= <template-args>

    <unqualified-name>::=<source-name>
                      ::=<operator-name>
                      ::=<special-name>

Any comment ?

Alain



From samuel at codesourcery.com  Fri Apr 14 00:47:21 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Thu, 13 Apr 2000 17:47:21 -0700 (PDT)
Subject: bug in mangling example?
Message-ID: <14582.27289.456806.908910@coriander.indetermi.net>

The 13th mangling example, 

    _Z3fooIiPFidEiEv

is supposed to encode

    void foo<int,int(*)(double),int>()

The standard states,

    "Empty parameter lists, whether declared as () or conventionally
    as (void), are encoded with a void parameter specifier (v)."

so I believe the mangled form should have an extra `v' at the end.
The first encodes its return type (it being a template function), and
the second encodes its empty parameter list.

BTW is there a plan at some point to number sections and subsections
of the ABI standard?

Regards,
Alex Samuel



From dehnert at sgi.com  Fri Apr 14 00:51:44 2000
From: dehnert at sgi.com (Jim Dehnert)
Date: Thu, 13 Apr 2000 17:51:44 -0700
Subject: mangling enum literals
References: <14580.46438.87690.890669@coriander.indetermi.net> <38F4B8FA.C6806532@edg.com>
Message-ID: <38F66BA0.DBE46872@sgi.com>

This is what we decided to do today, along with the name of the enumerated
type.

Jim

Daveed Vandevoorde wrote:
> 
> Alex Samuel wrote:
> >
> > The paragraph discussing literal template arguments doesn't mention
> > enumeral values.  Do we use the value's <source-name>, or numerical
> > representation in the underlying type?
> 
> I think you need to use the numerical value, because some valid enum
> values may not have a name.



From dehnert at baalbek.engr.sgi.com  Fri Apr 14 02:29:23 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Thu, 13 Apr 2000 19:29:23 -0700 (PDT)
Subject: bug in mangling example?
Message-ID: <200004140229.TAA66313@baalbek.engr.sgi.com>

> Date: Thu, 13 Apr 2000 17:47:21 -0700 (PDT)
> From: Alex Samuel <samuel at codesourcery.com>
> 
> The 13th mangling example, 
> 
>     _Z3fooIiPFidEiEv
> 
> is supposed to encode
> 
>     void foo<int,int(*)(double),int>()
> 
> The standard states,
> 
>     "Empty parameter lists, whether declared as () or conventionally
>     as (void), are encoded with a void parameter specifier (v)."
> 
> so I believe the mangled form should have an extra `v' at the end.
> The first encodes its return type (it being a template function), and
> the second encodes its empty parameter list.

I think so, and have changed it (not on the web yet).  Does anyone
believe that wasn't intended?  The reason for including the 'v' was to
eliminate ambiguity with data, but it isn't necessary for that purpose
when the return type is encoded.

> BTW is there a plan at some point to number sections and subsections
> of the ABI standard?

Plan?  No.  Comtemplation?  Yes.  I've also considered Standard-style
naming.  But so far I'm too lazy...

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Fri Apr 14 06:21:03 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 13 Apr 2000 23:21:03 -0700
Subject: mangling enum literals
In-Reply-To: <38F66BA0.DBE46872@sgi.com>
References: <14580.46438.87690.890669@coriander.indetermi.net>
	<38F4B8FA.C6806532@edg.com>
	<38F66BA0.DBE46872@sgi.com>
Message-ID: <20000413232103B.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at sgi.com> writes:

    Jim> This is what we decided to do today, along with the name of
    Jim> the enumerated type.

Jim --

  Thanks for replying to these emails with the meeting results.  None
of us could make the meeting today (another meeting instead!), so it's
very helpful to get Jason's and your replies.

  Thanks!

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From mark at codesourcery.com  Fri Apr 14 06:36:20 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Thu, 13 Apr 2000 23:36:20 -0700
Subject: Vcall offsets
Message-ID: <20000413233620Z.mitchell@codesourcery.com>


We have:

  [T]he vtable for a virtual base A also includes a vcall offset entry
  for each virtual function represented in A's primary vtable and the
  secondary vtables from A's non-virtual bases.  The vcall offset
  entries are allocated from the inside out, in the the same order as
  the functions appear in A's vtables.

Now consider this hierarchy:

    struct A {
      int i;
      virtual void f ();
    };

    struct B {
      int j;
      virtual void g ();
      virtual void h ();
    };

    struct C : public A, public B {
      virtual void g ();
    };

Assume that C is being used as a virtual base.  The question is what
vcall offsets are present in C and in what order.  Note that A is the
primary base of C.

One reading of the paragraph quoted above could lead one to conclude
that C contains 4 vcall offsets:

  o One for `A::f' - A::f appears in C's primary vtable
  o One for `B::g' - B::g appears in the secondary vtable for B
  o One for `B::h' - B::h appears in the secondary vtable for B
  o One for `B::g' - B::g appears in C's primary vtable

I think we should make clear that the last one is not required.  Even
though the vtable entry for B::g is replicated, there's no reason to
replicate the vcall offset.

On to the order of the three remaining entries.  The A::f entry must
go closest to the vptr, since A is a primary base.  (It would actually
work, here, without that consideration since A is not a primary
*virtual* base, but the current document doesn't distinguish these
cases and there's no reason why it should.)  Is the final order:

  B::g
  B::h
  A::f
  
or:

  B::h
  B::g
  A::f

?  "From the inside out" isn't too helpful.  I don't think this
matters at all -- except we have to decide.  I like the second order
better, I think.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From nathan at codesourcery.com  Fri Apr 14 09:12:50 2000
From: nathan at codesourcery.com (Nathan Sidwell)
Date: Fri, 14 Apr 2000 10:12:50 +0100
Subject: More rtti woes
References: <38F2E001.B1173F20@codesourcery.com> <u9k8i1q5ol.fsf@yorick.cygnus.com>
Message-ID: <38F6E112.F6100A43@codesourcery.com>

Jason Merrill wrote:
[I've combined stuff from both your emails]

>  > The presence of such a ptr to member, will mean that it, and all
>  > pointers to it will have their incomplete flag set, but its target
>  > might not be an incomplete chain. In implementing G++'s rtti runtime I
>  > found the following three flags useful, (this is with
>  > __pointer_to_member_type_info derived from __pointer_type_info)
> 
> I don't think it's proper to make that derivation; a pointer to member is
> not a pointer.  This matters to the EH type matching code, which does a
> dynamic_cast to _pti*.
I presume you're refering to g++'s runtime. The only dynamic_casts of
this kind are in g++'s old-abi catch matcher. The new-abi doesn't need
any, using virtual functions. Or were you thinking of somewhere else?
Where the old-abi has dynamic casts, the new abi code has.
   catch_type->do_catch (...)
&
   thrown_type->is_pointer_p ()

> It was suggested in the meeting today that both _pti and _ptmti be derived
> from a common base instead; this makes sense to me.
I do not think this is necessary, but I've no strong feeling about it.
Having a common base adds complexity (bad), but not having it constrains
implementations to use vfuncs rather than dynamic_cast (possibly bad).

> 17.4.4.4 specifies that you can add overloads to member functions in
> certain ways that *can* be detected by a conforming program.  There are no
> restrictions on adding member functions with other names, by the as-if rule.
Doh! you're right a conforming program could tell by (attempting to)
take the function's address.

> Never mind; this won't work, of course.  In the meeting we liked your
> proposal B, and deferred a decision on A.  Thinking about it now, I'd
> prefer to just go with B; splitting up the type_infos seems unnecessary.
I have come to this conclusion too.

nathan

-- 
Dr Nathan Sidwell   ::   http://www.codesourcery.com   ::   CodeSourcery LLC
         'But that's a lie.' - 'Yes it is. What's your point?'
nathan at codesourcery.com : http://www.cs.bris.ac.uk/~nathan/ : nathan at acm.org



From alainm at cup.hp.com  Sat Apr 15 00:36:10 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 14 Apr 2000 17:36:10 -0700
Subject: another mangling issue
Message-ID: <38F7B97A.43DE63E0@cup.hp.com>


Here is the text:

[ description of the numbering ]
All substitutable components are so numbered, except 
those that have been substituted already, but the 
substitution occurs only if "S<seq-id>_" (or "S_") 
is strictly shorter than the unsubstituted encoding.
A component is less recent than the structure of which 
it is a part. For example: 

   "_ZN1N1TIiiE2mfES2_IddE": Ret? N::T<int, int>::mf(N::T<double,
double>)

since at the point where S2_ appears: 

   "S_" == N::T<int, int>::mf
   "S0_" == N::T<int, int>
   "S1_" == int
   "S2_" == N::T (template is less recent than template-id)
   "S3_" == N (qualifier is less recent than qualified entity)


	1) why does "int" appears only once ? since the second one is 
not a substituted (its direct encoding being shorter than the 
substitution), I would expect:
   "S_" == N::T<int, int>::mf
   "S0_" == N::T<int, int>
   "S1_" == int
   "S2_" == int
   "S3_" == N::T (template is less recent than template-id)
   "S4_" == N (qualifier is less recent than qualified entity)

or is it that, since the first "int" is a "potential" source 
for substitution, the second one is not ? ifthat's the case,
maybe  "except those that have been substituted already"
should be replace with sometyhing like "except those that
are been seen as substituable already" ?
 
Alain



From dehnert at baalbek.engr.sgi.com  Sat Apr 15 00:59:52 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 14 Apr 2000 17:59:52 -0700 (PDT)
Subject: Updates from meeting/email
Message-ID: <200004150059.RAA67808@baalbek.engr.sgi.com>

I've updated the documents for most of the important meeting results.
There are comments yet to go into the open issues, and I haven't dealt
with pointer RTTI yet.  (All this HTML only.)

I'd like to call your attention to the mangling of nested names.  I
despaired of making the substitution rules clear without either being
far too permissive about the structure or being so baroque that nothing
was clear.  So I made two grammar fragments, one to show the structure,
and another to indicate what is substitutable.  Please take a look,
especially those who've been struggling with the lack of clarity,
and let me know what you think.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Sat Apr 15 01:32:42 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 14 Apr 2000 18:32:42 -0700 (PDT)
Subject: another mangling issue
Message-ID: <200004150132.SAA67114@baalbek.engr.sgi.com>

> Date: Fri, 14 Apr 2000 17:36:10 -0700
> From: Alain Miniussi <alainm at cup.hp.com>
> 
> Here is the text:
> 
> [ description of the numbering ]
> All substitutable components are so numbered,
==================================================
> except  those that have been substituted already,
==================================================
> but the  substitution occurs only if "S<seq-id>_" (or "S_") 
> is strictly shorter than the unsubstituted encoding.
> A component is less recent than the structure of which 
> it is a part. For example: 
> 
>    "_ZN1N1TIiiE2mfES2_IddE": Ret? N::T<int, int>::mf(N::T<double,
> double>)
> 
> since at the point where S2_ appears: 
> 
>    "S_" == N::T<int, int>::mf
>    "S0_" == N::T<int, int>
>    "S1_" == int
>    "S2_" == N::T (template is less recent than template-id)
>    "S3_" == N (qualifier is less recent than qualified entity)
> 
> 
> 	1) why does "int" appears only once ?

The answer is the highlighted clause above.  We decided a couple of
weeks ago not to add the same type/name to the list multiple times.
So int (and everything else) only appears once.

> since the second one is 
> not a substituted (its direct encoding being shorter than the 
> substitution), I would expect:
>    "S_" == N::T<int, int>::mf
>    "S0_" == N::T<int, int>
>    "S1_" == int
>    "S2_" == int
>    "S3_" == N::T (template is less recent than template-id)
>    "S4_" == N (qualifier is less recent than qualified entity)
> 
> or is it that, since the first "int" is a "potential" source 
> for substitution, the second one is not ? ifthat's the case,
> maybe  "except those that have been substituted already"
> should be replace with sometyhing like "except those that
> are been seen as substituable already" ?

Yes, I'll do that.

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From coleen at zko.dec.com  Mon Apr 17 18:18:04 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 17 Apr 2000 14:18:04 -0400
Subject: Proposal for mangling template partial specializations.
Message-ID: <200004171818.AA03966@philli.zko.dec.com>

/*
I propose that partial specializations should be mangled differently than
template instantiations.  The reasons:

 1) It's the standard.  14.5.4 pp 3:

 -3- Each class template partial specialization is a distinct template
     and definitions shall be provided for the members of a
     template partial specialization (temp.class.spec.mfunc). 

     Note that the end of paragraph 1 in this section says "no diagnostic is
     required", but does that mean if a template instantiation can be linked
     instead of a specialization and not violate the standard?  Or does that
     only mean that the compiler/linker is not required to diagnose the error
     and can call the wrong version of the function?

 2)  Since this is a new ABI, users must recompile.
     The correction to this problem is a source line change to declare
     the specialization.  We should strive to be 100% standard-compliant
     with the new ABI, especially with a case we can diagnose.  Users
     should expect the new ABI to be 100% compliant as well.

The argument against making partial instantiations link incompatible with
is that users may depend on linking in the template instantiation when
the definition of partial instantiation is not available.  Two points:

 1) With the COMDAT model, if the partial instantiation is available in one
    compilation unit and the template instantiation comes from another -
    which will be picked?  Isn't this really bad?

 2) As a data point, DEC/Compaq changed the mangling for partial
    specializations when using the new syntax (template <>) but kept the
    mangling for them the same when using the old non-standard syntax (omit
    the template <>).  We don't have any entries about it in our database of
    complaints. (We realize more code is written for Sun, HP, g++, etc,
    so you may end up with complaints on code our compiler hasn't seen.)
 
So I propose a mangling qualifier for partial specializations on each template
argument that is specialized (maybe you don't need the 'E'):

    <template-args> ::= I <template-arg>+ E
    <template-arg> ::= <type>                     # type
    <template-arg> ::= D <type> E                 # partially specialize'D'
    <template-arg> ::= L <type> <value number> E  # literal
    <template-arg> ::= LZ <encoding> E            # external name
    <template-arg> ::= X <expression> E           # expression

Coleen
*/

//
// Example of partial specialization [not] linking against template
// instantiation.
// 
// spec.h 
extern "C" int printf(const char *,...);
template <class T> class X { public:
   void f(); // { printf("X<T>::f called\n"); }
};
// spec1.cxx

#include "spec.h"
main()
{
  X<int> t;
  t.f();
}
// spec2.cxx
#include "spec.h"
template <> class X<int> { public:
   void f();
};
template <> void X<int>::f() { printf("X<int>::f();\n"); }

void foo()
{
   X<int> x;
   x.f();
}
//
// EDG/Compaq C++
% exx spec1.cxx spec2.cxx
spec1.cxx:
spec2.cxx:
ld:
Unresolved:
X<int>::f(void)

//
// Sun
33% CC spec1.cxx spec2.cxx
spec1.cxx:
spec2.cxx:
34% a.out
X<int>::f();

// G++
781% g++ spec1.cxx spec2.cxx
782% a.out
X<int>::f();



From mark at codesourcery.com  Mon Apr 17 18:53:11 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 17 Apr 2000 11:53:11 -0700
Subject: Proposal for mangling template partial specializations.
In-Reply-To: <200004171818.AA03966@philli.zko.dec.com>
References: <200004171818.AA03966@philli.zko.dec.com>
Message-ID: <20000417115311J.mitchell@codesourcery.com>


I'm not persuaded that we should mangle specializations and
instantiations differently.  If I understand Colleen's proposal, these
two functions:

  template <class T> void f(T);
  template <> void f<int>(int) {}

and

  template <class T> void f(T) {}
  template void f<int>(int);

(the first a specialization, the second instantiation, would be
mangled separately.)  If I misunderstood, then I apologize, and only
some of it what follows is relevant.

Here are my objections:

  o Real code depends on being able to intermix the two.  In fact,
    this is a historical way of putting instantiations in libraries:
    you declare a specialization, but then provide an explicit
    instantiation in the library.  That prevents clients of the
    library from doing implicit instantiations.

  o I don't think the standard doesn't require a diagnostic.

  o There are other wways of getting a diagnostic, if you want one,
    other than mangling.  In fact, mangling is probably not likely
    to yield useful diagnostics: the message will just be
    "xyz undefined", not "you mixed an instantiation and a
    specialization".  Other mechanisms could be used for that.
    (Analagous here is the ODR: you could mangle into every inline
    function its token sequence, and then check the ODR at link-time.
    But, you'd be better off to store this on the side.)

  o Real implementations are underway.  We have to start taking making
    changes to the draft ABI more seriously.  We're already
    implementing the ABI in two different compilers, and I expect
    others are doing the same.  It's important that we have compilers
    ready as quickly as possible; the chip is almost live, and we
    don't want there to be a substantial installed base of
    non-compliant compilers; that will substantially reduce the
    value of the work this committe has done.  If it ain't broke,
    we really shouldn't be fixing it now.

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From coleen at zko.dec.com  Mon Apr 17 19:45:57 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 17 Apr 2000 15:45:57 -0400
Subject: Construction vtables example.
Message-ID: <38FB69F5.882B8087@zko.dec.com>


For the Construction Vtables section, I have two corrections and comments
on the red parts.

The red part in "VTT Order" #3  - it should be depth first search postorder.
I don't understand the parenthetical remark with respect to "relevant
condition", since you have a secondary vptr if either condition holds (
virtual bases or virtual function overrides).  There's a black 'preorder'
in that paragraph too that should be postorder.

#4 red part looks okay.

In the example, you have 11 entries in the VTT, I think it's because you
moved the virtual function in A2 from A1.  But now A2 shares the virtual
function table with V1 so there's no extra vptr (which I think is what
you were trying to show).  This is the VTT order that I get from finally
instrumenting my compiler to print it out.

primary vtable for class D index 1
  secondary VTT for base C1 index 2
  secondary VTT for base C2 index 3
  secondary VTT for base C2 sub_bcp V1 index 4
  secondary VTT for base C2 sub_bcp V2 index 5
  secondary vptr for base V1 index 6
  secondary vptr for base V2 index 7
  secondary vptr for base C2 index 8  ( postorder!! )
  secondary VTT for base V2 index 9
  secondary VTT for base V2 secondary vptr V1 index 10
                                          (who shares vptr with A2 now)

If you make A2 virtual then you get 14 entries in the VTT.  The
exercise is left to the astute reader.

Coleen
-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From dehnert at baalbek.engr.sgi.com  Mon Apr 17 20:07:40 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Mon, 17 Apr 2000 13:07:40 -0700 (PDT)
Subject: No meeting this week
Message-ID: <200004172007.NAA74138@baalbek.engr.sgi.com>

By the way, for those who missed last week's meeting:

Due to peripatetic committee members (Japan, Florida, Timbuktu),
we will not meet this week (20 April).  If you aren't going somewhere,
use the time to prepare extra well for next week!

Jim
-		Jim Dehnert  x3-4272



From coleen at zko.dec.com  Mon Apr 17 20:39:47 2000
From: coleen at zko.dec.com (Coleen Phillimore)
Date: Mon, 17 Apr 2000 16:39:47 -0400
Subject: Proposal for mangling template partial specializations.
References: <200004171818.AA03966@philli.zko.dec.com> <20000417115311J.mitchell@codesourcery.com>
Message-ID: <38FB7693.1106C0A7@zko.dec.com>

Mark Mitchell wrote:
> 
> I'm not persuaded that we should mangle specializations and
> instantiations differently.  If I understand Colleen's proposal, these
> two functions:
> 
>   template <class T> void f(T);
>   template <> void f<int>(int) {}
> 
> and
> 
>   template <class T> void f(T) {}
>   template void f<int>(int);
> 
> (the first a specialization, the second instantiation, would be
> mangled separately.)  If I misunderstood, then I apologize, and only
> some of it what follows is relevant.

Yes, you understood correctly.

> 
> Here are my objections:
> 
>   o Real code depends on being able to intermix the two.  In fact,
>     this is a historical way of putting instantiations in libraries:
>     you declare a specialization, but then provide an explicit
>     instantiation in the library.  That prevents clients of the
>     library from doing implicit instantiations.

We have a #pragma do_not_instantiate which we use for that purpose.
Supporting pre-instantiation libraries is very important to us as well.
Unfortunately, other than a pragma, there doesn't seem to be a cleaner
way to do this.

> 
>   o I don't think the standard doesn't require a diagnostic.

No, it doesn't.  But does the standard prohibit linking a specialization when
an instantiation is required?  Is this something that Perennial can write a
test for?

> 
>   o There are other wways of getting a diagnostic, if you want one,
>     other than mangling.  In fact, mangling is probably not likely
>     to yield useful diagnostics: the message will just be
>     "xyz undefined", not "you mixed an instantiation and a
>     specialization".  Other mechanisms could be used for that.
>     (Analagous here is the ODR: you could mangle into every inline
>     function its token sequence, and then check the ODR at link-time.
>     But, you'd be better off to store this on the side.)
> 
>   o Real implementations are underway.  We have to start taking making
>     changes to the draft ABI more seriously.  We're already
>     implementing the ABI in two different compilers, and I expect
>     others are doing the same.  It's important that we have compilers
>     ready as quickly as possible; the chip is almost live, and we
>     don't want there to be a substantial installed base of
>     non-compliant compilers; that will substantially reduce the
>     value of the work this committe has done.  If it ain't broke,
>     we really shouldn't be fixing it now.

>From my perspective, it is broke.  It prevents conforming implementations
from being ABI complaint.  Unlike this ABI, the C++ standard has been
voted in and has "shipped".  If different implementations choose to implement
the C++ language differently (that implementations can see), there's a
bigger effort wasted.

Coleen
> 
> --
> Mark Mitchell                   mark at codesourcery.com
> CodeSourcery, LLC               http://www.codesourcery.com

-- 
-----------------------------------------------------------------------
Coleen Phillimore                  | mailto:coleen at zko.dec.com
Compaq Computer Corp.   Nashua, NH | COMPAQ C++ Compiler Development
-----------------------------------------------------------------------



From mark at codesourcery.com  Mon Apr 17 21:02:26 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Mon, 17 Apr 2000 14:02:26 -0700
Subject: Proposal for mangling template partial specializations.
In-Reply-To: <38FB7693.1106C0A7@zko.dec.com>
References: <200004171818.AA03966@philli.zko.dec.com>
	<20000417115311J.mitchell@codesourcery.com>
	<38FB7693.1106C0A7@zko.dec.com>
Message-ID: <20000417140226K.mitchell@codesourcery.com>

>>>>> "Coleen" == Coleen Phillimore <coleen at zko.dec.com> writes:

    Coleen> We have a #pragma do_not_instantiate which we use for that
    Coleen> purpose.  Supporting pre-instantiation libraries is very
    Coleen> important to us as well.  Unfortunately, other than a
    Coleen> pragma, there doesn't seem to be a cleaner way to do this.

My point is that a sizable existing body of code does this using the
specializatoin/instantiation trick.  I'll not argue that it's cleaner,
but it is important to take existing practice into account.

    >>  o I don't think the standard doesn't require a diagnostic.

    Coleen> No, it doesn't.  But does the standard prohibit linking a
    Coleen> specialization when an instantiation is required?  Is this
    Coleen> something that Perennial can write a test for?

I don't think the standard says anything.  It just says "undefined
behavior, no diangostic required", I think.  That means
implementations can do what they want.  Perennial can certainly write
a test -- but it's a quality-of-implementation issue, and not even one
where it's clear to me which implementation has a higher quality!

    >> From my perspective, it is broke.  It prevents conforming
    >> implementations from being ABI complaint.

I don't understand that sentence.  Can you explain why no conforming
implementation can mangle a specialization and an instantiation in the
same way?

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From jfw at sgi.com  Tue Apr 18 19:03:17 2000
From: jfw at sgi.com (John Wilkinson)
Date: Tue, 18 Apr 2000 12:03:17 -0700
Subject: Proposal for mangling template partial specializations.
References: <200004171818.AA03966@philli.zko.dec.com>
Message-ID: <38FCB175.60A7749B@sgi.com>


-- 
John Wilkinson
-------------- next part --------------
I have come to the somewhat reluctant conclusion that attempting
to diagnose this kind of error through name-mangling would be a mistake.
If other ways can be found, I think they should probably be left to
individual implementations and not made part of the ABI (but I am less
committed to this point:  I have not, however, thought of any promising
approach to this).

(1)  If the standard requires no diagnostic for a violation of the rules,
then certainly  a standard-conforming implementation is permitted to
link and execute the program.  (1.4, Paragraph 2).  So this is a
quality-of-implementation issue, not a standard-conformance issue.

(2)  As Mark points out, if we use mangling to distinguish
specializations from instantiations, the resulting diagnostics may
be hard to interpret.  I regard this as less important, however, than

(3)  Providing distinct manglings may just allow definitions to coexist
that are  forbidden from doing so.   So it doesn't solve the problem
of providing a diagnostic for this error; it only does so for one
flavor of the error.

(4)  The specific mangling scheme that Colleen proposes does not
distinguish all the necessary variants.  Consider the declarations

   template <class T> struct X     {void foo();};

   template <class T> struct X<T*> {void foo();};

   template <> struct X<int*>      {void foo();};

A program that declares

  X<int*> x;

and invokes x.foo()

will thereby reference a function with the signature

  void X<int*>::foo(void).

Three different functions can be invoked, depending on whether the
program includes just the first declaration, just the first and second, or
the first and third (with or without the second).  Colleen's mangling
scheme clearly distinguishes the first and third cases, but for the
second case is forced to pick one of the other two manglings.  It
cannot distinguish all three.

From alainm at cup.hp.com  Tue Apr 18 19:16:38 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Tue, 18 Apr 2000 12:16:38 -0700
Subject: substitutions
Message-ID: <38FCB496.9BC6CCB2@cup.hp.com>


Suppose that we need to encode the following 

C1::C2
C1::C3::C4
C1::C3::C5

in a name, we'll get :

N2C12C2E .... NS<n1>_2C32C4E  NS<n2>_2C5E ......

The problem:

We accept the substitution only if the size of the encoded 
substitution is strictly smaller than the size of the
substituted entity.

Now, let's say that S<n2>_ is longuer than S<n1>_2C3, what should
we do ? 
Clearly, we can't write NS<n1>_2C3 instead of S<n2>_ because
n1 does not reffers to the same entity at that point. If we are
ready to replace n1 with it's updated value n1+delta, the rule
and the implementation becomes more complicated (imagine that 
we have something more complex than S<n1>_2C3, with some 
substitued template args and so on...).

Now, the typical size of a substitution will be 3, encoded source 
names are at least 2 char long (and I don't think it's the typical 
size).
So the only "real world" (but every one has it's own, so...) 
waste of space of more than 1 char/substitution I can think of 
involve builtin type. What about supressing the "smaller size" 
rule and saying that builtin types can't be source of further 
substitution ?

Alain



From dehnert at baalbek.engr.sgi.com  Tue Apr 18 21:09:12 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Apr 2000 14:09:12 -0700 (PDT)
Subject: substitutions
Message-ID: <200004182109.OAA77360@baalbek.engr.sgi.com>

I'll take a shot at this, but please correct me if I get it wrong.

> From: Alain Miniussi <alainm at cup.hp.com>
> 
> Suppose that we need to encode the following 
> 
> C1::C2
> C1::C3::C4
> C1::C3::C5
> 
> in a name, we'll get :
> 
> N2C12C2E .... NS<n1>_2C32C4E  NS<n2>_2C5E ......

So, the substitution dictionary that gets built up is:

C1
C1::C2
...
C1::C3
C1::C3::C4
...
C1::C3::C6

Assuming nothing in the ellipses, these are, at the point of the last
one:
  S2_
  S1_
  S0_
  S_

> The problem:
> 
> We accept the substitution only if the size of the encoded 
> substitution is strictly smaller than the size of the
> substituted entity.
> 
> Now, let's say that S<n2>_ is longuer than S<n1>_2C3, what should
> we do ? 

Ah, I think I see your problem.  The entity that we're considering for
substitution is 2C12C3, _not_ S<n1>_2C3.  Earlier substitutions don't
come into play.

> Clearly, we can't write NS<n1>_2C3 instead of S<n2>_ because
> n1 does not reffers to the same entity at that point.

Right.  Our choices at this point are (with the above numbering)
2C12C3 (no substitution), S2_2C3 (substitute for C1), or S0_
(substitute for C1::C3).  We wouldn't choose the second because it's
not shorter, and would choose the third unless <n> were > 3 digits.

> If we are
> ready to replace n1 with it's updated value n1+delta, the rule
> and the implementation becomes more complicated (imagine that 
> we have something more complex than S<n1>_2C3, with some 
> substitued template args and so on...).

I don't think this is true if you recognize that you're not
substituting for already-substituted strings.  Do you?

> Now, the typical size of a substitution will be 3, encoded source 
> names are at least 2 char long (and I don't think it's the typical 
> size).
> So the only "real world" (but every one has it's own, so...) 
> waste of space of more than 1 char/substitution I can think of 
> involve builtin type. What about supressing the "smaller size" 
> rule and saying that builtin types can't be source of further 
> substitution ?

I don't feel strongly about this.  Does anyone else?

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Apr 18 21:51:35 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Apr 2000 14:51:35 -0700 (PDT)
Subject: Vcall offsets
Message-ID: <200004182151.OAA77828@baalbek.engr.sgi.com>

Once again, I'll take a shot at this one, but please correct my
misconceptions.

> From: Mark Mitchell <mark at codesourcery.com>
> 
> We have:
> 
>   [T]he vtable for a virtual base A also includes a vcall offset entry
>   for each virtual function represented in A's primary vtable and the
>   secondary vtables from A's non-virtual bases.  The vcall offset
>   entries are allocated from the inside out, in the the same order as
>   the functions appear in A's vtables.
> 
> Now consider this hierarchy:
> 
>     struct A {
>       int i;
>       virtual void f ();
>     };
> 
>     struct B {
>       int j;
>       virtual void g ();
>       virtual void h ();
>     };
> 
>     struct C : public A, public B {
>       virtual void g ();
>     };
> 
> Assume that C is being used as a virtual base.  The question is what
> vcall offsets are present in C and in what order.  Note that A is the
> primary base of C.
> 
> One reading of the paragraph quoted above could lead one to conclude
> that C contains 4 vcall offsets:
> 
>   o One for `A::f' - A::f appears in C's primary vtable
>   o One for `B::g' - B::g appears in the secondary vtable for B
>   o One for `B::h' - B::h appears in the secondary vtable for B
>   o One for `B::g' - B::g appears in C's primary vtable
> 
> I think we should make clear that the last one is not required.  Even
> though the vtable entry for B::g is replicated, there's no reason to
> replicate the vcall offset.

I agree with your objective, but would come to a different interpretation.
I would state the rule for what's included as follows:

 1) First, whatever's required by the primary base class.

 2) Next, anything additional (not overrides of the primary base) from
    the class being laid out.

 3) Finally, anything additional from the base classes, in declaration
    preorder for the bases, declaration order for the functions within
    the bases.

So, I think we need a vcall offset for C::g (2) but not for B::g (3).
Not a functional difference, but it affects the ordering.

> On to the order of the three remaining entries.  The A::f entry must
> go closest to the vptr, since A is a primary base.  (It would actually
> work, here, without that consideration since A is not a primary
> *virtual* base, but the current document doesn't distinguish these
> cases and there's no reason why it should.)  Is the final order:
> 
>   B::g
>   B::h
>   A::f
>   
> or:
> 
>   B::h
>   B::g
>   A::f
> 
> ?  "From the inside out" isn't too helpful.  I don't think this
> matters at all -- except we have to decide.  I like the second order
> better, I think.

So, applying the above rule, I would get (with the rule number in
parentheses):

	B::h  (3)
	C::g  (2)
	A::f  (1)

I'll try to clarify this rule (or whatever other concensus emerges) in
the document.  Please comment if this doesn't match your understanding.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Tue Apr 18 22:12:42 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 18 Apr 2000 15:12:42 -0700
Subject: Vcall offsets
In-Reply-To: <200004182151.OAA77828@baalbek.engr.sgi.com>
References: <200004182151.OAA77828@baalbek.engr.sgi.com>
Message-ID: <20000418151242E.mitchell@codesourcery.com>


  Once again, I'll take a shot at this one, but please correct my
  misconceptions.

Thanks.

  I agree with your objective, but would come to a different interpretation.
  I would state the rule for what's included as follows:

   1) First, whatever's required by the primary base class.

   2) Next, anything additional (not overrides of the primary base) from
      the class being laid out.

   3) Finally, anything additional from the base classes, in declaration
      preorder for the bases, declaration order for the functions within
      the bases.

  So, I think we need a vcall offset for C::g (2) but not for B::g (3).
  Not a functional difference, but it affects the ordering.

I have no objection to the order you suggest.

  So, applying the above rule, I would get (with the rule number in
  parentheses):

	  B::h  (3)
	  C::g  (2)
	  A::f  (1)

I was actually trying to clarify something different here.  If `f'
appears before `g' in the class declaration, does the vcall offset for
`f' appear before, or after, `g' in the vtable layout?  (Assuming
neither is overridden, so we don't get the complications being
discussed above.)

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From alainm at cup.hp.com  Tue Apr 18 22:11:38 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Tue, 18 Apr 2000 15:11:38 -0700
Subject: substitutions
References: <200004182109.OAA77360@baalbek.engr.sgi.com>
Message-ID: <38FCDD9A.BB2E9503@cup.hp.com>

Jim Dehnert wrote:
> 
> I'll take a shot at this, but please correct me if I get it wrong.
> 
> > From: Alain Miniussi <alainm at cup.hp.com>
> >
> > Suppose that we need to encode the following
> >
> > C1::C2
> > C1::C3::C4
> > C1::C3::C5
> >
> > in a name, we'll get :
> >
> > N2C12C2E .... NS<n1>_2C32C4E  NS<n2>_2C5E ......
> 
> So, the substitution dictionary that gets built up is:
> 
> C1
> C1::C2
> ...
> C1::C3
> C1::C3::C4
> ...
> C1::C3::C6

Yes, except that the corresponding string in the encoding are:

C1       ->   2C1
C1::C2   ->   2C12C2
...
C1::C3   ->   S<c1n>_2C3
C1::C3::C4 -> S<c1n>_2C32C4
...
C1::C3::C5 -> ????2C5

> Assuming nothing in the ellipses, these are, at the point of the last
> one:
>   S2_
>   S1_
>   S0_
>   S_
> 
> > The problem:
> >
> > We accept the substitution only if the size of the encoded
> > substitution is strictly smaller than the size of the
> > substituted entity.
> >
> > Now, let's say that S<n2>_ is longuer than S<n1>_2C3, what should
> > we do ?
> 
> Ah, I think I see your problem.  The entity that we're considering for
> substitution is 2C12C3, _not_ S<n1>_2C3.  Earlier substitutions don't
> come into play.

But we don't have the string 2C12C3 in the encoding, if C1::C2 already
appear before, we need to reuse (let say that C1 is a long enough name)
the C1 preffix, so we only have S<nc1>2C2 appearing in the encoding.
And probably some map indicating that C1::C3 is encoded with that
string.

> > Clearly, we can't write NS<n1>_2C3 instead of S<n2>_ because
> > n1 does not reffers to the same entity at that point.
> 
> Right.  Our choices at this point are (with the above numbering)
> 2C12C3 (no substitution), S2_2C3 (substitute for C1), or S0_
> (substitute for C1::C3).  We wouldn't choose the second because it's
> not shorter, and would choose the third unless <n> were > 3 digits.

Maybe my problem will be more clear with the following example:

struct C1xxxx {
    struct C2 {};
    struct C3 {
        struct C4 {};
    };
}

template <class T12, class T13, class Tune, class T134>
struct Temp : virtual something{};

And we need to encode the name:

Temp<C1xxxx::C2,C1xxxx::C3,int,C1xxxx::C3::C4>

(to encode it's vptr for example)

We have:

4Temp 
  I
    N 6C1xxxx 2C2 E 
    N S1_ 2C3 ES
    i
    N S2_ 2C4 E // S2_ -> S1_ 2C3, let's call S2_ S<C13n>_ instead.
  E

Now imagine, instead of "int", we have something very 
big that generate a 5 digit (or more) C13n (sure, it's 
a big number, it won't append very often) so that 
strlen( "S<C13n>_2C4" ) > strlen ("S1_ 2C3")

At that point, I don't see what to write instead of "S<C13n>_2C4".
 
> > If we are
> > ready to replace n1 with it's updated value n1+delta, the rule
> > and the implementation becomes more complicated (imagine that
> > we have something more complex than S<n1>_2C3, with some
> > substitued template args and so on...).
> 
> I don't think this is true if you recognize that you're not
> substituting for already-substituted strings.  Do you?
> 
> > Now, the typical size of a substitution will be 3, encoded source
> > names are at least 2 char long (and I don't think it's the typical
> > size).
> > So the only "real world" (but every one has it's own, so...)
> > waste of space of more than 1 char/substitution I can think of
> > involve builtin type. What about supressing the "smaller size"
> > rule and saying that builtin types can't be source of further
> > substitution ?
> 
> I don't feel strongly about this.  Does anyone else?
> 
> Jim
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272



From dehnert at baalbek.engr.sgi.com  Tue Apr 18 23:20:26 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Apr 2000 16:20:26 -0700 (PDT)
Subject: Vcall offsets
References: <200004182151.OAA77828@baalbek.engr.sgi.com>
Message-ID: <200004182320.QAA78124@baalbek.engr.sgi.com>

> I was actually trying to clarify something different here.  If `f'
> appears before `g' in the class declaration, does the vcall offset for
> `f' appear before, or after, `g' in the vtable layout?  (Assuming
> neither is overridden, so we don't get the complications being
> discussed above.)

The way I view this is that we produce things in a normal top-down
declaration order, and then invert the whole list so that the "first"
entry is closest to the vptr address.  That would put f after g in
memory order.

Jim


-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From mark at codesourcery.com  Wed Apr 19 00:05:17 2000
From: mark at codesourcery.com (Mark Mitchell)
Date: Tue, 18 Apr 2000 17:05:17 -0700
Subject: Vcall offsets
In-Reply-To: <200004182320.QAA78124@baalbek.engr.sgi.com>
References: <200004182151.OAA77828@baalbek.engr.sgi.com>
	<200004182320.QAA78124@baalbek.engr.sgi.com>
Message-ID: <20000418170517K.mitchell@codesourcery.com>

>>>>> "Jim" == Jim Dehnert <dehnert at baalbek.engr.sgi.com> writes:

    >> I was actually trying to clarify something different here.  If
    >> `f' appears before `g' in the class declaration, does the vcall
    >> offset for `f' appear before, or after, `g' in the vtable
    >> layout?  (Assuming neither is overridden, so we don't get the
    >> complications being discussed above.)

    Jim> The way I view this is that we produce things in a normal
    Jim> top-down declaration order, and then invert the whole list so
    Jim> that the "first" entry is closest to the vptr address.  That
    Jim> would put f after g in memory order.

Good -- that's what I was proposing too.  I just couldn't really make
"from the inside out" mean that to me.  So, I think all we need is an
editorial clarification.

Thanks,

--
Mark Mitchell                   mark at codesourcery.com
CodeSourcery, LLC               http://www.codesourcery.com



From dehnert at baalbek.engr.sgi.com  Wed Apr 19 01:08:20 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 18 Apr 2000 18:08:20 -0700 (PDT)
Subject: substitutions
References: <200004182109.OAA77360@baalbek.engr.sgi.com>
Message-ID: <200004190108.SAA78400@baalbek.engr.sgi.com>

> From alainm at cup.hp.com  Tue Apr 18 15:12:22 2000
> > >
> > > Now, let's say that S<n2>_ is longuer than S<n1>_2C3, what should
> > > we do ?
> > 
> > Ah, I think I see your problem.  The entity that we're considering for
> > substitution is 2C12C3, _not_ S<n1>_2C3.  Earlier substitutions don't
> > come into play.
> 
> But we don't have the string 2C12C3 in the encoding, if C1::C2 already
> appear before, we need to reuse (let say that C1 is a long enough name)
> the C1 preffix, so we only have S<nc1>2C2 appearing in the encoding.
> And probably some map indicating that C1::C3 is encoded with that
> string.

But you need to behave as though you did have the string 2C12C3.
That's what you're substituting for.  As the document says:

  ...the substitution occurs only if "S<seq-id>_" (or "S_")
  is strictly shorter than the unsubstituted encoding,

to which I just added for more clarity:

  i.e. the encoding obtained if no substitution of its parts were done.

> > > Clearly, we can't write NS<n1>_2C3 instead of S<n2>_ because
> > > n1 does not reffers to the same entity at that point.
> > 
> > Right.  Our choices at this point are (with the above numbering)
> > 2C12C3 (no substitution), S2_2C3 (substitute for C1), or S0_
> > (substitute for C1::C3).  We wouldn't choose the second because it's
> > not shorter, and would choose the third unless <n> were > 3 digits.
> 
> Maybe my problem will be more clear with the following example:
> 
> struct C1xxxx {
>     struct C2 {};
>     struct C3 {
>         struct C4 {};
>     };
> }
> 
> template <class T12, class T13, class Tune, class T134>
> struct Temp : virtual something{};
> 
> And we need to encode the name:
> 
> Temp<C1xxxx::C2,C1xxxx::C3,int,C1xxxx::C3::C4>
> 
> (to encode it's vptr for example)
> 
> We have:
> 
> 4Temp 
>   I
>     N 6C1xxxx 2C2 E 
>     N S1_ 2C3 ES
>     i
>     N S2_ 2C4 E // S2_ -> S1_ 2C3, let's call S2_ S<C13n>_ instead.
>   E
> 
> Now imagine, instead of "int", we have something very 
> big that generate a 5 digit (or more) C13n (sure, it's 
> a big number, it won't append very often) so that 
> strlen( "S<C13n>_2C4" ) > strlen ("S1_ 2C3")

But is strlen( "S<C13n>_2C4" ) > strlen ("6C1xxxx2C3")?
That's the question that matters.

> At that point, I don't see what to write instead of "S<C13n>_2C4".

Is "S<C13n>_" shorter than "6C1xxxx2C3"?  If so, use it.
Otherwise, is "S<C1n>" shorter than "6C1xxxx"?  If so, use S<C1n>2C3.
Otherwise, use "6C1xxxx".

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From alainm at cup.hp.com  Wed Apr 19 17:29:32 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Wed, 19 Apr 2000 10:29:32 -0700
Subject: substitutions
References: <200004182109.OAA77360@baalbek.engr.sgi.com> <200004190108.SAA78400@baalbek.engr.sgi.com>
Message-ID: <38FDECFC.6D2D0B6B@cup.hp.com>

Jim Dehnert wrote:
> 
> > From alainm at cup.hp.com  Tue Apr 18 15:12:22 2000
> > > >
> > > > Now, let's say that S<n2>_ is longuer than S<n1>_2C3, what should
> > > > we do ?
> > >
> > > Ah, I think I see your problem.  The entity that we're considering for
> > > substitution is 2C12C3, _not_ S<n1>_2C3.  Earlier substitutions don't
> > > come into play.
> >
> > But we don't have the string 2C12C3 in the encoding, if C1::C2 already
> > appear before, we need to reuse (let say that C1 is a long enough name)
> > the C1 preffix, so we only have S<nc1>2C2 appearing in the encoding.
> > And probably some map indicating that C1::C3 is encoded with that
> > string.
> 
> But you need to behave as though you did have the string 2C12C3.
> That's what you're substituting for.  As the document says:
> 
>   ...the substitution occurs only if "S<seq-id>_" (or "S_")
>   is strictly shorter than the unsubstituted encoding,

Ok, I thought "unsubstituted encoding" only meant "the target of the
substitution".

> to which I just added for more clarity:
> 
>   i.e. the encoding obtained if no substitution of its parts were done.

Thanks,

Alain



From loewis at informatik.hu-berlin.de  Wed Apr 19 18:10:46 2000
From: loewis at informatik.hu-berlin.de (Martin von Loewis)
Date: Wed, 19 Apr 2000 20:10:46 +0200
Subject: substitutions
In-Reply-To: <38FCDD9A.BB2E9503@cup.hp.com> (message from Alain Miniussi on
	Tue, 18 Apr 2000 15:11:38 -0700)
References: <200004182109.OAA77360@baalbek.engr.sgi.com> <38FCDD9A.BB2E9503@cup.hp.com>
Message-ID: <200004191810.UAA16094@pandora>

> But we don't have the string 2C12C3 in the encoding, if C1::C2 already
> appear before, we need to reuse (let say that C1 is a long enough name)
> the C1 preffix, so we only have S<nc1>2C2 appearing in the encoding.
> And probably some map indicating that C1::C3 is encoded with that
> string.

IMO, the back-references always refer to the original expanded names,
in some interal form. Conceptually, you have C1::C3 in the compression
table, not 2C12C3 (and neither S<n>_2C3).

> 4Temp 
>   I
>     N 6C1xxxx 2C2 E 
>     N S1_ 2C3 ES
>     i
>     N S2_ 2C4 E // S2_ -> S1_ 2C3, let's call S2_ S<C13n>_ instead.
>   E

> Now imagine, instead of "int", we have something very 
> big that generate a 5 digit (or more) C13n (sure, it's 
> a big number, it won't append very often) so that 
> strlen( "S<C13n>_2C4" ) > strlen ("S1_ 2C3")

> At that point, I don't see what to write instead of "S<C13n>_2C4".

The procedure is as follows:

1. Do you have a compression for C1xxxx::C3::C4? No.
2. Do you have a compression for C1xxxx::C3? Yes, S<C13n>.
   Is it shorter than 6C1xxxx2C3? Let's assume it isn't.
3. Do you have a compression for C1xxxx? Yes, S<C13n+3> (correct me if
   I'm wrong). Is it shorter than C1xxxx? Certainly not.
4. Use the uncompressed version, i.e.
   N6C1xxxx2C32C4E, putting new entries into the compression list,
   namely
   C1xxxx
   C1xxxx::C3
   C1xxxx::C3::C4
   which can be done as you encode them, after finding out that you
   cannot compress them.

Regards,
Martin



From dehnert at baalbek.engr.sgi.com  Thu Apr 20 00:29:52 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 19 Apr 2000 17:29:52 -0700 (PDT)
Subject: Status page updates
Message-ID: <200004200029.RAA80909@baalbek.engr.sgi.com>

I've updated the status pages from last week's meeting.  There are
plenty of additions in the open issues page, and plenty of red ink
in the ABI Data Layout document.  Please look it all over carefully.
(HTML only so far.)

REMEMBER -- no meeting this week.

Jim
-		Jim Dehnert  x3-4272



From dehnert at baalbek.engr.sgi.com  Wed Apr 26 05:27:21 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Tue, 25 Apr 2000 22:27:21 -0700 (PDT)
Subject: Interface section proposal
Message-ID: <200004260527.WAA08581@baalbek.engr.sgi.com>

I've updated the description of SGI's Interface section (for link-time
parameter checking) to support checking throw specifications and
instantiation/specialization mismatches.  It's linked from the summary
page -- take a good look (for F-3, F-4, and F-10).

I'll send an agenda tomorrow.  (It shouldn't be a surprise if you look
at the last one and the open issues.)

Jim

-		Jim Dehnert  x3-4272



From samuel at codesourcery.com  Wed Apr 26 18:18:30 2000
From: samuel at codesourcery.com (Alex Samuel)
Date: Wed, 26 Apr 2000 11:18:30 -0700 (PDT)
Subject: mangling type_info for builtin types
Message-ID: <14599.13046.826331.945372@coriander.indetermi.net>

Hi,

As far as I can tell, the mangling specification provides no way of
mangling the type_info of a builtin type, e.g. the result of 
typeid (int).

For class C, the typeinfo struct name would be mangled `_ZN1CTIE'.
I'd guess that the typeinfo for int would then be `_ZNiTIE'.  This
would require augmenting the <compound-prefix> production to have
alternatives for non-class/namespace types:

    <compound-prefix> ::= <path-component> [<template-args>]
                      ::= <builtin-type>
                      ::= <function-type>
                      ::= <array-type>
                      ::= <pointer-to-member-type>

Regards
Alex



From dehnert at baalbek.engr.sgi.com  Thu Apr 27 00:35:17 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Wed, 26 Apr 2000 17:35:17 -0700 (PDT)
Subject: Agenda for tomorrow
Message-ID: <200004270035.RAA10739@baalbek.engr.sgi.com>

Following is an updated agenda.  The status pages are updated and on
the web at:

	http://reality.sgi.com/dehnert_engr/cxx/cxx-summary.html

The contact info page is now also there, in password-protected PDF only
for privacy.  The password is "not an orc".

As usual, most of the updates are in the ABI layout document, in color.
The significant changes from last week are:

 - Clarify ordering of vcall offsets.

 - Further elaboration of the construction vtable.

 - Specify COMDAT RTTI name (proposed resolution of A-28).

 - Derive pointer-to-member RTTI and pointer RTTI from common base.
   (Proposed resolution of A-29.)

 - Clarify substitution in mangled names by changing grammar approach.

 - Updates in Vague Linkage section.

Please take a careful look at the colored text, and raise any issues
you observe.  In particular, be prepared to list other things which
need to be mentioned in the new vague linkage section.

Take a look at the material associated with the following issues.

  1) C-2:  Priority for constructors.  The base ABI group is not
     particularly interested in this, because they are not getting
     pressure from their C++ people to worry about it.  So, if we want
     to standardize this, we need to apply pressure within our
     companies.

  2) A-29:  pointer-to-member RTTI.  Proposed resolution and writeup OK?

  3) A-28:  incomplete class RTTI and equality testing.  Proposed
     resolution and writeup OK?

  4) F-7:  Mangling statics.  Is writeup OK?

  5) F-11:  Hash for local strings.  Close with current (non-hash)
     writeup?

  5) C-4:  Construction vtables.  Ready to close?

  6) F-2:  Mangled name size.  Our hope has been that the substitution
     mechanism will make further efforts unnecessary.  How do we go
     about validating this?  Martin's first data are excellent.
     Matt gave him another set of names to try -- any luck?

  7) F-3:  Mangling instantiation/specialization.
     F-4:  Empty throw specifications.
     F-10: Mangling return types.

     Coleen made a proposal for F-3.  Jim updated the SGI interface
     section to handle all three.  Where should we go with this?

  8) F-6:  Demangler.  We should be getting an updated proposal from
     Matt.

  9) D-12:  Unwind table location.

For next week, be prepared to discuss:

  1) C-3:  Order of ctors/dtors w.r.t. DSOs.

  2) E-*:  Do we go anywhere with templates?

  3) G-4, C-14:  Specify form of local-scope single-initialization.

Issues that are active and awaiting proposals:

  a) Demangler interface?  (Matt)

Jim

-		Jim Dehnert  x3-4272



From jason at cygnus.com  Thu Apr 27 18:30:49 2000
From: jason at cygnus.com (Jason Merrill)
Date: 27 Apr 2000 11:30:49 -0700
Subject: Agenda for tomorrow
In-Reply-To: dehnert@baalbek.engr.sgi.com's message of "Wed, 26 Apr 2000 17:35:17 -0700 (PDT)"
References: <200004270035.RAA10739@baalbek.engr.sgi.com>
Message-ID: <u9g0s7cs6e.fsf@yorick.cygnus.com>

Ack, sorry about missing the meeting.  I'm still recovering from jet lag,
and only just woke up.

Jason



From austern at sgi.com  Thu Apr 27 19:17:45 2000
From: austern at sgi.com (Matt Austern)
Date: Thu, 27 Apr 2000 12:17:45 -0700 (PDT)
Subject: Demangler interfacd
In-Reply-To: <u9g0s7cs6e.fsf@yorick.cygnus.com>
References: <200004270035.RAA10739@baalbek.engr.sgi.com>
	<u9g0s7cs6e.fsf@yorick.cygnus.com>
Message-ID: <14600.34829.942823.240052@isolde.engr.sgi.com>

This was a small meeting!  We ended up quitting early.

One thing I promised to do and didn't, though, was to come up with a
revised demangler interface.  Here it is.  It's more complicated than
I like, but the complexity does serve a real purpose.  Motivation:
 - allow returning an error code
 - interface callable from C
 - allow reusing a buffer between multiple invocations
 - allow resizing a buffer, since there is no way, even in principle,
   to know how large a buffer to provide.

namespace abi {

  char* __cxa_demangle(const char* mangled_name,
                       char* buf,
                       size_t* n,
                       int* status);

}

mangled-name is a pointer to a null-terminated array of characters

buf may be null.  If it is nonnull, then n must also be nonnull,
and buf is a pointer to an array, of at least *n characters, that
was allocated using malloc.

status points to an int that's used as an error indicator.  It is 
permitted to be null, in which case the user just doesn't get any
detailed error information.

Behavior: the return value is a pointer to a null-character array 
of characters, the demangled name.  If there is an error in
demangling, the return value is a null pointer.  The user can examine
*status to find out what kind of error it is.  Meaning of error 
indications:
     0:  success
     -1: memory allocation failure
     -2: invalid mangled name
     -3: invalid arguments (e.g. buf nonnull and n null)

Memory management: 
 - if buf is a null pointer, __cxa_demangle allocates a new buffer 
   with malloc.  It stoes the size of the buffer in *n, if n is
   nonnull.
 - if buf is not a null pointer, it must have been allocated with
   malloc.  If the array turns out to be too small, __cxa_demangle
   may use realloc to increase its size.  The new size will be stored
   in *n.


    







From ddd at cup.hp.com  Fri Apr 28 00:51:27 2000
From: ddd at cup.hp.com (Christophe de Dinechin)
Date: Fri, 28 Apr 2000 00:51:27 +0000
Subject: Demangler interfacd
References: <200004270035.RAA10739@baalbek.engr.sgi.com>
		<u9g0s7cs6e.fsf@yorick.cygnus.com> <14600.34829.942823.240052@isolde.engr.sgi.com>
Message-ID: <3908E08F.B074CBA@cup.hp.com>

Matt Austern wrote:
> 
> 
> Behavior: the return value is a pointer to a null-character array

I assume this is null-terminated, right?

Otherwise, the interface seems fine.


Christophe



From austern at sgi.com  Fri Apr 28 18:46:00 2000
From: austern at sgi.com (Matt Austern)
Date: Fri, 28 Apr 2000 11:46:00 -0700 (PDT)
Subject: Mangling ambiguity
Message-ID: <14601.55351.23402.938123@isolde.engr.sgi.com>

We discussed this yesterday at the meeting.  I'm just sending it out
to the list so everyone can see a simple example and comment on it.

Consider the following declarations:

       template <class T> struct A { };
       template <class T> struct B { };

       template <class T> struct X        { void f(T); };
       template <class T> struct X<A<T> > { void f(T); };

Now consider how to mangle these instantiations:
    void X<A<int> >::f(int);
    void X<B<int> >::f(B<int> >);

Under our current rules, I claim that the latter is clearly
    _Z N 1X I1BIiEE 1f E vT1_

How about the former?  It depends on how "multiple levels of template"
is to be interpreted, and we could reasonably interpret it as saying
either that the mangling should be
    _Z N 1X I1AIiEE 1f E vT1_
or that it should be
    _Z N 1X I1AIiEE 1f E vT2_

We should clarify the rules to make sure we say that it's "T2_"
instead of "T1_", because otherwise we'll have an ambiguity that can
be resolved only by the demangler knowing whether or not it's dealing
with a partial specialization.

                        --Matt



From daveed at edg.com  Fri Apr 28 19:06:47 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Apr 2000 12:06:47 -0700
Subject: Mangling ambiguity
References: <14601.55351.23402.938123@isolde.engr.sgi.com>
Message-ID: <3909E147.35F31C76@edg.com>

Matt Austern wrote:
[...]
>        template <class T> struct A { };
>        template <class T> struct B { };
> 
>        template <class T> struct X        { void f(T); };
>        template <class T> struct X<A<T> > { void f(T); };
> 
> Now consider how to mangle these instantiations:
>     void X<A<int> >::f(int);
>     void X<B<int> >::f(B<int> >);
> 
> Under our current rules, I claim that the latter is clearly
>     _Z N 1X I1BIiEE 1f E vT1_
> 
> How about the former?  It depends on how "multiple levels of template"
> is to be interpreted, and we could reasonably interpret it as saying
> either that the mangling should be
>     _Z N 1X I1AIiEE 1f E vT1_
> or that it should be
>     _Z N 1X I1AIiEE 1f E vT2_
> 
> We should clarify the rules to make sure we say that it's "T2_"
> instead of "T1_", because otherwise we'll have an ambiguity that can
> be resolved only by the demangler knowing whether or not it's dealing
> with a partial specialization.

I must be going blank, but where is the ambiguity with the first
mangling?  In the latter case, what does "T2_" refer to given that
there is only one template parameter?

	Daveed



From dehnert at baalbek.engr.sgi.com  Fri Apr 28 21:04:39 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 28 Apr 2000 14:04:39 -0700 (PDT)
Subject: Mangling ambiguity
References: <14601.55351.23402.938123@isolde.engr.sgi.com>
Message-ID: <200004282104.OAA15725@baalbek.engr.sgi.com>

> Date: Fri, 28 Apr 2000 12:06:47 -0700
> From: Daveed Vandevoorde <daveed at edg.com>
> 
> Matt Austern wrote:
> [...]
> >        template <class T> struct A { };
> >        template <class T> struct B { };
> > 
> >        template <class T> struct X        { void f(T); };
> >        template <class T> struct X<A<T> > { void f(T); };
> > 
> > Now consider how to mangle these instantiations:
> >     void X<A<int> >::f(int);
> >     void X<B<int> >::f(B<int> >);
> > 
> > Under our current rules, I claim that the latter is clearly
> >     _Z N 1X I1BIiEE 1f E vT1_
> > 
> > How about the former?  It depends on how "multiple levels of template"
> > is to be interpreted, and we could reasonably interpret it as saying
> > either that the mangling should be
> >     _Z N 1X I1AIiEE 1f E vT1_
> > or that it should be
> >     _Z N 1X I1AIiEE 1f E vT2_
> > 
> > We should clarify the rules to make sure we say that it's "T2_"
> > instead of "T1_", because otherwise we'll have an ambiguity that can
> > be resolved only by the demangler knowing whether or not it's dealing
> > with a partial specialization.
> 
> I must be going blank, but where is the ambiguity with the first
> mangling?  In the latter case, what does "T2_" refer to given that
> there is only one template parameter?

No, there are two.  There's the "int" given by I1E, and the A<int>
given by I1AIiEE.  The key here is that Matt's second example,
	void X<B<int> >::f(B<int> >);
does not match the specialization, so B<int> is "the" template
parameter, substituted for T in the definition:
	template <class T> struct X        { void f(T); };
But in the specialization,
	template <class T> struct X<A<T> > { void f(T); };
the mangling prefix is identical, i.e.
	_Z N 1X I1AIiEE 1f E v...
vs.
	_Z N 1X I1BIiEE 1f E v...
and if we specify the use of T1_ for both, the demangler will get one
of them wrong (it can't see the template definitions, after all).

The key to understanding the problem, I think, is that although there
is no ambiguity to the mangler, the demangler doesn't see the "template
<class T>" prefix and can't tell whether A<T> is the parameter or T is.
There are two potential solutions.  I've added one to the writeup as a
proposal, which is simply to number all of the elements of I..E
template parameter lists, outer level and inner levels, without regard
to which are the "real" parameters.  An alternative would be to put a
flag in the mangling to identify the "real" parameters.  I don't have a
strong bias.  I'll put the new document out shortly so you can see it.

Jim

-	    Jim Dehnert		dehnert at sgi.com
				(650)933-4272



From alainm at cup.hp.com  Fri Apr 28 21:00:28 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 28 Apr 2000 14:00:28 -0700
Subject: Mangling ambiguity
References: <14601.55351.23402.938123@isolde.engr.sgi.com> <3909E147.35F31C76@edg.com>
Message-ID: <3909FBEC.EF984DB4@cup.hp.com>

Daveed Vandevoorde wrote:
> 
> Matt Austern wrote:
> [...]
> >        template <class T> struct A { };
> >        template <class T> struct B { };
> >
> >        template <class T> struct X        { void f(T); };
> >        template <class T> struct X<A<T> > { void f(T); };
> >
> > Now consider how to mangle these instantiations:
> >     void X<A<int> >::f(int);
> >     void X<B<int> >::f(B<int> >);
> >
> > Under our current rules, I claim that the latter is clearly
> >     _Z N 1X I1BIiEE 1f E vT1_
> >
> > How about the former?  It depends on how "multiple levels of template"
> > is to be interpreted, and we could reasonably interpret it as saying
> > either that the mangling should be
> >     _Z N 1X I1AIiEE 1f E vT1_
> > or that it should be
> >     _Z N 1X I1AIiEE 1f E vT2_
> >
> > We should clarify the rules to make sure we say that it's "T2_"
> > instead of "T1_", because otherwise we'll have an ambiguity that can
> > be resolved only by the demangler knowing whether or not it's dealing
> > with a partial specialization.
> 
> I must be going blank, but where is the ambiguity with the first
> mangling? 

Let's start with:
template <class T> struct X { void f(T); };

we want to encode X<A<int> >::void f(T):
_Z N 1X I1AIiEE 1f E vT1_

Here, that mangled name seems to refer to void X<%1>::f(%1) with
%1=A<int>
Now, if we also consider:

template <class T> struct X<A<T> > { void f(T); };

and consider that 1 is the number of the first and only parameter T, we
have(for the same mangling):

void X<A<%1>::f(%1) with %1=int

And we don't know, while demangling, if we have a specialization.
So the idea is to say that we want to consider an occurence 
(probably the first but it's not explictly said yet) of T in the
actual instantiation parameters:

Instead of considering things like this:
template<class T:1> struct X<A<T> > { void f(%1); }

consider:
template<class T> struct X<A:1<int:2> > { void f(%2); }

Note that I think that the most general case must take into 
account that T can appears different time ( X<C<T,T> >) and 
that we need to put a number on every subtype  
(X<int*> -> X<int:2*:1>).

Alain


> In the latter case, what does "T2_" refer to given that
> there is only one template parameter?
> 
>         Daveed



From dehnert at baalbek.engr.sgi.com  Fri Apr 28 22:01:43 2000
From: dehnert at baalbek.engr.sgi.com (Jim Dehnert)
Date: Fri, 28 Apr 2000 15:01:43 -0700 (PDT)
Subject: Documents and meeting
Message-ID: <200004282201.PAA15872@baalbek.engr.sgi.com>

Hi, all,

I've updated the documents on the web site.  Since the meeting yesterday
was, uh, lightly attended, we didn't do much, and not much is reflected
from that.  The only real fallout is a proposed elaboration (or change)
in the template argument mangling, which we've been discussing on the
reflector.

I also reorganized the ABI document.  I removed the fiction that it is
just data layout, added chapter/section numbering (high-level, at
least), and reorganized in chapters that are (more or less)
introduction, data layout, calling conventions, and linkage.
I also changed the name from abi-layout.html to abi.html.  (I changed
the link in the summary, but it occurs to me that I have a bunch of
others to change -- you might, too.)  Let me know what you think.

I think we're close to resolving all of the important, tractable
issues.  I would like to push to clear them out over the next couple
of weeks.  So it would help if you would all take a hard look at the
issues on the most recent agenda, clarify them for yourselves,
suggest modifications/resolutions by email if appropriate, and
generally be prepared to push things through.  (Part of my motivation
is that I'll be traveling (business and vacation) for the five
Thursdays starting the 18th, so it would be nice to give you all
a vacation :-).

There is some feedback from the base ABI committee about priority
initialization.  They don't see a compelling need to do anything at
their level, and haven't been hearing demand from their C++ cohorts.
So they suggest that if we want something done, we should contact
our ABI counterparts within our companies and push them to do
something.  I think our current state is that IBM is pushing ahead
with their current implementation, gnu/Linux is doing the same, and
I'm not sure of other interest.  Unless something develops, I think
we'll have to drop this one (or perhaps agree on the source API and
leave it at that).

Jim
-		Jim Dehnert  x3-4272



From austern at sgi.com  Fri Apr 28 22:12:17 2000
From: austern at sgi.com (Matt Austern)
Date: Fri, 28 Apr 2000 15:12:17 -0700 (PDT)
Subject: Mangling ambiguity
In-Reply-To: <3909E147.35F31C76@edg.com>
References: <14601.55351.23402.938123@isolde.engr.sgi.com>
	<3909E147.35F31C76@edg.com>
Message-ID: <14602.2609.664138.288318@isolde.engr.sgi.com>


Daveed Vandevoorde writes:
 > Matt Austern wrote:
 > [...]
 > >        template <class T> struct A { };
 > >        template <class T> struct B { };
 > > 
 > >        template <class T> struct X        { void f(T); };
 > >        template <class T> struct X<A<T> > { void f(T); };
 > > 
 > > Now consider how to mangle these instantiations:
 > >     void X<A<int> >::f(int);
 > >     void X<B<int> >::f(B<int> >);
 > > 
 > > Under our current rules, I claim that the latter is clearly
 > >     _Z N 1X I1BIiEE 1f E vT1_
 > > 
 > > How about the former?  It depends on how "multiple levels of template"
 > > is to be interpreted, and we could reasonably interpret it as saying
 > > either that the mangling should be
 > >     _Z N 1X I1AIiEE 1f E vT1_
 > > or that it should be
 > >     _Z N 1X I1AIiEE 1f E vT2_
 > > 
 > > We should clarify the rules to make sure we say that it's "T2_"
 > > instead of "T1_", because otherwise we'll have an ambiguity that can
 > > be resolved only by the demangler knowing whether or not it's dealing
 > > with a partial specialization.
 > 
 > I must be going blank, but where is the ambiguity with the first
 > mangling?  In the latter case, what does "T2_" refer to given that
 > there is only one template parameter?

Well, that's the interesting question.  According to the data layout
document (and I wish we had section numbers so I could give a precise
citation), "Objects appearing within multiple levels of template
number the top-level parameters 1..n, the next level n+1..n_m, etc."

We have I1AIiEE, so we have an I...E nested within an I...E.  Is this
what's meant by "multiple levels of template"?  If so, then the way
to represent that inner parameter (IiE) is by T2_.

And now let's look at it the other way.  Suppose we decide that this
isn't what's meant by "multiple levels of template", and that
void X<A<int> >::f(int) should be mangled as _ZN1XI1AIiEE1fEvT1_.
How do we demangle it?  When we see the T1_, it seems to me that
it would naturally refer to the outer I...E block, i.e. to 
I1AIiEE, and that we would demangle _ZN1XI1AIiEE1fEvT1_ as 
void X<A<int> >::f(A<int>).  Remember, we've already decided that
we should demangle _ZN1XI1BIiEE1fEvT1_ as X<B<int> >::f(B<int>).

                        --Matt



From alainm at cup.hp.com  Fri Apr 28 22:24:39 2000
From: alainm at cup.hp.com (Alain Miniussi)
Date: Fri, 28 Apr 2000 15:24:39 -0700
Subject: Mangling ambiguity
References: <14601.55351.23402.938123@isolde.engr.sgi.com> <200004282104.OAA15725@baalbek.engr.sgi.com>
Message-ID: <390A0FA7.BDB65980@cup.hp.com>

Jim Dehnert wrote:
> 
> > Date: Fri, 28 Apr 2000 12:06:47 -0700
> > From: Daveed Vandevoorde <daveed at edg.com>
> >
> > Matt Austern wrote:
> > [...]
> > >        template <class T> struct A { };
> > >        template <class T> struct B { };
> > >
> > >        template <class T> struct X        { void f(T); };
> > >        template <class T> struct X<A<T> > { void f(T); };
> > >
> > > Now consider how to mangle these instantiations:
> > >     void X<A<int> >::f(int);
> > >     void X<B<int> >::f(B<int> >);
> > >
> > > Under our current rules, I claim that the latter is clearly
> > >     _Z N 1X I1BIiEE 1f E vT1_
> > >
> > > How about the former?  It depends on how "multiple levels of template"
> > > is to be interpreted, and we could reasonably interpret it as saying
> > > either that the mangling should be
> > >     _Z N 1X I1AIiEE 1f E vT1_
> > > or that it should be
> > >     _Z N 1X I1AIiEE 1f E vT2_
> > >
> > > We should clarify the rules to make sure we say that it's "T2_"
> > > instead of "T1_", because otherwise we'll have an ambiguity that can
> > > be resolved only by the demangler knowing whether or not it's dealing
> > > with a partial specialization.
> >
> > I must be going blank, but where is the ambiguity with the first
> > mangling?  In the latter case, what does "T2_" refer to given that
> > there is only one template parameter?
> 
> No, there are two.  There's the "int" given by I1E, and the A<int>
> given by I1AIiEE.  The key here is that Matt's second example,
>         void X<B<int> >::f(B<int> >);
> does not match the specialization, so B<int> is "the" template
> parameter, substituted for T in the definition:
>         template <class T> struct X        { void f(T); };
> But in the specialization,
>         template <class T> struct X<A<T> > { void f(T); };
> the mangling prefix is identical, i.e.
>         _Z N 1X I1AIiEE 1f E v...
> vs.
>         _Z N 1X I1BIiEE 1f E v...
> and if we specify the use of T1_ for both, the demangler will get one
> of them wrong (it can't see the template definitions, after all).
> 
> The key to understanding the problem, I think, is that although there
> is no ambiguity to the mangler, the demangler doesn't see the "template
> <class T>" prefix and can't tell whether A<T> is the parameter or T is.
> There are two potential solutions.  I've added one to the writeup as a
> proposal, which is simply to number all of the elements of I..E
> template parameter lists, outer level and inner levels, without regard
> to which are the "real" parameters.

In a situation where we have a specialization, we can have multiple
occurences of the same type (template<class T> X<T,T> {...};) maybe
we should make sure that we agree on the one to choose. Since we
already have substitution at work here, maybe it's enough to say
that substituation components are not numbered ?

Also, it seems that the problem is not limited to template terms but
to compound types in general:

template <class T> struct X        { void f(T); };
template <class T> struct X<T* >   { void f(T); };

void X<int*>::f(int*)

T1_ = int*
T2_ = int

If I don't miss anything (if yes, don't read the following) it seems to
imply 
the use of the same (or reverse ?) numbering as the one used in the
context 
of substitution, for each top level template parameter. This, in turn, 
means
that the numbers used can become relatively big, and that it could be
worth 
adopting the same 36 based encoding as the one used for substututions.
 
Alain


>  An alternative would be to put a
> flag in the mangling to identify the "real" parameters.  I don't have a
> strong bias.  I'll put the new document out shortly so you can see it.
> 
> Jim
> 
> -           Jim Dehnert         dehnert at sgi.com
>                                 (650)933-4272



From daveed at edg.com  Fri Apr 28 23:30:25 2000
From: daveed at edg.com (Daveed Vandevoorde)
Date: Fri, 28 Apr 2000 16:30:25 -0700
Subject: Mangling ambiguity
References: <14601.55351.23402.938123@isolde.engr.sgi.com> <200004282104.OAA15725@baalbek.engr.sgi.com>
Message-ID: <390A1F11.F911945E@edg.com>

I think there is some confusion about the meaning of the "T<num>_"
segments, and it is somewhat related to a problem in the current
standard where the term "template" is not always used consistently.

A template is one of the following things:
	a) a class template
	b) a function template
	c) a member function template
In particular, a regular member (function, static data, class, ...)
of a class template is not a template of its own.  (The standard used 
to say the opposite at one point, but I believe that is now corrected.)

The "T<num>_" segments should only be used to denote types of
instantiations of true templates; not in the instantiation of
template entities.  As it happens, the cannot appear in the
instantiation of class templates since they have no additional
signature.  So really, "T<num>_" should only appear in parameter
and return types of function and member function templates.

Reconsider Matt's original example:

>        template <class T> struct A { };
>        template <class T> struct B { };
> 
>        template <class T> struct X        { void f(T); };
>        template <class T> struct X<A<T> > { void f(T); };
> 

The mangling of:

>     void X<A<int> >::f(int);

is "_ZNXIAIiEE1fEvi"; and that of

>     void X<B<int> >::f(B<int> >);

is "ZNXIBIiEE1fEvS<num>_" for some suitable <num> that I'm too lazy
to determine.

The "T<num>_" segments are necessary in function templates though:

	template<typename T> void f(typename A<T>::X) {}
	template<typename T> void f(typename B<T>::X) {}

Both A<int>::X and B<int>::X may end up resolving to, say, "int"; so we
cannot just resolve the specialization type.  Instead we get:
	_Z1fIiEvN1AIT1_E1XE  and  _Z1fIiEvN1BIT1_E1XE
which could be demangled as:
	void f<int>(A<int>::X)  and  void f<int>(B<int>::X)

Another subtle case is:

	template<typename T1, typename T2> void f(T1, T2);
	template<typename T1, typename T2> void f(T2, T1);

(in different translation units).  Specializations of these are distinct
and must therefore mangle differently.

Either way, the "T<num>_" segments will only appear in the parameter and
return types of function and member function template specializations.
I believe that removes the need the rule for multilevel (nested?)
templates: each template level can safely number its parameters starting
from "1" (or "0" if we prefer to use some smarts as with the "S<num>_"
segments).

Does that make any sense at all?

	Daveed



