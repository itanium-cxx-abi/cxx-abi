<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> Special characters in mangled names
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20Special%20characters%20in%20mangled%20names&In-Reply-To=%3C199911151817.KAA13812%40cllmail.cup.hp.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000336.html">
   <LINK REL="Next"  HREF="000338.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>Special characters in mangled names</H1>
    <B>Christophe de Dinechin</B> 
    <A HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20Special%20characters%20in%20mangled%20names&In-Reply-To=%3C199911151817.KAA13812%40cllmail.cup.hp.com%3E"
       TITLE="Special characters in mangled names">ddd at cup.hp.com
       </A><BR>
    <I>Mon Nov 15 18:17:42 UTC 1999</I>
    <P><UL>
        <LI>Previous message: <A HREF="000336.html">Special characters in mangled names
</A></li>
        <LI>Next message: <A HREF="000338.html">Special characters in mangled names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#337">[ date ]</a>
              <a href="thread.html#337">[ thread ]</a>
              <a href="subject.html#337">[ subject ]</a>
              <a href="author.html#337">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> In a discussion with Matt Austern I suggested using a
</I>&gt;<i> collision-resistant hash function on the manglings to generate the 
</I>&gt;<i> names actually used in object files.  (The algorithm is: first mangle, 
</I>&gt;<i> then hash.)  This could really reduce .o size a ton; think expression 
</I>&gt;<i> templates, etc.  I bet this would have a much bigger impact that any 
</I>&gt;<i> obvious compression algorithm; you could just decree that all symbols 
</I>&gt;<i> be no longer than 256 bits long, say.  Lots of tools (assemblers,
</I>&gt;<i> debuggers) will use less space/time dealing with the shorter names. 
</I>&gt;<i> You would keep around a table mapping hashes back to the original
</I>&gt;<i> mangled names for debugging.
</I>
Can you please explain what is a &quot;collision-resistant&quot; hash  
function? I doubt you would get the same collisions from two  
different translation units, so I don't see how you could ensure a  
name that is identical between TUs and also avoids collisions.

Also: There is a wide assumption that name mangling is reversible.  
In other words, there is a c++filt tool, and hundreds of scripts use  
it somehow (combined with nm, to process the error output of ld,  
etc.) I'm not sure it is wise to give up this assumption.


Best regards,
Christophe.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000336.html">Special characters in mangled names
</A></li>
	<LI>Next message: <A HREF="000338.html">Special characters in mangled names
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#337">[ date ]</a>
              <a href="thread.html#337">[ thread ]</a>
              <a href="subject.html#337">[ subject ]</a>
              <a href="author.html#337">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">More information about the cxx-abi-dev
mailing list</a><br>
</body></html>
