<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium ABI
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20%5Bcxx-abi-dev%5D%20C%2B%2B0x%20std%3A%3Arethrow_exception%2C%20data%20races%20and%20the%20Itanium%0A%20ABI&In-Reply-To=%3COFD6AFD5D3.42D2D0A4-ON8525782B.0071F71F-8525782B.00819227%40ca.ibm.com%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="002392.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium ABI</H1>
    <B>Michael Wong</B> 
    <A HREF="mailto:cxx-abi-dev%40codesourcery.com?Subject=Re%3A%20%5Bcxx-abi-dev%5D%20C%2B%2B0x%20std%3A%3Arethrow_exception%2C%20data%20races%20and%20the%20Itanium%0A%20ABI&In-Reply-To=%3COFD6AFD5D3.42D2D0A4-ON8525782B.0071F71F-8525782B.00819227%40ca.ibm.com%3E"
       TITLE="[cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium ABI">michaelw at ca.ibm.com
       </A><BR>
    <I>Wed Feb  2 23:35:17 UTC 2011</I>
    <P><UL>
        
        <LI>Next message: <A HREF="002392.html">[cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium ABI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2391">[ date ]</a>
              <a href="thread.html#2391">[ thread ]</a>
              <a href="subject.html#2391">[ subject ]</a>
              <a href="author.html#2391">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Hi, I wonder if Nathan Sidwell, Mark Michell or others can comment on the
feasibility of these 2 enhancement choices to enable copyable exception
objects.
A solution to this is required by C++0x LWG issue 1369 which is in review
status now:
<A HREF="http://lwg.github.com/issues/lwg-active.html#1369">http://lwg.github.com/issues/lwg-active.html#1369</A>

We discussed this at Fermi Lab and one solution is that we need to start by
requiring one of the many ABI's out there starting with the C++ABI. I
realize there are other ABIs out there but it would be good to support
I like the second option, and it seems the spec as Anthony mention already
make provisions for enhancing the exception object header in the negative
direction, and in fact complete replace that header to allow a copyable
version of the exception object.

We just would like some confirmation that this is allowed from others who
have designed the original C++ ABI exception.


Regards, Michael

Rational C/C++ cafe:
<A HREF="http://www.ibm.com/software/rational/cafe/community/ccpp">http://www.ibm.com/software/rational/cafe/community/ccpp</A>
My Blogs:
Parallel &amp; Multi-Core Computing
<A HREF="http://www.ibm.com/software/rational/cafe/blogs/ccpp-parallel-multicore">http://www.ibm.com/software/rational/cafe/blogs/ccpp-parallel-multicore</A>
C++ Language &amp; Standard
<A HREF="http://www.ibm.com/software/rational/cafe/blogs/cpp-standard">http://www.ibm.com/software/rational/cafe/blogs/cpp-standard</A>
Commercial Computing
<A HREF="http://www.ibm.com/software/rational/cafe/blogs/ccpp-commercial">http://www.ibm.com/software/rational/cafe/blogs/ccpp-commercial</A>
Boost test results
<A HREF="http://www.ibm.com/support/docview.wss?rs=2239&amp;context=SSJT9L&amp;uid=swg27006911">http://www.ibm.com/support/docview.wss?rs=2239&amp;context=SSJT9L&amp;uid=swg27006911</A>

C/C++ Compilers Support Page
<A HREF="http://www.ibm.com/software/awdtools/ccompilers/support/">http://www.ibm.com/software/awdtools/ccompilers/support/</A>
C/C++ Feature Request Interface
<A HREF="http://www.ibm.com/support/docview.wss?uid=swg27005811">http://www.ibm.com/support/docview.wss?uid=swg27005811</A>
XL Fortran Compiler Support Page
<A HREF="http://www.ibm.com/software/awdtools/fortran/xlfortran/support/">http://www.ibm.com/software/awdtools/fortran/xlfortran/support/</A>
XL Fortran Feature Request Interface
<A HREF="http://www.ibm.com/support/docview.wss?uid=swg27005812">http://www.ibm.com/support/docview.wss?uid=swg27005812</A>

Michael Wong
XL C++ Compiler kernel Development
IBM Canada Ltd., C2/KD2/8200/MKM
8200 Warden Avenue
Markham, Ontario  L6G 1C7
W:905-413-3283 F:905-413-4839

Anthony Williams &lt;<A HREF="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">anthony at justsoftwaresolutions.co.uk</A>&gt; wrote on 11/17/2010
03:32:59 AM:

&gt;<i> [image removed]
</I>&gt;<i>
</I>&gt;<i> [cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium
</I>ABI
&gt;<i>
</I>&gt;<i> Anthony Williams
</I>&gt;<i>
</I>&gt;<i> to:
</I>&gt;<i>
</I>&gt;<i> cxx-abi-dev
</I>&gt;<i>
</I>&gt;<i> 11/17/2010 04:05 AM
</I>&gt;<i>
</I>&gt;<i> Hi,
</I>&gt;<i>
</I>&gt;<i> With the current draft of the upcoming C++0x standard, it is unclear
</I>&gt;<i> whether the exception thrown by std::rethrow_exception is the same
</I>&gt;<i> exception object that was originally thrown, or a copy thereof. Indeed,
</I>&gt;<i> different implementations do different things: gcc rethrows the same
</I>&gt;<i> exception object, and MSVC2010 throws a copy.
</I>&gt;<i>
</I>&gt;<i> I believe that this is a mistake; std::rethrow_exception should always
</I>&gt;<i> throw a copy. If it rethrows the same exception then the same exception
</I>&gt;<i> object may now become active in multiple threads. This then exposes the
</I>&gt;<i> **handlers** to data races should they catch by reference and call any
</I>&gt;<i> member functions that modify the exception object.
</I>&gt;<i>
</I>&gt;<i> One use case I have seen for this is to add call stack information to an
</I>&gt;<i> exception for logging purposes. e.g.
</I>&gt;<i>
</I>&gt;<i> void g();
</I>&gt;<i>
</I>&gt;<i> struct my_exception
</I>&gt;<i> {
</I>&gt;<i>      void add_caller(std::string const&amp; function_name,int arg1,int arg2);
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> void f(int arg1,int arg2){
</I>&gt;<i>     try{
</I>&gt;<i>        g();
</I>&gt;<i>     catch(my_exception&amp; e)
</I>&gt;<i>     {
</I>&gt;<i>        e.add_caller(&quot;f(int,int)&quot;,arg1,arg2);
</I>&gt;<i>        throw;
</I>&gt;<i>     }
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> Under C++03, any exception thrown by g() must originate in this thread,
</I>&gt;<i> so there is no possibility of a data race in f(). Under C++0x we must
</I>&gt;<i> contend with the possibility that the exception originated in another
</I>&gt;<i> thread. e.g.
</I>&gt;<i>
</I>&gt;<i> std::mutex m;
</I>&gt;<i> std::exception_ptr ep;
</I>&gt;<i>
</I>&gt;<i> void g()
</I>&gt;<i> {
</I>&gt;<i>      std::lock_guard&lt;std::mutex&gt; lk(m);
</I>&gt;<i>      if(ep)
</I>&gt;<i>          std::rethrow_exception(ep);
</I>&gt;<i> }
</I>&gt;<i>
</I>&gt;<i> If multiple threads call g() they may thus each rethrow the same
</I>&gt;<i> exception. If this truly is the **same** exception object (and not a
</I>&gt;<i> copy) then callers such as f() have now been exposed to a data race,
</I>&gt;<i> **without changing f()**.
</I>&gt;<i>
</I>&gt;<i> Also, under the latitude provided by the C++0x draft, this behaviour may
</I>&gt;<i> vary from compiler to compiler. I can write some code that is race-free
</I>&gt;<i> under MSVC2010, but if I then recompile it with gcc then I have a data
</I>&gt;<i> race, **without any indication from the compiler**.
</I>&gt;<i>
</I>&gt;<i> I am aware that the reason for gcc's behaviour in this case is that the
</I>&gt;<i> Itanium ABI does not provide the necessary information to copy an
</I>&gt;<i> exception object, which is why I am posting here. I would like to
</I>&gt;<i> propose changing the Itanium ABI to provide the necessary information to
</I>&gt;<i> copy the exception object, **whilst remaining backwards compatible**.
</I>&gt;<i>
</I>&gt;<i> Based on the documentation at
</I>&gt;<i> <A HREF="http://www.codesourcery.com/public/cxx-abi/abi.html">http://www.codesourcery.com/public/cxx-abi/abi.html</A> I have a couple of
</I>&gt;<i> ideas on how this could be done.
</I>&gt;<i>
</I>&gt;<i> One option I see would be to add a new class derived from
</I>&gt;<i> abi::__class_type_info that had virtual member functions for the size
</I>&gt;<i> and copy constructor:
</I>&gt;<i>
</I>&gt;<i> class __copyable_class_type_info: public __class_type_info
</I>&gt;<i> {
</I>&gt;<i> public:
</I>&gt;<i>      size_t __object_size;
</I>&gt;<i>      virtual void __copy_construct(void* __source, void* __dest)=0;
</I>&gt;<i> };
</I>&gt;<i>
</I>&gt;<i> You would need similar derived classes for __si_class_type_info and
</I>&gt;<i> __vmi_class_type_info.
</I>&gt;<i>
</I>&gt;<i> Because these are derived classes, they shouldn't affect the existing
</I>&gt;<i> ABI structures. The size of non-class types can be determined from the
</I>&gt;<i> type directly, since all pointers have the same size and fundamental
</I>&gt;<i> types have a fixed size under the ABI. Such types can also be copied
</I>&gt;<i> with memcpy(). The type_info for classes for which there is no public
</I>&gt;<i> copy constructor would not derive from these new type-info classes.
</I>&gt;<i>
</I>&gt;<i> rethrow_exception can then check the type_info pointed to by the
</I>&gt;<i> exceptionType member of the __cxa_exception header, and either
</I>&gt;<i>
</I>&gt;<i> (i) copy the exception with memcpy (because it's a fundamental type or
</I>&gt;<i> pointer)
</I>&gt;<i>
</I>&gt;<i> (ii) throw bad_alloc because this is an exception that cannot therefore
</I>&gt;<i> be copied (i.e. it has no public copy constructor, or because it is from
</I>&gt;<i> the old ABI)
</I>&gt;<i>
</I>&gt;<i> (iii) dynamic_cast the type info to __copyable_class_type_info use the
</I>&gt;<i> new __object_size and __copy_construct virtual functions to clone the
</I>&gt;<i> exception
</I>&gt;<i>
</I>&gt;<i> A second option is to add the size and copy construction functions to
</I>&gt;<i> the __cxa_exception header. The ABI says &quot;By convention, a
</I>&gt;<i> __cxa_exception pointer points at the C++ object representing the
</I>&gt;<i> exception being thrown, immediately following the header. The header
</I>&gt;<i> structure is accessed at a negative offset from the __cxa_exception
</I>&gt;<i> pointer. This layout allows consistent treatment of exception objects
</I>&gt;<i> from different languages (or different implementations of the same
</I>&gt;<i> language), and allows future extensions of the header structure while
</I>&gt;<i> maintaining binary compatibility. &quot;
</I>&gt;<i>
</I>&gt;<i> We could therefore take advantage of this leeway to &quot;extend the header
</I>&gt;<i> structure while maintaining binary compatibility&quot; to add the new size
</I>&gt;<i> and copy construction members. In this case, the stored copy constructor
</I>&gt;<i> could be NULL if there is no public copy constructor for the class.
</I>&gt;<i>
</I>&gt;<i> In either case, the intention is that old code would work without
</I>&gt;<i> recompilation even if the library code that it called was changed to use
</I>&gt;<i> the new ABI, and new code could take advantage of the ability to copy
</I>&gt;<i> exceptions where the exception was thrown from code that used the new
</I>ABI.
&gt;<i>
</I>&gt;<i> What do you think? Are these options implementable in a
</I>&gt;<i> backwards-binary-compatible way? Is there an alternative implementation
</I>&gt;<i> option?
</I>&gt;<i>
</I>&gt;<i> Thanks,
</I>&gt;<i>
</I>&gt;<i> Anthony
</I>&gt;<i> --
</I>&gt;<i> Author of C++ Concurrency in Action     <A HREF="http://www.stdthread.co.uk/book/">http://www.stdthread.co.uk/book/</A>
</I>&gt;<i> just::thread C++0x thread library             <A HREF="http://www.stdthread.co.uk">http://www.stdthread.co.uk</A>
</I>&gt;<i> Just Software Solutions Ltd       <A HREF="http://www.justsoftwaresolutions.co.uk">http://www.justsoftwaresolutions.co.uk</A>
</I>&gt;<i> 15 Carrallack Mews, St Just, Cornwall, TR19 7UL, UK. Company No. 5478976
</I>&gt;<i>
</I>-------------- next part --------------
An HTML attachment was scrubbed...
URL: &lt;<A HREF="http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20110202/9bdc687e/attachment.html">http://sourcerytools.com/pipermail/cxx-abi-dev/attachments/20110202/9bdc687e/attachment.html</A>&gt;
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="002392.html">[cxx-abi-dev] C++0x std::rethrow_exception, data races and the Itanium ABI
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#2391">[ date ]</a>
              <a href="thread.html#2391">[ thread ]</a>
              <a href="subject.html#2391">[ subject ]</a>
              <a href="author.html#2391">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="http://sourcerytools.com/cgi-bin/mailman/listinfo/cxx-abi-dev">More information about the cxx-abi-dev
mailing list</a><br>
</body></html>
