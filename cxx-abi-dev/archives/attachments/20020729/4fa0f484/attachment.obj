            typedef __builtin_va_list __builtin_va_list;
namespace std
{




using ::__builtin_va_list;

}
typedef char int8_t;
typedef unsigned char uint8_t;
typedef short int16_t;
typedef unsigned short uint16_t;
typedef int int32_t;
typedef unsigned int uint32_t;

typedef int intfast_t;
typedef unsigned int uintfast_t;




typedef long long int64_t;
typedef unsigned long long uint64_t;





typedef int64_t intmax_t;
typedef uint64_t uintmax_t;
typedef long intptr_t;
typedef unsigned long uintptr_t;
typedef char int_least8_t;


typedef unsigned char uint_least8_t;


typedef int int_fast8_t;


typedef unsigned int uint_fast8_t;


typedef short int_least16_t;


typedef unsigned short uint_least16_t;


typedef int int_fast16_t;


typedef unsigned int uint_fast16_t;


typedef int int_least32_t;


typedef unsigned int uint_least32_t;


typedef int int_fast32_t;


typedef unsigned int uint_fast32_t;





typedef int64_t int_least64_t;


typedef int64_t int_fast64_t;


typedef uint64_t uint_least64_t;


typedef uint64_t uint_fast64_t;
typedef uint32_t ptr32_t;

typedef uint64_t ptr64_t;
                typedef int mqd_t;





     typedef int32_t dev_t;





        typedef uint32_t ino32_t;






       typedef uint64_t ino64_t;
         typedef unsigned long ino_t;





     typedef uint16_t mode_t;




     typedef uint16_t nlink_t;




    typedef int32_t fpos32_t;





       typedef int64_t fpos64_t;









       typedef long fpos_t;






     typedef uint32_t fsblkcnt32_t;





       typedef uint64_t fsblkcnt64_t;
       typedef unsigned long fsblkcnt_t;





     typedef int32_t off32_t;




     typedef int32_t sbsize32_t;
     typedef uint32_t bsize32_t;





        typedef int64_t off64_t;






        typedef int64_t sbsize64_t;
        typedef uint64_t bsize64_t;
        typedef long off_t;
        typedef long sbsize_t;
        typedef unsigned long bsize_t;





     typedef uint32_t fsfilcnt32_t;





       typedef uint64_t fsfilcnt64_t;
        typedef unsigned long fsfilcnt_t;





     typedef int32_t blkcnt32_t;





       typedef int64_t blkcnt64_t;
        typedef long blkcnt_t;





     typedef int32_t pid_t;




     typedef int32_t lwpid_t;




     typedef int32_t gid_t;




     typedef int32_t uid_t;




     typedef int32_t tid_t;




        typedef long ssize_t;




     typedef uint16_t __site_t;




     typedef uint16_t __cnode_t;












                typedef long time_t;







        typedef unsigned long size_t;






     typedef uint32_t clock_t;







      typedef int32_t key_t;


   typedef unsigned short __ushort;

   typedef int32_t __daddr_t;
   typedef char *__caddr_t;
   typedef int32_t __swblk_t;






     typedef __caddr_t caddr_t;







     typedef int32_t id_t;




     typedef uint32_t useconds_t;






      typedef uint32_t rlim32_t;





        typedef uint64_t rlim64_t;
       typedef unsigned long rlim_t;




   typedef __site_t site_t;



   typedef unsigned char u_char;
   typedef unsigned short u_short;
   typedef unsigned int u_int;
   typedef unsigned long u_long;
   typedef unsigned int uint;
   typedef unsigned short ushort;
   typedef unsigned char ubit8;
   typedef unsigned short ubit16;
   typedef uint32_t ubit32;
   typedef char sbit8;
   typedef short sbit16;
   typedef int32_t sbit32;

   typedef __swblk_t swblk_t;
   typedef __daddr_t daddr_t;
   typedef __cnode_t cnode_t;
typedef uintptr_t paddr_t;
typedef intptr_t page_t;

typedef int64_t pgcnt_t;
typedef uint64_t upgcnt_t;
typedef uintptr_t physpfn_t;
typedef uintptr_t iophyspfn_t;
typedef uintptr_t pgaddr_t;

typedef uint32_t prot_t;
typedef uint64_t space_t;



typedef uint32_t rid_t;







   typedef unsigned long ulong_t;


   typedef int16_t cnt_t;
   typedef uint32_t cdno_t;
   typedef uint16_t use_t;

   typedef struct _physadr { intptr_t r[1]; } *physadr;

   typedef int spu_t;
   typedef int ldom_t;





     typedef short cpu_t;




typedef struct lkinfo {
       char *lk_name;
       int lk_flags;
       long lk_pad[2];
} lkinfo_t;

typedef unsigned long pl_t;



      typedef int32_t aid_t;
   typedef pid_t sid_t;
typedef int32_t __fd_mask;
   typedef struct fd_set {
     long fds_bits[(((2048)+(((sizeof(long) * 8))-1))/((sizeof(long) * 8)))];
     } fd_set;



        extern "C" {
        }
     typedef __fd_mask fd_mask;




        extern "C" {
        }
        typedef int32_t dir_off_t;
extern "C" {
      typedef struct {
         unsigned char __parse_size:3;
         unsigned char __dummy:4;
         unsigned char __shift_state:1;
         char __parse_buf[7];
      } mbstate_t;







   typedef struct {
        int __cnt;
        unsigned char *__ptr;
        unsigned char *__base;
        unsigned short __flag;
        unsigned char __fileL;
        unsigned char __fileH;
   } FILE;


   typedef struct {
        int __cnt;
        unsigned char *__ptr;
        unsigned char *__base;
        unsigned short __flag;
        unsigned char __fileL;
        unsigned char __fileH;
        unsigned char *__bufendp;
        unsigned char *__newbase;
        unsigned char __smbuf[8 +2*4];



        void *__unused;


        int __orientation ;
        mbstate_t __state ;




   } _FILEX;
        typedef __builtin_va_list __va_list;
#pragma extern __iob

   extern FILE __iob[];





#pragma builtin fclose, fflush, scanf, fscanf, sscanf, fprintf 
#pragma builtin printf, sprintf, fgetc, fputc
#pragma extern remove, tmpnam, fclose, fflush, setbuf, setvbuf, fprintf
#pragma extern fscanf, printf, scanf, sprintf, sscanf, fgetc, fgets, fputc
#pragma extern fputs, getc, getchar, gets, putc, putchar, puts, ungetc
#pragma extern fseek, ftell, rewind, clearerr, feof, ferror, perror

     extern int remove(const char *);



#pragma extern rename

     extern int rename(const char *, const char *);

     extern char *tmpnam(char *);
     extern int fclose(FILE *);
     extern int fflush(FILE *);
     extern void setbuf(FILE *, char *);
     extern int setvbuf(FILE *, char *, int, size_t);
     extern int fprintf(FILE *, const char *, ...);
     extern int fscanf(FILE *, const char *,...);
     extern int printf(const char *,...);
     extern int scanf(const char *,...);
     extern int sprintf(char *, const char *,...);
     extern int sscanf(const char *, const char *,...);
     extern int fgetc(FILE *);
     extern char *fgets(char *, int, FILE *);
     extern int fputc(int, FILE *);
     extern int fputs(const char *, FILE *);
     extern int getc(FILE *);
     extern int getchar(void);
     extern char *gets(char *);
     extern int putc(int, FILE *);
     extern int putchar(int);
     extern int puts(const char *);
     extern int ungetc(int, FILE *);



#pragma builtin fopen
#pragma extern tmpfile, fgetpos, fsetpos, fopen, freopen

     extern FILE *tmpfile(void);
     extern int fgetpos(FILE *, fpos_t *);
     extern int fsetpos(FILE *, const fpos_t *);
     extern FILE *fopen(const char *, const char *);
     extern FILE *freopen(const char *, const char *, FILE *);
     extern int fseek(FILE *, long int, int);
     extern long int ftell(FILE *);
     extern void rewind(FILE *);
     extern void clearerr(FILE *);
     extern int feof(FILE *);
     extern int ferror(FILE *);
     extern void perror(const char *);

#pragma extern fread, fwrite

       extern size_t fread(void *, size_t, size_t, FILE *);
       extern size_t fwrite(const void *, size_t, size_t, FILE *);

#pragma extern __flsbuf, __filbuf 
     extern int __flsbuf(unsigned char, FILE *);
     extern int __filbuf(FILE *);
#pragma extern ctermid, fileno, fdopen 
     extern char *ctermid(char *);
     extern int fileno(FILE *);
     extern FILE *fdopen(int, const char *);
#pragma extern optarg, opterr, optind, optopt, getopt, cuserid


     extern char *optarg;
     extern int opterr;
     extern int optind;
     extern int optopt;
       extern int getopt(int, char * const [], const char *);
       extern char *cuserid(char *);
#pragma extern getw, putw, pclose, popen, tempnam
     extern int getw(FILE *);
     extern int putw(int, FILE *);
     extern int pclose(FILE *);
     extern FILE *popen(const char *, const char *);
     extern char *tempnam(const char *, const char *);
#pragma extern vprintf, vfprintf, vsprintf





     extern int vprintf(const char *, __builtin_va_list);
     extern int vfprintf(FILE *, const char *, __builtin_va_list);
     extern int vsprintf(char *, const char *, __builtin_va_list);






#pragma builtin snprintf
#pragma extern snprintf, vsnprintf, vscanf, vfscanf, vsscanf, flockfile
#pragma extern ftrylockfile, funlockfile
     extern int snprintf(char *, size_t, const char *,...);
     extern int vsnprintf(char *, size_t, const char *, __va_list);
     extern int vscanf(const char *, __va_list);
     extern int vfscanf(FILE *, const char *, __va_list);
     extern int vsscanf(char *, const char *, __va_list);
     extern void flockfile(FILE *);
     extern int ftrylockfile(FILE *);
     extern void funlockfile(FILE *);
#pragma extern __bufendtab


   extern unsigned char *__bufendtab[];
}
namespace std
{




using ::FILE;
using ::fpos_t;
using ::size_t;




using ::fclose;
using ::fflush;
using ::fgetc;
using ::fgetpos;
using ::fgets;
using ::fopen;
using ::fprintf;
using ::fputc;
using ::fputs;
using ::fread;
using ::freopen;
using ::fscanf;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::fwrite;
using ::gets;
using ::perror;
using ::printf;
using ::puts;
using ::remove;
using ::rename;
using ::rewind;
using ::scanf;
using ::setbuf;
using ::setvbuf;
using ::sprintf;
using ::sscanf;
using ::tmpfile;
using ::tmpnam;
using ::ungetc;
using ::vfprintf;
using ::vprintf;
using ::vsprintf;

using ::clearerr;
using ::feof;
using ::ferror;
using ::getc;
using ::putc;
using ::getchar;
using ::putchar;
}
#pragma extern errno


        extern int errno;
     extern "C" {







#pragma extern errno

         extern int errno;



     }
#pragma extern perror, strerror
#pragma extern sys_nerr, sys_errlist 


extern "C" {

    extern void perror(const char*);
    extern char *strerror (int);

    extern int sys_nerr;
    extern char *sys_errlist[];
}
#pragma builtin_milli abs
#pragma extern abs

         inline int abs(int d) { return (d>0)?d:-d; }

extern "C" {





#pragma builtin_milli div, ldiv, labs
#pragma builtin rand, srand, atoi, exit, free 
#pragma extern __nl_char_size 

#pragma extern atof

#pragma extern atoi, atol, strtod, strtol, strtoul, rand
#pragma extern srand, atexit, exit, getenv, system, div, ldiv, labs 
#pragma extern mblen, mbtowc, wctomb, mbstowcs, wcstombs, free, qsort 


#pragma extern strtof
   extern int __nl_char_size;

   typedef struct {
        int quot;
        int rem;
   } div_t;
   typedef struct {
        long int quot;
        long int rem;
   } ldiv_t;




       extern double atof(const char *);

     extern int atoi(const char *);
     extern long int atol(const char *);
     extern double strtod(const char *, char **);
     extern long int strtol(const char *, char **, int);
   extern float strtof(const char *, char **);






     extern unsigned long int strtoul(const char *, char **, int);
     extern int rand(void);
     extern void srand(unsigned int);
     extern int atexit(void (*) (void));
     extern void exit(int);
     extern char *getenv(const char *);
     extern int system(const char *);
     extern div_t div(int, int);
     extern ldiv_t ldiv(long int, long int);
     extern long int labs(long int);
     extern int mblen(const char *, size_t);
     extern int mbtowc(wchar_t *, const char *, size_t);
     extern int wctomb(char *, wchar_t);
     extern size_t mbstowcs(wchar_t *, const char *, size_t);
     extern size_t wcstombs(char *, const wchar_t *, size_t);
     extern void free(void *);
     extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

#pragma builtin abort, calloc, malloc, realloc
#pragma extern bsearch, abort, calloc, malloc, realloc

       extern void abort(void);
       extern void *bsearch(const void *, const void *, size_t, size_t, int (*) (const void *, const void *));
       extern void *calloc(size_t, size_t);
       extern void *malloc(size_t);
       extern void *realloc(void *, size_t);

#pragma extern setkey, lcong48 
     extern void setkey(const char *);
     extern void lcong48( unsigned short [] );
#pragma extern drand48, erand48, jrand48, lrand48, mrand48, nrand48 
#pragma extern srand48, seed48, putenv
     extern double drand48(void);
     extern double erand48(unsigned short []);
     extern long jrand48(unsigned short []);
     extern long lrand48(void);
     extern long mrand48(void);
     extern long nrand48(unsigned short []);
     extern void srand48(long);
     extern unsigned short *seed48(unsigned short []);
     extern int putenv(const char *);
#pragma extern clearenv, getopt, getpass, memalign
#pragma extern optarg, optind, opterr
       extern int clearenv(void);
       extern int getopt(int, char * const [], const char *);
       extern char *getpass(const char *);
       extern void *memalign(size_t, size_t);







     extern char *optarg;
     extern int optind;
     extern int opterr;
    extern "C" {




#pragma extern wait, waitpid







       extern pid_t wait(int *);
       extern pid_t waitpid(pid_t, int *, int);







    }
typedef union sigval {




        struct {
                uint64_t __svi_pad1a;
                uint32_t __svi_pad1b;
                int __svi_int;
        } __svi_int_s;
        struct {
                uint64_t __svi_pad2a;
                uint32_t __svi_pad2b;
                void * __svi_ptr;
        } __svi_ptr_s;
   } sigval_t;
typedef int pthread_attr_t;




typedef struct sigevent {



      int __sigev_notify;
      int __sigev_signo;
      uint64_t __sigev_reserved0a;
      sigval_t __sigev_value;



      uint64_t __sigev_pad1a;
      uint32_t __sigev_pad1b;

      void (*__sigev_notify_function)(sigval_t);




      uint64_t __sigev_pad2a;
      uint32_t __sigev_pad2b;

      pthread_attr_t *__sigev_notify_attributes;
        uint64_t __sigev_reserved[8];




   } sigevent_t;


  enum __sigev_types {
          __SIGEV_NONE = 1,
          __SIGEV_SIGNAL

          ,__SIGEV_THREAD

  };

   struct tm {
      int tm_sec;
      int tm_min;
      int tm_hour;
      int tm_mday;
      int tm_mon;
      int tm_year;
      int tm_wday;
      int tm_yday;
      int tm_isdst;
   };

  struct timespec {
        time_t tv_sec;
        long tv_nsec;
};
typedef struct timespec timestruc_t;





struct itimerspec {
        struct timespec it_interval;
        struct timespec it_value;
};


typedef enum __clockid_t {
        CLOCK_INVALID = 0,
        CLOCK_REALTIME = 1,
        CLOCK_VIRTUAL = 2,
        CLOCK_PROFILE = 4,
        RTTIMER0 = 8,
        RTTIMER1 = 16
} clockid_t;



        typedef unsigned long timer_t;
        struct timeval {

                time_t tv_sec;



                long tv_usec;
        };



   struct itimerval {
        struct timeval it_interval;
        struct timeval it_value;
   };






   struct timezone {
        int tz_minuteswest;
        int tz_dsttime;
   };



   typedef struct __cycles {
        uint32_t hi;
        uint32_t lo;
   } cycles_t;
   extern "C" {





#pragma extern difftime 

     extern double difftime(time_t, time_t);






#pragma extern mktime 

     extern time_t mktime(struct tm *);






#pragma extern time 

     extern time_t time(time_t *);





#pragma extern asctime 

     extern char *asctime(const struct tm *);






#pragma extern ctime 

     extern char *ctime(const time_t *);






#pragma extern gmtime 

     extern struct tm *gmtime(const time_t *);






#pragma extern localtime 

     extern struct tm *localtime(const time_t *);






#pragma extern strftime 

     extern size_t strftime(char *, size_t, const char *, const struct tm *);


#pragma extern clock 

       extern clock_t clock(void);

#pragma extern tzset 






     extern void tzset(void);
#pragma extern tzname


   extern char *tzname[2];







#pragma extern clock_settime, clock_gettime, clock_getres 
#pragma extern timer_create, timer_delete, timer_settime 
#pragma extern timer_gettime, timer_getoverrun, nanosleep 


     extern int clock_settime(clockid_t, const struct timespec *);
     extern int clock_gettime(clockid_t, struct timespec *);
     extern int clock_getres(clockid_t, struct timespec *);
     extern int timer_create(clockid_t, struct sigevent *, timer_t *);
     extern int timer_delete(timer_t);
     extern int timer_settime(timer_t, int, const struct itimerspec *,
                              struct itimerspec *);
     extern int timer_gettime(timer_t, struct itimerspec *);
     extern int timer_getoverrun(timer_t);
     extern int nanosleep(const struct timespec *, struct timespec *);
#pragma extern strptime


#pragma extern timezone


#pragma extern daylight





         extern char *strptime(const char *, const char *, struct tm *);
       extern long timezone;




       extern int daylight;






   }
   extern "C" {




#pragma extern getitimer, setitimer, utimes, gettimeofday, select



     extern int getitimer(int, struct itimerval *);
     extern int setitimer(int, const struct itimerval *, struct itimerval *);
     extern int utimes(const char *, const struct timeval[2]);
     extern int gettimeofday(struct timeval *, void *);



       extern int select(int, fd_set *, fd_set *, fd_set *, struct timeval *);
   }






   extern "C" {





#pragma extern adjtime

#pragma extern getdate






#pragma extern settimeofday, stime, profil


     extern int adjtime(const struct timeval *, struct timeval *);



       extern struct tm *getdate(const char *);
     extern int settimeofday(const struct timeval *, const struct timezone *);
     extern int stime(const time_t *);
     extern void profil(void *, size_t, size_t, int);
#pragma extern getdate_err 

       extern int getdate_err;






   }
    struct ki_timeval {
            uint32_t pad1;
            uint32_t pad2;
    };
typedef uint64_t kt_t;
struct rlimit {
        rlim_t rlim_cur;
        rlim_t rlim_max;
};
struct rusage {
        struct timeval ru_utime;
        struct timeval ru_stime;

        long ru_maxrss;

        long ru_ixrss;
        long ru_idrss;
        long ru_isrss;
        long ru_minflt;
        long ru_majflt;
        long ru_nswap;
        long ru_inblock;
        long ru_oublock;
        long ru_ioch;
        long ru_msgsnd;
        long ru_msgrcv;
        long ru_nsignals;
        long ru_nvcsw;
        long ru_nivcsw;

};
   extern "C" {




#pragma extern getpriority, getrusage, setpriority 

#pragma extern getrlimit, setrlimit



   extern int getpriority (int, id_t);
   extern int getrusage (int, struct rusage *);
   extern int setpriority (int, id_t, int);

   extern int getrlimit (int, struct rlimit *);
   extern int setrlimit (int, const struct rlimit *);
   }
      extern "C" {




#pragma extern wait3







           extern pid_t wait3(int *, int, struct rusage *);
      }
typedef struct __siginfo {




        uint32_t __si_version, __si_size; int si_signo; int si_code; int si_errno; uint32_t __si_reserved0b; uint64_t __si_reserved0c; sigval_t si_value; union { struct { uint64_t __pad2a; uint32_t __pad2b; pid_t __pid; union { struct { uint64_t __pad2c; uint32_t __pad2d; uid_t __uid; } __kill; struct { uint64_t __pad2e; uint32_t __pad2f; int __status; } __SIGCLD; } __pdata; } __proc; struct { uint64_t __pad5a; uint32_t __pad5b; void *__addr; uint64_t __pad5c; uint32_t __pad5d; unsigned int __imm; } __fault; struct { uint64_t __pad6a; uint32_t __pad6b; int __fd; uint64_t __pad6c; uint32_t __pad6d; long __band; } __file; struct { uint64_t __pad7a; uint32_t __pad7b; void *__addr; uint64_t __pad7c; uint32_t __pad7d; void *__lockpage; uint64_t __pad7e; uint32_t __pad7f; long __dev_id; } __gfault; } __data;



        uint64_t __pad[8];




} siginfo_t;
enum __si_codes {
        SI_USER = -1,
        SI_QUEUE = -2,
        SI_TIMER = -3,
        SI_ASYNCIO= -4,
        SI_MESGQ = -5
};
     typedef struct __sigset_t {
          unsigned int sigset[8];
     } sigset_t;
typedef struct __stack {
        uint32_t __ss_pad0;
        void *ss_sp;
        uint32_t __ss_pad1;
        int ss_flags;
        uint32_t __ss_pad2;
        size_t ss_size;
        uint64_t __ss_reserved[5];
} stack_t;
typedef struct {
        long double __mc_opaque[2976];
} __mcontext_t;



typedef __mcontext_t mcontext_t;
typedef struct {

        uint32_t __uc_version;
        uint32_t __uc_size;
        int __uc_syscall;
        char __uc_syscall_action;
        char __uc_eosys;
        uint16_t __uc_errno;
        uint64_t __uc_pad0a;

        uint32_t __uc_pad0b;

        struct __ucontext *__uc_link;



        uint64_t __uc_pad4a;
        uint64_t __uc_rval1;
        uint64_t __uc_pad5a;
        uint64_t __uc_rval2;
        sigset_t __uc_sigmask;



        uint64_t __uc_pad6[4];
        stack_t __uc_stack;


        uint64_t __uc_arg[8];
        uint64_t __uc_pad7[8];
        uint64_t __uc_created_by_getcontext:1;
        uint64_t __uc_onstack:1;
        uint64_t __uc_reserved_flags:62;

        uint64_t __uc_core_lwpid;
        uint64_t __uc_core_user_tid;
        uint64_t __uc_core_sig;
        uint64_t __uc_core_code;



} __uc_misc_t;




typedef struct __ucontext {
        __uc_misc_t __uc_misc;






        double __uc_reserved[((1024 - sizeof(__uc_misc_t)) / sizeof(double))];
        mcontext_t __uc_mcontext;
} ucontext_t;

  typedef unsigned int sig_atomic_t;

   struct sigaction {
      union {



              void (*__sa_sigaction)(int, siginfo_t *, void *);







              void (*__sa_handler)(int);
      } __handler;

      sigset_t sa_mask;


      int sa_flags;
   };
typedef int pthread_t;
   struct sigstack {

        void *ss_sp;



        int ss_onstack;
   };
   struct sigvec {
      void (*sv_handler)(int);
      int sv_mask;
      int sv_flags;
   };
   extern "C" {





#pragma extern signal, raise




     extern void (*signal(int, void (*) (int)))(int);
     extern int raise(int);

#pragma extern kill, sigemptyset, sigfillset, sigaddset, sigdelset
#pragma extern sigismember, sigaction, sigprocmask, sigsuspend
#pragma extern sigpending
#pragma extern ___sysconf


     extern int kill(pid_t, int);
     extern int sigemptyset(sigset_t *);
     extern int sigfillset(sigset_t *);
     extern int sigaddset(sigset_t *, int);
     extern int sigdelset(sigset_t *, int);
     extern int sigismember(const sigset_t *, int);
     extern int sigaction(int, const struct sigaction *, struct sigaction *);
     extern int sigprocmask(int, const sigset_t *, sigset_t *);
     extern int sigsuspend(const sigset_t *);
     extern int sigpending(sigset_t *);
     extern long ___sysconf(int);
#pragma extern sigwait

#pragma extern pthread_sigmask, pthread_kill



     extern int sigwait(const sigset_t *set, int *sig);

     extern int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);
     extern int pthread_kill(pthread_t thread, int sig);
#pragma extern sigwaitinfo, sigtimedwait, sigqueue


     extern int sigwaitinfo(const sigset_t *set, siginfo_t *info);
     extern int sigtimedwait(const sigset_t *set, siginfo_t * info,
                             const struct timespec *timeout);
     extern int sigqueue(pid_t pid, int signo,
                         const union sigval value);
#pragma extern bsd_signal, killpg, sigaltstack, siginterrupt

#pragma extern sigstack



        extern void (*bsd_signal(int, void(*)(int)))(int);
        extern int killpg(pid_t, int);

        extern int sigstack(struct sigstack *, struct sigstack *);



        extern int sigaltstack(const stack_t *, stack_t *);
        extern int siginterrupt(int, int);
#pragma extern sigset, sighold, sigrelse, sigignore, sigpause


           extern void (*sigset(int, void (*)(int)))(int);
           extern int sighold(int);
           extern int sigrelse(int);
           extern int sigignore(int);
           extern int sigpause(int);
#pragma extern sigblock, sigsetmask, sigvector, ssignal, sigspace, gsignal





     extern long sigblock(long);
     extern long sigsetmask(long);
     extern int sigvector(int, const struct sigvec *, struct sigvec *);
     extern int (*ssignal(int, int (*) (int)))(int);



     extern ssize_t sigspace(ssize_t);
     extern int gsignal(int);
   }
struct sigcontext {
        struct __ucontext __uc;
};
typedef struct frame_marker {
        int __scratch[4];
} frame_marker_t;
typedef enum {
        P_PID,
        P_PGID,
        P_SID,
        P_UID,
        P_GID,
        P_CID,
        P_ALL,
        P_LWPID
} idtype_t;





      extern "C" {




#pragma extern waitid



        extern int waitid(idtype_t, id_t, siginfo_t *, int);





      }
   union wait {
        int w_status;



        struct {
                unsigned short w_pad;
                unsigned int w_Retcode:8;
                unsigned int w_Coredump:1;
                unsigned int w_Termsig:7;
        } w_T;





        struct {
                unsigned short w_pad;
                unsigned int w_Stopsig:8;
                unsigned int w_Stopval:8;
        } w_S;
   };
#pragma extern a64l, l64a, gcvt, getsubopt, grantpt, ptsname, realpath 
#pragma extern unlockpt, valloc, initstate, setstate 
#pragma extern srandom, random




#pragma extern mkstemp, mktemp, ttyslot
         extern int mkstemp(char *);
         extern char *mktemp(char *);
         extern int ttyslot(void);
     extern long a64l(const char *);
     extern char *l64a(long);




#pragma extern fcvt, ecvt 

      extern char *fcvt(double, int, int *, int *);
      extern char *ecvt(double, int, int *, int *);


    extern char *gcvt(double, int, char *);
    extern int getsubopt(char **, char * const *, char **);
    extern int grantpt(int);
    extern char *ptsname(int);
    extern char *realpath(const char *, char *);
    extern int unlockpt(int);
    extern void *valloc(size_t);
    extern char *initstate(unsigned int, char *, size_t);
    extern char *setstate(const char *);
    extern void srandom(unsigned int);
        extern long random(void);
  struct mallinfo {
        int32_t arena;
        int32_t ordblks;
        int32_t smblks;
        int32_t hblks;
        int32_t hblkhd;
        int32_t usmblks;
        int32_t fsmblks;
        int32_t uordblks;
        int32_t fordblks;
        int32_t keepcost;
  };
     typedef long double long_double;





#pragma extern _ldecvt, _ldfcvt, _ldgcvt, _extecvt, _extfcvt, ltostr
#pragma extern ultostr, ltoa, ultoa, mallinfo, mallopt, strtold
extern "C" {




   struct passwd {
        char *pw_name;
        char *pw_passwd;
        uid_t pw_uid;
        gid_t pw_gid;
        char *pw_age;
        char *pw_comment;
        char *pw_gecos;
        char *pw_dir;
        char *pw_shell;
        int32_t pw_audid;
        int pw_audflg;
   };


#pragma extern getpwuid, getpwnam
     extern struct passwd *getpwuid(uid_t);
     extern struct passwd *getpwnam(const char *);
#pragma extern endpwent, getpwent, setpwent
     extern void endpwent(void);
     extern struct passwd *getpwent(void);
     extern void setpwent(void);
   struct s_passwd {
       char *pw_name;
       char *pw_passwd;
       char *pw_age;
       int32_t pw_audid;
       int pw_audflg;
   };



#pragma extern putpwent, fgetpwent, getspwent, getspwuid, getspwaid
#pragma extern getspwnam, fgetspwent, setspwent, endspwent
         extern int putpwent(const struct passwd *, FILE *);
     extern struct passwd *fgetpwent(FILE *);
     extern struct s_passwd *getspwent(void);
     extern struct s_passwd *getspwuid(uid_t);
     extern struct s_passwd *getspwaid(int32_t);
     extern struct s_passwd *getspwnam(char *);
     extern struct s_passwd *fgetspwent(FILE *);
     extern void setspwent(void);
     extern void endspwent(void);
}
     extern char *_ldecvt(long_double, int, int *, int *);
     extern char *_ldfcvt(long_double, int, int *, int *);
     extern char *_ldgcvt(long_double, int, char *);

       extern char *_extecvt(long double, int, int *, int *);
       extern char *_extfcvt(long double, int, int *, int *);



#pragma extern getpw, l3tol, ltol3

     extern int getpw(int, char *);
     extern void l3tol(long *, const char *, int);
     extern void ltol3(char *, const long *, int);
     extern char *ltostr(long, int);
     extern char *ultostr(unsigned long, int);
     extern char *ltoa(long);
     extern char *ultoa(unsigned long);





     extern struct mallinfo mallinfo(void);
     extern int mallopt(int, int);
     extern long_double strtold(const char *, char **);
}
inline long abs (long a) { return labs( a ); }
inline ldiv_t div (long a, long b) { return ldiv( a, b ); }







namespace std
{




using ::div_t;
using ::ldiv_t;
using ::size_t;




using ::abort;
using ::abs;
using ::atexit;
using ::atof;
using ::atoi;
using ::atol;
using ::bsearch;
using ::calloc;
using ::div;
using ::exit;
using ::free;
using ::getenv;
using ::labs;
using ::ldiv;
using ::malloc;
using ::mblen;
using ::mbstowcs;
using ::mbtowc;
using ::qsort;
using ::rand;
using ::realloc;
using ::srand;
using ::strtod;
using ::strtol;
using ::strtoul;
using ::system;
using ::wcstombs;
using ::wctomb;

}
namespace __rw {

template <bool b>
struct __rw_compile_assert;

template<>
struct __rw_compile_assert<true> { enum { ok }; };




}
template <class _TypeUnused, bool b>
struct _C_dispatch { };

template <class _TypeUnused>
struct _C_dispatch <_TypeUnused, true> { };

    typedef long ptrdiff_t;







namespace std
{




using ::ptrdiff_t;
using ::size_t;

}
namespace std {


struct input_iterator_tag { };
struct output_iterator_tag { };
struct forward_iterator_tag : public input_iterator_tag { };
struct bidirectional_iterator_tag : public forward_iterator_tag { };
struct random_access_iterator_tag : public bidirectional_iterator_tag { };


template <class _Category, class _TypeT,
          class _Distance = ptrdiff_t,
          class _Pointer = _TypeT*,
          class _Reference = _TypeT&>
struct iterator
{
    typedef _TypeT value_type;
    typedef _Distance difference_type;
    typedef _Pointer pointer;
    typedef _Reference reference;
    typedef _Category iterator_category;
};




template <class _Iterator>
struct iterator_traits
{
    typedef typename _Iterator::value_type value_type;
    typedef typename _Iterator::difference_type difference_type;
    typedef typename _Iterator::pointer pointer;
    typedef typename _Iterator::reference reference;
    typedef typename _Iterator::iterator_category iterator_category;
};


template <class _TypeT>
struct iterator_traits<_TypeT*>
{
    typedef _TypeT value_type;
    typedef ptrdiff_t difference_type;
    typedef value_type* pointer;
    typedef value_type& reference;
    typedef random_access_iterator_tag iterator_category;
};


template <class _TypeT>
struct iterator_traits<const _TypeT*>
{
    typedef _TypeT value_type;
    typedef ptrdiff_t difference_type;
    typedef const value_type* pointer;
    typedef const value_type& reference;
    typedef random_access_iterator_tag iterator_category;
};


template <class _ForwardIterator>
inline typename iterator_traits<_ForwardIterator>::difference_type
distance (_ForwardIterator __first, _ForwardIterator __last)
{
    typename iterator_traits<_ForwardIterator>::difference_type __n = 0;

    __distance (__first, __last, __n,
                typename iterator_traits< _ForwardIterator >::iterator_category ());

    return __n;
}


template <class _ForwardIterator, class _Distance>
inline void advance (_ForwardIterator& __i, _Distance __n)
{
    __advance (__i, __n, typename iterator_traits< _ForwardIterator >::iterator_category ());
}
template <class _TypeT>
inline random_access_iterator_tag __iterator_category (const _TypeT*)
{
    return random_access_iterator_tag ();
}


template <class _Category, class _TypeT, class _Distance,
          class _Pointer, class _Reference>
inline _Category
__iterator_category (const iterator<_Category, _TypeT,
                                    _Distance, _Pointer, _Reference>&)
{

    typedef typename iterator<_Category, _TypeT, _Distance, _TypeT*,
                               _TypeT&>::iterator_category _IterCategory;

    return _IterCategory ();
}





template <class _Tag>
inline bool __is_input_iterator (_Tag)
{
    return false;
}

template <class _Tag>
inline bool __is_bidirectional_iterator (_Tag)
{
    return false;
}

template <class _Tag>
inline bool __is_random_access_iterator (_Tag)
{
    return false;
}

template<>
inline bool __is_input_iterator (input_iterator_tag)
{
    return true;
}

template<>
inline bool __is_bidirectional_iterator (bidirectional_iterator_tag)
{
    return true;
}

template<>
inline bool __is_bidirectional_iterator (random_access_iterator_tag)
{
    return true;
}

template<>
inline bool __is_random_access_iterator (random_access_iterator_tag)
{
    return true;
}
template <class _Iterator>
inline typename iterator_traits<_Iterator>::value_type*
__value_type (_Iterator)
{
    return 0;
}
template <class _Iterator>
inline typename iterator_traits<_Iterator>::difference_type*
__distance_type (_Iterator)
{
    return 0;
}
template <class _InputIterator, class _Distance>
inline void __advance (_InputIterator &__i, _Distance __n, input_iterator_tag)
{
    while (__n > 0) {
        --__n;
        ++__i;
    }
}


template <class _ForwardIterator, class _Distance>
inline void __advance (_ForwardIterator &__i, _Distance __n,
                       forward_iterator_tag)
{
    __advance (__i, __n, input_iterator_tag ());
}


template <class _BidirectionalIterator, class _Distance>
inline void __advance (_BidirectionalIterator &__i, _Distance __n,
                       bidirectional_iterator_tag)
{
    if (__n > 0)
        __advance (__i, __n, input_iterator_tag ());
    else
        while (__n) {
            ++__n;
            --__i;
        }
}


template <class _InputIterator, class _Distance>
inline void __distance (const _InputIterator &__first,
                        const _InputIterator &__last,
                        _Distance &__n,
                        input_iterator_tag)
{
    for (_InputIterator __it = __first; __it != __last; ++__it)
        ++__n;
}


template <class _ForwardIterator, class _Distance>
inline void __distance (const _ForwardIterator &__first,
                        const _ForwardIterator &__last,
                        _Distance &__n,
                        forward_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}

template <class _BidirectionalIterator, class _Distance>
inline void __distance (const _BidirectionalIterator &__first,
                        const _BidirectionalIterator &__last,
                        _Distance &__n,
                        bidirectional_iterator_tag)
{
    __distance (__first, __last, __n, input_iterator_tag ());
}


template <class _RandomAccessIterator, class _Distance>
inline void __distance (const _RandomAccessIterator &__first,
                        const _RandomAccessIterator &__last,
                        _Distance &__n,
                        random_access_iterator_tag)
{
    __n = __last - __first;
}


template <class _RandomAccessIterator, class _Distance>
inline void __advance (_RandomAccessIterator& __i, _Distance __n,
                       random_access_iterator_tag)
{
    __i += __n;
}


template <class _ForwardIterator, class _Distance>
inline void distance (const _ForwardIterator &__first,
                      const _ForwardIterator &__last,
                      _Distance &__n)
{
    __distance (__first, __last, __n,
                typename iterator_traits< _ForwardIterator >::iterator_category ());
}


}

namespace __rw {

using namespace std;






template <class _ForwardIterator, class _Distance>
inline _Distance
__rw_distance (const _ForwardIterator &__first,
               const _ForwardIterator &__last,
               _Distance __n)
{
    std::__distance (__first, __last, __n,
                      typename iterator_traits< _ForwardIterator >::iterator_category ());
    return __n;
}


}

namespace std {
template <class _Iterator>
class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
                      typename iterator_traits<_Iterator>::value_type,
                      typename iterator_traits<_Iterator>::difference_type,
                      typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
{
    typedef iterator_traits<_Iterator> traits_type;
public:
    typedef typename traits_type::difference_type difference_type;
    typedef typename traits_type::value_type value_type;
    typedef typename traits_type::pointer pointer;
    typedef typename traits_type::reference reference;
    typedef _Iterator iterator_type;

    reverse_iterator () { }

    explicit reverse_iterator (iterator_type __rhs) : current (__rhs) { }





      template <class _TypeU>
      reverse_iterator (const reverse_iterator<_TypeU>& __rhs)
          : current (__rhs.base ()) { }
    iterator_type base () const {
        return current;
    }

    reference operator* () const {
        iterator_type __tmp = base ();
        return *--__tmp;
    }

    pointer operator->() const { return &**this; };

    reverse_iterator& operator++ () {
        return --current, *this;
    }

    reverse_iterator operator++ (int) {
        reverse_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }

    reverse_iterator& operator-- () {
        return ++current, *this;
    }

    reverse_iterator operator-- (int) {
        reverse_iterator __tmp = *this;
        --*this;
        return __tmp;
    }

    reverse_iterator& operator+= (difference_type __n) {
        return current -= __n, *this;
    }

    reverse_iterator& operator-= (difference_type __n) {
        return *this += -__n;
    }

    reverse_iterator operator+ (difference_type __n) const {
        return reverse_iterator (*this) += __n;
    }

    reverse_iterator operator- (difference_type __n) const {
        return reverse_iterator (*this) -= __n;
    }

    reference operator[] (difference_type __n) const {
        return *(*this + __n);
    }

protected:

    iterator_type current;
};


template <class _Iterator>
inline bool operator== (const reverse_iterator <_Iterator>& __x,
                        const reverse_iterator <_Iterator>& __y)
{
    return __x.base () == __y.base ();
}


template <class _Iterator>
inline bool operator< (const reverse_iterator <_Iterator>& __x,
                       const reverse_iterator <_Iterator>& __y)
{
    return __y.base() < __x.base();
}


template <class _Iterator>
inline bool operator!= (const reverse_iterator <_Iterator>& __x,
                        const reverse_iterator <_Iterator>& __y)
{
    return !(__x == __y);
}


template <class _Iterator>
inline bool operator> (const reverse_iterator <_Iterator>& __x,
                       const reverse_iterator <_Iterator>& __y)
{
    return __y < __x;
}


template <class _Iterator>
inline bool operator<= (const reverse_iterator <_Iterator>& __x,
                        const reverse_iterator <_Iterator>& __y)
{
    return !(__y < __x);
}


template <class _Iterator>
inline bool operator>= (const reverse_iterator <_Iterator>& __x,
                        const reverse_iterator <_Iterator>& __y)
{
    return !(__x < __y);
}


template <class _Iterator>
inline typename iterator_traits<_Iterator>::difference_type
operator- (const reverse_iterator <_Iterator>& __x,
           const reverse_iterator <_Iterator>& __y)
{
    return __y.base () - __x.base ();
}


template <class _Iterator>
inline reverse_iterator <_Iterator>
operator+ (typename iterator_traits<_Iterator>::difference_type __n,
           const reverse_iterator <_Iterator>& __x)
{
    return __x + __n;
}
template <class _Container>
class back_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit back_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    back_insert_iterator&
    operator= (typename container_type::const_reference __x) {
        return container->push_back (__x), *this;
    }

    back_insert_iterator& operator* () {
        return *this;
    }

    back_insert_iterator& operator++ () {
        return *this;
    }

    back_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline back_insert_iterator<_Container> back_inserter (_Container& __x)
{
    return back_insert_iterator<_Container>(__x);
}


template <class _Container>
class front_insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    explicit front_insert_iterator (container_type& __rhs)
        : container (&__rhs) { }

    front_insert_iterator&
    operator= (typename container_type::const_reference __x) {
        return container->push_front (__x), *this;
    }

    front_insert_iterator& operator* () {
        return *this;
    }

    front_insert_iterator& operator++ () {
        return *this;
    }

    front_insert_iterator operator++ (int) {
        return *this;
    }

protected:

    container_type* container;
};


template <class _Container>
inline front_insert_iterator<_Container> front_inserter (_Container& __x)
{
    return front_insert_iterator<_Container>(__x);
}


template <class _Container>
class insert_iterator: public iterator<output_iterator_tag, void, void, void, void>
{
public:
    typedef _Container container_type;

    insert_iterator (container_type& __x,
                     typename container_type::iterator __i)
      : iter (__i), container (&__x) { }

    insert_iterator&
    operator= (typename container_type::const_reference __x) {
        iter = container->insert (iter, __x);
        return ++iter, *this;
    }

    insert_iterator& operator* () {
        return *this;
    }

    insert_iterator& operator++ () {
        return *this;
    }

    insert_iterator& operator++ (int) {
        return *this;
    }

protected:

    typename container_type::iterator iter;
    container_type* container;
};


template <class _Container, class _Iterator>
inline insert_iterator<_Container> inserter (_Container& __x, _Iterator __i)
{
    return insert_iterator<_Container> (__x,
                                        typename _Container::iterator (__i));
}


}
extern const char* __no_named_exception;
extern const char* __bad_exception;


namespace std {


  class exception {
  public:
    exception() throw() {}
    exception(const exception&) throw() {}
    exception& operator=(const exception&) throw() { return *this; }
    virtual ~exception() throw();
    virtual const char* what() const throw() {
      return __no_named_exception;
    }
  };

  class bad_exception : public exception {
  public:
    bad_exception() throw() {}
    virtual ~bad_exception() throw() {}
    virtual const char* what() const throw() {
      return __bad_exception;
    }
  };

  typedef void (*unexpected_handler)();
  unexpected_handler set_unexpected(unexpected_handler f) throw();
  void unexpected();
  typedef void (*terminate_handler)();
  terminate_handler set_terminate(terminate_handler f) throw();
  void terminate();
  bool uncaught_exception();


}
namespace std {



template <class _CharT, class _Traits, class _Allocator>
class basic_string;

template <class _CharT>
struct char_traits;

template <class _TypeT>
class allocator;


typedef basic_string<char, char_traits<char>, allocator<char> > string;



class __rw_exception: public exception
{
    char *_C_what;

    __rw_exception& _C_assign (const char*,
                               size_t __len = ~0) throw();

    __rw_exception& _C_vformat (const char*,
                                __builtin_va_list) throw();

    __rw_exception& _C_vformat (int, __builtin_va_list) throw();

public:

    __rw_exception () throw()
    : exception (), _C_what (0) { }

    __rw_exception (const __rw_exception &__rhs) throw()
    : exception (__rhs), _C_what (0) {
        *this = __rhs;
    }

    explicit __rw_exception (const string& __what) throw();

    explicit __rw_exception (const char* __what) throw()
    : exception (), _C_what (0) {
        _C_assign (__what);
    }

    explicit __rw_exception (int __id) throw()
    : _C_what (0) {
        _C_format (__id);
    }

    virtual ~__rw_exception () throw() {
        delete[] _C_what;
    }

    __rw_exception&
    operator= (const __rw_exception &__rhs) throw() {
        return _C_assign (__rhs.what ()), *this;
    }

    virtual const char* what () const throw() {
        return _C_what;
    }


    __rw_exception& _C_format (const char*, ...) throw();


    __rw_exception& _C_format (int, ...) throw();
};


inline __rw_exception&
__rw_exception::_C_format (const char *__fmat, ...) throw()
{
    __builtin_va_list __arg;
    __builtin_stdarg_start(__arg);

    _C_vformat (__fmat, __arg);

    (void)0;

    return *this;
}


inline __rw_exception&
__rw_exception::_C_format (int __fmat_id, ...) throw()
{
    __builtin_va_list __arg;
    __builtin_stdarg_start(__arg);

    _C_vformat (__fmat_id, __arg);

    (void)0;

    return *this;
}


}






namespace std {





class logic_error: public __rw_exception
{
public:
    explicit logic_error (const string& __str) throw()
    : __rw_exception (__str) { }


    explicit logic_error (const char *__s = 0) throw()
    : __rw_exception (__s) { }
};
class domain_error : public logic_error
{
public:
    explicit domain_error (const string &__str) throw()
    : logic_error (__str) { }


    explicit domain_error (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class invalid_argument : public logic_error
{
public:
    explicit invalid_argument (const string &__str) throw()
    : logic_error (__str) { }


    explicit invalid_argument (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class length_error : public logic_error
{
public:
    explicit length_error (const string &__str) throw()
    : logic_error (__str) { }


    explicit length_error (const char *__s = 0) throw()
    : logic_error (__s) { }
};



class out_of_range : public logic_error
{
public:
    explicit out_of_range (const string &__str) throw()
    : logic_error (__str) { }


    explicit out_of_range (const char *__s = 0) throw()
    : logic_error (__s) { }
};






class runtime_error : public __rw_exception
{
public:
    explicit runtime_error (const string &__str) throw()
    : __rw_exception (__str) { }


    explicit runtime_error (const char *__s = 0) throw()
    : __rw_exception (__s) { }
};



class range_error : public runtime_error
{
public:
    explicit range_error (const string &__str) throw()
    : runtime_error (__str) { }


    explicit range_error (const char *__s = 0) throw()
    : runtime_error (__s) { }
};



class overflow_error : public runtime_error
{
public:
    explicit overflow_error (const string &__str) throw()
    : runtime_error (__str) { }


    explicit overflow_error (const char *__s = 0) throw()
    : runtime_error (__s) { }
};



class underflow_error : public runtime_error
{
public:
    explicit underflow_error (const string &__str) throw()
    : runtime_error (__str) { }


    explicit underflow_error (const char *__s = 0) throw()
    : runtime_error (__s) { }
};


}
extern "C" {
#pragma builtin acos, asin, atan, atan2, cos, sin, tan, cosh, sinh, tanh, exp, ldexp, log, log10, modf, pow, sqrt, ceil, fabs, floor, fmod 






   extern double acos(double);
   extern double asin(double);
   extern double atan(double);
   extern double atan2(double, double);
   extern double cos(double);
   extern double sin(double);
   extern double tan(double);
   extern double cosh(double);
   extern double sinh(double);
   extern double tanh(double);
   extern double exp(double);
   extern double frexp(double, int *);
   extern double ldexp(double, int);
   extern double log(double);
   extern double log10(double);
   extern double modf(double, double *);
   extern double pow(double, double);
   extern double sqrt(double);
   extern double ceil(double);
   extern double fabs(double);
   extern double floor(double);
   extern double fmod(double, double);


#pragma builtin acosf, asinf, atanf, atan2f, cosf, sinf, tanf, coshf, sinhf, tanhf, expf, ldexpf, logf, log10f, modff, powf, sqrtf, ceilf, fabsf, floorf, fmodf 


     extern float acosf(float);
     extern float asinf(float);
     extern float atanf(float);
     extern float atan2f(float, float);
     extern float cosf(float);
     extern float sinf(float);
     extern float tanf(float);
     extern float coshf(float);
     extern float sinhf(float);
     extern float tanhf(float);
     extern float expf(float);
     extern float frexpf(float, int *);
     extern float ldexpf(float, int);
     extern float logf(float);
     extern float log10f(float);
     extern float modff(float, float *);
     extern float powf(float, float);
     extern float sqrtf(float);
     extern float ceilf(float);
     extern float fabsf(float);
     extern float floorf(float);
     extern float fmodf(float, float);

#pragma builtin acosl, asinl, atanl, atan2l, cosl, sinl, tanl, coshl, sinhl, tanhl, expl, ldexpl, logl, log10l, modfl, powl, sqrtl, ceill, fabsl, floorl, fmodl 


     extern long double acosl(long double);
     extern long double asinl(long double);
     extern long double atanl(long double);
     extern long double atan2l(long double, long double);
     extern long double cosl(long double);
     extern long double sinl(long double);
     extern long double tanl(long double);
     extern long double coshl(long double);
     extern long double sinhl(long double);
     extern long double tanhl(long double);
     extern long double expl(long double);
     extern long double frexpl(long double, int *);
     extern long double ldexpl(long double, int);
     extern long double logl(long double);
     extern long double log10l(long double);
     extern long double modfl(long double, long double *);
     extern long double powl(long double, long double);
     extern long double sqrtl(long double);
     extern long double ceill(long double);
     extern long double fabsl(long double);
     extern long double floorl(long double);
     extern long double fmodl(long double, long double);
   extern int signgam;
#pragma builtin erf, erfc, gamma, hypot, isnan, j0, j1, jn, lgamma, y0, y1, yn 




     extern double erf(double);
     extern double erfc(double);
     extern double gamma(double);
     extern double hypot(double, double);
     extern int isnan(double);
     extern double j0(double);
     extern double j1(double);
     extern double jn(int, double);
     extern double lgamma(double);
     extern double y0(double);
     extern double y1(double);
     extern double yn(int, double);
#pragma builtin acosh, asinh, atanh, cbrt, expm1, ilogb, log1p, logb, nextafter, remainder, rint, scalb 




     extern double acosh(double);
     extern double asinh(double);
     extern double atanh(double);
     extern double cbrt(double);
     extern double expm1(double);
     extern int ilogb(double);
     extern double log1p(double);
     extern double logb(double);
     extern double nextafter(double, double);
     extern double remainder(double, double);
     extern double rint(double);
     extern double scalb(double,double);
       typedef float float_t;
       typedef double double_t;
#pragma builtin copysign, log2, exp2, fdim, fmax, fmin, nan, scalbn, nearbyint, round, trunc, lrint, lround, _iround, cosd, sind, tand, exp10, _pown, compound, annuity, fma, scalbln, tgamma, nexttoward, acosd, asind, atand, atan2d, _iceil, _ifloor





#pragma builtin llrint, llround, _powlln, _llceil, _llfloor




     extern double copysign(double, double);
     extern double log2(double);
     extern double lgamma_r(double, int *);
     extern double exp2(double);
     extern double fdim(double, double);
     extern double fmax(double, double);
     extern double fmin(double, double);
     extern double nan(const char *);
     extern double scalbn(double, int);
     extern double nearbyint(double);
     extern double round(double);
     extern double trunc(double);
     extern double remquo(double, double, int *);
     extern long lrint(double);
     extern long lround(double);

       extern long long llrint(double);
       extern long long llround(double);

     extern double cosd(double);
     extern double sind(double);
     extern double tand(double);

       extern double exp10(double);
       extern double _pown(double, int);
       extern int _iround(double);
       extern int _iceil(double);
       extern int _ifloor(double);

         extern double _powlln(double, long long);
         extern long long _llceil(double);
         extern long long _llfloor(double);

       extern double compound(double, double);
       extern double annuity(double, double);
       extern double fma(double, double, double);
       extern double scalbln(double, long);
       extern double tgamma(double);
       extern double nexttoward(double, long double);

     extern double acosd(double);
     extern double asind(double);
     extern double atand(double);
     extern double atan2d(double, double);
#pragma builtin cbrtf, copysignf, nextafterf, log2f, cosdf, sindf, tandf, acosdf, asindf, atandf, atan2df, exp2f, exp10f, expm1f, log1pf, _pownf, fmaf, acoshf, asinhf, atanhf, logbf, scalbf, scalbnf, scalblnf, ilogbf, hypotf, compoundf, annuityf, erff, erfcf, gammaf, lgammaf, tgammaf, nearbyintf, rintf, roundf, lrintf, lroundf, _iroundf, truncf, nanf, remainderf, fdimf, fmaxf, fminf, nextafttowardf, _iceilf, _ifloorf
#pragma builtin _powllnf, llrintf, llroundf, _llceilf, _llfloorf 



     extern float cbrtf(float);
     extern float copysignf(float, float);
     extern float nextafterf(float, float);
     extern float log2f(float);
     extern float cosdf(float);
     extern float sindf(float);
     extern float tandf(float);
     extern float acosdf(float);
     extern float asindf(float);
     extern float atandf(float);
     extern float atan2df(float, float);

       extern float exp2f(float);
       extern float exp10f(float);
       extern float expm1f(float);
       extern float log1pf(float);
       extern float _pownf(float, int);

         extern float _powllnf(float, long long);

       extern float fmaf(float, float, float);
       extern float acoshf(float);
       extern float asinhf(float);
       extern float atanhf(float);
       extern float logbf(float);
       extern float scalbf(float, float);
       extern float scalbnf(float, int);
       extern float scalblnf(float, long);
       extern int ilogbf(float);
       extern float hypotf(float, float);
       extern float compoundf(float, float);
       extern float annuityf(float, float);
       extern float erff(float);
       extern float erfcf(float);
       extern float gammaf(float);
       extern float lgammaf(float);
       extern float lgammaf_r(float, int *);
       extern float tgammaf(float);
       extern float nearbyintf(float);
       extern float rintf(float);
       extern float roundf(float);
       extern long lrintf(float);
       extern long lroundf(float);
       extern int _iroundf(float);
       extern int _iceilf(float);
       extern int _ifloorf(float);

         extern long long llrintf(float);
         extern long long llroundf(float);
         extern long long _llceilf(float);
         extern long long _llfloorf(float);

       extern float truncf(float);
       extern float nanf(const char *);
       extern float remainderf(float, float);
       extern float remquof(float, float, int *);
       extern float fdimf(float, float);
       extern float fmaxf(float, float);
       extern float fminf(float, float);
       extern float nexttowardf(float, long double);
#pragma builtin acosdl, asindl, atandl, atan2dl, acoshl, asinhl, atanhl, cosdl, sindl, tandl, exp2l, exp10l, expm1l, log2l, log1pl, logbl, scalbl, scalbnl, scalblnl, ilogbl, fabsl, _pownl, hypotl, cbrtl, compoundl, annuityl, erfl, erfcl, gammal, lgammal, tgammal, nearbyintl, rintl, roundl, lrintl, lroundl, _iroundl, truncl, nanl, remainderl, copysignl, nextafterl, nexttowardl, fdiml, fmaxl, fminl, fmal, _iceill, _ifloorl
#pragma builtin _powllnl, llrintl, llroundl, _llceill, _llfloorl 

       extern long double acosdl(long double);
       extern long double asindl(long double);
       extern long double atandl(long double);
       extern long double atan2dl(long double, long double);
       extern long double acoshl(long double);
       extern long double asinhl(long double);
       extern long double atanhl(long double);
       extern long double cosdl(long double);
       extern long double sindl(long double);
       extern long double tandl(long double);
       extern long double exp2l(long double);
       extern long double exp10l(long double);
       extern long double expm1l(long double);
       extern long double log2l(long double);
       extern long double log1pl(long double);
       extern long double logbl(long double);
       extern long double scalbl(long double, long double);
       extern long double scalbnl(long double, int);
       extern long double scalblnl(long double, long);
       extern int ilogbl(long double);
       extern long double _pownl(long double, int);

         extern long double _powllnl(long double, long long);

       extern long double hypotl(long double, long double);
       extern long double cbrtl(long double);
       extern long double compoundl(long double, long double);
       extern long double annuityl(long double, long double);
       extern long double erfl(long double);
       extern long double erfcl(long double);
       extern long double gammal(long double);
       extern long double lgammal(long double);
       extern long double lgammal_r(long double, int *);
       extern long double tgammal(long double);
       extern long double nearbyintl(long double);
       extern long double rintl(long double);
       extern long double roundl(long double);
       extern long lrintl(long double);
       extern long lroundl(long double);
       extern int _iroundl(long double);
       extern int _iceill(long double);
       extern int _ifloorl(long double);

         extern long long llrintl(long double);
         extern long long llroundl(long double);
         extern long long _llceill(long double);
         extern long long _llfloorl(long double);

       extern long double truncl(long double);
       extern long double nanl(const char *);
       extern long double remainderl(long double, long double);
       extern long double remquol(long double, long double, int *);
       extern long double copysignl(long double, long double);
       extern long double nextafterl(long double, long double);
       extern long double nexttowardl(long double, long double);
       extern long double fdiml(long double, long double);
       extern long double fmaxl(long double, long double);
       extern long double fminl(long double, long double);
       extern long double fmal(long double, long double, long double);
#pragma extern _DINFINITY



   extern const double _DINFINITY;
#pragma extern _SINFINITY, _LINFINITY, _WINFINITY, _SQNAN



     extern const float _SINFINITY;

       extern const long double _LINFINITY;




     extern const float _SQNAN;
     extern int _Isfinite(double);
     extern int _Isinf(double);
     extern int _Isnormal(double);
     extern int _Signbit(double);
     extern int _Isunordered(double, double);
     extern int _Isless(double, double);
     extern int _Islessequal(double, double);
     extern int _Isgreater(double, double);
     extern int _Isgreaterequal(double, double);
     extern int _Islessgreater(double, double);
     extern int _Isnanf(float);
     extern int _Isfinitef(float);
     extern int _Isinff(float);
     extern int _Isnormalf(float);
     extern int _Signbitf(float);
     extern int _Isunorderedf(float, float);
     extern int _Islessf(float, float);
     extern int _Islessequalf(float, float);
     extern int _Isgreaterf(float, float);
     extern int _Isgreaterequalf(float, float);
     extern int _Islessgreaterf(float, float);

       extern int _Fpclass(double);
       extern int _Fpclassf(float);
       extern int _Isnanf128(long double);
       extern int _Isfinitef128(long double);
       extern int _Isinff128(long double);
       extern int _Isnormalf128(long double);
       extern int _Signbitf128(long double);
       extern int _Isunorderedf128(long double,long double);
       extern int _Islessf128(long double,long double);
       extern int _Islessequalf128(long double,long double);
       extern int _Isgreaterf128(long double,long double);
       extern int _Isgreaterequalf128(long double,long double);
       extern int _Islessgreaterf128(long double,long double);
       extern int _Fpclassf128(long double);
}
inline double abs (double x) { return fabs(x); }


inline double pow(double x, int y) { return _pown(x, y); }
inline float acos (float x) { return acosf(x); }
inline float asin (float x) { return asinf(x); }
inline float atan (float x) { return atanf(x); }
inline float atan2(float x, float y) { return atan2f(x, y); }
inline float cos (float x) { return cosf(x); }
inline float cosh (float x) { return coshf(x); }
inline float exp (float x) { return expf(x); }
inline float fmod (float x, float y) { return fmodf(x, y); }
inline float log (float x) { return logf(x); }
inline float log10(float x) { return log10f(x); }
inline float pow (float x, float y) { return powf(x, y); }
inline float sin (float x) { return sinf(x); }
inline float sinh (float x) { return sinhf(x); }
inline float tan (float x) { return tanf(x); }
inline float tanh (float x) { return tanhf(x); }
inline float sqrt (float x) {

#pragma STDC FENV_ACCESS ON

        return sqrtf(x);
}







inline float fabs (float x) { return fabsf(x); }
inline float abs (float x) { return fabsf(x); }

inline float ceil (float x) { return ceilf(x); }
inline float floor(float x) { return floorf(x); }
inline float frexp(float x, int *eptr) { return frexpf(x, eptr); }
inline float ldexp(float x, int e) { return ldexpf(x, e); }
inline float modf (float x, float *iptr) { return modff(x, iptr); }

inline float pow (float x, int y) { return _pownf(x, y); }
inline long double abs (long double x) { return fabsl(x); }
inline long double acos (long double x) { return acosl(x); }
inline long double asin (long double x) { return asinl(x); }
inline long double atan (long double x) { return atanl(x); }
inline long double atan2(long double x, long double y) { return atan2l(x, y); }
inline long double ceil (long double x) { return ceill(x); }
inline long double cos (long double x) { return cosl(x); }
inline long double cosh (long double x) { return coshl(x); }
inline long double exp (long double x) { return expl(x); }
inline long double fabs (long double x) { return fabsl(x); }
inline long double floor(long double x) { return floorl(x); }
inline long double frexp(long double x, int *eptr) { return frexpl(x, eptr); }
inline long double ldexp(long double x, int e) { return ldexpl(x, e); }
inline long double log (long double x) { return logl(x); }
inline long double log10(long double x) { return log10l(x); }
inline long double modf (long double x, long double *iptr) { return modfl(x,iptr); }
inline long double pow (long double x, long double y) { return powl(x, y); }

inline long double pow (long double x, int y) { return _pownl(x, y); }



inline long double sin (long double x) { return sinl(x); }
inline long double sqrt (long double x) { return sqrtl(x); }
inline long double sinh (long double x) { return sinhl(x); }
inline long double tan (long double x) { return tanl(x); }
inline long double tanh (long double x) { return tanhl(x); }
inline float cbrt(float x) { return cbrtf(x); }



inline float copysign(float x, float y) { return copysignf(x, y); }

inline float nextafter(float x, float y) { return nextafterf(x, y); }
inline float log2(float x) { return log2f(x); }
inline float cosd(float x) { return cosdf(x); }
inline float sind(float x) { return sindf(x); }
inline float tand(float x) { return tandf(x); }
inline float acosd(float x) { return acosdf(x); }
inline float asind(float x) { return asindf(x); }
inline float atand(float x) { return atandf(x); }
inline float atan2d(float x, float y) { return atan2df(x, y); }
inline float exp2(float x) { return exp2f(x); }
inline float exp10(float x) { return exp10f(x); }
inline float expm1(float x) { return expm1f(x); }
inline float log1p(float x) { return log1pf(x); }






inline float fma(float x, float y, float z) { return fmaf(x, y, z); }

inline float acosh(float x) { return acoshf(x); }
inline float asinh(float x) { return asinhf(x); }
inline float atanh(float x) { return atanhf(x); }
inline float logb(float x) { return logbf(x); }
inline float scalbn(float x, int n) { return scalbnf(x, n); }
inline float scalbln(float x, long n) { return scalblnf(x, n); }
inline int ilogb(float x) { return ilogbf(x); }
inline float hypot(float x, float y) { return hypotf(x,y); }
inline float compound(float x, float y) { return compoundf(x,y); }
inline float annuity(float x, float y) { return annuityf(x,y); }
inline float erf(float x) { return erff(x); }
inline float erfc(float x) { return erfcf(x); }
inline float gamma(float x) { return gammaf(x); }
inline float lgamma(float x) { return lgammaf(x); }
inline float lgamma_r(float x, int *p) { return lgammaf_r(x, p); }
inline float tgamma(float x) { return tgammaf(x); }
inline float nearbyint(float x) { return nearbyintf(x); }
inline float rint(float x) { return rintf(x); }
inline float round(float x) { return roundf(x); }
inline float trunc(float x) { return truncf(x); }
inline float remainder(float x, float y) { return remainderf(x, y); }
inline float remquo(float x, float y, int *p) { return remquof(x, y, p); }
inline float fdim(float x, float y) { return fdimf(x, y); }
inline float fmax(float x, float y) { return fmaxf(x, y); }
inline float fmin(float x, float y) { return fminf(x, y); }
inline float nexttoward(float x, long double y) { return nexttowardf(x, y); }
inline long lrint(float x) { return lrintf(x); }

inline long lround(float x) { return lroundf(x); }
inline long double copysign(long double x, long double y) { return copysignl(x, y); }
inline long double nextafter(long double x, long double y) { return nextafterl(x, y); }
inline long double log2(long double x) { return log2l(x); }
inline long double acosd(long double x) { return acosdl(x); }
inline long double asind(long double x) { return asindl(x); }
inline long double atand(long double x) { return atandl(x); }
inline long double atan2d(long double x, long double y) { return atan2dl(x, y); }
inline long double acosh(long double x) { return acoshl(x); }
inline long double asinh(long double x) { return asinhl(x); }
inline long double atanh(long double x) { return atanhl(x); }
inline long double cosd(long double x) { return cosdl(x); }
inline long double sind(long double x) { return sindl(x); }
inline long double tand(long double x) { return tandl(x); }
inline long double exp2(long double x) { return exp2l(x); }
inline long double exp10(long double x) { return exp10l(x); }
inline long double expm1(long double x) { return expm1l(x); }
inline long double log1p(long double x) { return log1pl(x); }
inline long double cbrt(long double x) { return cbrtl(x); }
inline long double hypot(long double x, long double y) { return hypotl(x,y); }
inline long double compound(long double x, long double y) { return compoundl(x,y); }
inline long double annuity(long double x, long double y) { return annuityl(x,y); }
inline long double logb(long double x) { return logbl(x); }
inline long double scalbn(long double x, int n) { return scalbnl(x, n); }
inline long double scalbln(long double x, long n) { return scalblnl(x, n); }
inline int ilogb(long double x) { return ilogbl(x); }
inline long double nearbyint(long double x) { return nearbyintl(x); }
inline long double rint(long double x) { return rintl(x); }
inline long double round(long double x) { return roundl(x); }
inline long double trunc(long double x) { return truncl(x); }
inline long double remainder(long double x, long double y) { return remainderl(x, y); }
inline long double remquo(long double x, long double y, int *p) { return remquol(x, y, p); }
inline long double fmod(long double x, long double y) { return fmodl(x, y); }
inline long double fdim(long double x, long double y) { return fdiml(x, y); }
inline long double fmax(long double x, long double y) { return fmaxl(x, y); }
inline long double fmin(long double x, long double y) { return fminl(x, y); }
inline long double fma(long double x, long double y, long double z) { return fmal(x, y, z); }
inline long double nexttoward(long double x, long double y) { return nexttowardl(x, y); }
inline long lrint(long double x) { return lrintl(x); }
inline long lround(long double x) { return lroundl(x); }

inline long double erf(long double x) { return erfl(x); }
inline long double erfc(long double x) { return erfcl(x); }

inline long double gamma(long double x) { return gammal(x); }
inline long double lgamma(long double x) { return lgammal(x); }
inline long double lgamma_r(long double x, int *p) { return lgammal_r(x, p); }
inline long double tgamma(long double x) { return tgammal(x); }
inline int isnan(float x) { return _Isnanf(x); }
inline int isinf(float x) { return _Isinff(x); }
inline int signbit(float x) { return _Signbitf(x); }
inline int isfinite(float x) { return _Isfinitef(x); }
inline int isnormal(float x) { return _Isnormalf(x); }
inline int fpclassify(float x) { return _Fpclassf(x); }
inline int isunordered(float x, float y) { return _Isunorderedf(x, y); }
inline int isgreater(float x, float y) { return _Isgreaterf(x, y); }
inline int isgreaterequal(float x, float y){ return _Isgreaterequalf(x, y); }
inline int isless(float x, float y) { return _Islessf(x, y); }
inline int islessequal(float x, float y) { return _Islessequalf(x, y); }
inline int islessgreater(float x, float y) { return _Islessgreaterf(x, y); }

inline int isinf(double x) { return _Isinf(x); }
inline int signbit(double x) { return _Signbit(x); }
inline int isfinite(double x) { return _Isfinite(x); }
inline int isnormal(double x) { return _Isnormal(x); }
inline int fpclassify(double x) { return _Fpclass(x); }
inline int isunordered(double x, double y) { return _Isunordered(x, y); }
inline int isgreater(double x, double y) { return _Isgreater(x, y); }
inline int isgreaterequal(double x, double y){ return _Isgreaterequal(x, y); }
inline int isless(double x, double y) { return _Isless(x, y); }
inline int islessequal(double x, double y) { return _Islessequal(x, y); }
inline int islessgreater(double x, double y) { return _Islessgreater(x, y); }
inline int isnan(long double x) { return _Isnanf128(x); }
inline int isinf(long double x) { return _Isinff128(x); }
inline int signbit(long double x) { return _Signbitf128(x); }
inline int isfinite(long double x) { return _Isfinitef128(x); }
inline int isnormal(long double x) { return _Isnormalf128(x); }
inline int fpclassify(long double x) { return _Fpclassf128(x); }
inline int isunordered(long double x, long double y) { return _Isunorderedf128(x,y); }
inline int isgreater(long double x, long double y) { return _Isgreaterf128(x,y); }
inline int isgreaterequal(long double x, long double y){ return _Isgreaterequalf128(x,y); }
inline int isless(long double x, long double y) { return _Islessf128(x,y); }
inline int islessequal(long double x, long double y) { return _Islessequalf128(x,y); }
inline int islessgreater(long double x, long double y) { return _Islessgreaterf128(x,y); }






namespace std {
using ::abs;
using ::acos;
using ::asin;
using ::atan2;
using ::atan;
using ::ceil;
using ::cos;
using ::cosh;
using ::exp;
using ::fabs;
using ::floor;
using ::fmod;
using ::frexp;
using ::ldexp;
using ::log10;
using ::log;
using ::modf;
using ::pow;
using ::sin;
using ::sinh;
using ::sqrt;
using ::tan;
using ::tanh;
}
typedef enum {
        _SZ_B = 1,
        _SZ_H = 2,
        _SZ_W = 4,
        _SZ_D = 8
} _Asm_sz;


typedef enum {
        _SEM_ACQ = 1,
        _SEM_REL = 2
} _Asm_sem;


typedef enum {
        _FASZ_W = 4,
        _FASZ_D = 8
} _Asm_fasz;


typedef enum {
        _MBTYPE_REV = 1,
        _MBTYPE_MIX = 2,
        _MBTYPE_SHUF = 3,
        _MBTYPE_ALT = 4,
        _MBTYPE_BRCST = 5
} _Asm_mbtype;


typedef enum {
        _LDHINT_NONE = 0,
        _LDHINT_NT1 = 1,
        _LDHINT_NTA = 2
} _Asm_ldhint;


typedef enum {
        _STHINT_NONE = 0,
        _STHINT_NTA = 1
} _Asm_sthint;


typedef enum {
        _LFTYPE_NONE = 0,
        _LFTYPE_FAULT = 1
} _Asm_lftype;


typedef enum {
        _LFHINT_NONE = 0,
        _LFHINT_NT1 = 1,
        _LFHINT_NT2 = 2,
        _LFHINT_NTA = 3
} _Asm_lfhint;


typedef enum {
        _REG_BANK_ZERO = 0,
        _REG_BANK_ONE = 1
} _Asm_reg_bank;


typedef enum {
        _PC_S = 1,
        _PC_D = 2,
        _PC_NONE = 3
} _Asm_pc;


typedef enum {
        _FP_NAT = (1<<8),
        _FP_QNAN = (1<<7),
        _FP_SNAN = (1<<6),
        _FP_POS = (1<<0),
        _FP_NEG = (1<<1),
        _FP_ZERO = (1<<2),
        _FP_UNNORM = (1<<3),
        _FP_NORM = (1<<4),
        _FP_INF = (1<<5)
} _Asm_fclass_type;


typedef enum {
        _FP_EQ = 1,
        _FP_LT = 2,
        _FP_LE = 3,
        _FP_GT = 4,
        _FP_GE = 5,
        _FP_UNORD = 6,
        _FP_NEQ = 7,
        _FP_NLT = 8,
        _FP_NLE = 9,
        _FP_NGT = 10,
        _FP_NGE = 11,
        _FP_ORD = 12
} _Asm_frel;


typedef enum {
        _FX_S = 1,
        _FX_ST = 2,
        _FX_U = 3,
        _FX_UT = 4
} _Asm_fx_type;


typedef enum {
        _FM_NS = 1,
        _FM_S = 2,
        _FM_SE = 3
} _Asm_fm_type;



typedef enum {
        _FR_S = 1,
        _FR_D = 2,
        _FR_EXP = 3,
        _FR_SIG = 4
} _Asm_fr_access;


typedef enum {
        _XM_L = 1,
        _XM_LU = 2,
        _XM_H = 3,
        _XM_HU = 4
} _Asm_xm_type;


typedef enum {
        _SF0 = 0,
        _SF1 = 1,
        _SF2 = 2,
        _SF3 = 3
} _Asm_sf;


typedef enum {
        _AREG0, _AREG1, _AREG2, _AREG3, _AREG4, _AREG5, _AREG6, _AREG7, _AREG8,
        _AREG9, _AREG10, _AREG11, _AREG12, _AREG13, _AREG14, _AREG15, _AREG16,
        _AREG17, _AREG18, _AREG19, _AREG20, _AREG21, _AREG22, _AREG23, _AREG24,
        _AREG25, _AREG26, _AREG27, _AREG28, _AREG29, _AREG30, _AREG31, _AREG32,
        _AREG33, _AREG34, _AREG35, _AREG36, _AREG37, _AREG38, _AREG39, _AREG40,
        _AREG41, _AREG42, _AREG43, _AREG44, _AREG45, _AREG46, _AREG47, _AREG48,
        _AREG49, _AREG50, _AREG51, _AREG52, _AREG53, _AREG54, _AREG55, _AREG56,
        _AREG57, _AREG58, _AREG59, _AREG60, _AREG61, _AREG62, _AREG63, _AREG64,
        _AREG65, _AREG66, _AREG67, _AREG68, _AREG69, _AREG70, _AREG71, _AREG72,
        _AREG73, _AREG74, _AREG75, _AREG76, _AREG77, _AREG78, _AREG79, _AREG80,
        _AREG81, _AREG82, _AREG83, _AREG84, _AREG85, _AREG86, _AREG87, _AREG88,
        _AREG89, _AREG90, _AREG91, _AREG92, _AREG93, _AREG94, _AREG95, _AREG96,
        _AREG97, _AREG98, _AREG99, _AREG100, _AREG101, _AREG102, _AREG103,
        _AREG104, _AREG105, _AREG106, _AREG107, _AREG108, _AREG109, _AREG110,
        _AREG111, _AREG112, _AREG113, _AREG114, _AREG115, _AREG116, _AREG117,
        _AREG118, _AREG119, _AREG120, _AREG121, _AREG122, _AREG123, _AREG124,
        _AREG125, _AREG126, _AREG127,

        _AREG_KR0 = _AREG0,
        _AREG_KR1 = _AREG1,
        _AREG_KR2 = _AREG2,
        _AREG_KR3 = _AREG3,
        _AREG_KR4 = _AREG4,
        _AREG_KR5 = _AREG5,
        _AREG_KR6 = _AREG6,
        _AREG_KR7 = _AREG7,
        _AREG_RSC = _AREG16,
        _AREG_BSP = _AREG17,
        _AREG_BSPSTORE = _AREG18,
        _AREG_RNAT = _AREG19,
        _AREG_CCV = _AREG32,
        _AREG_UNAT = _AREG36,
        _AREG_FPSR = _AREG40,
        _AREG_ITC = _AREG44,
        _AREG_PFS = _AREG64,
        _AREG_LC = _AREG65,
        _AREG_EC = _AREG66,


        _AREG_IOBASE = _AREG_KR0,
        _AREG_TSS = _AREG_KR1,
        _AREG_TSSD = _AREG_KR2,
        _AREG_Eflags = _AREG24,
        _AREG_CSD = _AREG25,
        _AREG_SSD = _AREG26,
        _AREG_CFLG = _AREG27,
        _AREG_FSR = _AREG28,
        _AREG_FIR = _AREG29,
        _AREG_FDR = _AREG30
} _Asm_app_reg;


typedef enum {
        _CREG0, _CREG1, _CREG2, _CREG3, _CREG4, _CREG5, _CREG6, _CREG7, _CREG8,
        _CREG9, _CREG10, _CREG11, _CREG12, _CREG13, _CREG14, _CREG15, _CREG16,
        _CREG17, _CREG18, _CREG19, _CREG20, _CREG21, _CREG22, _CREG23, _CREG24,
        _CREG25, _CREG26, _CREG27, _CREG28, _CREG29, _CREG30, _CREG31, _CREG32,
        _CREG33, _CREG34, _CREG35, _CREG36, _CREG37, _CREG38, _CREG39, _CREG40,
        _CREG41, _CREG42, _CREG43, _CREG44, _CREG45, _CREG46, _CREG47, _CREG48,
        _CREG49, _CREG50, _CREG51, _CREG52, _CREG53, _CREG54, _CREG55, _CREG56,
        _CREG57, _CREG58, _CREG59, _CREG60, _CREG61, _CREG62, _CREG63, _CREG64,
        _CREG65, _CREG66, _CREG67, _CREG68, _CREG69, _CREG70, _CREG71, _CREG72,
        _CREG73, _CREG74, _CREG75, _CREG76, _CREG77, _CREG78, _CREG79, _CREG80,
        _CREG81, _CREG82, _CREG83, _CREG84, _CREG85, _CREG86, _CREG87, _CREG88,
        _CREG89, _CREG90, _CREG91, _CREG92, _CREG93, _CREG94, _CREG95, _CREG96,
        _CREG97, _CREG98, _CREG99, _CREG100, _CREG101, _CREG102, _CREG103,
        _CREG104, _CREG105, _CREG106, _CREG107, _CREG108, _CREG109, _CREG110,
        _CREG111, _CREG112, _CREG113, _CREG114, _CREG115, _CREG116, _CREG117,
        _CREG118, _CREG119, _CREG120, _CREG121, _CREG122, _CREG123, _CREG124,
        _CREG125, _CREG126, _CREG127,

        _CREG_DCR = _CREG0,
        _CREG_ITM = _CREG1,
        _CREG_IVA = _CREG2,
        _CREG_PTA = _CREG8,
        _CREG_GPTA = _CREG9,
        _CREG_IPSR = _CREG16,
        _CREG_ISR = _CREG17,
        _CREG_IIP = _CREG19,
        _CREG_IFA = _CREG20,
        _CREG_ITIR = _CREG21,
        _CREG_IIPA = _CREG22,
        _CREG_IFS = _CREG23,
        _CREG_IIM = _CREG24,
        _CREG_IHA = _CREG25,
        _CREG_LID = _CREG64,
        _CREG_IVR = _CREG65,
        _CREG_TPR = _CREG66,
        _CREG_EOI = _CREG67,
        _CREG_IRR0 = _CREG68,
        _CREG_IRR1 = _CREG69,
        _CREG_IRR2 = _CREG70,
        _CREG_IRR3 = _CREG71,
        _CREG_ITV = _CREG72,
        _CREG_PMV = _CREG73,
        _CREG_CMCV = _CREG74,
        _CREG_LRR0 = _CREG80,
        _CREG_LRR1 = _CREG81
} _Asm_cntl_reg;


typedef enum {
        _NO_FENCE = 0x0,
        _UP_MEM_FENCE = 0x1,
        _UP_ALU_FENCE = 0x2,
        _UP_FLOP_FENCE = 0x4,
        _UP_SYS_FENCE = 0x8,
        _UP_CALL_FENCE = 0x10,
        _UP_BR_FENCE = 0x20,

        _DOWN_MEM_FENCE = 0x100,
        _DOWN_ALU_FENCE = 0x200,
        _DOWN_FLOP_FENCE= 0x400,
        _DOWN_SYS_FENCE = 0x800,
        _DOWN_CALL_FENCE= 0x1000,
        _DOWN_BR_FENCE = 0x2000
} _Asm_fence;
extern const float _FLT_NANS;
extern const float _FLT_DMIN;





extern const double _DBL_NANS;
extern const double _DBL_DMIN;
extern const long double _LDBL_NANS;
extern const long double _LDBL_DMIN;
namespace std {


enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _TypeT>
class numeric_limits
{
public:




    static const bool is_specialized = false;

    static _TypeT min () throw() { return 0; }
    static _TypeT max () throw() { return 0; }

    static const int digits = 0;
    static const int digits10 = 0;

    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;

    static const int radix = 0;

    static _TypeT epsilon () throw() { return 0; }
    static _TypeT round_error () throw() { return 0; }

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;

    static _TypeT infinity () throw() { return 0; }
    static _TypeT quiet_NaN () throw() { return 0; }
    static _TypeT signaling_NaN () throw() { return 0; }
    static _TypeT denorm_min () throw() { return 0; }

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;
    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};


}
namespace std {


template<> class numeric_limits<float> { public:


    static const bool is_specialized = (true);

    static float min () throw() { return ((float)1.17549435E-38F); }
    static float max () throw() { return ((float)3.40282347E+38F); }

    static const int digits = (24);
    static const int digits10 = (6);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static float epsilon () throw() { return ((float)1.19209290E-07F); }
    static float round_error () throw() { return 0.5f; }

    static const int min_exponent = ((-125));
    static const int min_exponent10 = ((-37));
    static const int max_exponent = (128);
    static const int max_exponent10 = (38);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_present);

    static const bool has_denorm_loss = (false);


    static float infinity () throw() { return _FLT_NANS; };
    static float quiet_NaN () throw() { return _FLT_NANS; };




    static float signaling_NaN () throw() { return _FLT_NANS; };
    static float denorm_min () throw() { return _FLT_DMIN; };

    static const bool is_iec559 = (true);
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);

    static const bool traps = (true);
    static const bool tinyness_before = (true);

    static const float_round_style round_style = (static_cast< float_round_style >(1));


    typedef double _C_convertible;

};


template<> class numeric_limits<double> { public:

    static const bool is_specialized = (true);

    static double min () throw() { return ((double)2.2250738585072014E-308); }
    static double max () throw() { return ((double)1.7976931348623157E+308); }

    static const int digits = (53);
    static const int digits10 = (15);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static double epsilon () throw() { return ((double)2.2204460492503131E-16); }
    static double round_error () throw() { return 0.5; }

    static const int min_exponent = ((-1021));
    static const int min_exponent10 = ((-307));
    static const int max_exponent = (1024);
    static const int max_exponent10 = (308);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_present);

    static const bool has_denorm_loss = (false);


    static double infinity () throw() { return ((double)_FLT_NANS); };
    static double quiet_NaN () throw() { return ((double)_FLT_NANS); };




    static double signaling_NaN () throw() { return _DBL_NANS; };
    static double denorm_min () throw() { return _DBL_DMIN; };

    static const bool is_iec559 = (true);
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);

    static const bool traps = (true);
    static const bool tinyness_before = (true);

    static const float_round_style round_style = (static_cast< float_round_style >(1));



    typedef long double _C_convertible;




};
template<> class numeric_limits<long double> { public:


    static const bool is_specialized = (true);

    static long double min () throw() { return 3.36210314311209350626267781732175261E-4932L; }
    static long double max () throw() { return 1.18973149535723176508575932662800702E+4932L; }

    static const int digits = (113);
    static const int digits10 = (33);

    static const bool is_signed = (true);
    static const bool is_integer = (false);
    static const bool is_exact = (false);
    static const int radix = (2);

    static long double epsilon () throw() { return 1.92592994438723585305597794258492732E-34L; }
    static long double round_error () throw() { return 0.5L; }

    static const int min_exponent = ((-16381));
    static const int min_exponent10 = ((-4931));
    static const int max_exponent = (16384);
    static const int max_exponent10 = (4932);

    static const bool has_infinity = (true);
    static const bool has_quiet_NaN = (true);
    static const bool has_signaling_NaN = (true);
    static const float_denorm_style has_denorm = (denorm_present);

    static const bool has_denorm_loss = (false);


    static long double infinity () throw() { return ((long double)_FLT_NANS); };

    static long double quiet_NaN () throw() { return ((long double)_FLT_NANS); };





    static long double signaling_NaN () throw() { return _LDBL_NANS; };
    static long double denorm_min () throw() { return _LDBL_DMIN; };

    static const bool is_iec559 = (true);
    static const bool is_bounded = (true);
    static const bool is_modulo = (false);

    static const bool traps = (true);
    static const bool tinyness_before = (true);

    static const float_round_style round_style = (static_cast< float_round_style >(1));



    typedef long double _C_convertible;

};
template<> class numeric_limits<char> { public: static const bool is_specialized = (true); static char min () throw() { return (-128); } static char max () throw() { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 127 ? 1 : (8 * sizeof (char) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static char epsilon () throw() { return 0; } static char round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static char infinity () throw() { return 0; } static char quiet_NaN () throw() { return 0; } static char signaling_NaN () throw() { return 0; } static char denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };

template<> class numeric_limits<unsigned char> { public: static const bool is_specialized = (true); static unsigned char min () throw() { return 0; } static unsigned char max () throw() { return 0377; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 0377 ? 1 : (8 * sizeof (unsigned char) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static unsigned char epsilon () throw() { return 0; } static unsigned char round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned char infinity () throw() { return 0; } static unsigned char quiet_NaN () throw() { return 0; } static unsigned char signaling_NaN () throw() { return 0; } static unsigned char denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0377); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };


template<> class numeric_limits<signed char> { public: static const bool is_specialized = (true); static signed char min () throw() { return (-128); } static signed char max () throw() { return 127; } static const bool is_signed = ((-128) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 127 ? 1 : (8 * sizeof (signed char) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static signed char epsilon () throw() { return 0; } static signed char round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static signed char infinity () throw() { return 0; } static signed char quiet_NaN () throw() { return 0; } static signed char signaling_NaN () throw() { return 0; } static signed char denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 127); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };

template<> class numeric_limits<short int> { public: static const bool is_specialized = (true); static short int min () throw() { return (-32768); } static short int max () throw() { return 32767; } static const bool is_signed = ((-32768) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 32767 ? 1 : (8 * sizeof (short int) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static short int epsilon () throw() { return 0; } static short int round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static short int infinity () throw() { return 0; } static short int quiet_NaN () throw() { return 0; } static short int signaling_NaN () throw() { return 0; } static short int denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 32767); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };

template<> class numeric_limits<unsigned short> { public: static const bool is_specialized = (true); static unsigned short min () throw() { return 0; } static unsigned short max () throw() { return 0177777; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 0177777 ? 1 : (8 * sizeof (unsigned short) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static unsigned short epsilon () throw() { return 0; } static unsigned short round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned short infinity () throw() { return 0; } static unsigned short quiet_NaN () throw() { return 0; } static unsigned short signaling_NaN () throw() { return 0; } static unsigned short denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 0177777); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned int _C_convertible; };


template<> class numeric_limits<int> { public: static const bool is_specialized = (true); static int min () throw() { return (-2147483647 - 1); } static int max () throw() { return 2147483647; } static const bool is_signed = ((-2147483647 - 1) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 2147483647 ? 1 : (8 * sizeof (int) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static int epsilon () throw() { return 0; } static int round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static int infinity () throw() { return 0; } static int quiet_NaN () throw() { return 0; } static int signaling_NaN () throw() { return 0; } static int denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 2147483647); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef long _C_convertible; };

template<> class numeric_limits<unsigned int> { public: static const bool is_specialized = (true); static unsigned int min () throw() { return 0; } static unsigned int max () throw() { return 4294967295U; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 4294967295U ? 1 : (8 * sizeof (unsigned int) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static unsigned int epsilon () throw() { return 0; } static unsigned int round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned int infinity () throw() { return 0; } static unsigned int quiet_NaN () throw() { return 0; } static unsigned int signaling_NaN () throw() { return 0; } static unsigned int denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 4294967295U); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned long _C_convertible; };


template<> class numeric_limits<long int> { public: static const bool is_specialized = (true); static long int min () throw() { return (-2147483647L - 1); } static long int max () throw() { return 2147483647L; } static const bool is_signed = ((-2147483647L - 1) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 2147483647L ? 1 : (8 * sizeof (long int) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static long int epsilon () throw() { return 0; } static long int round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static long int infinity () throw() { return 0; } static long int quiet_NaN () throw() { return 0; } static long int signaling_NaN () throw() { return 0; } static long int denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 2147483647L); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef long _C_convertible; };

template<> class numeric_limits<unsigned long int> { public: static const bool is_specialized = (true); static unsigned long int min () throw() { return 0; } static unsigned long int max () throw() { return 4294967295UL; } static const bool is_signed = (0 != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == 4294967295UL ? 1 : (8 * sizeof (unsigned long int) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static unsigned long int epsilon () throw() { return 0; } static unsigned long int round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static unsigned long int infinity () throw() { return 0; } static unsigned long int quiet_NaN () throw() { return 0; } static unsigned long int signaling_NaN () throw() { return 0; } static unsigned long int denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != 4294967295UL); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef unsigned long _C_convertible; };
template<> class numeric_limits<wchar_t> { public: static const bool is_specialized = (true); static wchar_t min () throw() { return ( wchar_t (0) - 1 > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-32768) : sizeof (wchar_t) == sizeof (int) ? (-2147483647 - 1) : sizeof (wchar_t) == sizeof (long) ? (-2147483647L - 1) : (-128)); } static wchar_t max () throw() { return ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 4294967295UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 2147483647L : 0377)); } static const bool is_signed = (( wchar_t (0) - 1 > 0 ? 0 : sizeof (wchar_t) == sizeof (short) ? (-32768) : sizeof (wchar_t) == sizeof (int) ? (-2147483647 - 1) : sizeof (wchar_t) == sizeof (long) ? (-2147483647L - 1) : (-128)) != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 4294967295UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 2147483647L : 0377)) ? 1 : (8 * sizeof (wchar_t) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static wchar_t epsilon () throw() { return 0; } static wchar_t round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static wchar_t infinity () throw() { return 0; } static wchar_t quiet_NaN () throw() { return 0; } static wchar_t signaling_NaN () throw() { return 0; } static wchar_t denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != ( wchar_t (0) - 1 > 0 ? ( sizeof (wchar_t) == sizeof (short) ? 0177777 : sizeof (wchar_t) == sizeof (int) ? 4294967295U : sizeof (wchar_t) == sizeof (long) ? 4294967295UL : 127) : ( sizeof (wchar_t) == sizeof (short) ? 32767 : sizeof (wchar_t) == sizeof (int) ? 2147483647 : sizeof (wchar_t) == sizeof (long) ? 2147483647L : 0377))); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef long _C_convertible; };
template<> class numeric_limits<bool> { public: static const bool is_specialized = (true); static bool min () throw() { return false; } static bool max () throw() { return true; } static const bool is_signed = (false != 0); static const bool is_integer = (true); static const bool is_exact = (true); static const int digits = (1 == true ? 1 : (8 * sizeof (bool) - is_signed)); static const int digits10 = ((((digits) * 301) / 1000)); static const int radix = (2); static bool epsilon () throw() { return 0; } static bool round_error () throw() { return 0; } static const int min_exponent = (0); static const int min_exponent10 = (0); static const int max_exponent = (0); static const int max_exponent10 = (0); static const bool has_infinity = (false); static const bool has_quiet_NaN = (false); static const bool has_signaling_NaN = (false); static const float_denorm_style has_denorm = (denorm_absent); static const bool has_denorm_loss = (false); static bool infinity () throw() { return 0; } static bool quiet_NaN () throw() { return 0; } static bool signaling_NaN () throw() { return 0; } static bool denorm_min () throw() { return 0; } static const bool is_iec559 = (false); static const bool is_bounded = (true); static const bool is_modulo = (1 != true); static const bool traps = (false); static const bool tinyness_before = (false); static const float_round_style round_style = (round_toward_zero); typedef int _C_convertible; };
}
namespace std {



template <class _TypeT>
const bool numeric_limits<_TypeT>::is_specialized;

template <class _TypeT>
const int numeric_limits<_TypeT>::digits;

template <class _TypeT>
const int numeric_limits<_TypeT>::digits10;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_signed;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_integer;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_exact;

template <class _TypeT>
const int numeric_limits<_TypeT>::radix;

template <class _TypeT>
const int numeric_limits<_TypeT>::min_exponent;

template <class _TypeT>
const int numeric_limits<_TypeT>::min_exponent10;

template <class _TypeT>
const int numeric_limits<_TypeT>::max_exponent;

template <class _TypeT>
const int numeric_limits<_TypeT>::max_exponent10;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_infinity;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_quiet_NaN;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_signaling_NaN;

template <class _TypeT>
const float_denorm_style numeric_limits<_TypeT>::has_denorm;

template <class _TypeT>
const bool numeric_limits<_TypeT>::has_denorm_loss;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_iec559;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_bounded;

template <class _TypeT>
const bool numeric_limits<_TypeT>::is_modulo;

template <class _TypeT>
const bool numeric_limits<_TypeT>::traps;

template <class _TypeT>
const bool numeric_limits<_TypeT>::tinyness_before;

template <class _TypeT>
const float_round_style numeric_limits<_TypeT>::round_style;



}
extern const char* __bad_alloc_exception;


namespace std {


  class bad_alloc : public exception {
  public:
    bad_alloc() throw() {}
    virtual ~bad_alloc() throw() {}
    virtual const char* what() const throw() {
      return __bad_alloc_exception;
    }
  };

  struct nothrow_t {};
  const nothrow_t nothrow = {};

  typedef void (*new_handler)();

  new_handler set_new_handler(new_handler new_p) throw();


}
void* operator new(size_t size) throw(std::bad_alloc);
void* operator new(size_t size, const std::nothrow_t&) throw();
void operator delete(void* ptr) throw();
void operator delete(void* ptr, const std::nothrow_t&) throw();
void* operator new[](size_t size) throw(std::bad_alloc);
void* operator new[](size_t size, const std::nothrow_t&) throw();
void operator delete[](void* ptr) throw();
void operator delete[](void* ptr, const std::nothrow_t&) throw();
inline void* operator new (size_t size, void* ptr) throw() { return ptr; }
inline void* operator new[](size_t size, void* ptr) throw() { return ptr; }
inline void operator delete (void* ptr, void*) throw() {}
inline void operator delete[](void* ptr, void*) throw() {}
namespace std {







namespace rel_ops {


template <class _TypeT>
inline bool operator!= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x == __y);
}

template <class _TypeT>
inline bool operator> (const _TypeT& __x, const _TypeT& __y)
{
    return __y < __x;
}

template <class _TypeT>
inline bool operator<= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__y < __x);
}

template <class _TypeT>
inline bool operator>= (const _TypeT& __x, const _TypeT& __y)
{
    return !(__x < __y);
}


}






template <class _TypeT, class _TypeU>
struct pair
{
    typedef _TypeT first_type;
    typedef _TypeU second_type;

    first_type first;
    second_type second;

    pair (const first_type &__x, const second_type &__y)
        : first (__x), second (__y) { }

    pair ()

      : first (first_type ()), second (second_type ())

    { ; }

    pair (const pair &__rhs): first (__rhs.first), second (__rhs.second) { }



    template <class _TypeX, class _TypeY>
    pair (const pair <_TypeX, _TypeY> &__rhs)
        : first (__rhs.first), second (__rhs.second) { }



};


template <class _TypeT, class _TypeU>
inline bool
operator== (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return __x.first == __y.first && __x.second == __y.second;
}


template <class _TypeT, class _TypeU>
inline bool
operator!= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return !(__x == __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator< (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return __x.first < __y.first
           || (!(__y.first < __x.first) && __x.second < __y.second);
}


template <class _TypeT, class _TypeU>
inline bool
operator> (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return __y < __x;
}


template <class _TypeT, class _TypeU>
inline bool
operator>= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return !(__x < __y);
}


template <class _TypeT, class _TypeU>
inline bool
operator<= (const pair<_TypeT, _TypeU>& __x, const pair<_TypeT, _TypeU>& __y)
{
    return !(__y < __x);
}


template <class _TypeT, class _TypeU>
inline pair<_TypeT, _TypeU>
make_pair (const _TypeT &__x, const _TypeU &__y)
{
    return pair<_TypeT, _TypeU>(__x, __y);
}


}
extern "C" {
#pragma builtin_milli memcmp, strncat, strncmp, memmove, strcpy
#pragma builtin_milli strncpy, strcat, strcmp, strchr, strrchr, strstr 
#pragma builtin strpbrk, strcoll, strxfrm, strtok



#pragma extern memcmp, strncat, strncmp, memmove, strcpy, strncpy, strcat
#pragma extern strcmp, strcoll, strxfrm, strchr, strpbrk, strrchr, strstr 
#pragma extern strtok, strerror

     extern int memcmp(const void *, const void *, size_t);
     extern char *strncat(char *, const char *, size_t);
     extern int strncmp(const char *, const char *, size_t);
     extern void *memmove(void *, const void *, size_t);
     extern char *strcpy(char *, const char *);
     extern char *strncpy(char *, const char *, size_t);
     extern char *strcat(char *, const char *);
     extern int strcmp(const char *, const char *);
     extern int strcoll(const char *, const char *);
     extern size_t strxfrm(char *, const char *, size_t);
     extern char *strtok(char *, const char *);
     extern char *strerror(int);

#pragma builtin_milli memchr, memcpy, memset, strcspn, strlen
#pragma extern memcpy, memchr, memset, strcspn, strspn, strlen

       extern void *memcpy(void *, const void *, size_t);
       extern void *memset(void *, int, size_t);
       extern size_t strcspn(const char *, const char *);
       extern size_t strspn(const char *, const char *);





         extern size_t strlen(const char *);

#pragma builtin_milli memccpy 
#pragma extern memccpy
       extern void *memccpy(void *, const void *, int, size_t);
#pragma builtin strdup 
#pragma extern strdup
     extern char *strdup(const char *);
#pragma builtin strcasecmp, strncasecmp 
#pragma extern strrstr, strcasecmp, strncasecmp 
     extern char *strrstr(const char *, const char *);
     extern int strcasecmp(const char *, const char *);
     extern int strncasecmp(const char *, const char *, size_t);
}
#pragma builtin_milli strchr, strrchr, strstr, memchr
#pragma builtin strpbrk
#pragma extern strchr, strpbrk, strrchr, strstr, memchr
    extern "C" const char* strpbrk(const char *, const char *);
    extern "C" const char* strstr(const char *, const char *);
    extern "C" const char* strrchr(const char *, int);
    extern "C" const char* strchr(const char *, int);
    extern "C" const void* memchr(const void *, int, size_t);

    inline char* strpbrk(char *s, const char *p) {
        return const_cast<char*> (strpbrk(const_cast<const char*>(s), p));
    }
    inline char* strstr(char *s, const char *p) {
        return const_cast<char*> (strstr(const_cast<const char*>(s), p));
    }
    inline char* strrchr(char *s, int c) {
        return const_cast<char*> (strrchr(const_cast<const char*>(s), c));
    }
    inline char* strchr(char *s, int c) {
        return const_cast<char*> (strchr(const_cast<const char*>(s), c));
    }
    inline void* memchr(void *s, int c, size_t n) {
        return const_cast<void*> (memchr(const_cast<const void*>(s), c, n));
    }
namespace std
{

using ::size_t;





using ::memchr;
using ::memcmp;
using ::memcpy;
using ::memmove;
using ::memset;
using ::strcat;
using ::strchr;
using ::strcmp;
using ::strcoll;
using ::strcpy;
using ::strcspn;
using ::strerror;
using ::strlen;
using ::strncat;
using ::strncmp;
using ::strncpy;
using ::strpbrk;
using ::strrchr;
using ::strspn;
using ::strstr;
using ::strtok;
using ::strxfrm;

}
namespace __rw {


template <class _TypeT, class _TypeU>
inline
_TypeT __rw_atomic_exchange (_TypeT &__t, const _TypeU &__u, bool)
{
    _TypeT __tmp = __t;
    __t = __u;
    return __tmp;
}




struct __rw_mutex_base
{



    void _C_acquire () { }

    void _C_release () { }
};


struct __rw_mutex: public __rw_mutex_base
{
};


struct __rw_guard
{



    __rw_guard (__rw_mutex_base&) { }

    __rw_guard (__rw_mutex_base*) { }
};


struct __rw_synchronized
{




    __rw_mutex _C_mutex;


    void _C_lock () { }

    void _C_unlock () { }

    __rw_guard _C_guard () {
        return __rw_guard (_C_mutex);
    }
};


}
namespace __rw {





template <class _Container>
inline size_t __rw_new_capacity (size_t __size, const _Container*)
{
    size_t __cap = static_cast< size_t >(__size * float(1.618));

    return (__size += size_t(32)) > __cap ? __size : __cap;
}
template <class _TypeT>
inline void __rw_destroy (_TypeT &__ref)
{


    __ref.~_TypeT ();






}
template <class _TypeT, class _TypeU>
inline void __rw_construct (_TypeT* __p, const _TypeU& __val)
{
    new (__p) _TypeT (__val);
}


template <class _ForwardIterator>
inline void __rw_destroy (_ForwardIterator __first,
                                     _ForwardIterator __last)
{
    for (; __first != __last; ++__first)
        __rw_destroy (*__first);
}





template <class _TypeT>
inline void __rw_destroy (_TypeT**, _TypeT**)
{ }




}


namespace std {


template <class _TypeT> class allocator;


template<>
class allocator<void> {
public:
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;




    template <class _TypeU>
    struct rebind {
        typedef allocator<_TypeU> other;
    };



};


template <class _TypeT>
class allocator
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _TypeT value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    allocator () throw() { }

    allocator (const allocator&) throw() { }




    template <class _TypeU>
    struct rebind {
        typedef allocator<_TypeU> other;
    };

    template <class _TypeU>
    allocator (const allocator<_TypeU>&) throw() { }

    template <class _TypeU>
    allocator&
    operator= (const allocator<_TypeU>& __rhs) throw() {
        return *this;
    }




    pointer address (reference __x) const {
        return &__x;
    }

    const_pointer address (const_reference __x) const {
        return &__x;
    }

    pointer allocate (size_type __n, allocator<void>::const_pointer = 0) {


        pointer __tmp =
            static_cast< pointer >(::operator new (__n * sizeof (value_type)));





        ((0 == __tmp) ? throw bad_alloc () : (void)0);
        return __tmp;
    }


    void deallocate (pointer __p, size_type)



    {
        ::operator delete (__p);
    }

    size_type max_size () const throw() {
        return 1 > 4294967295U / sizeof (value_type) ? size_type (1)
            : size_type (4294967295U / sizeof (value_type));
    }

    void construct (pointer __p, const_reference __val) {
        __rw::__rw_construct (__p, __val);
    }

    void destroy (pointer __p) {
        ((void)0);
        __rw::__rw_destroy (*__p);
    }
};
template <class _TypeT, class _TypeU>
inline bool
operator== (const allocator<_TypeT>&,
            const allocator<_TypeU>&) throw()
{
    return true;
}




template <class _TypeT, class _TypeU>
inline bool
operator!= (const allocator<_TypeT>& __x,
            const allocator<_TypeU>& __y) throw()
{
    return !(__x == __y);
}





template <class _OutputIterator, class _TypeT>
class raw_storage_iterator:
    public iterator<output_iterator_tag, void, void, void, void>
{
protected:
    _OutputIterator _C_iter;

public:
    explicit raw_storage_iterator (_OutputIterator __x) : _C_iter (__x) { }

    raw_storage_iterator& operator* () {
        return *this;
    }

    raw_storage_iterator& operator= (const _TypeT& __rhs) {
        ::new (&(*_C_iter)) _TypeT (__rhs);
        return *this;
    }

    raw_storage_iterator& operator++ () {
        ++_C_iter;
        return *this;
    }

    raw_storage_iterator operator++ (int) {
        raw_storage_iterator __tmp = *this;
        ++*this;
        return __tmp;
    }
};


}


namespace __rw {





template <class _TypeT>
class __rw_indestructible
{
    union _C_data_t {
        char _C_data;
        long double _C_padding;
    };

    enum { _C_n = 1 + sizeof (_TypeT) / sizeof (_C_data_t) };

    _C_data_t _C_data [_C_n];

public:
    typedef _TypeT value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;




    operator reference () {
        return reinterpret_cast< reference >(*_C_data);
    }

    operator const_reference () const {
        return reinterpret_cast< const_reference >(*_C_data);
    }


    pointer operator& () {



        return &(reference)*this;
    }


    const_pointer operator& () const {



        return &(const_reference)*this;
    }
};


inline char* __rw_get_static_buf ()
{
    typedef char _CharBuf [0 + 1];


    static __rw_indestructible<_CharBuf> __buffer;

    return static_cast< char* >(__buffer);
}







inline std::pair<void*, std::size_t>
__rw_reallocate_temp_buffer (void *__p, std::size_t __size)
{
    static unsigned long __busy = 0;

    unsigned long __cntr = ++(__busy);

    static char *__buffer = __rw_get_static_buf ();

    if (__p == (void*)__buffer) {
        __p = 0;
        __size = 0;


        --(__busy);
    }
    else
        ::operator delete (__p);

    if (__size > 0 || __cntr > 1) {
        try {
            __p = ::operator new (__size);
        }
        catch (...) {
            __p = 0;
            __size = 0;
        }


        --(__busy);
    }
    else {
        __p = __buffer;


    }

    return std::pair<void*, std::size_t>(__p, __size);
}


}


namespace std {
template <class _TypeT, class _Distance>
inline pair<_TypeT*, _Distance> get_temporary_buffer (_Distance __n, _TypeT*)
{
    pair<void*, size_t> __pair =
        __rw::__rw_reallocate_temp_buffer (0, __n * sizeof (_TypeT));

    return make_pair (static_cast< _TypeT* >(__pair.first),
                      _Distance (__pair.second / sizeof (_TypeT)));
}





template <class _TypeT>
inline pair<_TypeT*, ptrdiff_t> get_temporary_buffer (ptrdiff_t __n)
{
    return get_temporary_buffer (__n, (_TypeT*)0);
}





template <class _TypeT>
inline void return_temporary_buffer (_TypeT *__p)
{
    __rw::__rw_reallocate_temp_buffer (__p, 0);
}



template <class _InputIterator, class _ForwardIterator>
inline
_ForwardIterator uninitialized_copy (_InputIterator __first,
                                     _InputIterator __last,
                                     _ForwardIterator __result)
{
    _ForwardIterator __start = __result;

    try {
        for (; __first != __last; ++__first, ++__result)
            __rw::__rw_construct (&*__result, *__first);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __result);
        throw;
    }

    return __result;
}







template <class _InputIterator, class _ForwardIterator, class _Allocator>
inline
_ForwardIterator uninitialized_copy (_InputIterator __first,
                                     _InputIterator __last,
                                     _ForwardIterator __result,
                                     _Allocator& __alloc)
{
    _ForwardIterator __start = __result;

    try {
        for (; __first != __last; ++__first, ++__result)
            __alloc.construct (&*__result, *__first);
    }
    catch (...) {
        for (; __start != __result; ++__start)
            __alloc.destroy (&*__start);
        throw;
    }

    return __result;
}




template <class _ForwardIterator, class _TypeT>
inline
void uninitialized_fill (_ForwardIterator __first, _ForwardIterator __last,
                         const _TypeT& __x)
{
    _ForwardIterator __start = __first;

    try {
        for (; __first != __last; ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __first);
        throw;
    }
}



template <class _ForwardIterator, class _Size, class _TypeT>
inline
void uninitialized_fill_n (_ForwardIterator __first, _Size __n,
                           const _TypeT& __x)
{
    _ForwardIterator __start = __first;

    try {
        for (; __n; --__n, ++__first)
            __rw::__rw_construct (&*__first, __x);
    }
    catch (...) {
        __rw::__rw_destroy (__start, __first);
        throw;
    }
}







template <class _ForwardIter, class _Size, class _TypeT, class _Allocator>
inline
void uninitialized_fill_n (_ForwardIter __first, _Size __n,
                           const _TypeT& __x, _Allocator& __alloc)
{
    _ForwardIter __start = __first;

    try {
        for (; __n; --__n, ++__first)
            __alloc.construct (&*__first, __x);
    }
    catch (...) {
        for (; __start != __first; ++__start)
            __alloc.destroy (&*__start);
        throw;
    }
}
template<class _TypeT>
class auto_ptr;




template <class _TypeT>
class auto_ptr_ref
{
public:
    auto_ptr<_TypeT>& _C_ptr;

    auto_ptr_ref (auto_ptr<_TypeT>& __rhs) : _C_ptr (__rhs) { }
};


template<class _TypeT>
class auto_ptr
{
public:
    typedef _TypeT element_type;

    explicit auto_ptr (element_type* __p = 0) throw()
     : _C_ptr (__p) { }

    auto_ptr (auto_ptr& __rhs) throw()
     : _C_ptr (__rhs.release ()) { }

    auto_ptr& operator= (auto_ptr& __rhs) throw() {
        reset (__rhs.release ());
        return *this;
    }


    auto_ptr&
    operator= (auto_ptr_ref<element_type> __rhs) throw() {
        reset (__rhs._C_ptr.release ());
        return *this;
    }



    template <class _TypeU>
    operator auto_ptr_ref<_TypeU>() throw() {
        return auto_ptr_ref<_TypeU>(*this);
    }

    template <class _TypeU>
    operator auto_ptr<_TypeU>() throw() {
        return auto_ptr<_TypeU>(release ());
    }

    template <class _TypeU>
    auto_ptr (auto_ptr<_TypeU>& __rhs) throw()
    : _C_ptr (__rhs.release ()) { }

    template <class _TypeU>
    auto_ptr& operator= (auto_ptr<_TypeU>& __rhs) throw() {
        reset (__rhs.release ());
        return *this;
    }




    ~auto_ptr () throw() {
        delete _C_ptr;
    }

    element_type* get () const throw() {
        return _C_ptr;
    }

    element_type& operator* () const throw() {
        ((void)0);
        return *get ();
    }

    element_type* operator-> () const throw() { return &**this; }


    element_type* release () throw() {
        element_type* __tmp = _C_ptr;
        _C_ptr = 0;
        return __tmp;
    }

    void reset (element_type* __p = 0) throw() {
        if (_C_ptr != __p) {
            delete _C_ptr;
            _C_ptr = __p;
        }
    }

    auto_ptr (auto_ptr_ref<element_type> __r) throw()
    : _C_ptr (__r._C_ptr.release ()) { }

private:
    element_type* _C_ptr;
};


}
namespace std {




  template <class _OutputIter, class _TypeT>
  class raw_storage_iterator;






  template <class _InputIter, class _Function>
  _Function for_each (_InputIter __first, _InputIter __last, _Function __f);

  template <class _InputIter, class _TypeT>
  _InputIter find (_InputIter __first, _InputIter __last,
                   const _TypeT& __value);

  template <class _InputIter, class _Predicate>
  _InputIter find_if (_InputIter __first, _InputIter __last,
                      _Predicate __pred);

  template <class _FwdIter1, class _FwdIter2,
  class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _BinaryPredicate __pred,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2,
                             _BinaryPredicate __pred);

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                                  _FwdIter2 __first2, _FwdIter2 __last2);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  _FwdIter1 find_first_of (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2,
                                  _BinaryPredicate __pred);

  template <class _FwdIter>
  _FwdIter adjacent_find (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _BinaryPredicate>
  _FwdIter adjacent_find (_FwdIter __first, _FwdIter __last,
                                 _BinaryPredicate __binary_pred);


  template <class _InputIter, class _TypeT>
  typename iterator_traits<_InputIter>::difference_type
  count (_InputIter __first, _InputIter __last, const _TypeT& __value);

  template <class _InputIter, class _Predicate>
  typename iterator_traits<_InputIter>::difference_type
  count_if (_InputIter __first, _InputIter __last, _Predicate __pred);



  template <class _InputIter, class _TypeT, class _Size>
  void count (_InputIter __first, _InputIter __last, const _TypeT& __value,
              _Size& __n);

  template <class _InputIter, class _Predicate, class _Size>
  void count_if (_InputIter __first, _InputIter __last, _Predicate __pred,
                 _Size& __n);


  template <class _InputIter1, class _InputIter2>
  pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                _InputIter1 __last1,
                                                _InputIter2 __first2);

  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  pair<_InputIter1, _InputIter2> mismatch (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _BinaryPredicate __binary_pred);

  template <class _InputIter1, class _InputIter2>
  inline bool equal (_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2)
  {
    return std::mismatch(__first1, __last1, __first2).first == __last1;
  }

  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  inline bool equal (_InputIter1 __first1, _InputIter1 __last1,
                     _InputIter2 __first2, _BinaryPredicate __binary_pred)
  {
    return std::mismatch(__first1, __last1, __first2, __binary_pred).first ==
        __last1;
  }

  template <class _FwdIter1, class _FwdIter2,
  class Distance1, class Distance2>
  _FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                             _FwdIter2 __first2, _FwdIter2 __last2,
                             Distance1*, Distance2*);

  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter1 search (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2)
  {
    return __search(__first1, __last1, __first2, __last2,
                    __distance_type(__first1),
                    __distance_type(__first2));
  }

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate, class Distance1, class Distance2>
  _FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _BinaryPredicate __binary_pred,
                      Distance1*, Distance2*);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  inline _FwdIter1 search (_FwdIter1 __first1,_FwdIter1 __last1,
                                  _FwdIter2 __first2,_FwdIter2 __last2,
                                  _BinaryPredicate __binary_pred)
  {
    return __search(__first1, __last1, __first2, __last2, __binary_pred,
                    __distance_type(__first1), __distance_type(__first2));
  }

  template <class _FwdIter, class _Distance, class _Size, class _TypeT>
  _FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                       _Distance*, _Size __count, const _TypeT& __value);

  template <class _FwdIter, class _Size, class _TypeT>
  inline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
                                   _Size __count, const _TypeT& __value)
  {
    if (__count)
      return __search_n(__first, __last, __distance_type(__first),
                        __count, __value);
    else
      return __first;
  }

  template <class _FwdIter, class _Distance, class _Size, class _TypeT,
  class _BinaryPredicate>
  _FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                       _Distance*, _Size __count,
                       const _TypeT& __value,
                       _BinaryPredicate __pred);

  template <class _FwdIter, class _Size, class _TypeT, class _BinaryPredicate>
  inline _FwdIter search_n (_FwdIter __first, _FwdIter __last,
                                   _Size __count, const _TypeT& __value,
                                   _BinaryPredicate __pred)
  {
    if (__count)
      return __search_n(__first, __last, __distance_type(__first),
                         __count,__value, __pred);
    else
      return __first;
  }





  template <class _InputIter, class _OutputIter>
  _OutputIter copy (_InputIter __first, _InputIter __last,
                       _OutputIter __result);

  template <class _BidirIter1, class _BidirIter2>
  _BidirIter2 copy_backward (_BidirIter1 __first,
                                        _BidirIter1 __last,
                                        _BidirIter2 __result);

  template <class _TypeT>
  inline void swap (_TypeT& __a, _TypeT& __b)
  {
    _TypeT __tmp = __a;
    __a = __b;
    __b = __tmp;
  }

  template <class _FwdIter1, class _FwdIter2, class _TypeT>
  inline void __iter_swap (_FwdIter1 __a, _FwdIter2 __b, _TypeT*)
  {
    _TypeT __tmp = *__a;
    *__a = *__b;
    *__b = __tmp;
  }

  template <class _FwdIter1, class _FwdIter2>
  inline void iter_swap (_FwdIter1 __a, _FwdIter2 __b)
  {
    __iter_swap(__a, __b, __value_type (__a));
  }

  template <class _FwdIter1, class _FwdIter2>
  _FwdIter2 swap_ranges (_FwdIter1 __first1, _FwdIter1 __last1,
                                _FwdIter2 __first2);

  template <class _InputIter, class _OutputIter, class _UnaryOperation>
  _OutputIter transform (_InputIter __first, _InputIter __last,
                         _OutputIter __result, _UnaryOperation __unary_op);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _BinaryOperation>
  _OutputIter transform (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _OutputIter __result,
                            _BinaryOperation __binary_op);

  template <class _FwdIter, class _TypeT>
  void replace (_FwdIter __first, _FwdIter __last, const _TypeT& __old_value,
                const _TypeT& __new_value);

  template <class _FwdIter, class _Predicate, class _TypeT>
  void replace_if (_FwdIter __first, _FwdIter __last, _Predicate __pred,
                   const _TypeT& __new_value);

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter replace_copy (_InputIter __first, _InputIter __last,
                            _OutputIter __result,
                            const _TypeT& __old_value,
                            const _TypeT& __new_value);

  template <class _Iter, class _OutputIter, class _Predicate, class _TypeT>
  _OutputIter replace_copy_if (_Iter __first, _Iter __last,
                                  _OutputIter __result, _Predicate __pred,
                                  const _TypeT& __new_value);

  template <class _FwdIter, class _TypeT>



  void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value);


  template <class _OutputIter, class _Size, class _TypeT>
  void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value);

  template <class _FwdIter, class _Generator>
  void generate (_FwdIter __first, _FwdIter __last, _Generator __gen);

  template <class _OutputIter, class _Size, class _Generator>
  void generate_n (_OutputIter __first, _Size __n, _Generator __gen);

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter remove_copy (_InputIter __first, _InputIter __last,
                              _OutputIter __result, const _TypeT& __value);

  template <class _InputIter, class _OutputIter, class _Predicate>
  _OutputIter remove_copy_if (_InputIter __first, _InputIter __last,
                                 _OutputIter __result, _Predicate __pred);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter remove (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value)
  {
    __first = std::find(__first, __last, __value);
    _FwdIter __next = __first;
    return __first == __last ?
        __first : std::remove_copy(++__next, __last, __first, __value);
  }

  template <class _FwdIter, class _Predicate>
  inline _FwdIter remove_if (_FwdIter __first, _FwdIter __last,
                                    _Predicate __pred)
  {
    __first = std::find_if(__first, __last, __pred);
    _FwdIter __next = __first;
    return __first == __last ?
        __first : std::remove_copy_if(++__next, __last, __first, __pred);
  }

  template <class _InputIter, class _FwdIter>
  _FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                                 _FwdIter __result, forward_iterator_tag);

  template <class _InputIter, class _BidirIter>
  inline _BidirIter __unique_copy (_InputIter __first,
                                              _InputIter __last,
                                              _BidirIter __result,
                                              bidirectional_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, forward_iterator_tag());
  }

  template <class _InputIter, class _RandomAccessIter>
  inline _RandomAccessIter __unique_copy (_InputIter __first,
                                             _InputIter __last,
                                             _RandomAccessIter __result,
                                             random_access_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, forward_iterator_tag());
  }

  template <class _InputIter, class _OutputIter, class _TypeT>
  _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                _OutputIter __result, _TypeT*);

  template <class _InputIter, class _OutputIter>
  inline _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                       _OutputIter __result,
                                       output_iterator_tag)
  {
    return __unique_copy(__first, __last, __result,
                         __value_type (__first));
  }

  template <class _InputIter, class _OutputIter>
  inline _OutputIter unique_copy (_InputIter __first, _InputIter __last,
                                     _OutputIter __result)
  {
    return __first == __last ? __result :


    __unique_copy(__first, __last, __result,
        typename iterator_traits<_OutputIter>::iterator_category());






  }

  template <class _InputIter, class _FwdIter, class _BinaryPredicate>
  _FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                                 _FwdIter __result,
                                 _BinaryPredicate __binary_pred,
                                 forward_iterator_tag);
  template <class _InputIter, class _BidirIter,
  class _BinaryPredicate>
  inline _BidirIter __unique_copy (_InputIter __first,
                                              _InputIter __last,
                                              _BidirIter __result,
                                              _BinaryPredicate __binary_pred,
                                              bidirectional_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred,
                         forward_iterator_tag());
  }

  template <class _InputIter, class _RandomAccessIter,
  class _BinaryPredicate>
  inline _RandomAccessIter __unique_copy (_InputIter __first,
                                             _InputIter __last,
                                             _RandomAccessIter __result,
                                             _BinaryPredicate __binary_pred,
                                             random_access_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred,
                         forward_iterator_tag());
  }

  template <class _InputIter, class _OutputIter, class _BinaryPredicate,
  class _TypeT>
  _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                _OutputIter __result,
                                _BinaryPredicate __binary_pred, _TypeT*);

  template <class _InputIter, class _OutputIter, class _BinaryPredicate>
  inline _OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                                       _OutputIter __result,
                                       _BinaryPredicate __binary_pred,
                                       output_iterator_tag)
  {
    return __unique_copy(__first, __last, __result, __binary_pred,
                         __value_type (__first));
  }

  template <class _InputIter, class _OutputIter, class _BinaryPredicate>
  inline _OutputIter unique_copy (_InputIter __first, _InputIter __last,
                                     _OutputIter __result,
                                     _BinaryPredicate __binary_pred)
  {
    return __first == __last ? __result :




    __unique_copy(__first, __last, __result, __binary_pred,
        typename iterator_traits<_OutputIter>::iterator_category());
  }

  template <class _FwdIter>
  inline _FwdIter unique (_FwdIter __first, _FwdIter __last)
  {
    __first = std::adjacent_find(__first, __last);
    return std::unique_copy(__first, __last, __first);
  }

  template <class _FwdIter, class _BinaryPredicate>
  inline _FwdIter unique (_FwdIter __first, _FwdIter __last,
                                 _BinaryPredicate __binary_pred)
  {
    __first = std::adjacent_find(__first, __last, __binary_pred);
    return std::unique_copy(__first, __last, __first, __binary_pred);
  }

  template <class _BidirIter>
  void __reverse (_BidirIter __first, _BidirIter __last,
                  bidirectional_iterator_tag);

  template <class _RandomAccessIter>
  void __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
                  random_access_iterator_tag);

  template <class _BidirIter>
  inline void reverse (_BidirIter __first, _BidirIter __last)
  {


    __reverse(__first, __last,
        typename iterator_traits<_BidirIter>::iterator_category());






  }

  template <class _BidirIter, class _OutputIter>
  _OutputIter reverse_copy (_BidirIter __first,
                               _BidirIter __last,
                               _OutputIter __result);

  template <class _FwdIter, class _Distance>
  void __rotate (_FwdIter __first, _FwdIter __middle,
                 _FwdIter __last, _Distance*, forward_iterator_tag);

  template <class _BidirIter, class _Distance>
  inline void __rotate (_BidirIter __first,
                        _BidirIter __middle,
                        _BidirIter __last, _Distance*,
                        bidirectional_iterator_tag)
  {
    std::reverse(__first, __middle);
    std::reverse(__middle, __last);
    std::reverse(__first, __last);
  }

  template <class _EuclideanRingElement>
  _EuclideanRingElement __gcd (_EuclideanRingElement __m,
                               _EuclideanRingElement __n);

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __rotate_cycle (_RandomAccessIter __first, _RandomAccessIter __last,
                       _RandomAccessIter __initial,
                       _Distance __shift, _TypeT*);

  template <class _RandomAccessIter, class _Distance>
  void __rotate (_RandomAccessIter __first, _RandomAccessIter __middle,
                 _RandomAccessIter __last, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter>
  inline void rotate (_FwdIter __first, _FwdIter __middle,
                      _FwdIter __last)
  {
    if (!(__first == __middle || __middle == __last))
    {



      __rotate(__first, __middle, __last,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
    }
  }

  template <class _FwdIter, class _OutputIter>
  inline _OutputIter rotate_copy (_FwdIter __first,
                                     _FwdIter __middle,
                                     _FwdIter __last,
                                     _OutputIter __result)
  {
    return std::copy(__first, __middle,
                         std::copy(__middle, __last, __result));
  }

  template <class _RandomAccessIter, class _Distance>
  void __random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Distance*);

  template <class _RandomAccessIter>
  inline void random_shuffle (_RandomAccessIter __first,
                              _RandomAccessIter __last)
  {
    __random_shuffle(__first, __last, __distance_type(__first));
  }

  template <class _RandomAccessIter, class _RandomNumberGenerator>
  void random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                       _RandomNumberGenerator& __rand);

  template <class _BidirIter, class _Predicate>
  _BidirIter partition (_BidirIter __first,
                                   _BidirIter __last, _Predicate __pred);

  template <class _BidirIter, class _Predicate, class _Distance>
  _BidirIter __inplace_stable_partition (_BidirIter __first,
                                                    _BidirIter __last,
                                                    _Predicate __pred,
                                                    _Distance __len);

  template <class _BidirIter, class _Pointer, class _Predicate,
  class _Distance, class _TypeT>
  _BidirIter __stable_partition_adaptive (_BidirIter __first,
                                          _BidirIter __last,
                                          _Predicate __pred,
                                          _Distance __len,
                                          _Pointer __buffer,
                                          _Distance __buffer_size,
                                          _Distance& __fill_pointer, _TypeT*);

  template <class _BidirIter, class _Predicate, class _Pointer,
  class _Distance>
  _BidirIter __stable_partition (_BidirIter __first,
                                            _BidirIter __last,
                                            _Predicate __pred,
                                            _Distance __len,
                                            pair<_Pointer, _Distance> __p);


template <class _BidirIter, class _Predicate, class _Distance>
inline _BidirIter __stable_partition_aux (_BidirIter __first,
                                          _BidirIter __last,
                                          _Predicate __pred,
                                          _Distance*)
{
    _Distance __len = std::distance (__first, __last);



    return __len == 0 ? __last :
        __stable_partition (__first, __last, __pred, __len,
                          std::get_temporary_buffer (__len,
                                                __value_type (__first)));
}


  template <class _BidirIter, class _Predicate>
  inline _BidirIter stable_partition (_BidirIter __first,
                                                 _BidirIter __last,
                                                 _Predicate __pred)
  {
    return __stable_partition_aux(__first, __last, __pred,
      __distance_type(__first));
  }





  template <class _TypeT>
  inline const _TypeT& __median (const _TypeT& __a,
                                 const _TypeT& __b,
                                 const _TypeT& __c)
  {
    if (__a < __b)
      if (__b < __c)
        return __b;
      else if (__a < __c)
        return __c;
      else
        return __a;
    else if (__a < __c)
      return __a;
    else if (__b < __c)
      return __c;
    else
      return __b;
  }

  template <class _TypeT, class _Compare>
  inline const _TypeT& __median (const _TypeT& __a, const _TypeT& __b,
                                 const _TypeT& __c, _Compare __comp)
  {
    if (__comp(__a, __b))
      if (__comp(__b, __c))
        return __b;
      else if (__comp(__a, __c))
        return __c;
      else
        return __a;
    else if (__comp(__a, __c))
      return __a;
    else if (__comp(__b, __c))
      return __c;
    else
      return __b;
  }

  template <class _RandomAccessIter, class _TypeT>
  _RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                              _RandomAccessIter __last,
                                              _TypeT __pivot);

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  _RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                              _RandomAccessIter __last,
                                              _TypeT __pivot,
                                              _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  void __quick_sort_loop_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void __quick_sort_loop (_RandomAccessIter __first,
                                 _RandomAccessIter __last)
  {
    __quick_sort_loop_aux(__first, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __quick_sort_loop_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last,
                              _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void __quick_sort_loop (_RandomAccessIter __first,
                                 _RandomAccessIter __last, _Compare __comp)
  {
    __quick_sort_loop_aux(__first, __last, __value_type (__first),
                          __comp);
  }

  template <class _RandomAccessIter, class _TypeT>
  void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __value);

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __unguarded_linear_insert (_RandomAccessIter __last,_TypeT __value,
      _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  inline void __linear_insert (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*)
  {
    _TypeT __value = *__last;
    if (__value < *__first)
    {
      std::copy_backward(__first, __last, __last + 1);
      *__first = __value;
    }
    else
      __unguarded_linear_insert(__last, __value);
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  inline void __linear_insert (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*,
                               _Compare __comp)
  {
    _TypeT __value = *__last;
    if (__comp(__value, *__first))
    {
      std::copy_backward(__first, __last, __last + 1);
      *__first = __value;
    }
    else
      __unguarded_linear_insert(__last, __value, __comp);
  }

  template <class _RandomAccessIter>
  void __insertion_sort (_RandomAccessIter __first, _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void __insertion_sort (_RandomAccessIter __first,
                         _RandomAccessIter __last, _Compare __comp);

  template <class _RandomAccessIter, class _TypeT>
  void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                       _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void __unguarded_insertion_sort(_RandomAccessIter __first,
                                         _RandomAccessIter __last)
  {
    __unguarded_insertion_sort_aux(__first, __last,
      __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                       _RandomAccessIter __last,
                                       _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void __unguarded_insertion_sort (_RandomAccessIter __first,
                                          _RandomAccessIter __last,
                                          _Compare __comp)
  {
    __unguarded_insertion_sort_aux(__first, __last,
      __value_type (__first), __comp);
  }

  template <class _RandomAccessIter>
  void __final_insertion_sort (_RandomAccessIter __first,
                               _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void __final_insertion_sort (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Compare __comp);

  template <class _RandomAccessIter>
  inline void sort (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
    {
      __quick_sort_loop(__first, __last);
      __final_insertion_sort(__first, __last);
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void sort (_RandomAccessIter __first,
                    _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
    {
      __quick_sort_loop(__first, __last, __comp);
      __final_insertion_sort(__first, __last, __comp);
    }
  }

  template <class _RandomAccessIter>
  inline void __inplace_stable_sort (_RandomAccessIter __first,
                                     _RandomAccessIter __last)
  {
    if (__last - __first < 15)
      __insertion_sort(__first, __last);
    else
    {
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle);
      __inplace_stable_sort(__middle, __last);
      __merge_without_buffer(__first, __middle, __last, __middle - __first,
                             __last - __middle);
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void __inplace_stable_sort (_RandomAccessIter __first,
                                     _RandomAccessIter __last,
                                     _Compare __comp)
  {
    if (__last - __first < 15)
      __insertion_sort(__first, __last, __comp);
    else
    {
      _RandomAccessIter __middle = __first + (__last - __first) / 2;
      __inplace_stable_sort(__first, __middle, __comp);
      __inplace_stable_sort(__middle, __last, __comp);
      __merge_without_buffer(__first, __middle, __last, __middle - __first,
                             __last - __middle, __comp);
    }
  }

  template <class _RandomAccessIter1, class _RandomAccessIter2,
  class _Distance>
  void __merge_sort_loop (_RandomAccessIter1 __first,
                          _RandomAccessIter1 __last,
                          _RandomAccessIter2 __result, _Distance __step_size);

  template <class _RandomAccessIter1, class _RandomAccessIter2,
  class _Distance, class _Compare>
  void __merge_sort_loop (_RandomAccessIter1 __first,
                          _RandomAccessIter1 __last,
                          _RandomAccessIter2 __result, _Distance __step_size,
                          _Compare __comp);

  template <class _RandomAccessIter, class _Distance>
  void __chunk_insertion_sort (_RandomAccessIter __first,
                               _RandomAccessIter __last,
                               _Distance __chunk_size);

  template <class _RandomAccessIter, class _Distance, class _Compare>
  void __chunk_insertion_sort (_RandomAccessIter __first,
                               _RandomAccessIter __last,
                               _Distance __chunk_size, _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  void __merge_sort_with_buffer (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 _Pointer __buffer, _Distance*, _TypeT*);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT,
  class _Compare>
  void __merge_sort_with_buffer (_RandomAccessIter __first,
                                 _RandomAccessIter __last, _Pointer __buffer,
                                 _Distance*, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  void __stable_sort_adaptive (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Pointer __buffer,
                               _Distance __buffer_size, _TypeT*);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT, class _Compare>
  void __stable_sort_adaptive (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Pointer __buffer,
                               _Distance __buffer_size, _TypeT*,
                               _Compare __comp);

  template <class _RandomAccessIter, class _Pointer, class _Distance,
            class _TypeT>
  inline void __stable_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             pair<_Pointer, _Distance>& __p, _TypeT*)
  {
    if (__p.first == 0)
      __inplace_stable_sort(__first, __last);
    else
    {
      _Distance __len = std::min((int)__p.second, (int)(__last - __first));
      copy(__first, __first + __len,
           raw_storage_iterator<_Pointer, _TypeT>(__p.first));
      __stable_sort_adaptive(__first, __last, __p.first, __p.second,
                             static_cast< _TypeT* >(0));
      __rw::__rw_destroy(__p.first, __p.first + __len);
      return_temporary_buffer(__p.first);
    }
  }

  template <class _RandomAccessIter, class _Pointer, class _Distance,
      class _TypeT, class _Compare>
  inline void __stable_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             pair<_Pointer, _Distance>& __p, _TypeT*,
                             _Compare __comp)
  {
    if (__p.first == 0)
      __inplace_stable_sort(__first, __last, __comp);
    else
    {
      _Distance __len = min((int)__p.second, (int)(__last - __first));
      copy(__first, __first + __len,
           raw_storage_iterator<_Pointer, _TypeT>(__p.first));
      __stable_sort_adaptive(__first, __last, __p.first, __p.second,
               static_cast< _TypeT* >(0), __comp);
      __rw::__rw_destroy(__p.first, __p.first + __len);
      std::return_temporary_buffer(__p.first);
    }
  }


template <class _RandomAccessIter, class _TypeT, class _Distance>
inline void __stable_sort_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*,
                               _Distance*)
{


    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (_Distance (__last - __first),
                                       (_TypeT*)0);

    __stable_sort (__first, __last, __buf, static_cast< _TypeT* >(0));
}


template <class _RandomAccessIter, class _TypeT, class _Distance,
    class _Compare>
inline void __stable_sort_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _TypeT*,
                               _Distance*,
                               _Compare __comp)
{


    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (_Distance (__last - __first),
                                       (_TypeT*)0);

    __stable_sort (__first, __last, __buf, static_cast< _TypeT* >(0),
                   __comp);
}


  template <class _RandomAccessIter>
  inline void stable_sort (_RandomAccessIter __first,
                           _RandomAccessIter __last)
  {
    if (!(__first == __last))
    {
      __stable_sort_aux(__first, __last, __value_type (__first),
                        __distance_type(__first));
    }
  }

  template <class _RandomAccessIter, class _Compare>
  inline void stable_sort (_RandomAccessIter __first,
                           _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
    {
      __stable_sort_aux(__first, __last, __value_type (__first),
                        __distance_type(__first), __comp);
    }
  }

  template <class _RandomAccessIter, class _TypeT>
  void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                       _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void partial_sort (_RandomAccessIter __first,
                            _RandomAccessIter __middle,
                            _RandomAccessIter __last)
  {
    if (!(__first == __middle))
      __partial_sort(__first, __middle, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                       _RandomAccessIter __last, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void partial_sort (_RandomAccessIter __first,
                            _RandomAccessIter __middle,
                            _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __middle))
      __partial_sort(__first, __middle, __last, __value_type (__first),
                     __comp);
  }

  template <class _InputIter, class _RandomAccessIter, class _Distance,
      class _TypeT>
  _RandomAccessIter __partial_sort_copy (_InputIter __first,
                                            _InputIter __last,
                                            _RandomAccessIter __result_first,
                                            _RandomAccessIter __result_last,
                                            _Distance*, _TypeT*);

  template <class _InputIter, class _RandomAccessIter>
  inline _RandomAccessIter
  partial_sort_copy (_InputIter __first, _InputIter __last,
                     _RandomAccessIter __result_first,
                     _RandomAccessIter __result_last)
  {
    return __first == __last ? __result_first :
    __partial_sort_copy(__first, __last, __result_first, __result_last,
                        __distance_type(__result_first),
                        __value_type (__first));
  }

  template <class _InputIter, class _RandomAccessIter, class _Compare,
  class _Distance, class _TypeT>
  _RandomAccessIter __partial_sort_copy (_InputIter __first,
                                            _InputIter __last,
                                            _RandomAccessIter __result_first,
                                            _RandomAccessIter __result_last,
                                            _Compare __comp, _Distance*,
                                            _TypeT*);

  template <class _InputIter, class _RandomAccessIter, class _Compare>
  inline _RandomAccessIter
  partial_sort_copy (_InputIter __first, _InputIter __last,
                     _RandomAccessIter __result_first,
                     _RandomAccessIter __result_last, _Compare __comp)
  {
    return __first == __last ? __result_first :
    __partial_sort_copy(__first, __last, __result_first, __result_last,
                        __comp,
                        __distance_type(__result_first),
                        __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT>
  void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                      _RandomAccessIter __last, _TypeT*);

  template <class _RandomAccessIter>
  inline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                           _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __nth_element(__first, __nth, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                      _RandomAccessIter __last, _TypeT*, _Compare __comp);

  template <class _RandomAccessIter, class _Compare>
  inline void nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                           _RandomAccessIter __last, _Compare __comp)
  {
    if (!(__first == __last))
      __nth_element(__first, __nth, __last, __value_type (__first),
                    __comp);
  }





  template <class _FwdIter, class _TypeT, class _Distance>
  _FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline _FwdIter __lower_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __lower_bound(__first, __last, __value,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  _RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value,
                                      _Distance*, random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter lower_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value)
  {



    return __lower_bound(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  _FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Compare __comp,
                                 _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline _FwdIter __lower_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value,
                                        _Compare __comp, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __lower_bound(__first, __last, __value, __comp,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  _RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value, _Compare __comp,
                                      _Distance*,
                                      random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline _FwdIter lower_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value, _Compare __comp)
  {


    return __lower_bound(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT, class _Distance>
  _FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline _FwdIter __upper_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __upper_bound(__first, __last, __value,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  _RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value,
                                      _Distance*, random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline _FwdIter upper_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value)
  {


    return __upper_bound(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  _FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                                 const _TypeT& __value, _Compare __comp,
                                 _Distance*,
                                 forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline _FwdIter __upper_bound (_FwdIter __first,
                                        _FwdIter __last,
                                        const _TypeT& __value,
                                        _Compare __comp, _Distance*,
                                        bidirectional_iterator_tag)
  {
    return __upper_bound(__first, __last, __value, __comp,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  _RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                      _RandomAccessIter __last,
                                      const _TypeT& __value, _Compare __comp,
                                      _Distance*,
                                      random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline _FwdIter upper_bound (_FwdIter __first,_FwdIter __last,
                                      const _TypeT& __value, _Compare __comp)
  {


    return __upper_bound(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT, class _Distance>
  pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Distance*, forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Distance>
  inline pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Distance*, bidirectional_iterator_tag)
  {
    return __equal_range(__first, __last, __value,
                         static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  pair<_RandomAccessIter, _RandomAccessIter>
  __equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
                 const _TypeT& __value, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter, class _TypeT>
  inline pair<_FwdIter, _FwdIter>
  equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value)
  {


    return __equal_range(__first, __last, __value,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Compare __comp, _Distance*, forward_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
  inline pair<_FwdIter, _FwdIter>
  __equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
                 _Compare __comp, _Distance*, bidirectional_iterator_tag)
  {
    return __equal_range(__first, __last, __value, __comp,
      static_cast< _Distance* >(0),
                         forward_iterator_tag());
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  pair<_RandomAccessIter, _RandomAccessIter>
  __equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
                 const _TypeT& __value, _Compare __comp, _Distance*,
                 random_access_iterator_tag);

  template <class _FwdIter, class _TypeT, class _Compare>
  inline pair<_FwdIter, _FwdIter>
  equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __value,
               _Compare __comp)
  {


    return __equal_range(__first, __last, __value, __comp,
        static_cast< typename iterator_traits<_FwdIter>::difference_type* >(0),
        typename iterator_traits<_FwdIter>::iterator_category());
  }

  template <class _FwdIter, class _TypeT>
  inline bool binary_search (_FwdIter __first, _FwdIter __last,
                             const _TypeT& __value)
  {
    _FwdIter __i = std::lower_bound(__first, __last, __value);
    return __i != __last && !(__value < *__i);
  }

  template <class _FwdIter, class _TypeT, class _Compare>
  inline bool binary_search (_FwdIter __first, _FwdIter __last,
                             const _TypeT& __value, _Compare __comp)
  {
    _FwdIter __i = std::lower_bound(__first, __last, __value, __comp);
    return __i != __last && !__comp(__value, *__i);
  }





  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                        _InputIter2 __first2, _InputIter2 __last2,
                        _OutputIter __result, _Compare __comp);

  template <class _BidirIter, class _Distance>
  void __merge_without_buffer (_BidirIter __first,
                               _BidirIter __middle,
                               _BidirIter __last,
                               _Distance __len1, _Distance __len2);

  template <class _BidirIter, class _Distance, class _Compare>
  void __merge_without_buffer (_BidirIter __first,
                               _BidirIter __middle,
                               _BidirIter __last,
                               _Distance __len1, _Distance __len2,
                               _Compare __comp);

  template <class _BidirIter1, class _BidirIter2,
  class _Distance>
  _BidirIter1 __rotate_adaptive (_BidirIter1 __first,
                                            _BidirIter1 __middle,
                                            _BidirIter1 __last,
                                            _Distance __len1,
                                            _Distance __len2,
                                            _BidirIter2 __buffer,
                                            _Distance __buffer_size);

  template <class _BidirIter1, class _BidirIter2,
  class _BidirIter3>
  _BidirIter3 __merge_backward (_BidirIter1 __first1,
                                           _BidirIter1 __last1,
                                           _BidirIter2 __first2,
                                           _BidirIter2 __last2,
                                           _BidirIter3 __result);

  template <class _BidirIter1, class _BidirIter2,
  class _BidirIter3, class _Compare>
  _BidirIter3 __merge_backward (_BidirIter1 __first1,
                                           _BidirIter1 __last1,
                                           _BidirIter2 __first2,
                                           _BidirIter2 __last2,
                                           _BidirIter3 __result,
                                           _Compare __comp);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
  void __merge_adaptive (_BidirIter __first,
                         _BidirIter __middle,
                         _BidirIter __last, _Distance __len1,_Distance __len2,
                         _Pointer __buffer, _Distance __buffer_size, _TypeT*);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
  class _Compare>
  void __merge_adaptive (_BidirIter __first,
                         _BidirIter __middle,
                         _BidirIter __last, _Distance __len1,_Distance __len2,
                         _Pointer __buffer, _Distance __buffer_size, _TypeT*,
                         _Compare __comp);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
  void __inplace_merge (_BidirIter __first,
                        _BidirIter __middle,
                        _BidirIter __last, _Distance __len1,
                        _Distance __len2, pair<_Pointer, _Distance> __p,
                        _TypeT*);

  template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
  class _Compare>
  void __inplace_merge (_BidirIter __first,
                        _BidirIter __middle,
                        _BidirIter __last, _Distance __len1,
                        _Distance __len2, pair<_Pointer, _Distance> __p,
                        _TypeT*,
                        _Compare __comp);


template <class _BidirIter, class _TypeT, class _Distance>
inline void __inplace_merge_aux (_BidirIter __first,
                                 _BidirIter __middle,
                                 _BidirIter __last, _TypeT*, _Distance*)
{
    _Distance __len1 = std::distance (__first, __middle);
    _Distance __len2 = std::distance (__middle, __last);



    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (__len1 + __len2, (_TypeT*)0);

    __inplace_merge (__first, __middle, __last, __len1, __len2, __buf,
                     (_TypeT*)0);
}


template <class _BidirIter, class _TypeT, class _Distance, class _Compare>
inline void __inplace_merge_aux (_BidirIter __first,
                                 _BidirIter __middle,
                                 _BidirIter __last, _TypeT*, _Distance*,
                                 _Compare __comp)
{
    _Distance __len1 = std::distance (__first, __middle);
    _Distance __len2 = std::distance (__middle, __last);

    pair<_TypeT*, _Distance> __buf =
        std::get_temporary_buffer (__len1 + __len2, (_TypeT*)0);

    __inplace_merge (__first, __middle, __last, __len1, __len2, __buf,
                     (_TypeT*)0);
}


template <class _BidirIter>
inline void inplace_merge (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last)
  {
    if (!(__first == __middle || __middle == __last))
      __inplace_merge_aux(__first, __middle, __last,
                          __value_type (__first),
                          __distance_type(__first));
  }

  template <class _BidirIter, class _Compare>
  inline void inplace_merge (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last, _Compare __comp)
  {
    if (!(__first == __middle || __middle == __last))
      __inplace_merge_aux(__first, __middle, __last,
                          __value_type (__first),
                          __distance_type(__first), __comp);
  }





  template <class _InputIter1, class _InputIter2>
  bool includes (_InputIter1 __first1, _InputIter1 __last1,
                 _InputIter2 __first2, _InputIter2 __last2);

  template <class _InputIter1, class _InputIter2, class _Compare>
  bool includes (_InputIter1 __first1, _InputIter1 __last1,
                 _InputIter2 __first2, _InputIter2 __last2,
                 _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2,
                                   _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _InputIter2 __last2,
                                   _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2,
                                 _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                                 _InputIter2 __first2, _InputIter2 __last2,
                                 _OutputIter __result, _Compare __comp);

  template <class _InputIter1, class _InputIter2, class _OutputIter>
  _OutputIter set_symmetric_difference (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _InputIter2 __last2,
                                           _OutputIter __result);

  template <class _InputIter1, class _InputIter2, class _OutputIter,
  class _Compare>
  _OutputIter set_symmetric_difference (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _InputIter2 __last2,
                                           _OutputIter __result,
                                           _Compare __comp);





  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __topIndex, _TypeT __value);

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  inline void __push_heap_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Distance*, _TypeT*)
  {
    __push_heap(__first, _Distance((__last-__first)-1), _Distance(0),
      _TypeT(*(__last-1)));
  }

  template <class _RandomAccessIter>
  inline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __push_heap_aux(__first, __last, __distance_type(__first),
                      __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT,
      class _Compare>
  void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __topIndex, _TypeT __value, _Compare __comp);

  template <class _RandomAccessIter, class _Compare, class _Distance,
      class _TypeT>
  inline void __push_heap_aux (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Compare __comp,
                               _Distance*, _TypeT*)
  {
    __push_heap(__first, _Distance((__last-__first)-1), _Distance(0),
                _TypeT(*(__last - 1)), __comp);
  }

  template <class _RandomAccessIter, class _Compare>
  inline void push_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Compare __comp)
  {
    if (!(__first == __last))
      __push_heap_aux(__first, __last, __comp, __distance_type(__first),
                      __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT>
  void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                      _Distance __len, _TypeT __value);

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  inline void __pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                          _RandomAccessIter __result, _TypeT __value,
                          _Distance*)
  {
    *__result = *__first;
    __adjust_heap(__first, _Distance(0), _Distance(__last - __first),
                  __value);
  }

  template <class _RandomAccessIter, class _TypeT>
  inline void __pop_heap_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*)
  {
    __pop_heap(__first, __last-1, __last-1, _TypeT(*(__last-1)),
      __distance_type(__first));
  }

  template <class _RandomAccessIter>
  inline void pop_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__first == __last))
      __pop_heap_aux(__first, __last, __value_type (__first));
  }

  template <class _RandomAccessIter, class _Distance, class _TypeT,
      class _Compare>
  void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                      _Distance __len, _TypeT __value, _Compare __comp);

  template <class _RandomAccessIter, class _TypeT, class _Compare,
      class _Distance>
  inline void __pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                          _RandomAccessIter __result, _TypeT __value,
                          _Compare __comp, _Distance*)
  {
    *__result = *__first;
    __adjust_heap(__first, _Distance(0), _Distance(__last - __first), __value,
      __comp);
  }

  template <class _RandomAccessIter, class _TypeT, class _Compare>
  inline void __pop_heap_aux (_RandomAccessIter __first,
                              _RandomAccessIter __last, _TypeT*,
                              _Compare __comp)
  {
    __pop_heap(__first, __last - 1, __last - 1, _TypeT(*(__last - 1)), __comp,
               __distance_type(__first));
  }

  template <class _RandomAccessIter, class _Compare>
  inline void pop_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                        _Compare __comp)
  {
    if (!(__first == __last))
      __pop_heap_aux(__first, __last, __value_type (__first), __comp);
  }

  template <class _RandomAccessIter, class _TypeT, class _Distance>
  void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
      _TypeT*, _Distance*);

  template <class _RandomAccessIter>
  inline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    if (!(__last - __first < 2))
      __make_heap(__first, __last, __value_type (__first),
                  __distance_type(__first));
  }

  template <class _RandomAccessIter, class _Compare, class _TypeT,
      class _Distance>
  void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                    _Compare __comp, _TypeT*, _Distance*);

  template <class _RandomAccessIter, class _Compare>
  inline void make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                         _Compare __comp)
  {
    if (!(__last - __first < 2))
      __make_heap(__first, __last, __comp, __value_type (__first),
                  __distance_type(__first));
  }

  template <class _RandomAccessIter>
  void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last);

  template <class _RandomAccessIter, class _Compare>
  void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare __comp);






  template <class _TypeT>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b)
  {
    return __b < __a ? __b : __a;
  }


  template <class _TypeT, class _Compare>
  inline const _TypeT& min (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp)
  {
    return __comp(__b, __a) ? __b : __a;
  }


  template <class _TypeT>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b)
  {
    return __a < __b ? __b : __a;
  }


  template <class _TypeT, class _Compare>
  inline const _TypeT& max (const _TypeT& __a, const _TypeT& __b,
      _Compare __comp)
  {
    return __comp(__a, __b) ? __b : __a;
  }

  template <class _FwdIter>
  _FwdIter min_element (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _Compare>
  _FwdIter min_element (_FwdIter __first, _FwdIter __last,
                               _Compare __comp);

  template <class _FwdIter>
  _FwdIter max_element (_FwdIter __first, _FwdIter __last);

  template <class _FwdIter, class _Compare>
  _FwdIter max_element (_FwdIter __first, _FwdIter __last,
                               _Compare __comp);

  template <class _InputIter1, class _InputIter2>
  bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                                _InputIter2 __first2, _InputIter2 __last2);

  template <class _InputIter1, class _InputIter2, class _Compare>
  bool lexicographical_compare(_InputIter1 __first1, _InputIter1 __last1,
                               _InputIter2 __first2, _InputIter2 __last2,
                               _Compare __comp);





  template <class _BidirIter>
  bool next_permutation (_BidirIter __first,
                         _BidirIter __last);

  template <class _BidirIter, class _Compare>
  bool next_permutation (_BidirIter __first, _BidirIter __last,
                         _Compare __comp);

  template <class _BidirIter>
  bool prev_permutation (_BidirIter __first,
                         _BidirIter __last);

  template <class _BidirIter, class _Compare>
  bool prev_permutation (_BidirIter __first, _BidirIter __last,
                         _Compare __comp);







  template <class _OutputIter, class _TypeT>
  class raw_storage_iterator;





  template <class _InputIter, class _Function>
  inline _Function for_each (_InputIter __first, _InputIter __last,
      _Function __f)
  {
    for (;__first != __last; ++__first)
        __f(*__first);
    return __f;
  }

  template <class _InputIter, class _TypeT>
  inline _InputIter find (_InputIter __first, _InputIter __last,
      const _TypeT& __value)
  {
    while (__first != __last && *__first != __value)
      ++__first;
    return __first;
  }

  template <class _InputIter, class _Predicate>
  inline _InputIter find_if (_InputIter __first, _InputIter __last,
      _Predicate __pred)
  {
    while (__first != __last && !__pred(*__first)) ++__first;
    return __first;
  }



  template <class _FwdIter1, class _FwdIter2, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _Distance*);

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate, class _Distance>
  _FwdIter1 __find_end (_FwdIter1 __first1,
                               _FwdIter1 __last1,
                               _FwdIter2 __first2,
                               _FwdIter2 __last2,
                               _BinaryPredicate __pred,
                               _Distance*);



  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2)
  {
    return __find_end(__first1,__last1,__first2,__last2,
                      __distance_type(__first1));
  }

  template <class _FwdIter1, class _FwdIter2,
  class _BinaryPredicate>
  _FwdIter1 find_end (_FwdIter1 __first1,
                             _FwdIter1 __last1,
                             _FwdIter2 __first2,
                             _FwdIter2 __last2,
                             _BinaryPredicate __pred)
  {
    return __find_end(__first1,__last1,__first2,__last2,
                      __pred,__distance_type(__first1));
  }


  template <class _InputIter, class _TypeT>
  inline typename iterator_traits<_InputIter>::difference_type
  count (_InputIter __first, _InputIter __last, const _TypeT& __value)
  {
    typename iterator_traits<_InputIter>::difference_type __n = 0;
    for (; __first != __last; ++__first)
        if (*__first == __value)
            ++__n;
    return __n;
  }

  template <class _InputIter, class _Predicate>
  inline typename iterator_traits<_InputIter>::difference_type
  count_if (_InputIter __first, _InputIter __last, _Predicate __pred)
  {
    typename iterator_traits<_InputIter>::difference_type __n = 0;
    for (;__first != __last; ++__first)
      if (__pred(*__first))
          ++__n;
    return __n;
  }




  template <class _InputIter, class _TypeT, class _Size>
  inline void count (_InputIter __first, _InputIter __last,
                     const _TypeT& __value, _Size& __n)
  {
    for (;__first != __last;++__first)
      if (*__first == __value)
          ++__n;
  }

  template <class _InputIter, class _Predicate, class _Size>
  inline void count_if (_InputIter __first, _InputIter __last,
                        _Predicate __pred, _Size& __n)
  {
    for (;__first != __last;++__first)
      if (__pred(*__first))
          ++__n;
  }


  template <class _InputIter1, class _InputIter2>
  pair<_InputIter1, _InputIter2> mismatch(_InputIter1 __first1,
                                                _InputIter1 __last1,
                                                _InputIter2 __first2)
  {
    while (__first1 != __last1 && *__first1 == *__first2) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
  }


  template <class _InputIter1, class _InputIter2, class _BinaryPredicate>
  pair<_InputIter1, _InputIter2> mismatch (_InputIter1 __first1,
                                           _InputIter1 __last1,
                                           _InputIter2 __first2,
                                           _BinaryPredicate __binary_pred)
  {
    while (__first1 != __last1 && __binary_pred(*__first1, *__first2)) {
      ++__first1;
      ++__first2;
    }
    return pair<_InputIter1, _InputIter2> (__first1, __first2);
  }





  template <class _InputIter, class _OutputIter>
  inline _OutputIter copy (_InputIter __first, _InputIter __last,
                              _OutputIter __result)
  {
    for (; __first != __last; ++__first,++__result)
        *__result = *__first;
    return __result;
  }

  template <class _BidirIter1, class _BidirIter2>
  inline _BidirIter2 copy_backward (_BidirIter1 __first,
                                        _BidirIter1 __last,
                                        _BidirIter2 __result)
  {
      while (__first != __last)
          *--__result = *--__last;
      return __result;
  }

  template <class _FwdIter1, class _FwdIter2>
  inline _FwdIter2 swap_ranges (_FwdIter1 __first1,
                                       _FwdIter1 __last1,
                                       _FwdIter2 __first2)
  {
      for (;__first1 != __last1; ++__first1, ++__first2)
          std::iter_swap(__first1, __first2);
      return __first2;
  }


  template <class _InputIter, class _OutputIter, class _UnaryOperation>
  inline _OutputIter transform (_InputIter __first, _InputIter __last,
                                   _OutputIter __result,
                                   _UnaryOperation __unary_op)
  {
    for (;__first != __last;++__result,++__first)
        *__result = __unary_op(*__first);
    return __result;
  }

  template <class _InputIter1, class _InputIter2,
            class _OutputIter, class _BinaryOperation>
  inline _OutputIter transform (_InputIter1 __first1, _InputIter1 __last1,
                                   _InputIter2 __first2, _OutputIter __result,
                                   _BinaryOperation __binary_op)
  {
      for (;__first1 != __last1;++__result,++__first1,++__first2)
          *__result = __binary_op(*__first1, *__first2);
      return __result;
  }

  template <class _FwdIter, class _TypeT>
  inline void replace (_FwdIter __first, _FwdIter __last,
                       const _TypeT& __old_value, const _TypeT& __new_value)
  {
      for (;__first != __last;++__first)
          if (*__first == __old_value)
              *__first = __new_value;
  }

  template <class _FwdIter, class _Predicate, class _TypeT>
  inline void replace_if (_FwdIter __first, _FwdIter __last,
                          _Predicate __pred, const _TypeT& __new_value)
  {
      for (;__first != __last;++__first)
          if (__pred(*__first))
              *__first = __new_value;
  }


  template <class _InputIter, class _OutputIter, class _TypeT>
  inline _OutputIter replace_copy (_InputIter __first, _InputIter __last,
                               _OutputIter __result,
                               const _TypeT& __old_value,
                               const _TypeT& __new_value)
  {
      for (;__first != __last;++__first,++__result)
          *__result = *__first == __old_value ? __new_value : *__first;
      return __result;
  }

  template <class _FwdIter, class _TypeT>




  inline void fill (_FwdIter __first, _FwdIter __last, const _TypeT& __value)

  {
      for (;__first != __last; ++__first)
          *__first = __value;
  }

  template <class _OutputIter, class _Size, class _TypeT>
  inline void fill_n (_OutputIter __first, _Size __n, const _TypeT& __value)
  {
      for (;__n > 0;--__n, ++__first)
          *__first = __value;
  }

  template <class _FwdIter, class _Generator>
  inline void generate (_FwdIter __first, _FwdIter __last, _Generator __gen)
  {
      for (;__first != __last;++__first)
          *__first = __gen();
  }

  template <class _OutputIter, class _Size, class _Generator>
  inline void generate_n (_OutputIter __first, _Size __n, _Generator __gen)
  {
      for (;__n > 0;--__n, ++__first)
          *__first = __gen();
  }

  template <class _BidirIter>
  inline void __reverse (_BidirIter __first, _BidirIter __last,
                  bidirectional_iterator_tag)
  {
      for(; __first != __last && __first != --__last; ++__first)
          std::iter_swap(__first, __last);
  }

  template <class _RandomAccessIter>
  inline void __reverse (_RandomAccessIter __first, _RandomAccessIter __last,
                  random_access_iterator_tag)
  {
      for (; __first < __last; ++__first)
          std::iter_swap(__first, --__last);
  }

  template <class _BidirIter, class _OutputIter>
  inline _OutputIter reverse_copy (_BidirIter __first,
                               _BidirIter __last,
                               _OutputIter __result)
  {
      for (;__first != __last; ++__result)
          *__result = *--__last;
      return __result;
  }


  template <class _RandomAccessIter>
  inline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last)
  {
    while (__last - __first > 1)
        std::pop_heap(__first, __last--);
  }

  template <class _RandomAccessIter, class _Compare>
  inline void sort_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare _RWSTD_COMP)
  {
    while (__last - __first > 1)
        std::pop_heap(__first, __last--, _RWSTD_COMP);
  }

}
namespace __rw {


using std::size_t;


template <unsigned _SIZE>
class __rw_random_generator
{
    enum { _C_SIZE = _SIZE };

    unsigned long _C_table [_C_SIZE];
    size_t _C_index1;
    size_t _C_index2;

public:

    __rw_random_generator (unsigned long __seed = 161803398) {
        seed (__seed);
    }

    void seed (unsigned long __seed);

    unsigned long operator() (unsigned long __limit);

    static unsigned long generate (unsigned long __limit);
};


template <unsigned _SIZE>
inline unsigned long
__rw_random_generator<_SIZE>::operator() (unsigned long __limit)
{
    ((void)0);

    _C_table [++_C_index1 %= _C_SIZE] -= _C_table [++_C_index2 %= _C_SIZE];

    return _C_table [_C_index1] % __limit;
}


template <unsigned _SIZE>
inline unsigned long
__rw_random_generator<_SIZE>::generate (unsigned long __limit)
{
    ((void)0);

    static __rw_random_generator __gen;

    return __gen (__limit);
}


template <class _Distance>
inline _Distance __rw_random (_Distance __limit)
{
    return __rw_random_generator<55>::generate (__limit);
}


}
namespace __rw {


template <unsigned _SIZE>
void __rw_random_generator<_SIZE>::seed (unsigned long __seed)
{
    unsigned long __k = 1;

    _C_table [_C_SIZE - 1] = __seed;

    size_t __i;

    for (__i = 0; __i != _C_SIZE - 1; ++__i) {
        size_t __ii = 21 * __i % _C_SIZE;
        _C_table [__ii] = __k;
        __k = __seed - __k;
        __seed = _C_table [__ii];
    }

    for (__i = 0; __i != 4; ++__i) {
        for (size_t __ii = 0; __ii != _C_SIZE; ++__ii)
            _C_table [__i] =
                _C_table [__i] - _C_table [(__i + 31) % _C_SIZE];
    }

    _C_index1 = 0;
    _C_index2 = _C_SIZE * 2 / 3 - 1;
}


}






namespace std {


template <class _FwdIter1, class _FwdIter2, class _Distance>
_FwdIter1 __find_end (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _Distance*)
{
    ((void)0);
    ((void)0);

    _Distance __dist1 = std::distance (__first2, __last2);

    if (!__dist1)
        return __last1;

    _Distance __dist2 = std::distance (__first1, __last1);

    _FwdIter1 __result = __last1;

    while (__dist2 >= __dist1) {
        if (equal (__first2, __last2, __first1))
            __result = __first1;

        __dist2 = std::distance (++__first1, __last1);
    }
    return __result;
}



template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate, class _Distance>
_FwdIter1 __find_end (_FwdIter1 __first1, _FwdIter1 __last1,
                      _FwdIter2 __first2, _FwdIter2 __last2,
                      _BinaryPredicate __pred, _Distance*)
{
    ((void)0);
    ((void)0);

    _Distance __dist1 = std::distance (__first2, __last2);

    if (!__dist1)
        return __last1;

    _Distance __dist2 = std::distance (__first1, __last1);

    _FwdIter1 __save = __last1;

    while (__dist2 >= __dist1)
    {
        if (std::equal (__first2, __last2, __first1, __pred))
            __save = __first1;
        __dist2 = std::distance (++__first1, __last1);
    }
    return __save;
}


template <class _FwdIter1, class _FwdIter2>
_FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                         _FwdIter2 __first2, _FwdIter2 __last2)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2)
        return __last1;
    _FwdIter1 __next = __first1;
    while (__next != __last1)
    {
        if (std::find (__first2, __last2, *__next) != __last2)
            return __next;
        ++__next;
    }
    return __last1;
}


template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate>
_FwdIter1 find_first_of (_FwdIter1 __first1, _FwdIter1 __last1,
                         _FwdIter2 __first2, _FwdIter2 __last2,
                         _BinaryPredicate __pred)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2)
        return __last1;

    for (_FwdIter1 __next = __first1; __next != __last1; ++__next)
        for (_FwdIter2 __iter = __first2; __iter != __last2; ++__iter)
            if (__pred (*__next, *__iter))
                return __next;
    return __last1;
}


template <class _FwdIter>
_FwdIter adjacent_find (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last) return __last;
    _FwdIter __next = __first;
    while (++__next != __last)
    {
        if (*__first == *__next) return __first;
        __first = __next;
    }
    return __last;
}


template <class _FwdIter, class _BinaryPredicate>
_FwdIter adjacent_find (_FwdIter __first, _FwdIter __last,
                        _BinaryPredicate __pred)
{
    ((void)0);

    if (__first == __last) return __last;
    _FwdIter __next = __first;
    while (++__next != __last) {
        if (__pred (*__first, *__next))
            return __first;
        __first = __next;
    }
    return __last;
}



template <class _FwdIter1, class _FwdIter2,
    class _Distance1, class _Distance2>
_FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                    _FwdIter2 __first2, _FwdIter2 __last2,
                    _Distance1*, _Distance2*)
{
    ((void)0);
    ((void)0);

    _Distance1 __dist1 = std::distance (__first1, __last1);
    _Distance2 __dist2 = std::distance (__first2, __last2);

    if (__dist1 < __dist2) return __last1;

    _FwdIter1 __cur1 = __first1;
    _FwdIter2 __cur2 = __first2;

    while (__cur2 != __last2) {
        if (*__cur1 != *__cur2) {
            ++__cur1;
            ++__cur2;
            if (__dist1-- == __dist2)
                return __last1;
            else {
                __cur1 = ++__first1;
                __cur2 = __first2;
            }
        }
        else {
            ++__cur1;
            ++__cur2;
        }
    }

    return (__cur2 == __last2) ? __first1 : __last1;
}

template <class _FwdIter1, class _FwdIter2,
    class _BinaryPredicate, class _Distance1, class _Distance2>
_FwdIter1 __search (_FwdIter1 __first1, _FwdIter1 __last1,
                    _FwdIter2 __first2, _FwdIter2 __last2,
                    _BinaryPredicate __pred, _Distance1*, _Distance2*)
{
    ((void)0);
    ((void)0);

    _Distance1 __dist1 = std::distance (__first1, __last1);
    _Distance2 __dist2 = std::distance (__first2, __last2);

    if (__dist1 < __dist2) return __last1;

    _FwdIter1 __cur1 = __first1;
    _FwdIter2 __cur2 = __first2;

    while (__cur2 != __last2) {
        if (!__pred (*__cur1, *__cur2)) {
            ++__cur1;
            ++__cur2;
            if (__dist1-- == __dist2)
                return __last1;
            else {
                __cur1 = ++__first1;
                __cur2 = __first2;
            }
        }
        else {
            ++__cur1;
            ++__cur2;
        }
    }

    return (__cur2 == __last2) ? __first1 : __last1;
}

template <class _FwdIter, class _Distance, class _Size, class _TypeT>
_FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                     _Distance*, _Size __count, const _TypeT& __val)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);

    if (__dist < __count || __count <= 0) return __last;

    _Distance __span = __dist - __count;
    _Size __matches = 0;
    _FwdIter __current = __first;

    while (__current != __last) {
        if (*__current != __val) {
            if (__span < __matches + 1)
                return __last;
            __span -= __matches + 1;
            __matches = 0;
            __first = ++__current;
        }
        else {
            if (++__matches == __count)
                return __first;
            ++__current;
        }
    }

    return __last;
}

template <class _FwdIter, class _Distance, class _Size, class _TypeT,
    class _BinaryPredicate>
_FwdIter __search_n (_FwdIter __first, _FwdIter __last,
                     _Distance*, _Size __count, const _TypeT& __val,
                     _BinaryPredicate __pred)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);

    if (__dist < __count || __count <= 0) return __last;

    _Distance __span = __dist - __count;
    _Size __matches = 0;
    _FwdIter __current = __first;

    while (__current != __last) {
        if (!__pred (*__current, __val)) {
            if (__span < __matches + 1)
                return __last;
            __span -= __matches + 1;
            __matches = 0;
            __first = ++__current;
        }
        else {
            if (++__matches == __count)
                return __first;
            ++__current;
        }
    }

    return __last;
}





template <class _Iter, class _OutputIter, class _Predicate, class _TypeT>
_OutputIter replace_copy_if (_Iter __first, _Iter __last,
                             _OutputIter __result, _Predicate __pred,
                             const _TypeT& __new_value)
{
    ((void)0);

    for (; __first != __last; ++__result, ++__first)
        if (__pred (*__first))
            *__result = __new_value;
        else
            *__result = *__first;
    return __result;
}

template <class _InputIter, class _OutputIter, class _TypeT>
_OutputIter remove_copy (_InputIter __first, _InputIter __last,
                         _OutputIter __result, const _TypeT& __val)
{
    ((void)0);

    for (; __first != __last; ++__first)
        if (*__first != __val) {
            *__result = *__first;
            ++__result;
        }
    return __result;
}

template <class _InputIter, class _OutputIter, class _Predicate>
_OutputIter remove_copy_if (_InputIter __first, _InputIter __last,
                            _OutputIter __result, _Predicate __pred)
{
    ((void)0);

    for (; __first != __last; ++__first)
        if (!__pred (*__first)) {
            *__result = *__first;
            ++__result;
        }
    return __result;
}

template <class _InputIter, class _FwdIter>
_FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                        _FwdIter __result, forward_iterator_tag)
{
    ((void)0);

    *__result = *__first;
    while (++__first != __last)
        if (*__result != *__first)
            *++__result = *__first;
    return ++__result;
}

template <class _InputIter, class _OutputIter, class _TypeT>
_OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                           _OutputIter __result, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__first;
    *__result = __val;
    while (++__first != __last) {
        if (__val != *__first) {
            __val = *__first;
            *++__result = __val;
        }
    }
    return ++__result;
}

template <class _InputIter, class _FwdIter, class _BinaryPredicate>
_FwdIter __unique_copy (_InputIter __first, _InputIter __last,
                        _FwdIter __result,
                        _BinaryPredicate __pred,
                        forward_iterator_tag)
{
    ((void)0);

    *__result = *__first;
    while (++__first != __last)
        if (!__pred (*__result, *__first)) *++__result = *__first;
    return ++__result;
}


template <class _InputIter, class _OutputIter, class _BinaryPredicate,
    class _TypeT>
_OutputIter __unique_copy (_InputIter __first, _InputIter __last,
                           _OutputIter __result,
                           _BinaryPredicate __pred, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__first;
    *__result = __val;
    while (++__first != __last) {
        if (!__pred (__val, *__first)) {
            __val = *__first;
            *++__result = __val;
        }
    }
    return ++__result;
}


template <class _FwdIter, class _Distance>
void __rotate (_FwdIter __first, _FwdIter __middle,
               _FwdIter __last, _Distance*, forward_iterator_tag)
{
    ((void)0);

    _FwdIter __i = __middle;
    for (; ; )
    {
        std::iter_swap (__first, __i);
        ++__first; ++__i;
        if (__first == __middle)
        {
            if (__i == __last) return;
            __middle = __i;
        }
        else if (__i == __last)
            __i = __middle;
    }
}

template <class _EuclideanRingElement>
_EuclideanRingElement __gcd (_EuclideanRingElement __m,
                            _EuclideanRingElement __n)
{
    while (__n != 0)
    {
        _EuclideanRingElement __r = __m % __n;
        __m = __n;
        __n = __r;
    }
    return __m;
}

template <class _RandomAccessIter, class _Distance, class _TypeT>
void __rotate_cycle (_RandomAccessIter __first, _RandomAccessIter __last,
                     _RandomAccessIter __initial, _Distance __shift, _TypeT*)
{
    ((void)0);

    _TypeT __val = *__initial;
    _RandomAccessIter __ptr1 = __initial;
    _RandomAccessIter __ptr2 = __ptr1 + __shift;
    while (__ptr2 != __initial)
    {
        *__ptr1 = *__ptr2;
        __ptr1 = __ptr2;
        if (__last - __ptr2 > __shift)
            __ptr2 += __shift;
        else
            __ptr2 = __first + (__shift - (__last - __ptr2));
    }
    *__ptr1 = __val;
}

template <class _RandomAccessIter, class _Distance>
void __rotate (_RandomAccessIter __first, _RandomAccessIter __middle,
               _RandomAccessIter __last, _Distance*,
               random_access_iterator_tag)
{
    ((void)0);

    _Distance __n = __gcd (__last - __first, __middle - __first);
    while (__n--)
        __rotate_cycle (__first, __last, __first + __n, __middle - __first,
                       __value_type (__first));
}

template <class _RandomAccessIter, class _Distance>
void __random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                       _Distance*)
{
    ((void)0);

    if (__first != __last)
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            std::iter_swap (__i,
                       __first + __rw::__rw_random (__i - __first + 1));
}

template <class _RandomAccessIter, class _RandomNumberGenerator>
void random_shuffle (_RandomAccessIter __first, _RandomAccessIter __last,
                     _RandomNumberGenerator& __rand)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            std::iter_swap (__i, __first + __rand ((__i - __first) + 1));
}

template <class _BidirIter, class _Predicate>
_BidirIter partition (_BidirIter __first, _BidirIter __last,
                      _Predicate __pred)
{
    ((void)0);

    while (true)
    {
        while (true)
        {
            if (__first == __last)
                return __first;
            else if (__pred (*__first))
                ++__first;
            else
                break;
        }
        --__last;
        while (true)
        {
            if (__first == __last)
                return __first;
            else if (!__pred (*__last))
                --__last;
            else
                break;
        }
        std::iter_swap (__first, __last);
        ++__first;
    }
}

template <class _BidirIter, class _Predicate, class _Distance>
_BidirIter __inplace_stable_partition (_BidirIter __first, _BidirIter __last,
                                       _Predicate __pred, _Distance __dist)
{
    ((void)0);

    if (__dist == 1) return __pred (*__first) ? __last : __first;
    _BidirIter __middle = __first;
    std::advance (__middle, __dist / 2);
    _BidirIter
        __first_cut = __inplace_stable_partition (__first, __middle, __pred,
                                                  __dist / 2);
    _BidirIter
        __second_cut = __inplace_stable_partition (__middle, __last, __pred,
                                                 __dist - __dist / 2);
    std::rotate (__first_cut, __middle, __second_cut);
    __dist = std::distance (__middle, __second_cut);
    std::advance (__first_cut, __dist);
    return __first_cut;
}

template <class _BidirIter, class _Pointer, class _Predicate,
    class _Distance, class _TypeT>
_BidirIter __stable_partition_adaptive (_BidirIter __first, _BidirIter __last,
                                        _Predicate __pred, _Distance __dist,
                                        _Pointer __buf,
                                        _Distance __buf_size,
                                        _Distance& __fill_pointer, _TypeT*)
{
    ((void)0);

    if (__dist <= __buf_size)
    {
        __dist = 0;
        _BidirIter __result1 = __first;
        _Pointer __result2 = __buf;
        for (; __first != __last && __dist < __fill_pointer; ++__first)
        {
            if (__pred (*__first)) {
                *__result1 = *__first;
                ++__result1;
            }
            else {
                *__result2 = *__first;
                ++__result2;
                ++__dist;
            }
        }
        if (__first != __last)
        {
            raw_storage_iterator<_Pointer, _TypeT> __result3 (__result2);
            for (; __first != __last; ++__first)
            {
                if (__pred (*__first)) {
                    *__result1 = *__first;
                    ++__result1;
                }
                else {
                    *__result3 = *__first;
                    ++__result3;
                    ++__dist;
                }
            }
            __fill_pointer = __dist;
        }
        std::copy (__buf, __buf + __dist, __result1);
        return __result1;
    }
    _BidirIter __middle = __first;
    std::advance (__middle, __dist / 2);



    _BidirIter __first_cut =
        __stable_partition_adaptive (__first, __middle, __pred,
                                     _Distance (__dist / 2),
                                     __buf, __buf_size,
                                     __fill_pointer, (_TypeT*)0);
    _BidirIter __second_cut =
        __stable_partition_adaptive (__middle, __last, __pred,
                                     _Distance (__dist - __dist / 2),
                                     __buf, __buf_size,
                                     __fill_pointer, (_TypeT*)0);

    std::rotate (__first_cut, __middle, __second_cut);
    __dist = std::distance (__middle, __second_cut);
    std::advance (__first_cut, __dist);
    return __first_cut;
}

template <class _BidirIter, class _Predicate, class _Pointer,
    class _Distance>
_BidirIter __stable_partition (_BidirIter __first, _BidirIter __last,
                               _Predicate __pred, _Distance __dist,
                               pair<_Pointer, _Distance> __pair)
{
    ((void)0);

    if (__pair.first == 0)
        return __inplace_stable_partition (__first, __last, __pred, __dist);
    _Distance __fill_pointer = 0;
    _BidirIter __result =
        __stable_partition_adaptive (__first, __last, __pred, __dist,
                                     __pair.first, __pair.second,
                                     __fill_pointer,
                                     __value_type (__first));
    __rw::__rw_destroy (__pair.first, __pair.first + __fill_pointer);
    std::return_temporary_buffer (__pair.first);
    return __result;
}





template <class _RandomAccessIter, class _TypeT>
_RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                         _RandomAccessIter __last,
                                         _TypeT __pivot)
{
    ((void)0);

    while (true)
    {
        while (*__first < __pivot) ++__first;
        --__last;
        while (__pivot < *__last) --__last;
        if (! (__first < __last)) return __first;
        std::iter_swap (__first, __last);
        ++__first;
    }
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
_RandomAccessIter __unguarded_partition (_RandomAccessIter __first,
                                         _RandomAccessIter __last,
                                         _TypeT __pivot, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (true)
    {
        while (_RWSTD_COMP (*__first, __pivot)) ++__first;
        --__last;
        while (_RWSTD_COMP (__pivot, *__last)) --__last;
        if (! (__first < __last)) return __first;
        std::iter_swap (__first, __last);
        ++__first;
    }
}

const int __stl_threshold = 16;

template <class _RandomAccessIter, class _TypeT>
void __quick_sort_loop_aux (_RandomAccessIter __first,
                            _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    while (__last - __first > __stl_threshold)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1))));
        if (__cut - __first >= __last - __cut)
        {
            __quick_sort_loop (__cut, __last);
            __last = __cut;
        }
        else
        {
            __quick_sort_loop (__first, __cut);
            __first = __cut;
        }
    }
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __quick_sort_loop_aux (_RandomAccessIter __first,
                            _RandomAccessIter __last, _TypeT*,
                            _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first > __stl_threshold)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1),
                                                     _RWSTD_COMP)),
             _RWSTD_COMP);
        if (__cut - __first >= __last - __cut)
        {
            __quick_sort_loop (__cut, __last, _RWSTD_COMP);
            __last = __cut;
        }
        else
        {
            __quick_sort_loop (__first, __cut, _RWSTD_COMP);
            __first = __cut;
        }
    }
}



template <class _RandomAccessIter, class _TypeT>
void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __val)
{
    _RandomAccessIter __next = __last;
    --__next;
    while (__val < *__next)
    {
        *__last = *__next;
        __last = __next--;
    }
    *__last = __val;
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __unguarded_linear_insert (_RandomAccessIter __last, _TypeT __val,
                                _Compare _RWSTD_COMP)
{
    _RandomAccessIter __next = __last;
    --__next;
    while (_RWSTD_COMP (__val , *__next))
    {
        *__last = *__next;
        __last = __next--;
    }
    *__last = __val;
}

template <class _RandomAccessIter>
void __insertion_sort (_RandomAccessIter __first, _RandomAccessIter __last)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            __linear_insert (__first, __i, __value_type (__first));
}

template <class _RandomAccessIter, class _Compare>
void __insertion_sort (_RandomAccessIter __first,
                       _RandomAccessIter __last, _Compare _RWSTD_COMP)
{
    ((void)0);

    if (! (__first == __last))
        for (_RandomAccessIter __i = __first + 1; __i != __last; ++__i)
            __linear_insert (__first, __i, __value_type (__first),
                             _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT>
void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                     _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert (__i, _TypeT (*__i));
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __unguarded_insertion_sort_aux (_RandomAccessIter __first,
                                     _RandomAccessIter __last,
                                     _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    for (_RandomAccessIter __i = __first; __i != __last; ++__i)
        __unguarded_linear_insert (__i, _TypeT (*__i), _RWSTD_COMP);
}


template <class _RandomAccessIter>
void __final_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last)
{
    ((void)0);

    if (__last - __first > __stl_threshold)
    {
        __insertion_sort (__first, __first + __stl_threshold);
        __unguarded_insertion_sort (__first + __stl_threshold, __last);
    }
    else
        __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _Compare>
void __final_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__last - __first > __stl_threshold)
    {
        __insertion_sort (__first, __first + __stl_threshold, _RWSTD_COMP);
        __unguarded_insertion_sort (__first + __stl_threshold, __last,
                                    _RWSTD_COMP);
    }
    else
        __insertion_sort (__first, __last, _RWSTD_COMP);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
    class _Distance>
void __merge_sort_loop (_RandomAccessIter1 __first,
                        _RandomAccessIter1 __last,
                        _RandomAccessIter2 __result, _Distance __step)
{
    ((void)0);

    _Distance __two_step = 2 * __step;

    while (__last - __first >= __two_step)
    {
        __result = std::merge (__first, __first + __step,
                       __first + __step, __first + __two_step, __result);
        __first += __two_step;
    }
    __step = std::min (_Distance (__last - __first), __step);

    std::merge (__first, __first + __step, __first + __step, __last,
           __result);
}

template <class _RandomAccessIter1, class _RandomAccessIter2,
    class _Distance, class _Compare>
void __merge_sort_loop (_RandomAccessIter1 __first,
                        _RandomAccessIter1 __last,
                        _RandomAccessIter2 __result, _Distance __step,
                        _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __two_step = 2 * __step;

    while (__last - __first >= __two_step)
    {
        __result = std::merge (__first, __first + __step,
                       __first + __step, __first + __two_step, __result,
                        _RWSTD_COMP);
        __first += __two_step;
    }
    __step = std::min (_Distance (__last - __first), __step);

    std::merge (__first, __first + __step, __first + __step, __last,
           __result, _RWSTD_COMP);
}

const int __stl_chunk_size = 7;

template <class _RandomAccessIter, class _Distance>
void __chunk_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Distance __chunk_size)
{
    ((void)0);

    while (__last - __first >= __chunk_size)
    {
        __insertion_sort (__first, __first + __chunk_size);
        __first += __chunk_size;
    }
    __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _Distance, class _Compare>
void __chunk_insertion_sort (_RandomAccessIter __first,
                             _RandomAccessIter __last,
                             _Distance __chunk_size, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first >= __chunk_size)
    {
        __insertion_sort (__first, __first + __chunk_size, _RWSTD_COMP);
        __first += __chunk_size;
    }
    __insertion_sort (__first, __last, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT>
void __merge_sort_with_buffer (_RandomAccessIter __first,
                               _RandomAccessIter __last,
                               _Pointer __buf, _Distance*, _TypeT*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Pointer __buf_last = __buf + __dist;

    _Distance __step = __stl_chunk_size;
    __chunk_insertion_sort (__first, __last, __step);

    while (__step < __dist)
    {
        __merge_sort_loop (__first, __last, __buf, __step);
        __step *= 2;
        __merge_sort_loop (__buf, __buf_last, __first, __step);
        __step *= 2;
    }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT, class _Compare>
void __merge_sort_with_buffer (_RandomAccessIter __first,
                               _RandomAccessIter __last, _Pointer __buf,
                               _Distance*, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Pointer __buf_last = __buf + __dist;

    _Distance __step = __stl_chunk_size;
    __chunk_insertion_sort (__first, __last, __step, _RWSTD_COMP);

    while (__step < __dist)
    {
        __merge_sort_loop (__first, __last, __buf, __step, _RWSTD_COMP);
        __step *= 2;
        __merge_sort_loop (__buf, __buf_last, __first, __step,
                           _RWSTD_COMP);
        __step *= 2;
    }
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT>
void __stable_sort_adaptive (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Pointer __buf,
                             _Distance __buf_size, _TypeT*)
{
    ((void)0);

    _Distance __dist = (__last - __first + 1) / 2;
    _RandomAccessIter __middle = __first + __dist;
    if (__dist > __buf_size)
    {
        __stable_sort_adaptive (__first, __middle, __buf, __buf_size,
                               (_TypeT*)0);
        __stable_sort_adaptive (__middle, __last, __buf, __buf_size,
                                (_TypeT*)0);
    }
    else
    {
        __merge_sort_with_buffer (__first, __middle, __buf,
                                 (_Distance*)0, (_TypeT*)0);
        __merge_sort_with_buffer (__middle, __last, __buf,
                                 (_Distance*)0,(_TypeT*)0);
    }
    __merge_adaptive (__first, __middle, __last,
                      _Distance (__middle - __first),
                      _Distance (__last - __middle), __buf, __buf_size,
                      (_TypeT*)0);
}

template <class _RandomAccessIter, class _Pointer, class _Distance,
    class _TypeT, class _Compare>
void __stable_sort_adaptive (_RandomAccessIter __first,
                             _RandomAccessIter __last, _Pointer __buf,
                             _Distance __buf_size, _TypeT*,
                             _Compare _RWSTD_COMP)
{
    ((void)0);

    _Distance __dist = (__last - __first + 1) / 2;
    _RandomAccessIter __middle = __first + __dist;
    if (__dist > __buf_size)
    {
        __stable_sort_adaptive (__first, __middle, __buf, __buf_size,
                                (_TypeT*)0, _RWSTD_COMP);
        __stable_sort_adaptive (__middle, __last, __buf, __buf_size,
                                (_TypeT*)0, _RWSTD_COMP);
    }
    else
    {
        __merge_sort_with_buffer (__first, __middle, __buf,
                                 (_Distance*)0, (_TypeT*)0, _RWSTD_COMP);
        __merge_sort_with_buffer (__middle, __last, __buf,
                                 (_Distance*)0, (_TypeT*)0, _RWSTD_COMP);
    }
    __merge_adaptive (__first, __middle, __last,
                      _Distance (__middle - __first),
                     _Distance (__last - __middle), __buf, __buf_size,
                      (_TypeT*)0, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT>
void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                     _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    std::make_heap (__first, __middle);
    for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (*__i < *__first)
            __pop_heap (__first, __middle, __i, _TypeT (*__i),
                        __distance_type (__first));
    std::sort_heap (__first, __middle);
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __partial_sort (_RandomAccessIter __first, _RandomAccessIter __middle,
                     _RandomAccessIter __last, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    std::make_heap (__first, __middle, _RWSTD_COMP);
    for (_RandomAccessIter __i = __middle; __i < __last; ++__i)
        if (_RWSTD_COMP (*__i, *__first))
            __pop_heap (__first, __middle, __i, _TypeT (*__i), _RWSTD_COMP,
                        __distance_type (__first));
    std::sort_heap (__first, __middle, _RWSTD_COMP);
}

template <class _InputIter, class _RandomAccessIter, class _Distance,
    class _TypeT>
_RandomAccessIter __partial_sort_copy (_InputIter __first,
                                       _InputIter __last,
                                       _RandomAccessIter __first2,
                                       _RandomAccessIter __last2,
                                       _Distance*, _TypeT*)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2) return __last2;
    _RandomAccessIter __result = __first2;
    for (; __first != __last && __result != __last2;
         ++__first, ++__result )
        *__result = *__first;
    std::make_heap (__first2, __result);
    for (; __first != __last; ++__first) {
        if (*__first < *__first2)
            __adjust_heap (__first2, _Distance (),
                          _Distance (__result - __first2),
                          _TypeT (*__first));
    }
    std::sort_heap (__first2, __result);
    return __result;
}

template <class _InputIter, class _RandomAccessIter, class _Compare,
    class _Distance, class _TypeT>
_RandomAccessIter __partial_sort_copy (_InputIter __first,
                                       _InputIter __last,
                                       _RandomAccessIter __first2,
                                       _RandomAccessIter __last2,
                                       _Compare _RWSTD_COMP,
                                       _Distance*, _TypeT*)
{
    ((void)0);
    ((void)0);

    if (__first2 == __last2) return __last2;
    _RandomAccessIter __result = __first2;
    for (; __first != __last && __result != __last2;
         ++__first, ++__result)
        *__result = *__first;
    std::make_heap (__first2, __result, _RWSTD_COMP);
    for (; __first != __last; ++__first)
    {
        if (_RWSTD_COMP (*__first, *__first2))
            __adjust_heap (__first2, _Distance (),
                          _Distance (__result - __first2),
                           _TypeT (*__first),
                          _RWSTD_COMP);
    }
    std::sort_heap (__first2, __result, _RWSTD_COMP);
    return __result;
}

template <class _RandomAccessIter, class _TypeT>
void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                    _RandomAccessIter __last, _TypeT*)
{
    ((void)0);

    while (__last - __first > 3) {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1))));
        if (__cut <= __nth)
            __first = __cut;
        else
            __last = __cut;
    }
    __insertion_sort (__first, __last);
}

template <class _RandomAccessIter, class _TypeT, class _Compare>
void __nth_element (_RandomAccessIter __first, _RandomAccessIter __nth,
                    _RandomAccessIter __last, _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    while (__last - __first > 3)
    {
        _RandomAccessIter __cut =
            __unguarded_partition (__first, __last,
                                   _TypeT (__median (*__first,
                                                     * (__first +
                                                        (__last - __first)/2),
                                                     * (__last - 1),
                                                     _RWSTD_COMP)),
             _RWSTD_COMP);
        if (__cut <= __nth)
            __first = __cut;
        else
            __last = __cut;
    }
    __insertion_sort (__first, __last, _RWSTD_COMP);
}





template <class _FwdIter, class _TypeT, class _Distance>
_FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Distance*,
                        forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (*__middle < __val)
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
_RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (*__middle < __val)
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
_FwdIter __lower_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Compare _RWSTD_COMP,
                        _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
_RandomAccessIter __lower_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Compare _RWSTD_COMP,
                                 _Distance*,
                                 random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else
            __dist = __half;
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Distance>
_FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Distance*,
                        forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);

        if (__val < *__middle)
            __dist = __half;
        else
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
_RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (__val < *__middle)
            __dist = __half;
        else
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
_FwdIter __upper_bound (_FwdIter __first, _FwdIter __last,
                        const _TypeT& __val, _Compare _RWSTD_COMP,
                        _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
_RandomAccessIter __upper_bound (_RandomAccessIter __first,
                                 _RandomAccessIter __last,
                                 const _TypeT& __val,
                                 _Compare _RWSTD_COMP, _Distance*,
                                 random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
    }
    return __first;
}

template <class _FwdIter, class _TypeT, class _Distance>
pair<_FwdIter, _FwdIter>
__equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __val,
               _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (*__middle < __val)
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else if (__val < *__middle)
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val);
            std::advance (__first, __dist);
            __right = std::upper_bound (++__middle, __first, __val);
            pair<_FwdIter, _FwdIter> __tmp (__left, __right);
            return __tmp;
        }
    }
    pair<_FwdIter, _FwdIter> __tmp (__first, __first);
    return __tmp;
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
pair<_RandomAccessIter, _RandomAccessIter>
__equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
               const _TypeT& __val, _Distance*, random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (*__middle < __val)
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else if (__val < *__middle)
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val);
            __right = std::upper_bound (++__middle, __first + __dist, __val);
            pair<_RandomAccessIter, _RandomAccessIter> __tmp(__left, __right);
            return __tmp;
        }
    }
    pair<_RandomAccessIter, _RandomAccessIter> __tmp (__first, __first);
    return __tmp;
}

template <class _FwdIter, class _TypeT, class _Compare, class _Distance>
pair<_FwdIter, _FwdIter>
__equal_range (_FwdIter __first, _FwdIter __last, const _TypeT& __val,
               _Compare _RWSTD_COMP, _Distance*, forward_iterator_tag)
{
    ((void)0);

    _Distance __dist = std::distance (__first, __last);
    _Distance __half;
    _FwdIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first;
        std::advance (__middle, __half);
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle;
            ++__first;
            __dist = __dist - __half - 1;
        }
        else if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle, __val, _RWSTD_COMP);
            std::advance (__first, __dist);
            __right = std::upper_bound (++__middle, __first, __val, _RWSTD_COMP);
            pair<_FwdIter, _FwdIter> __tmp (__left, __right);
            return __tmp;
        }
    }
    pair<_FwdIter, _FwdIter> __tmp (__first, __first);
    return __tmp;
}

template <class _RandomAccessIter, class _TypeT, class _Compare,
    class _Distance>
pair<_RandomAccessIter, _RandomAccessIter>
__equal_range (_RandomAccessIter __first, _RandomAccessIter __last,
               const _TypeT& __val, _Compare _RWSTD_COMP, _Distance*,
               random_access_iterator_tag)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __half;
    _RandomAccessIter __middle, __left, __right;

    while (__dist > 0)
    {
        __half = __dist / 2;
        __middle = __first + __half;
        if (_RWSTD_COMP (*__middle, __val))
        {
            __first = __middle + 1;
            __dist = __dist - __half - 1;
        }
        else if (_RWSTD_COMP (__val, *__middle))
            __dist = __half;
        else
        {
            __left = std::lower_bound (__first, __middle,
                                           __val, _RWSTD_COMP);
            __right = std::upper_bound (++__middle, __first + __dist,
                                            __val, _RWSTD_COMP);
            pair<_RandomAccessIter, _RandomAccessIter> __tmp(__left, __right);
            return __tmp;
        }
    }
    pair<_RandomAccessIter, _RandomAccessIter> __tmp (__first, __first);
    return __tmp;
}





template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter merge (_InputIter1 __first1, _InputIter1 __last1,
                   _InputIter2 __first2, _InputIter2 __last2,
                   _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _BidirIter, class _Distance>
void __merge_without_buffer (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last,
                             _Distance __dist1, _Distance __dist2)
{
    ((void)0);

    if (__dist1 == 0 || __dist2 == 0) return;
    if (__dist1 + __dist2 == 2)
    {
        if (*__middle < *__first) std::iter_swap (__first, __middle);
        return;
    }
    _BidirIter __first_cut = __first;
    _BidirIter __second_cut = __middle;
    _Distance __dist11;
    _Distance __dist22;
    if (__dist1 > __dist2)
    {
        __dist11 = __dist1 / 2;
        std::advance (__first_cut, __dist11);
        __second_cut = std::lower_bound (__middle, __last, *__first_cut);
        std::distance (__middle, __second_cut, __dist22);
    }
    else
    {
        __dist22 = __dist2 / 2;
        std::advance (__second_cut, __dist22);
        __first_cut = std::upper_bound (__first, __middle, *__second_cut);
        std::distance (__first, __first_cut, __dist11);
    }
    std::rotate (__first_cut, __middle, __second_cut);
    _BidirIter __middle2 = __first_cut;
    std::advance (__middle2, __dist22);
    __merge_without_buffer (__first, __first_cut, __middle2,
                            __dist11, __dist22);
    __merge_without_buffer (__middle2, __second_cut, __last,
                            __dist1 - __dist11,
                           __dist2 - __dist22);
}

template <class _BidirIter, class _Distance, class _Compare>
void __merge_without_buffer (_BidirIter __first,
                             _BidirIter __middle,
                             _BidirIter __last,
                             _Distance __dist1, _Distance __dist2,
                             _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__dist1 == 0 || __dist2 == 0) return;
    if (__dist1 + __dist2 == 2)
    {
        if (_RWSTD_COMP (*__middle, *__first))
            std::iter_swap (__first, __middle);
        return;
    }
    _BidirIter __first_cut = __first;
    _BidirIter __second_cut = __middle;
    _Distance __dist11;
    _Distance __dist22;
    if (__dist1 > __dist2)
    {
        __dist11 = __dist1 / 2;
        std::advance (__first_cut, __dist11);
        __second_cut = std::lower_bound (__middle, __last,
                                             *__first_cut, _RWSTD_COMP);
        std::distance (__middle, __second_cut, __dist22);
    }
    else
    {
        __dist22 = __dist2 / 2;
        std::advance (__second_cut, __dist22);
        __first_cut = std::upper_bound (__first, __middle,
                                            *__second_cut, _RWSTD_COMP);
        std::distance (__first, __first_cut, __dist11);
    }
    std::rotate (__first_cut, __middle, __second_cut);

    _BidirIter __middle2 = __first_cut;

    std::advance (__middle2, __dist22);

    __merge_without_buffer (__first, __first_cut, __middle2,
                            __dist11, __dist22, _RWSTD_COMP);
    __merge_without_buffer (__middle2, __second_cut, __last,
                            __dist1 - __dist11, __dist2 - __dist22, _RWSTD_COMP);
}

template <class _BidirIter1, class _BidirIter2,
    class _Distance>
_BidirIter1 __rotate_adaptive (_BidirIter1 __first,
                               _BidirIter1 __middle,
                               _BidirIter1 __last,
                               _Distance __dist1, _Distance __dist2,
                               _BidirIter2 __buf,
                               _Distance __buf_size)
{
    ((void)0);

    _BidirIter2 __buf_end;
    if (__dist1 > __dist2 && __dist2 <= __buf_size)
    {
        __buf_end = std::copy (__middle, __last, __buf);
        std::copy_backward (__first, __middle, __last);
        return std::copy (__buf, __buf_end, __first);
    }
    else if (__dist1 <= __buf_size)
    {
        __buf_end = std::copy (__first, __middle, __buf);
        std::copy (__middle, __last, __first);
        return std::copy_backward (__buf, __buf_end, __last);
    }
    else
    {
        std::rotate (__first, __middle, __last);
        std::advance (__first, __dist2);
        return __first;
    }
}

template <class _BidirIter1, class _BidirIter2,
    class _BidirIter3>
_BidirIter3 __merge_backward (_BidirIter1 __first1,
                              _BidirIter1 __last1,
                              _BidirIter2 __first2,
                              _BidirIter2 __last2,
                              _BidirIter3 __result)
{
    ((void)0);
    ((void)0);

    if (__first1 == __last1)
        return std::copy_backward (__first2, __last2, __result);

    if (__first2 == __last2)
        return std::copy_backward (__first1, __last1, __result);

    --__last1;
    --__last2;
    while (true)
    {
        if (*__last2 < *__last1)
        {
            *--__result = *__last1;
            if (__first1 == __last1)
                return std::copy_backward (__first2, ++__last2, __result);
            --__last1;
        }
        else
        {
            *--__result = *__last2;
            if (__first2 == __last2)
                return std::copy_backward (__first1, ++__last1, __result);
            --__last2;
        }
    }
}

template <class _BidirIter1, class _BidirIter2,
    class _BidirIter3, class _Compare>
_BidirIter3 __merge_backward (_BidirIter1 __first1,
                              _BidirIter1 __last1,
                              _BidirIter2 __first2,
                              _BidirIter2 __last2,
                              _BidirIter3 __result,
                              _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    if (__first1 == __last1)
        return std::copy_backward (__first2, __last2, __result);
    if (__first2 == __last2)
        return std::copy_backward (__first1, __last1, __result);
    --__last1;
    --__last2;
    while (true)
    {
        if (_RWSTD_COMP (*__last2, *__last1))
        {
            *--__result = *__last1;
            if (__first1 == __last1)
                return std::copy_backward (__first2, ++__last2, __result);
            --__last1;
        }
        else
        {
            *--__result = *__last2;
            if (__first2 == __last2)
                return std::copy_backward (__first1, ++__last1, __result);
            --__last2;
        }
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
void __merge_adaptive (_BidirIter __first,
                       _BidirIter __middle,
                       _BidirIter __last,
                       _Distance __dist1, _Distance __dist2,
                       _Pointer __buf, _Distance __buf_size, _TypeT*)
{
    ((void)0);

    if (__dist1 <= __dist2 && __dist1 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__first, __middle, __buf);
        std::merge (__buf, __buf_end, __middle, __last, __first);
    }
    else if (__dist2 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__middle, __last, __buf);
        __merge_backward (__first, __middle, __buf, __buf_end, __last);
    }
    else
    {
        _BidirIter __first_cut = __first;
        _BidirIter __second_cut = __middle;
        _Distance __dist11;
        _Distance __dist22;
        if (__dist1 > __dist2)
        {
            __dist11 = __dist1 / 2;
            std::advance (__first_cut, __dist11);
            __second_cut = std::lower_bound (__middle, __last, *__first_cut);
            std::distance (__middle, __second_cut, __dist22);
        }
        else
        {
            __dist22 = __dist2 / 2;
            std::advance (__second_cut, __dist22);
            __first_cut = std::upper_bound (__first, __middle, *__second_cut);
            std::distance (__first, __first_cut, __dist11);
        }
        _BidirIter __middle2 =
            __rotate_adaptive (__first_cut, __middle, __second_cut,
                               __dist1 - __dist11, __dist22, __buf, __buf_size);

        __merge_adaptive (__first, __first_cut, __middle2, __dist11, __dist22,
                          __buf, __buf_size, (_TypeT*)0);
        __merge_adaptive (__middle2, __second_cut, __last, __dist1 - __dist11,
                         __dist2 - __dist22, __buf, __buf_size, (_TypeT*)0);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
    class _Compare>
void __merge_adaptive (_BidirIter __first, _BidirIter __middle,
                       _BidirIter __last,
                       _Distance __dist1, _Distance __dist2,
                       _Pointer __buf, _Distance __buf_size, _TypeT*,
                       _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__dist1 <= __dist2 && __dist1 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__first, __middle, __buf);
        std::merge (__buf, __buf_end, __middle, __last, __first, _RWSTD_COMP);
    }
    else if (__dist2 <= __buf_size)
    {
        _Pointer __buf_end = std::copy (__middle, __last, __buf);
        __merge_backward (__first, __middle, __buf, __buf_end, __last,
                          _RWSTD_COMP);
    }
    else
    {
        _BidirIter __first_cut = __first;
        _BidirIter __second_cut = __middle;
        _Distance __dist11;
        _Distance __dist22;
        if (__dist1 > __dist2)
        {
            __dist11 = __dist1 / 2;
            std::advance (__first_cut, __dist11);
            __second_cut = std::lower_bound (__middle, __last, *__first_cut,
                                                 _RWSTD_COMP);
            std::distance (__middle, __second_cut, __dist22);
        }
        else
        {
            __dist22 = __dist2 / 2;
            std::advance (__second_cut, __dist22);
            __first_cut = std::upper_bound (__first, __middle, *__second_cut,
                                                _RWSTD_COMP);
            std::distance (__first, __first_cut, __dist11);
        }
        _BidirIter __middle2 =
            __rotate_adaptive (__first_cut, __middle, __second_cut,
                               __dist1 - __dist11, __dist22,
                               __buf, __buf_size);
        __merge_adaptive (__first, __first_cut, __middle2,
                          __dist11, __dist22,
                          __buf,
                          __buf_size, (_TypeT*)0,
                          _RWSTD_COMP);
        __merge_adaptive (__middle2, __second_cut, __last,
                          __dist1 - __dist11, __dist2 - __dist22,
                          __buf, __buf_size, (_TypeT*)0, _RWSTD_COMP);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT>
void __inplace_merge (_BidirIter __first,
                      _BidirIter __middle,
                      _BidirIter __last, _Distance __dist1,
                      _Distance __dist2, pair<_Pointer, _Distance> __pair,
                      _TypeT*)
{
    ((void)0);

    if (__pair.first == 0)
        __merge_without_buffer (__first, __middle, __last, __dist1, __dist2);
    else
    {
        _Distance __dist = std::min (__pair.second, __dist1 + __dist2);

        std::fill_n (raw_storage_iterator<_Pointer, _TypeT> (__pair.first),
                         __dist, *__first);

        __merge_adaptive (__first, __middle, __last, __dist1, __dist2,
                          __pair.first, __pair.second, (_TypeT*)0);

        __rw::__rw_destroy (__pair.first, __pair.first + __dist);

        std::return_temporary_buffer (__pair.first);
    }
}

template <class _BidirIter, class _Distance, class _Pointer, class _TypeT,
    class _Compare>
void __inplace_merge (_BidirIter __first,
                      _BidirIter __middle,
                      _BidirIter __last, _Distance __dist1,
                      _Distance __dist2, pair<_Pointer, _Distance> __pair,
                      _TypeT*, _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__pair.first == 0)
        __merge_without_buffer (__first, __middle, __last, __dist1, __dist2,
                                _RWSTD_COMP);
    else
    {
        _Distance __dist = std::min (__pair.second, __dist1 + __dist2);

        std::fill_n (raw_storage_iterator<_Pointer, _TypeT> (__pair.first),
                         __dist, *__first);
        __merge_adaptive (__first, __middle, __last, __dist1, __dist2,
                          __pair.first, __pair.second,
                          (_TypeT*)0, _RWSTD_COMP);
        __rw::__rw_destroy (__pair.first, __pair.first + __dist);
        std::return_temporary_buffer (__pair.first);
    }
}
template <class _InputIter1, class _InputIter2>
bool includes (_InputIter1 __first1, _InputIter1 __last1,
               _InputIter2 __first2, _InputIter2 __last2)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2) {
        if (*__first2 < *__first1)
            return false;

        if (!(*__first1 < *__first2))
            ++__first2;

        ++__first1;
    }
    return __first2 == __last2;
}


template <class _InputIter1, class _InputIter2, class _Compare>
bool includes (_InputIter1 __first1, _InputIter1 __last1,
               _InputIter2 __first2, _InputIter2 __last2,
               _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2) {
        if (_RWSTD_COMP (*__first2, *__first1))
            return false;

        if (!_RWSTD_COMP (*__first1, *__first2))
            ++__first2;

        ++__first1;
    }
    return __first2 == __last2;
}


template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                       _InputIter2 __first2, _InputIter2 __last2,
                       _OutputIter __result)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__first1;
        }
        else if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_union (_InputIter1 __first1, _InputIter1 __last1,
                       _InputIter2 __first2, _InputIter2 __last2,
                       _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2; ++__result) {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__first2;
        }
        else {
            *__result = *__first1;
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2)
            ++__first1;
        else if (*__first2 < *__first1)
            ++__first2;
        else
        {
            *__result = *__first1;
            ++__result;
            ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_intersection (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2))
            ++__first1;
        else if (_RWSTD_COMP (*__first2, *__first1))
            ++__first2;
        else {
            *__result = *__first1;
            ++__result;
            ++__first1;
            ++__first2;
        }
    }
    return __result;
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (*__first2 < *__first1)
            ++__first2;
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first1, __last1, __result);
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_difference (_InputIter1 __first1, _InputIter1 __last1,
                            _InputIter2 __first2, _InputIter2 __last2,
                            _OutputIter __result, _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1))
            ++__first2;
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first1, __last1, __result);
}

template <class _InputIter1, class _InputIter2, class _OutputIter>
_OutputIter set_symmetric_difference (_InputIter1 __first1,
                                      _InputIter1 __last1,
                                      _InputIter2 __first2,
                                      _InputIter2 __last2,
                                      _OutputIter __result)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (*__first1 < *__first2) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (*__first2 < *__first1) {
            *__result = *__first2;
            ++__result;
            ++__first2;
        }
        else
        {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}

template <class _InputIter1, class _InputIter2, class _OutputIter,
    class _Compare>
_OutputIter set_symmetric_difference (_InputIter1 __first1,
                                      _InputIter1 __last1,
                                      _InputIter2 __first2,
                                      _InputIter2 __last2,
                                      _OutputIter __result,
                                      _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    while (__first1 != __last1 && __first2 != __last2)
    {
        if (_RWSTD_COMP (*__first1, *__first2)) {
            *__result = *__first1;
            ++__result;
            ++__first1;
        }
        else if (_RWSTD_COMP (*__first2, *__first1)) {
            *__result = *__first2;
            ++__result;
            ++__first2;
        }
        else {
            ++__first1;
            ++__first2;
        }
    }
    return std::copy (__first2, __last2,
                          std::copy (__first1, __last1, __result));
}





template <class _RandomAccessIter, class _Distance, class _TypeT>
void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                  _Distance __topIndex, _TypeT __val)
{
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex && * (__first + __parent) < __val)
    {
        * (__first + __holeIndex) = * (__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
    }
    * (__first + __holeIndex) = __val;
}

template <class _RandomAccessIter, class _Distance, class _TypeT,
    class _Compare>
void __push_heap (_RandomAccessIter __first, _Distance __holeIndex,
                  _Distance __topIndex, _TypeT __val, _Compare _RWSTD_COMP)
{
    _Distance __parent = (__holeIndex - 1) / 2;
    while (__holeIndex > __topIndex &&
           _RWSTD_COMP (* (__first + __parent), __val))
    {
        * (__first + __holeIndex) = * (__first + __parent);
        __holeIndex = __parent;
        __parent = (__holeIndex - 1) / 2;
    }
    * (__first + __holeIndex) = __val;
}

template <class _RandomAccessIter, class _Distance, class _TypeT>
void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __dist, _TypeT __val)
{
    _Distance __topIndex = __holeIndex;
    _Distance __secondChild = 2 * __holeIndex + 2;
    while (__secondChild < __dist)
    {
        if (* (__first + __secondChild) < * (__first + (__secondChild - 1)))
            __secondChild--;
        * (__first + __holeIndex) = * (__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
    }
    if (__secondChild == __dist)
    {
        * (__first + __holeIndex) = * (__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
    }
    __push_heap (__first, __holeIndex, __topIndex, __val);
}

template <class _RandomAccessIter, class _Distance, class _TypeT,
    class _Compare>
void __adjust_heap (_RandomAccessIter __first, _Distance __holeIndex,
                    _Distance __dist, _TypeT __val, _Compare _RWSTD_COMP)
{
    _Distance __topIndex = __holeIndex;
    _Distance __secondChild = 2 * __holeIndex + 2;
    while (__secondChild < __dist)
    {
        if (_RWSTD_COMP (* (__first + __secondChild),
                         * (__first + (__secondChild - 1))))
            __secondChild--;
        * (__first + __holeIndex) = * (__first + __secondChild);
        __holeIndex = __secondChild;
        __secondChild = 2 * (__secondChild + 1);
    }
    if (__secondChild == __dist)
    {
        * (__first + __holeIndex) = * (__first + (__secondChild - 1));
        __holeIndex = __secondChild - 1;
    }
    __push_heap (__first, __holeIndex, __topIndex, __val, _RWSTD_COMP);
}

template <class _RandomAccessIter, class _TypeT, class _Distance>
void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _TypeT*, _Distance*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __parent = (__dist - 2)/2;
    while (true)
    {
        __adjust_heap (__first, __parent, __dist,
                       _TypeT (*(__first + __parent)));
        if (__parent == 0) return;
        __parent--;
    }
}

template <class _RandomAccessIter, class _Compare, class _TypeT,
    class _Distance>
void __make_heap (_RandomAccessIter __first, _RandomAccessIter __last,
                  _Compare _RWSTD_COMP, _TypeT*, _Distance*)
{
    ((void)0);

    _Distance __dist = __last - __first;
    _Distance __parent = (__dist - 2)/2;
    while (true)
    {
        __adjust_heap (__first, __parent, __dist,
                       _TypeT (* (__first + __parent)),
                       _RWSTD_COMP);
        if (__parent == 0)
            return;
        __parent--;
    }
}






template <class _FwdIter>
_FwdIter min_element (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (*__first < *__result)
            __result = __first;

    return __result;
}

template <class _FwdIter, class _Compare>
_FwdIter min_element (_FwdIter __first, _FwdIter __last,
                      _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (_RWSTD_COMP (*__first, *__result))
            __result = __first;

    return __result;
}

template <class _FwdIter>
_FwdIter max_element (_FwdIter __first, _FwdIter __last)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (*__result < *__first)
            __result = __first;

    return __result;
}

template <class _FwdIter, class _Compare>
_FwdIter max_element (_FwdIter __first, _FwdIter __last,
                      _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last)
        return __first;

    _FwdIter __result = __first;
    while (++__first != __last)
        if (_RWSTD_COMP (*__result, *__first))
            __result = __first;

    return __result;
}

template <class _InputIter1, class _InputIter2>
bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first2, ++__first1)
    {
        if (*__first1 < *__first2)
            return true;
        if (*__first2 < *__first1)
            return false;
    }
    return __first1 == __last1 && __first2 != __last2;
}

template <class _InputIter1, class _InputIter2, class _Compare>
bool lexicographical_compare (_InputIter1 __first1, _InputIter1 __last1,
                              _InputIter2 __first2, _InputIter2 __last2,
                              _Compare _RWSTD_COMP)
{
    ((void)0);
    ((void)0);

    for (; __first1 != __last1 && __first2 != __last2;
         ++__first2, ++__first1) {
        if (_RWSTD_COMP (*__first1, *__first2))
            return true;
        if (_RWSTD_COMP (*__first2, *__first1))
            return false;
    }
    return __first1 == __last1 && __first2 != __last2;
}





template <class _BidirIter>
bool next_permutation (_BidirIter __first,
                       _BidirIter __last)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (*__i < *__ii)
        {
            _BidirIter __j = __last;
            while (! (*__i < *--__j))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter, class _Compare>
bool next_permutation (_BidirIter __first, _BidirIter __last,
                       _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (_RWSTD_COMP (*__i, *__ii))
        {
            _BidirIter __j = __last;
            while (!_RWSTD_COMP (*__i, *--__j))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter>
bool prev_permutation (_BidirIter __first,
                       _BidirIter __last)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (*__ii < *__i)
        {
            _BidirIter __j = __last;
            while (! (*--__j < *__i))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}

template <class _BidirIter, class _Compare>
bool prev_permutation (_BidirIter __first, _BidirIter __last,
                       _Compare _RWSTD_COMP)
{
    ((void)0);

    if (__first == __last) return false;
    _BidirIter __i = __first;
    ++__i;
    if (__i == __last) return false;
    __i = __last;
    --__i;

    for (; ; )
    {
        _BidirIter __ii = __i--;
        if (_RWSTD_COMP (*__ii, *__i))
        {
            _BidirIter __j = __last;
            while (!_RWSTD_COMP (*--__j, *__i))
                ;
            std::iter_swap (__i, __j);
            std::reverse (__ii, __last);
            return true;
        }
        if (__i == __first)
        {
            std::reverse (__first, __last);
            return false;
        }
    }
}


}
extern "C" {






#pragma extern isalnum, isalpha, iscntrl, isdigit, isgraph, islower
#pragma extern isprint, ispunct, isspace, isupper, isxdigit




     extern int isalnum(int);
     extern int isalpha(int);
     extern int iscntrl(int);
     extern int isdigit(int);
     extern int isgraph(int);
     extern int islower(int);
     extern int isprint(int);
     extern int ispunct(int);
     extern int isspace(int);
     extern int isupper(int);
     extern int isxdigit(int);

#pragma extern tolower, toupper

extern int tolower(int);
extern int toupper(int);

#pragma extern isascii, toascii
     extern int isascii(int);
     extern int toascii(int);
#pragma extern __tolower, __toupper
extern int __tolower(int);
extern int __toupper(int);
#pragma extern isctype, isblank
     extern int isctype(int, unsigned int);
     extern int isblank(int);







#pragma builtin _isalnum, _isalpha, _iscntrl, _isdigit, _isgraph, _islower
#pragma builtin _isprint, _ispunct, _isspace, _isupper, _isxdigit
#pragma extern _isalnum, _isalpha, _iscntrl, _isdigit, _isgraph, _islower
#pragma extern _isprint, _ispunct, _isspace, _isupper, _isxdigit





#pragma extern __SB_masks

     extern unsigned int *__SB_masks;

     extern int _isalnum(int);
     extern int _isalpha(int);
     extern int _iscntrl(int);
     extern int _isdigit(int);
     extern int _isgraph(int);
     extern int _islower(int);
     extern int _isprint(int);
     extern int _ispunct(int);
     extern int _isspace(int);
     extern int _isupper(int);
     extern int _isxdigit(int);
}
namespace std {
using ::isalnum;
using ::isalpha;
using ::iscntrl;
using ::isdigit;
using ::isgraph;
using ::islower;
using ::isprint;
using ::ispunct;
using ::isspace;
using ::isupper;
using ::isxdigit;
using ::tolower;
using ::toupper;
}
#pragma extern get_expiration_time
     extern int get_expiration_time (struct timespec *,struct timespec *);




     extern "C" {


     }
extern "C" {










      typedef unsigned int wint_t;




      typedef unsigned int wctype_t;









#pragma extern wcscat, wcsncat, wcscpy, wcsncpy, wcslen
#pragma extern wcsspn, wcscspn, wcscmp, wcsncmp, wcswcs, wcstok 





#pragma extern wcscoll, wcsxfrm, wcswidth, iswalnum, iswalpha, iswcntrl
#pragma extern iswdigit, iswgraph, iswlower, iswprint, iswpunct, iswspace
#pragma extern iswupper, iswxdigit, towlower, towupper, wctype, iswctype
#pragma extern fgetwc, fgetws, fputwc, fputws, getwc, getwchar, putwc, putwchar
#pragma extern ungetwc, wcstod, wcstol, wcstoul, wcsftime 

#pragma extern wcwidth 






#pragma extern getws, putws










#pragma extern btowc, fwide, fwprintf, fwscanf, mbsinit 
#pragma extern mbrlen, mbrtowc, mbsrtowcs, swprintf, swscanf 
#pragma extern vfwprintf, vwprintf, vswprintf, wctob, wmemchr
#pragma extern wmemcmp, wmemcpy, wmemmove, wmemset, wprintf
#pragma extern wscanf, wcrtomb, wcsrtombs, wcsstr 







              extern wint_t btowc (int);
              extern int fwide (FILE *, int);
              extern int fwprintf (FILE *, const wchar_t *, ...);
              extern int fwscanf (FILE *, const wchar_t *, ...);
              extern int mbsinit (const mbstate_t *);
              extern size_t mbrlen (const char *, size_t, mbstate_t *);
              extern size_t mbrtowc (wchar_t *, const char *, size_t, mbstate_t *);
              extern size_t mbsrtowcs (wchar_t *, const char **, size_t, mbstate_t *);
              extern int swprintf (wchar_t *, size_t, const wchar_t *, ...);
              extern int swscanf (const wchar_t *, const wchar_t *, ...);
              extern int vfwprintf (FILE *, const wchar_t *, __builtin_va_list);
              extern int vwprintf (const wchar_t *, __builtin_va_list);
              extern int vswprintf (wchar_t *, size_t, const wchar_t *, __builtin_va_list);
              extern int wctob ( wint_t);
              extern wchar_t *__wmemchr_keep_out (const wchar_t *, wchar_t, size_t);
              extern int wmemcmp (const wchar_t *, const wchar_t *, size_t);
              extern wchar_t *wmemcpy (wchar_t *, const wchar_t *, size_t);
              extern wchar_t *wmemmove (wchar_t *, const wchar_t *, size_t);
              extern wchar_t *wmemset (wchar_t *, wchar_t, size_t);
              extern int wprintf (const wchar_t *, ...);
              extern int wscanf (const wchar_t *, ...);
              extern size_t wcrtomb (char *, wchar_t, mbstate_t *);
              extern size_t wcsrtombs (char *, const wchar_t **, size_t, mbstate_t *);
              extern wchar_t *__wcsstr_keep_out (const wchar_t *, const wchar_t *);



         extern wchar_t *wcscat (wchar_t *, const wchar_t *);
         extern wchar_t *wcsncat (wchar_t *, const wchar_t *, size_t);
         extern wchar_t *wcscpy (wchar_t *, const wchar_t *);
         extern wchar_t *wcsncpy (wchar_t *, const wchar_t *, size_t);
         extern size_t wcslen (const wchar_t *);
         extern size_t wcsspn (const wchar_t *, const wchar_t *);
         extern size_t wcscspn (const wchar_t *, const wchar_t *);
         extern int wcscmp (const wchar_t *, const wchar_t *);
         extern int wcsncmp (const wchar_t *, const wchar_t *, size_t);


         extern size_t wcsftime (wchar_t *, size_t, const wchar_t *, const struct tm *);

         extern wchar_t *wcstok (wchar_t *, const wchar_t *, wchar_t **);

         extern wchar_t *wcswcs (const wchar_t *, const wchar_t *);






         extern int wcscoll (const wchar_t *, const wchar_t *);
         extern size_t wcsxfrm (wchar_t *, const wchar_t *, size_t);


               extern int wcwidth (wchar_t);





         extern int wcswidth (const wchar_t *, size_t);



         extern int iswalnum (wint_t);
         extern int iswalpha (wint_t);
         extern int iswcntrl (wint_t);
         extern int iswdigit (wint_t);
         extern int iswgraph (wint_t);
         extern int iswlower (wint_t);
         extern int iswprint (wint_t);
         extern int iswpunct (wint_t);
         extern int iswspace (wint_t);
         extern int iswupper (wint_t);
         extern int iswxdigit (wint_t);
         extern wint_t towlower (wint_t);
         extern wint_t towupper (wint_t);
         extern wctype_t wctype (const char *);
         extern int iswctype (wint_t, wctype_t);


         extern wint_t fgetwc (FILE *);
         extern wchar_t *fgetws (wchar_t *, int, FILE *);



         extern wint_t fputwc (wchar_t, FILE *);
         extern wint_t putwc (wchar_t, FILE *);
         extern wint_t putwchar (wchar_t);
         extern int fputws (const wchar_t *, FILE *);
         extern wint_t getwc (FILE *);
         extern wint_t getwchar (void);
         extern wint_t ungetwc (wint_t, FILE *);


         extern double wcstod (const wchar_t *, wchar_t **);
         extern long int wcstol (const wchar_t *, wchar_t **, int);
         extern unsigned long int wcstoul (const wchar_t *, wchar_t **, int);



         extern wchar_t *getws (wchar_t *);
         extern int putws (const wchar_t *);
#pragma extern iswblank







     extern int iswblank (wint_t);
}
#pragma extern wcschr, wcsrchr, wcspbrk, wcsstr, wmemchr
  extern "C" {
  extern const wchar_t *wcschr(const wchar_t *, wchar_t);
  extern const wchar_t *wcsrchr(const wchar_t *, wchar_t);
  extern const wchar_t *wcspbrk(const wchar_t *, const wchar_t *);


  extern const wchar_t* wcsstr(const wchar_t*, const wchar_t*);
  extern const wchar_t* wmemchr(const wchar_t*, wchar_t, size_t);

  }


  inline wchar_t *wcschr(wchar_t *p, wchar_t c)
  { return const_cast<wchar_t *> (wcschr(const_cast<const wchar_t *>(p), c)); }
  inline wchar_t *wcsrchr(wchar_t *p, wchar_t c)
  { return const_cast<wchar_t *> (wcsrchr(const_cast<const wchar_t *>(p),c)); }
  inline wchar_t *wcspbrk(wchar_t *p, const wchar_t *q)
  { return const_cast<wchar_t *> (wcspbrk(const_cast<const wchar_t *>(p),q)); }


  inline wchar_t* wcsstr(wchar_t *p, const wchar_t *q)
  { return const_cast<wchar_t*>(wcsstr(const_cast<const wchar_t*>(p),q)); }
  inline wchar_t* wmemchr(wchar_t *p, wchar_t c, size_t n)
  { return const_cast<wchar_t*>(wmemchr(const_cast<const wchar_t*>(p),c,n)); }
namespace std {



using ::wint_t;
using ::mbstate_t;
using ::size_t;




using ::fgetwc;
using ::fgetws;
using ::fputwc;
using ::fputws;
using ::getwc;
using ::getwchar;
using ::putwc;
using ::putwchar;
using ::ungetwc;
using ::wcscat;
using ::wcschr;
using ::wcscmp;
using ::wcscoll;
using ::wcscpy;
using ::wcscspn;
using ::wcsftime;
using ::wcslen;
using ::wcsncat;
using ::wcsncmp;
using ::wcsncpy;
using ::wcspbrk;
using ::wcsrchr;
using ::wcsspn;
using ::wcstod;
using ::wcstok;
using ::wcstol;
using ::wcstoul;
using ::wcsxfrm;



using ::btowc;
using ::fwide;
using ::fwprintf;
using ::fwscanf;
using ::mbrlen;
using ::mbrtowc;
using ::mbsinit;
using ::mbsrtowcs;
using ::swprintf;
using ::swscanf;
using ::vfwprintf;
using ::vswprintf;
using ::vwprintf;
using ::wcrtomb;
using ::wcsrtombs;
using ::wcsstr;
using ::wctob;
using ::wmemchr;
using ::wmemcmp;
using ::wmemcpy;
using ::wmemmove;
using ::wmemset;
using ::wprintf;
using ::wscanf;

}
namespace std {


typedef ssize_t streamsize;
typedef ssize_t streamoff;
typedef ssize_t wstreamoff;
template <class _StateT>
class fpos
{
public:

    typedef _StateT state_type;

    fpos (streamoff __off = 0, state_type __state = state_type())
        : _C_pos (__off),
          _C_state (__state)
        { }

    operator streamoff () const {
        return _C_pos;
    }

    fpos (const fpos&);

    fpos& operator= (const fpos&);

    state_type state () const {
        return _C_state;
    }

    void state (state_type __state) {
        _C_state = __state;
    }


    fpos operator- (const fpos &__off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (const fpos &__off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (const fpos &__off) {
        return _C_pos -= __off._C_pos, *this;
    }

    fpos& operator+= (const fpos &__off) {
        return _C_pos += __off._C_pos, *this;
    }

    fpos operator- (streamoff __off) const {
        return fpos (*this) -= __off;
    }

    fpos operator+ (streamoff __off) const {
        return fpos (*this) += __off;
    }

    fpos& operator-= (streamoff __off) {
        return _C_pos -= __off, *this;
    }

    fpos& operator+= (streamoff __off) {
        return _C_pos += __off, *this;
    }



    bool operator== (const fpos& __rhs) const;

    bool operator< (const fpos& __rhs) const {
        return _C_pos < __rhs._C_pos;
    }

    bool operator<= (const fpos& __rhs) const {
        return !(__rhs < *this);
    }

    bool operator>= (const fpos& __rhs) const {
        return !(*this < __rhs);
    }

    bool operator!= (const fpos& __rhs) const {
        return !(*this == __rhs);
    }

    bool operator> (const fpos& __rhs) const {
        return __rhs < *this;
    }

    bool operator== (streamoff __rhs) const {
        return _C_pos == __rhs;
    }

    bool operator< (streamoff __rhs) const {
        return _C_pos < __rhs;
    }

    bool operator<= (streamoff __rhs) const {
        return _C_pos <= __rhs;
    }

    bool operator>= (streamoff __rhs) const {
        return _C_pos >= __rhs;
    }

    bool operator> (streamoff __rhs) const {
        return _C_pos > __rhs;
    }

    bool operator!= (streamoff __rhs) const {
        return !(_C_pos == __rhs);
    }

private:

    streamoff _C_pos;
    state_type _C_state;
};


template <class _StateT>
inline
fpos<_StateT>::fpos(const fpos<_StateT>& __rhs)
{
    _C_pos = __rhs._C_pos;
    _C_state = __rhs._C_state;
}


template <class _StateT>
inline fpos<_StateT>&
fpos<_StateT>::operator= (const fpos<_StateT>& __rhs)
{
    if (&__rhs != this) {
        _C_pos = __rhs._C_pos;
        _C_state = __rhs._C_state;
    }
    return *this;
}


template <class _StateT>
inline bool
fpos<_StateT>::operator== (const fpos<_StateT>& __rhs) const
{
    return _C_pos == __rhs._C_pos

           && _C_state == __rhs._C_state

    ;
}

}







namespace std {


template <class _CharT>
struct char_traits
{
    typedef _CharT char_type;
    typedef int int_type;


    typedef wstreamoff off_type;
    typedef mbstate_t state_type;
    typedef fpos<state_type> pos_type;


    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {
        size_t __i = 0;
        while (__i < __n) {
            if (!eq (__s1[__i], __s2[__i])) {
                return lt (__s1[__i], __s2[__i]) ? -1 : 1;
            }
            ++__i;
        }
        return 0;
    }

    static size_t length (const char_type *__s) {
        size_t __len = 0;
        while (!eq (*__s++, char_type ()))
            ++__len;
        return __len;
    }

    static const char_type*
    find (const char_type* __s, size_t __n, const char_type& __a) {
        while (__n-- > 0 && !eq (*__s, __a) )
            ++__s;
        return eq (*__s, __a) ? __s : 0;
    }

    static char_type* move (char_type* __s1, const char_type* __s2,
                            size_t __n) {
        if (__s1 < __s2)
            copy (__s1, __s2, __n);
        else if (__s1 > __s2) {
            __s1 += __n;
            __s2 += __n;
            for (size_t __i = 0; __i < __n; ++__i)
                assign (*--__s1, *--__s2);
        }
        return __s1;
    }

    static char_type* copy (char_type *__dst, const char_type *__src,
                             size_t __n) {
        memcpy ((char*)__dst, (char*)__src, __n * sizeof (char_type));
        return __dst;
    }

    static char_type* assign (char_type* __s, size_t __n, char_type __a) {
        char_type* __tmp = __s;
        while (__n-- > 0)
            assign (*__tmp++, __a);
        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }

    static int_type to_int_type (const char_type& __c) {
        return __c;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (-1);
    }
};



template<>
struct char_traits<char>
{
    typedef char char_type;
    typedef int int_type;


    typedef streamoff off_type;
    typedef mbstate_t state_type;
    typedef fpos<state_type> pos_type;


    static void assign (char_type& __c1, const char_type& __c2){
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {
        return memcmp (__s1, __s2, __n);
    }

    static const char_type* find (const char_type* __s,
                                  size_t __n, const char_type& __a) {
        return (char_type*) memchr (__s, __a, __n);
    }

    static size_t length (const char_type *__s) {
        return strlen (__s);
    }

    static char_type * move (char_type* __s1, const char_type* __s2,
                             size_t __n) {

        memmove (__s1, __s2, __n);
        return __s1;
    }

    static char_type *copy (char_type *__dst, const char_type *__src,
                             size_t __n){
        memcpy (__dst, __src, __n);
        return __dst;
    }

    static char_type* assign (char_type* __s, size_t __n, char_type __a) {
        memset (__s, __a, __n);
        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return static_cast< char_type >(__c);
    }

    static int_type to_int_type (const char_type& __c) {

        return static_cast< unsigned char >(__c);
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (-1);
    }
};





template<>
struct char_traits<wchar_t>
{
    typedef wchar_t char_type;
    typedef wint_t int_type;






    typedef wstreamoff off_type;
    typedef mbstate_t state_type;
    typedef fpos<state_type> pos_type;


    static void assign (char_type& __c1, const char_type& __c2) {
        __c1 = __c2;
    }

    static bool eq (const char_type& __c1, const char_type& __c2) {
        return __c1 == __c2;
    }

    static bool lt (const char_type& __c1, const char_type& __c2) {
        return __c1 < __c2;
    }

    static int compare (const char_type* __s1, const char_type* __s2,
                        size_t __n) {

        return memcmp (__s1, __s2, __n*sizeof (char_type));
    }

    static size_t length (const char_type *__s) {

        return wcslen (__s);






     }


    static const char_type* find (const char_type* __s, size_t __n,
                                  const char_type& __a) {



        while (__n-- > 0 && !eq (*__s, __a))
            ++__s;
        return eq (*__s, __a) ? __s : 0;

    }


    static char_type * move (char_type* __s1, const char_type* __s2,
                             size_t __n) {

        memmove (__s1, __s2, __n*sizeof (char_type));
        return __s1;
    }

    static char_type * copy (char_type *__dst, const char_type *__src,
                             size_t __n) {
        memcpy ((char*)__dst, (char*)__src, __n * sizeof (char_type));
        return __dst;
    }

    static char_type* assign (char_type* __s, size_t __n, char_type __a){



        char_type* __tmp = __s;
        while (__n-- > 0)
            assign (*__tmp++, __a);

        return __s;
    }

    static int_type not_eof (const int_type& __c) {
        return eq_int_type (eof (), __c) ? 0 : __c;
    }

    static char_type to_char_type (const int_type& __c) {
        return __c;
    }

    static int_type to_int_type (const char_type& __c) {
        return __c;
    }

    static bool eq_int_type (const int_type& __c1, const int_type& __c2) {
        return __c1 == __c2;
    }


    static state_type get_state (pos_type __pos) {
        return __pos.state ();
    }


    static int_type eof () {
        return (wint_t)(-1);
    }
};




}


namespace __rw {


using namespace std;






template <class _CharT, class _Traits>
struct rw_traits
{
    static const _CharT* find (const _CharT* __s, const _CharT* __v) {
        size_t __slen = _Traits::length (__s);
        size_t __vlen = _Traits::length (__v);
        for (size_t __j = 0; (__j + __vlen) <= __slen ; ++__j) {
            bool __found = true;
            for (size_t __i = 0; __i < __vlen ; ++__i) {
                if (!_Traits::eq (__s[__j + __i], __v[__i])) {
                    __found = false;
                    break;
                }
            }
            if (__found)
                return &__s[__j];
        }
        return 0;
    }

    static const _CharT* rfind (const _CharT* __s, _CharT __v, size_t __pos) {
        const _CharT* __p = __s + __pos;
        while (__p >= __s) {
            if (_Traits::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;
    }

    static size_t find_first_of (const _CharT* __s, const _CharT* __v) {
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            for (const _CharT* q = __v; !_Traits::eq (*q, _CharT ()); ++q)
                if (_Traits::eq (*__p, *q))
                    return __p - __s;
        }
        return __p - __s;
    }

    static size_t find_first_not_of (const _CharT* __s, const _CharT* __v) {
        bool __found;
        const _CharT* __p = __s;
        for (; !_Traits::eq (*__p, _CharT ()); ++__p) {
            __found = false;
            for (const _CharT* q = __v; !_Traits::eq (*q, _CharT ()); ++q){
                if (_Traits::eq (*__p, *q)){
                    __found=true;
                    break;
                }
            }
            if (!__found)
                return __p - __s;
        }
        return __p-__s;
    }
};


template<>
struct rw_traits<char, std::char_traits<char> >
{
    static const char* find (const char* __s, const char* __v) {
        return strstr (__s, __v);
    }

    static const char* rfind (const char* __s, char __v, size_t __pos) {
        const char* __p = __s + __pos;
        while (__p >= __s)
        {
            if (std::char_traits<char>::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;
    }

    static size_t find_first_of (const char* __s, const char* __v) {
        return strcspn (__s, __v);
    }

    static size_t find_first_not_of (const char* __s, const char* __v) {
        return strspn (__s, __v);
    }

};



template<>
struct rw_traits<wchar_t, std::char_traits<wchar_t> >
{
    static const wchar_t* find (const wchar_t* __s, const wchar_t* __v) {

        return wcsstr (__s, __v);



    }

    static const wchar_t* rfind (const wchar_t* __s, wchar_t __v,
                                size_t __pos) {
        const wchar_t* __p = __s + __pos;
        while (__p >= __s) {
            if (std::char_traits<wchar_t>::eq (*__p, __v))
                return __p;
            __p--;
        }
        return 0;
    }

    static size_t find_first_of (const wchar_t* __s, const wchar_t* __v) {
        return wcscspn (__s, __v);
    }

    static size_t find_first_not_of (const wchar_t* __s, const wchar_t* __v) {
        return wcsspn (__s, __v);
    }

};




}





namespace std {
  template< class _CharT, class _Traits = char_traits<_CharT>,
  class _Allocator = allocator<_CharT> >
  class basic_string;


}


namespace __rw {

using std::basic_string;
  template <class _Allocator>
  class __string_noref_rep
  {
  public:
     explicit __string_noref_rep(long refs = 0)
      : __refs_((bool)refs), __capacity_(0), __nchars_(0) {;}
    __string_noref_rep(const __string_noref_rep& r)
      : __refs_((bool)r.__refs_), __capacity_(0), __nchars_(0) {;}

    typedef _Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;

  protected:

    size_type __capacity_;
    size_type __nchars_;
    bool __refs_;
  };

  template <class _CharT, class _Traits , class _Allocator>
  class __string_noref
   : public __string_noref_rep<_Allocator>
  {
  public:
    typedef __string_noref_rep<_Allocator> __string_ref_rep_type;
    typedef typename __string_noref_rep<_Allocator>::size_type size_type;

    explicit __string_noref (long=0)
    { ; }

  private:
    long __references () const
    {
      return (long)__string_noref_rep<_Allocator>::__refs_;
    }
    void __setRefCount (long r)
    { ; }
    void __addReference ()
    { ; }
    long __removeReference ()
    {
      return (long)__string_noref_rep<_Allocator>::__refs_;
    }
    size_type length () const
    {
      return __string_noref_rep<_Allocator>::__nchars_;
    }
    size_type __getCapac () const
    {
      return __string_noref_rep<_Allocator>::__capacity_;
    }
    _CharT* data () const
    {
      return (_CharT*)(this+1);
    }
    _CharT& operator[] (size_type i)
    {
      return (reinterpret_cast< _CharT* >((this+1)))[i];
    }
    const _CharT& operator[] (size_type i) const
    {
      return ((_CharT*)(this+1))[i];
    }

    friend class basic_string<_CharT, _Traits, _Allocator>;
  };
  template <class _Allocator>
  class __string_ref_rep
  {
  public:




    __string_ref_rep()
      : __refs_(0), __capacity_(0), __nchars_(0) {;}
    __string_ref_rep(long x)
      : __refs_(x), __capacity_(0), __nchars_(0) {;}
    __string_ref_rep(const __string_ref_rep& r)
      : __refs_(r.__refs_), __capacity_(0), __nchars_(0) {;}

    typedef _Allocator allocator_type;
    typedef typename allocator_type::size_type size_type;

  protected:
    long __refs_;

    size_type __capacity_;
    size_type __nchars_;
  };


  template <class _CharT, class _Traits , class _Allocator >
  class __string_ref : public __string_ref_rep<_Allocator>
  {
  public:
    typedef __string_ref_rep<_Allocator> __string_ref_rep_type;
    typedef typename __string_ref_rep<_Allocator>::size_type size_type;

    explicit __string_ref (long initRef = 0)
      : __string_ref_rep<_Allocator>(initRef - 1)
    { ; }

    __string_ref (const __string_ref<_CharT,_Traits,_Allocator>& ref)
      : __string_ref_rep<_Allocator>(ref.__refs_)
    { ; }

  private:
    long __references () const
    {
      return __string_ref_rep<_Allocator>::__refs_+1;
    }

    void __setRefCount (long r)
    {
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
         __rw::__rw_atomic_exchange ((this->__refs_), (r - 1), false);

      }
    }

    void __addReference ()
    {
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
         ++(this->__refs_);

      }
    }

    long __removeReference () {
      if (this != std::basic_string<_CharT,_Traits,_Allocator>::_C_get_null())
      {
        return 1 + --(this->__refs_);

      }
      else
        return 1;
    }

    size_type length () const
    { return __string_ref_rep<_Allocator>::__nchars_; }
    size_type __getCapac () const
    { return __string_ref_rep<_Allocator>::__capacity_;}

    _CharT* data () const
    {
      return (_CharT*)(this+1);
    }
    _CharT& operator[] (size_type i)
    {
      return (reinterpret_cast< _CharT* >((this+1)))[i];
    }
    const _CharT& operator[] (size_type i) const
    {
      return ((_CharT*)(this+1))[i];
    }

    friend class basic_string<_CharT, _Traits, _Allocator>;
  };
  template <class _CharT, class _Traits , class _Allocator,
            class stringRef = __string_ref_rep<_Allocator> >
  struct __null_string_ref_rep
  {



    stringRef __ref_hdr_;
    _CharT __eos_char_;

    __null_string_ref_rep (_CharT __eos = _CharT ())
      : __ref_hdr_(1), __eos_char_(__eos) { }
    __null_string_ref_rep (const __null_string_ref_rep<_CharT,_Traits,
                                                       _Allocator,stringRef>& r)
      : __ref_hdr_(r.__ref_hdr_), __eos_char_() {;}

  };


}
namespace std {
}
namespace __rw {
}

namespace std {


template <class _CharT, class _Traits, class _Allocator>
class basic_string
    : private _Allocator
{
public:

    typedef _Traits traits_type;
    typedef typename _Traits::char_type value_type;
    typedef _Allocator allocator_type;
    typedef __rw::__string_ref<value_type, traits_type, allocator_type>
     _C_string_ref_type;
    typedef typename _C_string_ref_type::__string_ref_rep_type _C_rep_type;






    typedef __rw::__null_string_ref_rep<value_type, traits_type,
                                      allocator_type, _C_rep_type>
        _C_null_ref_type;

private:

    typedef allocator_type
        _C_value_alloc_type;
    typedef typename allocator_type::template rebind < _C_string_ref_type >::other
        _C_ref_alloc_type;

public:

    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    iterator _C_make_iter (pointer __ptr) {
        return __ptr;
    }

    const_iterator _C_make_iter (const_pointer __ptr) const {
        return __ptr;
    }






    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    static const size_type npos = size_type(-1);


    explicit
    basic_string (const allocator_type& = allocator_type());





    basic_string (const basic_string&);

    basic_string (const basic_string&,
                  size_type, size_type = npos,
                  const allocator_type&
                        = allocator_type ());

    basic_string (const_pointer, size_type,
                  const allocator_type&
                        = allocator_type ());

    basic_string (const_pointer,
                  const allocator_type&
                        = allocator_type ());
    template <class _InputIterator>
    basic_string (_InputIterator, _InputIterator,
                  const allocator_type&
                        = allocator_type ());

    basic_string (int __n, value_type __c,
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned int __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
      : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (long __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned long __n, value_type __c,
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (short __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned short __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (char __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }

    basic_string (unsigned char __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }




    basic_string (wchar_t __n, value_type __c,
                  const allocator_type& __alloc
                         = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }






    basic_string (bool __n, value_type __c,
                  const allocator_type& __alloc
                        = allocator_type ())
        : allocator_type (__alloc) {
        _C_initn (__n, __c);
    }
    basic_string (const_pointer, const_pointer,
                  const allocator_type&
                        = allocator_type ());
    ~basic_string () {
        _C_unlink();
    }

    basic_string& operator= (const basic_string&);
    basic_string& operator= (const_pointer __s);

    basic_string& operator= (value_type __c) {
        return replace (0, size(), 1, __c);
    }

    iterator begin () {
        _C_cow(); _C_pref()->__setRefCount(0);
        return _C_make_iter (_C_data);
    }

    const_iterator begin () const {
        return _C_make_iter (_C_data);
    }

    iterator end () {
        _C_cow(); _C_pref()->__setRefCount(0);
        return _C_make_iter (_C_data + size ());
    }

    const_iterator end () const {
        return _C_make_iter (_C_data+size());
    }

    reverse_iterator rbegin () {
        return reverse_iterator (end ());
    }

    const_reverse_iterator rbegin () const {
        return const_reverse_iterator (end());
    }

    reverse_iterator rend () {
        return reverse_iterator (begin());
    }

    const_reverse_iterator rend () const {
        return const_reverse_iterator (begin());
    }

    size_type size () const {
        return _C_pref()->__nchars_;
    }

    size_type length () const {
        return size ();
    }

    size_type max_size () const {
        return npos - sizeof (_C_rep_type) - 2;
    }

    void resize (size_type, value_type);

    void resize (size_type __n) {
        resize (__n, value_type ());
    }

    size_type capacity () const {
        return _C_pref()->__getCapac ();
    }

    void reserve (size_type = 0);

    void clear () {
        erase ();
    }

    bool empty () const {
        return size () == 0;
    }

    const_reference operator[] (size_type) const;
    reference operator[] (size_type);

    const_reference at (size_type) const;
    reference at (size_type);

    basic_string& operator+= (const basic_string &__s) {
        return append (__s);
    }

    basic_string& operator+= (const_pointer __s) {
        return append (__s);
    }

    basic_string& operator+= (value_type __c) {
        return append (size_type (1), __c);
    }

    basic_string& append (const basic_string&, size_type, size_type);

    basic_string& append (const basic_string &__str) {
        return append (__str, 0, __str.size ());
    }

    basic_string& append (const_pointer __s, size_type __n) {
        return replace (size (), 0, __s, __n, 0, __n), *this;
    }

    basic_string& append (const_pointer __s) {
        return replace (size (), 0, __s);
    }




    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last) {



        return append (__first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator >::is_integer>*)0));
    }

    template<class _InputIterator>
    basic_string& append (_InputIterator __first, _InputIterator __last,
                          const _C_dispatch <void, false >*) {


        return replace (end (), end (), __first, __last), *this;
    }

    basic_string& append (size_type __n, value_type __c,
                          const _C_dispatch <void, true >*) {

        return replace (size (), 0, __n, __c);
    }
    basic_string& append (size_type __n, value_type __c) {
        return replace (size (), 0, __n, __c);
    }

    void push_back (value_type __c) {
        append (size_type (1), __c);
    }

    basic_string& assign (const basic_string &__str) {
        return replace (0, size (), __str);
    }

    basic_string& assign (const basic_string&, size_type, size_type);

    basic_string& assign (const_pointer __s, size_type __n) {
        return replace (0, size (), __s, __n, 0, __n), *this;
    }

    basic_string& assign (const_pointer __s) {
        return assign (__s, traits_type::length (__s));
    }





    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last) {



        return assign (__first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator >::is_integer>*)0));
    }

    template<class _InputIterator>
    basic_string& assign (_InputIterator __first, _InputIterator __last,
                          const _C_dispatch <void, false >*) {


        return replace (begin (), end (), __first, __last);
    }

    basic_string& assign (size_type __n, value_type __c,
                          const _C_dispatch <void, true >*) {

        return replace (0, size (), __n, __c);
    }
    basic_string& assign (size_type __n, value_type __c) {
        return replace (0, size (), __n, __c);
    }

    basic_string& insert (size_type, const basic_string&);
    basic_string& insert (size_type, const basic_string&,
                          size_type, size_type);

    basic_string& insert (size_type __pos, const_pointer __s, size_type __n) {
        return replace (__pos, 0, __s, __n, 0, __n), *this;
    }

    basic_string& insert (size_type __pos, const_pointer __s) {
        return insert (__pos, __s, traits_type::length (__s));
    }

    iterator insert (iterator __pos, value_type __c) {
      iterator __tmp = __replace_aux(__pos-begin(), 0, basic_string(1, __c));
      _C_pref()->__setRefCount(0);
      return __tmp;
    }





    template<class _InputIterator>
    void insert (iterator __p,
                 _InputIterator __first, _InputIterator __last) {




        insert (__p, __first, __last, ((_C_dispatch <void, numeric_limits< _InputIterator >::is_integer>*)0));
    }

    template<class _InputIterator>
    void insert (iterator __p, _InputIterator __first, _InputIterator __last,
                 const _C_dispatch <void, false >*) {



        replace (__p, __p, __first, __last);
    }

    void insert (iterator __p, size_type __n, value_type __c,
                 const _C_dispatch <void, true >*) {

        replace (__p - begin(), 0, __n, __c);
    }
    void insert (iterator __p, size_type __n, value_type __c) {
        replace (__p - begin(), 0, __n, __c);
    }

    basic_string& insert (size_type __pos, size_type __n, value_type __c) {
        return replace (__pos, 0, __n, __c);
    }

    basic_string& erase (size_type = 0, size_type = npos);

    iterator erase (iterator it) {
        iterator __tmp = replace (it - begin(), 1, const_pointer (0), 0, 0, 0);
        _C_pref()->__setRefCount(0);
        return __tmp;
    }

    iterator erase (iterator __first, iterator __last) {
        iterator __tmp = replace (__first - begin (), __last - __first,
                                   const_pointer (0), 0, 0, 0);
        _C_pref()->__setRefCount(0);
        return __tmp;
    }

private:



    iterator replace (size_type, size_type, const_pointer,
                      size_type, size_type, size_type);

    iterator __replace_aux (size_type pos1, size_type __n1,
                            const basic_string &__str,
                            size_type pos2 = 0,
                            size_type __n2 = npos) {
        return replace (pos1, __n1, __str.c_str(), __str.size(), pos2, __n2);
    }




    template<class _InputIterator>
    basic_string& __replace_aux (iterator first1,
                                 iterator last1,
                                 _InputIterator first2,
                                 _InputIterator last2);



  public:

    basic_string& replace (size_type pos1, size_type __n1,
                           const basic_string &__s,
                           size_type pos2, size_type __n2) {
        return replace (pos1, __n1, __s.c_str (), __s.size (), pos2, __n2), *this;
    }

    basic_string& replace (size_type __pos, size_type __n,
                           const basic_string &__s) {
        return replace (__pos, __n, __s, 0, __s.size ());
    }


    basic_string& replace (size_type __pos, size_type __n1, const_pointer __s,
                           size_type __n2) {
        return replace (__pos, __n1, __s, __n2, 0, __n2), *this;
    }

    basic_string& replace (size_type __pos, size_type __n, const_pointer __s) {
        return replace (__pos, __n, __s, traits_type::length (__s));
    }

    basic_string& replace (size_type, size_type, size_type, value_type);

    basic_string& replace (iterator __first, iterator __last,
                           const basic_string &__str) {
        return replace (__first - begin (), __last - __first, __str);
    }

    basic_string& replace (iterator __first, iterator __last,
                           const_pointer __s, size_type __n) {
        return replace (__first - begin (), __last - __first, __s, __n, 0, __n), *this;
    }

    basic_string& replace (iterator __first, iterator __last, const_pointer __s) {
        return replace (__first, __last, __s, traits_type::length(__s));
    }





    template<class _InputIterator>
    basic_string& replace (iterator __i1, iterator __i2,
                           _InputIterator __j1, _InputIterator __j2) {




        return replace (__i1, __i2, __j1, __j2,
                        ((_C_dispatch <void, numeric_limits< _InputIterator >::is_integer>*)0));
    }

    template<class _InputIterator>
    basic_string& replace (iterator, iterator,
                           _InputIterator, _InputIterator,
                           const _C_dispatch <void, false >*);


    basic_string& replace (iterator __first, iterator __last,
                           size_type __n, value_type __c,
                           const _C_dispatch <void, true >*) {

        return replace (__first - begin (), __last - __first, __n, __c);
    }
    basic_string& replace (iterator __first, iterator __last,
        size_type __n, value_type __c) {


        return replace (__first - begin (), __last - __first, __n, __c);
    }

    size_type copy (pointer, size_type, size_type = 0) const;
    basic_string copy () const;

    void swap (basic_string &__s) {
        pointer __temp = _C_data;
        _C_data = __s._C_data;
        __s._C_data = __temp;
    }




    const_pointer c_str () const {
        return _C_data;
    }

    const_pointer data () const {
        return _C_data;
    }

    allocator_type get_allocator() const {
        return *this;
    }


    size_type find (const basic_string &__str, size_type __pos = 0) const {
        return find (__str.c_str (), __pos, __str.size ());
    }


    size_type find (const_pointer, size_type, size_type) const;


    size_type find (const_pointer, size_type = 0) const;


    size_type find (value_type, size_type = 0) const;


    size_type rfind (const basic_string &__str, size_type __pos = npos) const {
        return rfind (__str.c_str (), __pos, __str.size ());
    }


    size_type rfind (const_pointer, size_type, size_type) const;


    size_type rfind (const_pointer __s, size_type __pos = npos) const {
        return rfind (__s, __pos, traits_type::length (__s));
    }


    size_type rfind (value_type, size_type = npos) const;


    size_type find_first_of (const basic_string &__str,
                             size_type __pos = 0) const {
        return find_first_of (__str.c_str (), __pos, __str.size ());
    }


    size_type find_first_of (const_pointer, size_type, size_type) const;


    size_type find_first_of (const_pointer, size_type = 0) const;


    size_type find_first_of (value_type __c, size_type __pos = 0) const {
        return find (__c, __pos);
    }


    size_type find_last_of (const basic_string &__str,
                            size_type __pos = npos) const {
        return find_last_of (__str.c_str (), __pos, __str.size ());
    }


    size_type find_last_of (const_pointer, size_type, size_type) const;


    size_type find_last_of (const_pointer __s, size_type __pos = npos) const {
        return find_last_of (__s, __pos, traits_type::length (__s));
    }


    size_type find_last_of (value_type __c, size_type __pos = npos) const {
        return rfind (__c, __pos);
    }


    size_type find_first_not_of (const basic_string &__str,
                                 size_type __pos = 0) const {
        return find_first_not_of (__str.c_str (), __pos, __str.size ());
    }


    size_type find_first_not_of (const_pointer, size_type,
                                 size_type) const;


    size_type find_first_not_of (const_pointer, size_type = 0) const;


    size_type find_first_not_of (value_type, size_type = 0) const;


    size_type find_last_not_of (const basic_string &__str,
                                size_type __pos = npos) const {
        return find_last_not_of (__str.c_str (), __pos, __str.size ());
    }


    size_type find_last_not_of (const_pointer, size_type, size_type) const;


    size_type find_last_not_of (const_pointer __s,
                                size_type __pos = npos) const {
        return find_last_not_of (__s, __pos, traits_type::length (__s));
    }


    size_type find_last_not_of (value_type, size_type = npos) const;


    basic_string substr (size_type = 0, size_type = npos) const;

    int compare (const basic_string &__str) const {
        return compare (0, size (), __str.c_str (), __str.size ());
    }

    int compare (size_type __pos, size_type __n, const basic_string &__str) const {
        return compare (__pos, __n, __str.c_str(), __str.size());
    }

    int compare (size_type, size_type, const basic_string&,
                size_type, size_type) const;

    int compare (const_pointer __s) const {
        return compare (0, size (), __s, traits_type::length(__s));
    }

    int compare (size_type, size_type, const_pointer, size_type) const;

    int compare (size_type __pos, size_type __n, const_pointer __s) const {
        return compare(__pos, __n, __s, traits_type::length (__s));
    }

  protected:

    void _C_cow () {
        if (_C_pref ()->__references() > 1)
            _C_clone();
    }

    void _C_cow (size_type __nc) {
        if (_C_pref ()->__references () > 1 || capacity () < __nc)
            _C_clone (__nc);
    }

  private:

    void _C_initn(size_type, value_type);




    void _C_clone (size_type __nc = npos);

    _C_string_ref_type * _C_pref () const {



      return reinterpret_cast< _C_string_ref_type* >(_C_data) - 1;

    }




    void _C_unlink ();


    friend
    class __rw::__string_ref<value_type, traits_type, allocator_type>;
    static const _C_null_ref_type __nullref;


    static _C_string_ref_type* _C_get_null ()
    {

      return reinterpret_cast< _C_string_ref_type* >(const_cast< _C_null_ref_type* >(&__nullref));
    }
    _C_string_ref_type * _C_getRep (size_type capac, size_type nchar);

    pointer _C_data;
};





  typedef basic_string<char, char_traits<char>, allocator<char> >
  string;


  typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
  wstring;




  template <>
  const string::_C_null_ref_type string::__nullref;

  template <>
  const wstring::_C_null_ref_type wstring::__nullref;
  template <class _CharT, class _Traits , class _Allocator>
  inline void basic_string<_CharT, _Traits, _Allocator>::_C_unlink()
  {
    if (!_C_data)
      return;
    if (_C_pref()->__references() == 0 || _C_pref()->__removeReference() == 0)
    {


      size_type dealloc_size =
          capacity() + sizeof(_C_rep_type)/sizeof(value_type) + 2;

      _C_ref_alloc_type(*this).destroy(_C_pref());
      allocator_type::deallocate (reinterpret_cast< pointer >(_C_pref()), dealloc_size);



      _C_data = 0;
    }
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline basic_string<_CharT, _Traits, _Allocator>
  ::basic_string (const allocator_type& __alloc)
      : allocator_type (__alloc)
  {
    _C_data = _C_get_null()->data();
    _C_get_null()->__addReference();
  }
template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>::
basic_string (const basic_string<_CharT, _Traits, _Allocator> &__s)
    : allocator_type (__s.get_allocator ())
{
    if (__s._C_pref()->__references () > 0) {
        _C_data = __s._C_data;
        _C_pref()->__addReference ();
    }
    else {
        size_type __n = __s.size();
        _C_data = _C_getRep (__n, __n)->data ();
        traits_type::copy (_C_data, __s.c_str (), __n);
    }
}


template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::erase (size_type __pos,
                                                  size_type __n)
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1064" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());




    const value_type __tmp = value_type();
    size_type __len = size () - __pos;
    return replace (__pos, __n < __len ? __n : __len, &__tmp, 0);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos) const
{






    return _C_data [__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::operator[] (size_type __pos)
{







    _C_cow();
    _C_pref()->__setRefCount(0);
    return _C_data[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::const_reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos) const
{
    (__pos < size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1110" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size());




    return _C_data[__pos];
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::reference
basic_string<_CharT, _Traits, _Allocator>::at (size_type __pos)
{
    (__pos < size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string" ":" "1123" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size());




    _C_cow();
    _C_pref()->__setRefCount(0);
    return _C_data[__pos];
}


  template <class _CharT, class _Traits , class _Allocator>
  inline void
  basic_string<_CharT, _Traits, _Allocator>::
  resize (size_type __n, value_type __c)
  {
      (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string" ":" "1139" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size());




    if (__n < size())
      erase(__n, size()-__n);
    else
      replace (size(), 0, __n-size(), __c);
    _C_pref()->__setRefCount(1);
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline void basic_string<_CharT, _Traits, _Allocator>::
  reserve(size_type res_arg)
  {
     (res_arg <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string" ":" "1155" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, res_arg, max_size());



    if (res_arg > capacity())
        _C_clone(res_arg);
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline basic_string<_CharT, _Traits, _Allocator>
  basic_string<_CharT, _Traits, _Allocator>::copy () const
  {
    basic_string __temp(*this);
    __temp._C_clone();
    return __temp;
  }


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (const_pointer __s, size_type __pos) const
{
    ((void)0);


    if (__pos > size ())
        return npos;

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::find (_C_data + __pos, __s);

   return __where ? __where - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (value_type __c, size_type __pos) const
{
    if (__pos > size())
        return npos;

    const_pointer __where = traits_type::find (_C_data + __pos,
                                                size() - __pos, __c);
    return __where ? __where - _C_data : npos;
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
rfind (value_type __c, size_type __pos) const
{
    if (!size ())
        return npos;

    if (__pos >= size ())
        __pos = size () - 1;

    const_pointer __where =
        __rw::rw_traits<value_type, traits_type>::rfind (_C_data,
                                                            __c, __pos);
    return __where ? __where - _C_data : npos;
}


  template <class _CharT, class _Traits , class _Allocator>
  inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
  basic_string<_CharT, _Traits, _Allocator>::
  find_first_of (const_pointer __s, size_type __pos) const
  {
    ((void)0);

    if (__pos > size())
      return npos;
    size_type __i = __rw::rw_traits<_CharT, _Traits>::find_first_of(_C_data+__pos, __s) + __pos;
    return __i >= size() ? npos : __i;
  }

  template <class _CharT, class _Traits , class _Allocator>
  inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
  basic_string<_CharT, _Traits, _Allocator>::
  find_first_not_of (const_pointer __s, size_type __pos) const
  {
    ((void)0);

    if (__pos > size())
      return npos;
    size_type __i = __rw::rw_traits<_CharT, _Traits>::find_first_not_of(_C_data+__pos, __s) + __pos;
    return __i >= size() ? npos : __i;
  }


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (value_type __c, size_type __pos) const
{
    return find_first_not_of (&__c, __pos, 1);
}


template <class _CharT, class _Traits , class _Allocator>
inline typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_not_of (value_type __c, size_type __pos) const
{




    value_type __tmp [2];
    traits_type::assign (__tmp [0], __c);
    traits_type::assign (__tmp [1], value_type ());


    return find_last_not_of (__tmp, __pos);
}


template <class _CharT, class _Traits, class _Allocator>
inline void
basic_string<_CharT, _Traits, _Allocator>::_C_clone (size_type __nc )
{
    size_type __len = size();
    _C_string_ref_type * __temp = _C_getRep (npos == __nc ? size () : __nc,
                                             __len > __nc ? __nc : __len);
    traits_type::copy (__temp->data(), _C_data, size());
    _C_unlink ();
    _C_data = __temp->data();
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator> &__lhs,
           const basic_string<_CharT, _Traits, _Allocator> &__rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (_CharT __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(1, __lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline basic_string<_CharT, _Traits, _Allocator>
operator+ (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           _CharT __rhs)
{
    return basic_string<_CharT, _Traits, _Allocator>(__lhs) += __rhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const _CharT* __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 == __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator== (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const _CharT* __rhs)
{
    return 0 == __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return 0 < __rhs.compare (__lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs)
{
    return 0 > __lhs.compare (__rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _CharT, class _Traits, class _Allocator>
inline void swap (basic_string<_CharT, _Traits, _Allocator>& __a,
                  basic_string<_CharT, _Traits, _Allocator>& __b)
{
    __a.swap (__b);
}




template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const _CharT* __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator!= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const _CharT* __rhs)
{
    return !(__lhs == __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const _CharT* __lhs,
           const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
           const _CharT* __rhs)
{
    return __rhs < __lhs;
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const _CharT* __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator<= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const _CharT* __rhs)
{
    return !(__rhs < __lhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const _CharT* __lhs,
            const basic_string<_CharT, _Traits, _Allocator>& __rhs)
{
    return !(__lhs < __rhs);
}



template <class _CharT, class _Traits , class _Allocator>
inline bool
operator>= (const basic_string<_CharT, _Traits, _Allocator>& __lhs,
            const _CharT* __rhs)
{
    return !(__lhs < __rhs);
}


}


namespace __rw {






template <class _CharT, class _Traits, class _Allocator>
inline size_t
__rw_new_capacity (size_t __size,
                   const std::basic_string<_CharT, _Traits, _Allocator>*)
{
    size_t __cap =
        static_cast< size_t >(__size * float(1.618));
    return (__size += size_t(128)) > __cap ? __size : __cap;
}
}
namespace std {







    template <class _CharT, class _Traits, class _Allocator>
    const typename basic_string<_CharT, _Traits, _Allocator>::size_type
    basic_string<_CharT, _Traits, _Allocator>::npos;





  template <class _CharT, class _Traits, class _Allocator>
  const typename basic_string<_CharT, _Traits, _Allocator>::_C_null_ref_type
  basic_string<_CharT, _Traits, _Allocator>::__nullref = _CharT ();



template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::_C_string_ref_type *
basic_string<_CharT, _Traits, _Allocator>::
_C_getRep (size_type __cap, size_type __len)
{
    (__cap <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "48" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __cap, max_size ());




    (__len <= __cap) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "53" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __len, __cap);




    if (!__cap) {
        _C_get_null()->__addReference();
        return _C_get_null();
    }





    _C_string_ref_type * ret =
        reinterpret_cast< _C_string_ref_type * >(allocator_type::allocate(__cap + sizeof(_C_rep_type)/ sizeof(value_type) + 2, 0));




    _C_ref_alloc_type(*this).construct(ret, _C_string_ref_type());
    value_type * __d = ret->data();
    allocator_type::construct(__d, value_type());

    ret->__capacity_ = __cap;
    ret->__setRefCount(1);
    traits_type::assign (ret->data()[ret->__nchars_ = __len], value_type ());
    return ret;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const basic_string &__s,
              size_type __pos, size_type __n, const allocator_type& __alloc)
    : allocator_type (__alloc)
{
    (__pos <= __s.size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "90" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, __s.size ());




    size_type __slen = __s.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    size_type __nlen = __n == npos ? 0 : __n;
    size_type __maxlen = __nlen > __rlen ? __nlen : __rlen;
    if (__maxlen)
      _C_data = _C_getRep (max (__rw::__rw_new_capacity (0, this),
                                size_t (__maxlen)),
                           __rlen)->data();
    else
      _C_data = _C_getRep(__maxlen,__rlen)->data();

    traits_type::copy(_C_data, &__s._C_data[__pos], __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
void basic_string<_CharT, _Traits, _Allocator>::
_C_initn (size_type __n, value_type __c)
{
    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "114" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    if (__n)
      _C_data = _C_getRep (max (__rw::__rw_new_capacity(0, this), size_t (__n)),
                           __n)->data();
    else
      _C_data = _C_getRep(__n, __n)->data();

    while (__n--) traits_type::assign(_C_data[__n], __c);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __s, size_type __n, const allocator_type& __alloc)
    : allocator_type (__alloc)
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "136" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    if (__n)
      _C_data = _C_getRep (max (__rw::__rw_new_capacity(0, this), size_t (__n)),
                           __n)->data();
    else
      _C_data = _C_getRep(__n, __n)->data();
    traits_type::copy(_C_data, __s, __n);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __s, const allocator_type& __alloc)
    : allocator_type(__alloc)
{
    ((void)0);

    size_type __len = traits_type::length(__s);
    if (__len)
        _C_data = _C_getRep (max (__rw::__rw_new_capacity (0, this),
                                  size_t (__len)),
                             __len)->data();
    else
      _C_data = _C_getRep(__len, __len)->data();

    traits_type::copy(_C_data, __s, __len);
}
template <class _CharT, class _Traits, class _Allocator>
template <class _InputIterator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (_InputIterator __first, _InputIterator __last,
              const allocator_type &__alloc)
    : allocator_type(__alloc)
{
    _C_data = _C_getRep(__rw::__rw_new_capacity(0, this), 0)->data();
    replace(_C_make_iter (_C_data), _C_make_iter (_C_data), __first, __last);
}




template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
basic_string (const_pointer __first, const_pointer __last,
              const allocator_type& __alloc)
    : allocator_type(__alloc)
{
    if(__last-__first)
      _C_data = _C_getRep (max (__rw::__rw_new_capacity(0, this),
                                size_t (__last - __first)), 0)->data();
    else
      _C_data = _C_getRep(__last-__first, 0)->data();
    replace(0, 0, __first, __last-__first, 0, __last-__first);
}
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
operator= (const basic_string<_CharT, _Traits, _Allocator>& __str)
{
    if (this != &__str)
    {
      if (__str._C_pref()->__references() > 0)
      {
        __str._C_pref()->__addReference();
        _C_unlink();
        _C_data = __str._C_data;
      }
      else
        this->replace(0, size(), __str.data(), __str.size());
    }
    return *this;
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::operator= (const_pointer __s)
{
    ((void)0);

    if (traits_type::eq(*__s, value_type()))
    {
      if (_C_pref()->__references() == 1)
      {
        _C_pref()->__nchars_ = 0;
        traits_type::assign(_C_data[0], value_type());
      }
      else
      {
        _C_unlink();
        _C_get_null()->__addReference();
        _C_data = _C_get_null()->data();
      }
      return *this;
    }

    return replace(0, size(), __s, traits_type::length(__s));
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
append (const basic_string<_CharT, _Traits, _Allocator>& __str,
        size_type __pos,
        size_type __n)
{
    (__pos <= __str.size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "312" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, __str.size ());




    size_type __slen = __str.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen;


    (size () <= max_size () - __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "321" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size (), max_size () - __rlen);




    replace(size(), 0, __str.c_str(), __str.size(), __pos, __n);

    return *this;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
assign (const basic_string<_CharT, _Traits, _Allocator>& __str,
        size_type __pos,
        size_type __n)
{
    (__pos <= __str.size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "339" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, __str.size ());




    size_type __slen = __str.size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    return replace(0, size(), __str, __pos, __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
insert (size_type pos1,
        const basic_string<_CharT, _Traits, _Allocator>& __str,
        size_type pos2,
        size_type __n)
{
    (pos1 <= size() && pos2 <= __str.size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "358" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, pos1 > size() ? pos1:pos2, __str.size());




    size_type __slen = __str.size() - pos2;
    size_type __rlen = __n < __slen ? __n : __slen;

    (size () <= max_size () - __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "366" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size (), max_size () - __rlen);




    return replace(pos1, 0, __str, pos2, __n);
}

template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
insert (size_type pos1, const basic_string &__str)
{
    (pos1 <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "379" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, pos1, size ());




    (size() <= max_size() - __str.size()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "384" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size (), max_size () - __str.size ());




    return replace(pos1, 0, __str);
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::iterator
basic_string<_CharT, _Traits, _Allocator>::
replace (size_type pos1, size_type __n1, const_pointer cs,
         size_type cslen, size_type pos2, size_type __n2)
{
    (pos1 <= size () && pos2 <= cslen) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "400" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, pos1 > size() ? pos1 : pos2, size () > cslen ? size () : cslen);





    size_type __slen = size() - pos1;
    size_type __xlen = __n1 < __slen ? __n1 : __slen;
    size_type __clen = cslen - pos2;
    size_type __rlen = __n2 < __clen ? __n2 : __clen;

    (size() - __xlen <= max_size () - __rlen && max_size () >= __rlen) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "411" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size () - __xlen, max_size() - __rlen);





    size_type tot = size() - __xlen + __rlen;

    if (!tot)
    {

      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }
    else
    {
      size_type rem = size() - __xlen - pos1;


      if ( (_C_pref()->__references() > 1)
           || (capacity() < tot)
           || (cs && (cs >= data() && cs < data()+size())))
      {

        size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
                                     size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (pos1) traits_type::copy(__temp->data(), _C_data, pos1);
        if (__rlen) traits_type::copy(__temp->data()+pos1, cs+pos2, __rlen);
        if (rem ) traits_type::copy(__temp->data()+pos1+__rlen, _C_data+pos1+__n1, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {

        if (rem)
            traits_type::move(_C_data+pos1+__rlen, _C_data+pos1+__n1, rem);

        if (__rlen)
            traits_type::move(_C_data+pos1, cs+pos2, __rlen);

        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type ());
      }
    }
    return _C_make_iter (_C_data + pos1);
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
replace (size_type __pos, size_type __n, size_type __n2, value_type __c)
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "465" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());




    size_type __slen = size() - __pos;
    size_type __xlen = __n < __slen ? __n : __slen;

    (size() - __xlen < max_size () - __n2 && max_size () >= __n2) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "474" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size () - __xlen, max_size () - __n2);





    size_type tot = size() - __xlen + __n2;

    if (!tot)
    {

      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }
    else
    {
      size_type rem = size() - __xlen - __pos;

      if ( (_C_pref()->__references() > 1) || (capacity() < tot))
      {

          size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
                                       size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
        if (__n2) traits_type::assign(__temp->data()+__pos, __n2, __c);
        if (rem ) traits_type::copy(__temp->data()+__pos+__n2, _C_data+__pos+__n, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {

        if (rem)
            traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, rem);
        if (__n2)
            traits_type::assign(_C_data+__pos, __n2, __c);
        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type ());
      }
    }
    return *this;
}
template<class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
replace (iterator first1, iterator last1,
         _InputIterator first2, _InputIterator last2,
         const _C_dispatch <void, false >*)
{


     iterator __first = first1;
     iterator __last = last1;


     if (__is_bidirectional_iterator(__iterator_category(first2)))
       return __replace_aux(first1, last1, first2, last2);

     (__first <= end () && __last <= end ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "548" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __first > end () ? __first : __last, end ());






     while (first2 != last2) {
         (size_type (__first - _C_data) <= max_size()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "555" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __first - _C_data, max_size ());






       if (__first == __last) {

         size_t __new_capacity = __rw::__rw_new_capacity(size(), this);
         size_t __delta = __new_capacity - size();

         _C_string_ref_type * __temp =
               _C_getRep(__new_capacity, __new_capacity);


         size_type __current = __last-begin();
         traits_type::copy (__temp->data (), _C_data, __current);
         traits_type::copy (__temp->data () + __current + __delta, __last,
                            end () - __last);
         _C_unlink();
         _C_data = __temp->data();
         __first = _C_make_iter (_C_data + __current);
         __last = __first + __delta;
       }

       traits_type::assign (*__first++, *first2++);
     }
     if (__first != __last)
         replace (__first - _C_data, __last - __first, 0, value_type ());

     return *this;
}




template<class _CharT, class _Traits, class _Allocator>
template<class _InputIterator>
inline basic_string<_CharT, _Traits, _Allocator>&
basic_string<_CharT, _Traits, _Allocator>::
__replace_aux (iterator first1, iterator last1,
               _InputIterator first2, _InputIterator last2)
{
    difference_type __n2 = 0;
    distance(first2, last2, __n2);
    size_type __n = last1-first1;
    size_type __pos = first1 - _C_data;

    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "603" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());




    size_type __slen = size() - __pos;
    size_type __xlen = __n < __slen ? __n : __slen;

   (size () - __xlen < max_size() - __n2) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "611" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, size () - __xlen, max_size () - __n2);




    size_type tot = size() - __xlen + __n2;

    if (!tot)
    {

      _C_unlink();
      _C_get_null()->__addReference();
      _C_data = _C_get_null()->data();
    }

    else
    {
      size_type __d = 0;
      size_type rem = size() - __xlen - __pos;

      if ( (_C_pref()->__references() > 1) || (capacity() < tot))
      {

        size_t __new_capacity = max (__rw::__rw_new_capacity (size(), this),
                                     size_t (tot));
        _C_string_ref_type * __temp = _C_getRep(__new_capacity, tot);
        if (__pos) traits_type::copy(__temp->data(), _C_data, __pos);
        for (__d = 0; __d < (size_type)__n2; __d++)
            traits_type::assign (*(__temp->data()+__pos+__d), *first2++);
        if (rem )
          traits_type::copy(__temp->data()+__pos+__n2, _C_data+__pos+__n, rem);
        _C_unlink();
        _C_data = __temp->data();
      }
      else
      {

        if (rem)
          traits_type::move(_C_data+__pos+__n2, _C_data+__pos+__n, rem);
        for (__d = 0; __d < (size_type)__n2; __d++)
            traits_type::assign (*(_C_data+__pos+__d), *first2++);
        traits_type::assign (_C_data[_C_pref()->__nchars_ = tot], value_type());
      }
    }
    return *this;
}




template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
copy (pointer __s, size_type __n, size_type __pos) const
{
    (__pos <= size()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "666" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());




    size_type __slen = size() - __pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    traits_type::copy(__s, _C_data+__pos, __rlen);
    return __rlen;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "685" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size());




    for (size_type xpos = __pos; (xpos + __n) <= size() ; xpos++)
    {
      if (!traits_type::compare(_C_data+xpos, __s, __n))
        return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
rfind (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "707" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    if (size() < __n)
      return npos;

    size_type __slen = size() -__n;
    size_type xpos_start = __slen < __pos ? __slen : __pos;

    for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
    {
      if (!traits_type::compare(_C_data+xpos-1, __s, __n))
        return xpos-1;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "735" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    for (size_type xpos = __pos; xpos < size() ; xpos++)
    {
      for (size_type __i = 0; __i < __n ; __i++)
        if (traits_type::eq(_C_data[xpos], __s[__i]))
          return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "758" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    if (size())
    {
      size_type __slen = size() -1;
      size_type xpos_start = __pos < __slen ? __pos : __slen;
      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
      {
        for(size_type __i = 0; __i < __n ; __i++)
          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
            return xpos-1;
      }
    }
    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_first_not_of (const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "785" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    for (size_type xpos = __pos; xpos < size() ; xpos++)
    {
      bool found = false;
      for (size_type __i = 0; __i < __n ; __i++)
      {
        if (traits_type::eq(_C_data[xpos], __s[__i]))
        {
          found = true;
          break;
        }
      }
      if (!found)
        return xpos;
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
typename basic_string<_CharT, _Traits, _Allocator>::size_type
basic_string<_CharT, _Traits, _Allocator>::
find_last_not_of(const_pointer __s, size_type __pos, size_type __n) const
{
    ((void)0);

    (__n <= max_size ()) ? (void)0 : throw (length_error&)length_error ("/opt/aCC/include_std/string.cc" ":" "816" ": ")._C_format ((0 + 8), __PRETTY_FUNCTION__, __n, max_size ());




    if (size())
    {
      size_type __slen = size() -1;
      size_type xpos_start = __pos < __slen ? __pos : __slen;
      for (size_type xpos = xpos_start+1; xpos != 0 ; xpos--)
      {
        bool found = false;
        for (size_type __i = 0; __i < __n ; __i++)
        {
          if (traits_type::eq(_C_data[xpos-1], __s[__i]))
          {
            found = true;
            break;
          }
        }
        if (!found)
          return xpos-1;
      }
    }

    return npos;
}


template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
basic_string<_CharT, _Traits, _Allocator>::
substr (size_type __pos, size_type __n) const
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "850" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());




    size_type __slen = size() -__pos;
    size_type __rlen = __n < __slen ? __n : __slen;
    return basic_string (_C_data + __pos, __rlen);
}


template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::
compare (size_type pos1, size_type __n1,
         const basic_string& __str,
         size_type pos2, size_type __n2) const
{
    (pos2 <= __str.size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "867" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, pos2, __str.size ());
    if(__str.size() - pos2 < __n2)
      __n2 = __str.size() - pos2;





    return compare(pos1, __n1, __str.c_str()+pos2, __n2);
}


template <class _CharT, class _Traits, class _Allocator>
int basic_string<_CharT, _Traits, _Allocator>::
compare (size_type __pos, size_type __n1,
         const_pointer __s, size_type __n2) const
{
    (__pos <= size ()) ? (void)0 : throw (out_of_range&)out_of_range ("/opt/aCC/include_std/string.cc" ":" "892" ": ")._C_format ((0 + 9), __PRETTY_FUNCTION__, __pos, size ());



    if(size() - __pos < __n1)
      __n1 = size() - __pos;
    size_type __rlen = __n1 < __n2 ? __n1 : __n2;
    int result = traits_type::compare(_C_data+__pos,__s, __rlen);

    if (result == 0)
      result = (__n1 < __n2) ? -1 : (__n1 != __n2);

    return result;
}


}
namespace std {
  template<class _CharT> struct char_traits;



  template <class _TypeT> class allocator;

  template <class stateT> class fpos;


template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ios;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_streambuf;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_istream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ostream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> >
class basic_stringbuf;

template<class _CharT,
        class _Traits = char_traits<_CharT>,
        class _Allocator = allocator<_CharT> >
class basic_istringstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> >
class basic_ostringstream;

template<class _CharT,
        class _Traits = char_traits<_CharT> >
class basic_filebuf;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ifstream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_ofstream;

template<class _TypeT,
         class _CharT = char,
         class _Traits = char_traits<_CharT> >
class ostream_iterator;

template<class _TypeT,
         class _CharT = char,
         class _Traits = char_traits<_CharT>,
         class Distance = ptrdiff_t >
class istream_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class ostreambuf_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class istreambuf_iterator;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_iostream;

template<class _CharT,
         class _Traits = char_traits<_CharT> >
class basic_fstream;

template<class _CharT,
         class _Traits = char_traits<_CharT>,
         class _Allocator = allocator<_CharT> >
class basic_stringstream;




class ios_base;

  typedef basic_ios<char> ios;
  typedef basic_streambuf<char> streambuf;
  typedef basic_istream<char> istream;
  typedef basic_ostream<char> ostream;
  typedef basic_stringbuf<char> stringbuf;
  typedef basic_istringstream<char> istringstream;
  typedef basic_ostringstream<char> ostringstream;
  typedef basic_filebuf<char> filebuf;
  typedef basic_ifstream<char> ifstream;
  typedef basic_ofstream<char> ofstream;
  typedef basic_fstream<char> fstream;
  typedef basic_iostream<char> iostream;
  typedef basic_stringstream<char> stringstream;

  typedef basic_ios<wchar_t> wios;
  typedef basic_streambuf<wchar_t> wstreambuf;
  typedef basic_istream<wchar_t> wistream;
  typedef basic_ostream<wchar_t> wostream;
  typedef basic_stringbuf<wchar_t> wstringbuf;
  typedef basic_istringstream<wchar_t> wistringstream;
  typedef basic_ostringstream<wchar_t> wostringstream;
  typedef basic_filebuf<wchar_t> wfilebuf;
  typedef basic_ifstream<wchar_t> wifstream;
  typedef basic_ofstream<wchar_t> wofstream;
  typedef basic_fstream<wchar_t> wfstream;
  typedef basic_iostream<wchar_t> wiostream;
  typedef basic_stringstream<wchar_t> wstringstream;
  typedef fpos<char_traits<char>::state_type> streampos;
  typedef fpos<char_traits<wchar_t>::state_type> wstreampos;





}
extern const char* __bad_cast_exception;
extern const char* __bad_typeid_exception;

struct _BaseClassTableEntry;
namespace std {


class bad_cast : public exception {
public:
        bad_cast() throw() { }
        virtual ~bad_cast() throw() {}
        virtual const char* what() const throw() {
           return __bad_cast_exception;
        }
};

class bad_typeid : public exception {
public:
        bad_typeid() { }
        virtual ~bad_typeid() throw() {}
        virtual const char* what() const throw() {
           return __bad_typeid_exception;
        }
};



class type_info {
public:
        virtual ~type_info();
        bool operator==(const type_info&) const;
        bool operator!=(const type_info&) const;
        bool before(const type_info&) const;
        const char * name() const { return theName; }
private:
        type_info(const type_info&);
        type_info& operator=(const type_info&);



        const _BaseClassTableEntry* findBase(const type_info*) const;

        const char *theName;
        void *baseClassTable;
        unsigned int hashValue;




};
}
namespace std {



using ::clock_t;
using ::size_t;
using ::time_t;
using ::tm;



using ::asctime;
using ::clock;
using ::ctime;
using ::difftime;
using ::gmtime;
using ::localtime;
using ::mktime;
using ::strftime;
using ::time;

}
  extern "C" {

  struct lconv {
        char *decimal_point;
        char *thousands_sep;
        char *grouping;
        char *int_curr_symbol;
        char *currency_symbol;
        char *mon_decimal_point;
        char *mon_thousands_sep;
        char *mon_grouping;
        char *positive_sign;
        char *negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        };




#pragma extern setlocale, localeconv 







     extern char *setlocale(int, const char *);





     extern struct lconv *localeconv(void);

#pragma extern __locale_names


   extern char __locale_names[6 +1][255 +1];
  struct locale_data {
    char LC_ALL_D[59];
    char LC_COLLATE_D[59];
    char LC_CTYPE_D[59];
    char LC_MONETARY_D[59];
    char LC_NUMERIC_D[59];
    char LC_TIME_D[59];
    char LC_MESSAGES_D[59];
    };


#pragma extern getlocale 






     extern struct locale_data *getlocale(int);
#pragma extern __err_string

extern char *__err_string;
}






namespace std
{

using ::lconv;


using ::localeconv;
using ::setlocale;

}
namespace std {

class locale;



template <class _Facet>
inline const _Facet& use_facet (const locale&);

template <class _Facet>
inline bool has_facet (const locale&) throw();
template <class _CharT> inline bool isspace (_CharT, const locale&);
template <class _CharT> inline bool isprint (_CharT, const locale&);
template <class _CharT> inline bool iscntrl (_CharT, const locale&);
template <class _CharT> inline bool isupper (_CharT, const locale&);
template <class _CharT> inline bool islower (_CharT, const locale&);
template <class _CharT> inline bool isalpha (_CharT, const locale&);
template <class _CharT> inline bool isdigit (_CharT, const locale&);
template <class _CharT> inline bool ispunct (_CharT, const locale&);
template <class _CharT> inline bool isxdigit (_CharT, const locale&);
template <class _CharT> inline bool isalnum (_CharT, const locale&);
template <class _CharT> inline bool isgraph (_CharT, const locale&);

template <class _CharT> inline _CharT toupper (_CharT, const locale&);
template <class _CharT> inline _CharT tolower (_CharT, const locale&);

class ctype_base;

template <class _CharT>
class ctype;

template<>
class ctype<char>;

template <class _CharT>
class ctype_byname;

template<>
class ctype_byname<char>;

class codecvt_base;

template <class internT, class externT, class stateT>
class codecvt;

template<>
class codecvt<char, char, mbstate_t>;



template<>
class ctype<wchar_t>;

template<>
class ctype_byname<wchar_t>;

template<>
class codecvt<wchar_t, char, mbstate_t>;



template <class internT, class externT, class stateT>
class codecvt_byname;

template <class _CharT,
    class InputIterator = istreambuf_iterator<_CharT> >
class num_get;

template <class _CharT,
    class OutputIterator = ostreambuf_iterator<_CharT> >
class num_put;

template <class _CharT>
class numpunct;

template <class _CharT>
class numpunct_byname;

template <class _CharT>
class collate;

template <class _CharT>
class collate_byname;

class time_base;

template <class _CharT,
    class InputIterator = istreambuf_iterator<_CharT> >
class time_get;

template <class _CharT,
    class InputIterator = istreambuf_iterator<_CharT> >
class time_get_byname;

template <class _CharT,
    class OutputIterator = ostreambuf_iterator<_CharT> >
class time_put;

template <class _CharT,
    class OutputIterator = ostreambuf_iterator<_CharT> >
class time_put_byname;

class money_base;

template <class _CharT,
    class InputIterator = istreambuf_iterator<_CharT> >
class money_get;

template <class _CharT,
    class OutputIterator = ostreambuf_iterator<_CharT> >
class money_put;

template <class _CharT, bool Intl = false>
class moneypunct;

template <class _CharT, bool Intl = false>
class moneypunct_byname;

class __rw_messages_base;

template <class _CharT>
class messages;

template <class _CharT>
class messages_byname;


}
namespace std {

class locale;

}


namespace __rw {

using namespace std;
template <class _CharT> class __rw_timepunct;




class __rw_locale_imp;

class __rw_facet_base;

struct __rw_digit_map_base;
template <class _CharT> class __rw_digit_map;
template <class _CharT> class __rw_keyword_def;
template <class _CharT> class __rw_keyword_map;
template <class _CharT> class __rw_keyword_cracker;

class __rw_digit_reader_base;
template <class _CharT> class __rw_digit_reader_base_1;
template <class _CharT,class InputIterator>
  class __rw_digit_reader;

class __rw_digit_writer_base;
template <class _CharT>
  class __rw_digit_writer_base_1;
template <class _CharT,class OutputIterator>
  class __rw_digit_writer;







class __rw_facet_base: public __rw_synchronized
{
    friend class __rw_locale_imp;
    friend class std::locale;

public:

    enum {
        _C_facet_cat = 0,
        _C_ok_implicit = 0,
        _C_initialized = 1
    };

    void _C_set_ref (size_t __ref) {
        _C_ref_count = __ref;
    }

private:

    int _C_category;
    int _C_flags;
    size_t _C_ref_count;

protected:

    __rw_facet_base (size_t __ref, int __cat = 0)
        : _C_category (__cat), _C_flags (0), _C_ref_count (__ref) { }

    __rw_facet_base (const __rw_facet_base &__rhs)
        : __rw_synchronized (),
          _C_category (__rhs._C_category),
          _C_flags (__rhs._C_flags),
          _C_ref_count (__rhs._C_ref_count) { }

    __rw_facet_base& operator= (const __rw_facet_base &__rhs) {
        if (this != &__rhs) {
            _C_category = __rhs._C_category;
            _C_flags = __rhs._C_flags;
            _C_ref_count = __rhs._C_ref_count;
        }
        return *this;
    }

    virtual ~__rw_facet_base () { }






    virtual void _C_initfacet (const locale&) { }
};


}
namespace __rw {

using std::size_t;
using std::ptrdiff_t;







template <class _TypeT>
class __rw_locale_vector
{
public:
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _TypeT value_type;
    typedef _TypeT& reference;
    typedef _TypeT* pointer;
    typedef _TypeT* iterator;

private:
    iterator _C_first;
    size_type _C_size;

public:
    __rw_locale_vector() : _C_first(0), _C_size(0)
        { }

    __rw_locale_vector(size_type __n) : _C_first(0), _C_size(__n) {
        if (__n)
            _C_first = new _TypeT[__n];
    }

    __rw_locale_vector(size_type __n, const _TypeT& __v) : _C_first(0), _C_size(__n) {
        if (__n)
            _C_first = new _TypeT[__n];
        while (__n)
            _C_first[--__n] = __v;
    }

    __rw_locale_vector(const __rw_locale_vector<_TypeT>& lv) : _C_first(0), _C_size(0) {
        size_type __n = _C_size = lv.size();
        if (__n)
            _C_first = new _TypeT[__n];
        while (__n--)
            _C_first[__n] = lv[__n];
    }

    ~__rw_locale_vector() { if (_C_first) delete [] _C_first;}
    const __rw_locale_vector& operator= (const __rw_locale_vector& lv) {
        size_type __n = _C_size = lv.size();
        if (_C_first)
        delete [] _C_first;
        if (__n)
        _C_first = new _TypeT[__n];
        while (__n--)
        _C_first[__n] = lv[__n];
        return *this;
    }

    iterator begin() const {
        return iterator(_C_first);
    }

    iterator end() const {
        return iterator(_C_first+_C_size);
    }

    size_type size() const {
        return _C_size;
    }

    _TypeT& operator[] (size_t __i) {
        return _C_first[__i];
    }

    const _TypeT& operator[] (size_t __i) const {
        return _C_first[__i];
    }


    iterator resize(size_t __s) {
        return resize(__s,_TypeT());
    }

    iterator resize(size_t __s, _TypeT __v) {
        _TypeT *__new_buf = new _TypeT[__s];
        iterator __j,__k;
        size_type __d = _C_size < __s ? _C_size : __s;

        for (__j = _C_first, __k = __new_buf; __j != _C_first+__d; ++__j,++__k)
            *__k = *__j;

        while (__d < __s)
            __new_buf[__d++] = __v;

        if (_C_first)
            delete [] _C_first;
        _C_first = __new_buf;
        _C_size = __s;
        return _C_first;
    }
};


}





namespace __rw {






class __rw_locale_imp: public __rw::__rw_synchronized
{
public:


    friend class std::locale;


    typedef int locale_cat;

    static const locale_cat _C_none = 0x0000;
    static const locale_cat _C_collate = 0x0010;
    static const locale_cat _C_ctype = 0x0020;
    static const locale_cat _C_monetary = 0x0040;
    static const locale_cat _C_numeric = 0x0080;
    static const locale_cat _C_time = 0x0100;
    static const locale_cat _C_messages = 0x0200;
    static const locale_cat _C_all = _C_ctype | _C_collate | _C_monetary | _C_time | _C_numeric | _C_messages;



    static const locale_cat _C_libc_constants = 0x000f;
    static const locale_cat _C_first_category = _C_collate;
    static const locale_cat _C_n_categories = 6;


    __rw_locale_vector<std::string> _C_facet_names;
    __rw_locale_vector<__rw_facet_base*> _C_facets;

    locale_cat _C_native;
    locale_cat _C_named;


    const char *_C_name;

    unsigned long _C_ref_count;

    __rw_locale_imp (const char* = 0, size_t = 36, size_t = 0);

    __rw_locale_imp (const __rw_locale_imp&, const char*, size_t);

    ~__rw_locale_imp () {

        delete [] const_cast< char* >(_C_name);
    }

    __rw_facet_base* _C_get_facet (size_t __inx) const {
        return __inx < _C_facets.size () ? _C_facets [__inx] : 0;
    }

private:
    inline const char *_C_category_name (locale_cat) const;


    static locale_cat _C_map_category (locale_cat);


    static bool _C_parse_name (__rw_locale_vector<std::string>&,const char*);


    static std::string _C_clean_name(std::string s) {



        return s;

    }
};






inline __rw_locale_imp::__rw_locale_imp (const char *__name,
                                         size_t __size, size_t __ref)
    : _C_facets (__size, 0),
      _C_native (0),
      _C_named (0),
      _C_name (0),
      _C_ref_count (__ref) {


    if (__name) {
        __size = strlen (__name) + 1;

        _C_name = (char*)memcpy (new char [__size], __name, __size);
    }

    _C_facet_names.resize (_C_n_categories, string ());
}


inline __rw_locale_imp::__rw_locale_imp (const __rw_locale_imp &__rhs,
                                         const char *__name, size_t __ref)
    : _C_facet_names (__rhs._C_facet_names),
      _C_facets (__rhs._C_facets),
      _C_native (__rhs._C_native),
      _C_named (__rhs._C_named),
      _C_name (0),
      _C_ref_count (__ref) {


    if (__name) {
        size_t __size = strlen (__name) + 1;
        _C_name = (char*)memcpy (new char [__size], __name, __size);
    }

    for (size_t __i = _C_facets.size (); __i--; ) {
        if (_C_facets [__i])
            ++(_C_facets [__i]->_C_ref_count);

    }
}


inline const char*
__rw_locale_imp::_C_category_name (locale_cat cat) const {

    locale_cat __mask = _C_first_category;

    for (size_t __i = 0;
         __i < size_t (_C_n_categories); ++__i, __mask <<= 1)

        if (cat & __mask)
            return _C_facet_names[__i].c_str();

    return "";
}
struct __rw_digit_map_base {
  enum { _C_zero, _C_minus, _C_plus, _C_X, _C_x, _C_E, _C_e };
  static const char _C_punct_chars[7];
  static const char _C_digit_chars[22];
  static const char _C_char_values[22];
};
template<>
class __rw_digit_map<char>:
    public __rw_digit_map_base
{
 public:
  typedef char char_type;

  bool _C_is_inited (void) const {
      return true;
  }
  const char *_C_get_punct (void) const {
      return _C_punct_chars;
  }
  inline int _C_eval (char c) const;

  static inline const __rw_digit_map<char>&
              _C_get_digit_map (const std::ctype<char>&);
};






inline int __rw_digit_map<char>::_C_eval (char c) const {
  int num=c;
  if ((num-='0')>9) {
    if (((num-=('A'-'0'))>5 && (num-=('a'-'A'))>5) || (num+=10)<10)
      num=-1;
  }
  return num;
}

template <class _CharT>
class __rw_digit_map:
    public __rw_digit_map_base
{
  bool _C_inited;
  _CharT _C_punct_array[7];
  _CharT _C_digit_array[22];
  char _C_value_array[22];
 public:
  typedef _CharT char_type;

  __rw_digit_map (void): _C_inited(false)
        { }
  bool _C_is_inited (void) const {
      return _C_inited;
  }
  void _C_init (const std::ctype<_CharT>& ct);

  const _CharT *_C_get_punct (void) const {
      return _C_punct_array;
  }
  int _C_eval (_CharT) const;




  static inline
  const __rw_digit_map<_CharT>&
                _C_get_digit_map (const std::ctype<_CharT>& ct) {

      if (!ct._C_digit_map._C_inited)
          (const_cast< __rw_digit_map<char_type>& >(ct._C_digit_map))
              ._C_init(ct);
      return ct._C_digit_map;
  }
};


template <class _CharT>
inline void
__rw_digit_map<_CharT>::_C_init (const std::ctype<_CharT> &__ctype) {

    __ctype.widen (_C_punct_chars, _C_punct_chars + sizeof _C_punct_chars,
                   _C_punct_array);

    __ctype.widen (_C_digit_chars, _C_digit_chars + sizeof _C_digit_chars,
                   _C_digit_array);

    std::memcpy (_C_value_array, _C_char_values, sizeof _C_value_array);
    _C_inited = true;
}


template <class _CharT>
inline int __rw_digit_map<_CharT>::_C_eval (_CharT __c) const {

    const _CharT *__end = _C_digit_array + sizeof _C_value_array;

    for (const _CharT *__p = _C_digit_array; __p != __end; ++__p)
        if (*__p == __c)
            return _C_value_array [__p - _C_digit_array];

    return -1;
}
template <class _CharT>
class __rw_keyword_def {
 public:
  const _CharT *_C_name;
  int _C_indx;
};
template <class _CharT>
class __rw_keyword_map {
 public:
  int _C_numdefs;
  const __rw_keyword_def<_CharT> *_C_defs;
};







template <class _CharT>
class __rw_punct_data
{
    friend class __rw_digit_reader_base_1<_CharT>;
    friend class __rw_digit_writer_base_1<_CharT>;

public:

    typedef std::basic_string<_CharT,
                               std::char_traits<_CharT>,
                               std::allocator<_CharT> > string_type;
protected:

    _CharT _C_dp, _C_ts;
    std::string _C_gr;
};
template <class _Facet>
inline _Facet*
__rw_create_named_facet (_Facet*, const char*, size_t);

template <class _Facet>
inline _Facet*
__rw_create_native_facet (_Facet*);

template <class _Facet>
inline _Facet*
__rw_create_classic_facet (_Facet*)
{
    return new _Facet ();
}
template <class _Facet>
class __rw_facet_maker
{
public:

    static __rw_facet_base*
    _C_maker_func (int __t, const char* __name, size_t __ref) {
        switch (__t) {
        case 0: return __rw_create_classic_facet ((_Facet*)0);
        case 1: return __rw_create_native_facet ((_Facet*)0);
        default: return __rw_create_named_facet ((_Facet*)0,
                                                    __name, __ref);
        }
    }
};





typedef __rw_facet_base* __rw_facet_maker_func (int, const char*, size_t);


}





namespace std {


class locale
{
public:
    class facet;
    class id;

    friend class facet;
    friend class id;

    typedef int category;

    static const category none = __rw::__rw_locale_imp::_C_none;
    static const category collate = __rw::__rw_locale_imp::_C_collate;
    static const category ctype = __rw::__rw_locale_imp::_C_ctype;
    static const category monetary = __rw::__rw_locale_imp::_C_monetary;
    static const category numeric = __rw::__rw_locale_imp::_C_numeric;
    static const category time = __rw::__rw_locale_imp::_C_time;
    static const category messages = __rw::__rw_locale_imp::_C_messages;
    static const category all = __rw::__rw_locale_imp::_C_all;





    inline locale () throw();






    inline locale (const locale& __rhs) throw()
        : _C_imp (__rhs._C_imp) {
        ++(_C_imp->_C_ref_count);
    }
    explicit locale (const char*);






    locale (const locale&, const char*, category);






    template <class _Facet>
    locale (const locale&, _Facet*);
    locale (const locale&, const locale&, category);

    ~locale () {


        if (_C_imp && 0 == --(_C_imp->_C_ref_count))

            delete _C_imp;
    }

    const locale& operator = (const locale&) throw();







    template <class _Facet>
    locale combine (const locale &__rhs) const {


        return locale (*this, (_Facet*)&use_facet < _Facet >(__rhs));
    }







    string name () const;





    bool operator== (const locale &__rhs) const {
        return this == &__rhs || _C_imp == __rhs._C_imp
               || name() != "*" && name () == __rhs.name();
    }

    bool operator != (const locale& __rhs) const {
        return !(*this == __rhs);
    }
    template <class _CharT, class _Traits, class _Allocator>
    bool
    operator() (const basic_string<_CharT, _Traits, _Allocator>& __x,
                const basic_string<_CharT, _Traits, _Allocator>& __y) const;
    static locale global (const locale&);


    static const locale &classic ();







    class facet: public __rw::__rw_facet_base {
        friend class __rw::__rw_locale_imp;
        friend class locale;

    protected:

        explicit facet (size_t __ref = 0, int __cat = 0)
            : __rw::__rw_facet_base (__ref, __cat) { }





    private:

        facet (const facet&);
        void operator= (const facet&);
    };
    class id {

        friend class locale;

        mutable size_t _C_id;

        void _C_init () const {
            static size_t _C_id_gen = 0;

            if (!_C_id)
                _C_id = ++(_C_id_gen);
        }

        operator size_t () const {
            return _C_id;
        }

    public:
        id (): _C_id (0) { }

    private:
        id (const id&);
        void operator= (const id&);
    };



    typedef __rw::__rw_facet_maker_func __facet_maker_func;


    const facet& _C_use_facet (const id &__id, bool __implicit, category __cat,
                               __facet_maker_func __maker) const;


    const facet& _C_unsafe_use_facet (const id &__id, bool __implicit,
                                      category __cat,
                                      __facet_maker_func __maker) const;





    facet* _C_make_facet (const id &__id, bool __implicit,
                             category __cat, __facet_maker_func) const;

    facet* _C_get_facet (const id &__id) const {
        return static_cast< facet* >(_C_imp->_C_get_facet (__id));
    }


    void _C_install_facet (__rw::__rw_facet_base*, const id&) const;

private:

    friend class __rw::__rw_locale_imp;


    explicit locale (__rw::__rw_locale_imp*);


    static void _C_init ();


    inline void _C_remove_facets (category);

    static __rw::__rw_locale_imp *_C_classic;
    static __rw::__rw_locale_imp *_C_native;
    static __rw::__rw_locale_imp *_C_global;

    __rw::__rw_locale_imp *_C_imp;
};
inline locale::locale (__rw::__rw_locale_imp *__rhs)
    : _C_imp (__rhs)
{
    ((void)0);

    if (!_C_global)
        _C_init ();


    ++_C_imp->_C_ref_count;
}


inline void locale::_C_remove_facets (category __cat)
{
    if (__cat & __rw::__rw_locale_imp::_C_libc_constants)


        __cat = __rw::__rw_locale_imp::_C_map_category (__cat);


    for (size_t __i = 0, end = _C_imp->_C_facets.size (); __i != end; ++__i) {
        __rw::__rw_facet_base *__facet = _C_imp->_C_facets [__i];
        if (__facet && (__cat & __facet->_C_category)) {

            if (0 == --(__facet->_C_ref_count))

                delete __facet;

            _C_imp->_C_facets [__i] = 0;
        }
    }
}




inline locale::locale () throw()
{
    if (!_C_global)
        _C_init ();

    _C_imp = _C_global;

    ((void)0);

    ++(_C_imp->_C_ref_count);
}





template <class _Facet>
inline locale::locale (const locale& __rhs, _Facet* __facet)
{
    ((void)0);

    ((void)0);




    _C_imp = new __rw::__rw_locale_imp (*__rhs._C_imp, 0, 1);

    if (__facet) {
        _C_install_facet (__facet, _Facet::id);
    }
}
template <class _CharT, class _Traits, class _Allocator>
inline bool
locale::operator() (const basic_string<_CharT,_Traits,_Allocator>& __x,
                    const basic_string<_CharT,_Traits,_Allocator>& __y) const
{
    return use_facet < std::collate<_CharT> >(*this)
        .compare (__x.data (), __x.data () + __x.length (),
                  __y.data (), __y.data () + __y.length ()) < 0;
}
inline const locale&
locale::operator= (const locale& __rhs) throw()
{
    ((void)0);

    if (_C_imp != __rhs._C_imp) {

        ++(__rhs._C_imp->_C_ref_count);


        if (0 == --(_C_imp->_C_ref_count))

            delete _C_imp;

        _C_imp = __rhs._C_imp;
    }
    return *this;
}


inline const locale& locale::classic()
{
    if (!_C_global)
        _C_init ();

    static locale __loc (_C_classic);

    return __loc;
}


inline const locale::facet&
locale::_C_use_facet (const id &__id, bool __implicit, category __cat,
                             __facet_maker_func __maker) const
{
    ((void)0);


    const facet *__facet = _C_get_facet (__id);






    if (!__facet) {
        ((void)0);

        __facet = _C_make_facet (__id, __implicit, __cat, __maker);
    }

    ((void)0);

    return *__facet;
}



inline const locale::facet&
locale::_C_unsafe_use_facet (const id &__id, bool __implicit, category __cat,
                             __facet_maker_func __maker) const
{
    ((void)0);

    const facet *__facet = _C_get_facet (__id);

    if (!__facet)
        __facet = _C_make_facet (__id, __implicit, __cat, __maker);

    ((void)0);

    return *__facet;
}

}


namespace __rw {
template <class _Facet>
inline _Facet*
__rw_create_named_facet (_Facet*, const char *__name, size_t __ref)
{
    ((void)&__name);






    _Facet *__facet = new _Facet ();

    __facet->_C_set_ref (__ref);

    return __facet;
}





class __rw_use_c_lib_locale
{
    int _C_saved_cat;
    char *_C_previous_locale_name;
public:
    __rw_use_c_lib_locale (const char* = 0, int = 0);

    ~__rw_use_c_lib_locale ();

    operator bool () const {
        return _C_previous_locale_name != 0L;
    }
};
inline __rw_use_c_lib_locale::~__rw_use_c_lib_locale ()
{
    if (_C_previous_locale_name) {



        std::setlocale(_C_saved_cat, _C_previous_locale_name);




        delete[] _C_previous_locale_name;
    }
}

}
namespace std {

class ctype_base {
 public:
  enum mask {
    space=1<<0, print=1<<1, cntrl=1<<2, upper=1<<3, lower=1<<4,
    alpha=1<<5, digit=1<<6, punct=1<<7, xdigit=1<<8,
    alnum=(1<<5)|(1<<6), graph=1<<9
  };
};

}

namespace __rw {
template <class _CharT>
class __rw_ctype_helper {

  friend class __rw_digit_map<_CharT>;



  __rw_digit_map<_CharT> _C_digit_map;
};

}

namespace std {





template<>
class ctype_byname<char>;






template<>
class ctype<char>: public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<char>
{
  friend class locale;
  friend class ctype_byname<char>;


  friend class ctype<wchar_t>;


 public:
  typedef char char_type;


  static const size_t table_size = 256;




  explicit ctype (const mask* __tab=0,bool __del=false,size_t __refs=0);


  bool is (mask __m,char __c) const {
      return (_C_table[(unsigned char)__c] & __m) != 0;
  }






  inline const char* is (const char* __lo,const char* __hi,mask* vec) const;
  inline const char* scan_is (mask __m,const char* __low,const char* __high) const;
  inline const char* scan_not (mask __m,const char* __low,const char* __high) const;

  char toupper (char __c) const {
      return do_toupper(__c);
  }
  char tolower (char __c) const {
      return do_tolower(__c);
  }
  char widen (char __c) const {
      return do_widen(__c);
  }
  char narrow (char __c, char __dfault) const {
      return do_narrow(__c,__dfault);
  }

  const char* toupper (char* __low,const char* __high) const {
      return do_toupper(__low,__high);
  }
  const char* tolower (char* __low,const char* __high) const {
      return do_tolower(__low,__high);
  }
  const char* widen (const char* __lo, const char* __hi, char* __to) const {
      return do_widen(__lo,__hi,__to);
  }
  const char* narrow (const char* __lo, const char* __hi, char __dfault,
                         char* __to) const {
      return do_narrow(__lo,__hi,__dfault,__to);
  }

  static locale::id id;


  typedef string string_type;


  string_type widen (const string &_s) const {
      return _s;
  }
  string narrow (const string_type &_s, char) const {
      return _s;
  }



  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

 protected:

  const mask* table() const throw() {
      return _C_table;
  }
  static const mask* classic_table() throw() {
      return _C_classic_table;
  }

  virtual ~ctype () {
      if (_C_delete_it)
          delete[] const_cast< mask* >(_C_table);
      delete[] _C_to_upper_tab;
      delete[] _C_to_lower_tab;
  }

  virtual inline const char* do_toupper (char* __low, const char* __high) const;
  virtual inline const char* do_tolower (char* __low, const char* __high) const;

  virtual char do_toupper (char __c) const {
      return is(lower,__c)? _C_to_upper_tab[(unsigned char)__c-_C_lower_min] : __c;
  }
  virtual char do_tolower (char __c) const {
      return is(upper,__c)? _C_to_lower_tab[(unsigned char)__c-_C_upper_min] : __c;
  }
  virtual char do_widen (char __c) const {
      return __c;
  }
  virtual const char* do_widen (const char* __low,
                                   const char* __high, char* __to) const {
      memcpy(__to,__low,__high-__low);
      return __high;
  }
  virtual char do_narrow (char __c, char ) const {
      return __c;
  }
  virtual const char* do_narrow (const char* __low, const char* __high,
                                    char , char* __to) const {
      memcpy(__to,__low,__high-__low); return __high;
  }

  virtual void _C_initfacet (const locale&);
 private:
  static const mask _C_classic_table[table_size];
  const mask* _C_table;
  bool _C_delete_it;
  int _C_lower_min,
              _C_lower_max;
  int _C_upper_min,
              _C_upper_max;
  char *_C_to_upper_tab;
  char *_C_to_lower_tab;
};


inline const char*
ctype<char>::is (const char* __lo, const char* __hi, mask* __vec) const {
    while (__lo != __hi)
        *__vec++ = _C_table[(unsigned char)*__lo++];
    return __hi;
}

inline const char*
ctype<char>::scan_is (ctype_base::mask __m,
                      const char* __lo, const char* __hi) const {
    while (__lo != __hi && !(_C_table[(unsigned char) *__lo] & __m))
        ++__lo;
    return __lo;
}

inline const char*
ctype<char>::scan_not (ctype_base::mask __m,
                       const char* __lo, const char* __hi) const {
    while (__lo != __hi && (_C_table[(unsigned char) *__lo] & __m))
        ++__lo;
    return __lo;
}


inline const char*
ctype<char>::do_toupper (char* __low, const char* __high) const {
    for ( ; __low<__high; ++__low)
        if (is(lower,*__low))
            *__low=_C_to_upper_tab[(unsigned char) *__low-_C_lower_min];
    return __low;
}


inline const char*
ctype<char>::do_tolower(char* __low, const char* __high) const {
    for (; __low < __high; ++__low)
        if (is(upper,*__low))
            *__low=_C_to_lower_tab[(unsigned char) *__low-_C_upper_min];
    return __low;
}
template<>
class ctype<wchar_t>: public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<wchar_t>
{

 private:
  static bool _C_fits (wchar_t __c) {
      return ((~(wchar_t)0377) & __c) == 0;
  }

 public:
  typedef wchar_t char_type;

  explicit ctype (size_t refs=0) : locale::facet(refs,locale::ctype)
        { }

  bool is (mask __m, wchar_t __c) const {
      return do_is( __m, __c);
  }
  const wchar_t* is (const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const {
      return do_is(__lo,__hi,__vec);
  }
  const wchar_t* scan_is (mask __m, const wchar_t* __lo, const wchar_t* __hi) const {
      return do_scan_is(__m,__lo,__hi);
  }
  const wchar_t* scan_not (mask __m, const wchar_t* __lo, const wchar_t* __hi) const {
      return do_scan_not(__m,__lo,__hi);
  }
  wchar_t toupper(wchar_t __c) const {
      return do_toupper(__c);
  }
  const wchar_t* toupper (wchar_t* __lo, const wchar_t* __hi) const {
      return do_toupper(__lo,__hi);
  }
  wchar_t tolower (wchar_t __c) const {
      return do_tolower(__c);
  }
  const wchar_t* tolower (wchar_t* __lo, const wchar_t* __hi) const {
      return do_tolower(__lo,__hi);
  }
  wchar_t widen (char __c) const {
      return do_widen(__c);
  }
  const char* widen (const char* __lo, const char* __hi, wchar_t* __to) const {
      return do_widen(__lo,__hi,__to);
  }
  char narrow (wchar_t __c, char __dfault) const {
      return do_narrow(__c,__dfault);
  }
  const wchar_t* narrow (const wchar_t* __lo, const wchar_t* __hi, char __dfault,
                         char* __to) const {
      return do_narrow(__lo,__hi,__dfault,__to);
  }

  static locale::id id;



  typedef wstring string_type;
  string_type widen (const string&) const;
  string narrow (const string_type&, char) const;



  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

  protected:

  virtual bool do_is (mask __m, wchar_t __c) const {
        return (mask_of(__c) & __m) != 0;
  }

  virtual inline
  const wchar_t* do_is (const wchar_t*, const wchar_t*, mask*) const;
  virtual inline
  const wchar_t* do_scan_is (mask,const wchar_t*,const wchar_t*) const;
  virtual inline
  const wchar_t* do_scan_not (mask,const wchar_t*,const wchar_t*) const;


  virtual inline
  const wchar_t* do_toupper (wchar_t*, const wchar_t*) const;
  virtual wchar_t do_toupper (wchar_t __c) const {
      return (mask_of(__c) & lower) ? (__c &~ 0x20) : __c;
  }

  virtual inline
  const wchar_t* do_tolower (wchar_t*, const wchar_t*) const;
  virtual wchar_t do_tolower (wchar_t __c) const {
      return (mask_of(__c) & upper) ? (__c | 0x20) : __c;
  }


  virtual inline
  const char* do_widen (const char*, const char*, wchar_t*) const;
  virtual wchar_t do_widen (char __c) const {
      return (wchar_t)(unsigned char)__c;
  }


  virtual inline
  const wchar_t* do_narrow (const wchar_t*, const wchar_t*,
                             char __dfault, char* __dest) const;
  virtual char do_narrow (wchar_t __c, char ____dfault) const {
      return (_C_fits(__c) ? (char)(unsigned char)__c : ____dfault);
  }

  private:

  static mask mask_of (wchar_t __c) {
        return _C_fits(__c) ? ctype<char>::classic_table()[(unsigned char)__c]
                          : (ctype_base::mask) 0;

  }




};




inline const wchar_t*
ctype<wchar_t>::do_is(const wchar_t* __lo, const wchar_t* __hi, mask* __vec) const {
    while (__lo != __hi)
        *__vec++ = mask_of(*__lo++);
    return __hi;
}


inline const wchar_t*
ctype<wchar_t>::do_scan_is(ctype_base::mask __m,
                           const wchar_t* __low, const wchar_t* __high) const {
    while (__low != __high && !(mask_of(*__low) & __m))
        ++__low;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_scan_not( mask __m, const wchar_t* __low, const wchar_t* __high) const {
    while (__low != __high && (mask_of(*__low) & __m))
        ++__low;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_toupper(wchar_t* __low, const wchar_t* __high) const {
    for (; __low < __high; ++__low)
        if (mask_of(*__low) & lower)
            *__low &=~ 0x20;
    return __low;
}


inline const wchar_t*
ctype<wchar_t>::do_tolower(wchar_t* __low, const wchar_t* __high) const {
    for (; __low < __high; ++__low)
        if ((mask_of(*__low) & upper) != 0) *__low |= 0x20;
    return __low;
}



inline const char*
ctype<wchar_t>::do_widen(const char* __lo, const char* __hi, wchar_t* __dest) const {
    while (__lo != __hi) {
        *__dest = (wchar_t)(unsigned char)*__lo;
        ++__lo; ++__dest;
    }
    return __hi;
}


inline const wchar_t*
ctype<wchar_t>::do_narrow(const wchar_t* __lo, const wchar_t* __hi,
                          char __dfault, char* __dest) const {
    for ( ; __lo != __hi; __lo++)
        *__dest++ = _C_fits(*__lo) ? (char)(unsigned char)*__lo : __dfault;
    return __hi;
}



inline ctype<wchar_t>::string_type
ctype<wchar_t>::widen (const string &_s) const {
    string_type result(_s.size(),0);
    do_widen(_s.begin(),_s.end(),result.begin());
    return result;
}


inline string
ctype<wchar_t>::narrow (const string_type &_s,char __dfault) const {
    string result(_s.size(),0);
    do_narrow(_s.begin(),_s.end(),__dfault,result.begin());
    return result;
}







template <class _CharT>
class ctype : public locale::facet, public ctype_base,
    public __rw::__rw_ctype_helper<_CharT>
{
 public:
  typedef _CharT char_type;

    explicit ctype (size_t __ref = 0)
      : locale::facet(__ref, locale::ctype) { }


  bool is(mask __m, _CharT __c) const
                 { return do_is( __m, __c); }
  const _CharT* is(const _CharT* __low, const _CharT* __high, mask* __vec) const
                 { return do_is(__low, __high, __vec); }
  const _CharT* scan_is(mask __m, const _CharT* __low, const _CharT* __high) const
                 { return do_scan_is( __m, __low, __high); }
  const _CharT* scan_not(mask __m, const _CharT* __low, const _CharT* __high) const
                 { return do_scan_not( __m, __low, __high); }

  _CharT toupper(_CharT __c) const
                 { return do_toupper(__c); }
  const _CharT* toupper(_CharT* __low, const _CharT* __high) const
                 { return do_toupper(__low, __high); }
  _CharT tolower(_CharT __c) const
                 { return do_tolower(__c); }
  const _CharT* tolower(_CharT* __low, const _CharT* __high) const
                 { return do_tolower(__low, __high); }

  _CharT widen(char __c) const { return do_widen(__c); }
  const char* widen(const char* __lo, const char* __hi, _CharT* __to) const
           { return do_widen(__lo, __hi, __to); }
  char narrow(_CharT __c, char __dfault) const { return do_narrow(__c, __dfault); }
  const _CharT* narrow(const _CharT* __lo, const _CharT* __hi,
                      char __dfault, char* __to) const
           { return do_narrow(__lo, __hi, __dfault, __to); }

  static locale::id id;



  typedef basic_string<_CharT,char_traits<_CharT>,allocator<_CharT> > string_type;
  string_type widen (const string&) const;
  string narrow (const string_type&, char) const;



  enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

 protected:

  virtual bool do_is(mask, _CharT) const {
      return false;
  }
  virtual const _CharT* do_is (const _CharT*, const _CharT* __high,
                               mask*) const {
      return __high;
  }
  virtual const _CharT* do_scan_is(mask,
                                   const _CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual const _CharT* do_scan_not(mask,
                                    const _CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT do_toupper(_CharT __c) const {
      return __c;
  }
  virtual const _CharT* do_toupper(_CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT do_tolower(_CharT __c) const {
      return __c;
  }
  virtual const _CharT* do_tolower(_CharT*, const _CharT* __high) const {
      return __high;
  }
  virtual _CharT do_widen(char __c) const {
      return _CharT(__c);
  }
  virtual const char* do_widen(const char* __lo,
                                const char* __hi, _CharT* __dest) const {
      while (__lo < __hi)
          *__dest++ = _CharT(*__lo++);
      return __hi;
  }
  virtual char do_narrow (_CharT, char __dfault) const {
      return __dfault;
  }
  virtual const _CharT* do_narrow(const _CharT*, const _CharT* __hi,
                                 char, char*) const {
      return __hi;
  }

 private:




};
template<>
class ctype_byname<char> : public ctype<char>
{
public:
  explicit ctype_byname (const char*, size_t refs=0);

private:

  static const mask *_C_get_mask_table (const char*);
};







template<>
class ctype_byname<wchar_t> : public ctype<wchar_t>
{
public:
    explicit ctype_byname (const char*, size_t __ref = 0)
        : ctype<wchar_t> (__ref) { }
};







template <class _CharT>
class ctype_byname: public ctype<_CharT>
{
public:
    explicit ctype_byname (const char*, size_t __ref = 0)
        : ctype<_CharT>(__ref) { }
};


}

namespace __rw {

inline const __rw_digit_map<char>&
__rw_digit_map<char>::_C_get_digit_map (const std::ctype<char>& ct)
{
  return ct._C_digit_map;
}


template<>
inline std::ctype<char>*
__rw_create_named_facet (std::ctype<char>*,
                            const char *__name, size_t __ref)
{
    return new std::ctype_byname<char>(__name, __ref);
}


template<>
inline std::ctype<char>*
__rw_create_classic_facet (std::ctype<char>*)
{
    return new std::ctype<char>(0L,false,0);
}



}
namespace std {






template <class charT> locale::id ctype<charT>::id;


}
extern const float _FLT_NANS;
extern const float _FLT_DMIN;





extern const double _DBL_NANS;
extern const double _DBL_DMIN;
extern const long double _LDBL_NANS;
extern const long double _LDBL_DMIN;
namespace std {


class ios_base: public __rw::__rw_synchronized
{
public:




    class failure : public __rw_exception {
    public:
        explicit failure (const string& __what):
            __rw_exception (__what) { }


        explicit failure (const char *__what = 0):
            __rw_exception (__what) { }
    };





    class badbit_set : public failure { };

    class eofbit_set : public failure { };

    class failbit_set : public failure { };






    typedef int fmtflags;


    static const fmtflags boolalpha = 0x0001;


    static const fmtflags dec = 0x0002;


    static const fmtflags fixed = 0x0004;


    static const fmtflags hex = 0x0008;



    static const fmtflags internal = 0x0010;


    static const fmtflags left = 0x0020;


    static const fmtflags oct = 0x0040;


    static const fmtflags right = 0x0080;


    static const fmtflags scientific = 0x0100;



    static const fmtflags showbase = 0x0200;



    static const fmtflags showpoint = 0x0400;


    static const fmtflags showpos = 0x0800;


    static const fmtflags skipws = 0x1000;


    static const fmtflags unitbuf = 0x2000;



    static const fmtflags uppercase = 0x4000;





    static const fmtflags bin = 0x8000;

    static const fmtflags basefield = dec | oct | hex | bin;







    static const fmtflags adjustfield = left | right | internal;
    static const fmtflags floatfield = scientific | fixed;


    static const fmtflags _C_padbits = adjustfield | right | internal;



    int _C_base () const {
        fmtflags __flags = flags () & basefield;
        return oct == __flags ? 8
               : dec == __flags ? 10
               : hex == __flags ? 16



               : bin == __flags ? 2



               : 0;
    }


    typedef int iostate;

    static const iostate goodbit = 0x00;



    static const iostate badbit = 0x01;


    static const iostate eofbit = 0x02;




    static const iostate failbit = 0x04;


    typedef int openmode;


    static const openmode app = 0x01;


    static const openmode binary = 0x02;


    static const openmode in = 0x04;


    static const openmode out = 0x08;


    static const openmode trunc = 0x10;


    static const openmode ate = 0x20;




    static const openmode nocreate = 0x40;


    static const openmode noreplace = 0x80;
    enum seekdir {
        _C_beg = 0,
        _C_cur = 1,
        _C_end = 2
    };



    static const seekdir beg = _C_beg;
    static const seekdir cur = _C_cur;
    static const seekdir end = _C_end;
    typedef seekdir seek_dir;
    typedef openmode open_mode;
    typedef iostate io_state;
    typedef std::streamoff streamoff;
    typedef std::streampos streampos;





    class Init {
        static int _C_initcnt;
    public:
        Init ();

        ~Init ();
    };

    fmtflags flags () const {
        return _C_fmtfl;
    }

    fmtflags flags (fmtflags __f) {
        return __rw::__rw_atomic_exchange ((_C_fmtfl), (__f), false);
    }

    fmtflags setf (fmtflags __f) {
        return flags (flags () | __f);
    }

    fmtflags setf (fmtflags __f, fmtflags __mask) {
        return flags (flags () & ~__mask | __f & __mask);
    }

    void unsetf (fmtflags __f) {
        flags (flags () & ~__f);
    }

    streamsize precision () const {
          return _C_prec;
    }

    streamsize precision (streamsize __p) {
        return __rw::__rw_atomic_exchange ((_C_prec), (__p), false);
    }

    streamsize width () const {
        return _C_wide;
    }

    streamsize width (streamsize __w) {
        return __rw::__rw_atomic_exchange ((_C_wide), (__w), false);
    }

    locale imbue (const locale&);




    locale& getloc () {
        return _C_loc;
    }

    locale getloc () const {
        return _C_loc;
    }

    static int xalloc () {
        return __rw::__rw_atomic_exchange ((_C_index), (_C_index + 1), false);
    }

    long& iword (int);
    void*& pword (int);

    enum event { erase_event, imbue_event, copyfmt_event };

    typedef void (*event_callback)(event, ios_base&, int);
    void register_callback (event_callback, int);

    static bool _C_is_sync () {
        return _C_sync_with_stdio;
    }

    static bool sync_with_stdio (bool __sync = true) {
        return __rw::__rw_atomic_exchange ((_C_sync_with_stdio), (__sync), false);
    }

    virtual ~ios_base();

protected:


    void _C_fire_event (event, bool __reentrant);


    void _C_copyfmt (const ios_base&);



    iostate _C_unsafe_clear (iostate = goodbit, iostate = ~0);


    locale _C_unsafe_imbue (const locale&);

    ios_base ();

    fmtflags _C_fmtfl;
    streamsize _C_prec;
    streamsize _C_wide;
    iostate _C_state;
    iostate _C_except;

private:


    ios_base (const ios_base&);
    ios_base& operator= (const ios_base&);

    struct _C_event_cb {
        int _C_index;
        event_callback _C_fn;
    };

    locale _C_loc;

    long *_C_iarray;
    void* *_C_parray;

    size_t _C_isize;
    size_t _C_psize;

    _C_event_cb *_C_cbarray;
    size_t _C_cbsize;

    static int _C_index;
    static bool _C_sync_with_stdio;
};


inline ios_base::ios_base ()
    : _C_iarray (0),
      _C_parray (0),
      _C_isize (0),
      _C_psize (0),
      _C_cbarray (0),
      _C_cbsize (0)
{
}


inline ios_base::~ios_base()
{
    _C_fire_event (erase_event, false);

    delete [] _C_iarray;
    delete [] _C_parray;
    delete [] _C_cbarray;
}


inline locale ios_base::_C_unsafe_imbue (const locale& __loc)
{
    locale __tmp = _C_loc;
    _C_loc = __loc;

    _C_fire_event (imbue_event, true);

    return __tmp;
}


inline locale ios_base::imbue (const locale& __loc)
{
    ((void)0);

    return _C_unsafe_imbue (__loc);
}





inline ios_base& unitbuf (ios_base& __strm)
{
    __strm.setf (ios_base::unitbuf);
    return __strm;
}



inline ios_base& nounitbuf (ios_base& __strm)
{
    __strm.unsetf (ios_base::unitbuf);
    return __strm;
}



inline ios_base& boolalpha (ios_base& __strm)
{
    __strm.setf (ios_base::boolalpha);
    return __strm;
}



inline ios_base& noboolalpha (ios_base& __strm)
{
    __strm.unsetf (ios_base::boolalpha);
    return __strm;
}



inline ios_base& showbase (ios_base& __strm)
{
    __strm.setf (ios_base::showbase);
    return __strm;
}



inline ios_base& noshowbase (ios_base& __strm)
{
    __strm.unsetf (ios_base::showbase);
    return __strm;
}



inline ios_base& showpoint (ios_base& __strm)
{
    __strm.setf (ios_base::showpoint);
    return __strm;
}



inline ios_base& noshowpoint (ios_base& __strm)
{
    __strm.unsetf (ios_base::showpoint);
    return __strm;
}



inline ios_base& showpos (ios_base& __strm)
{
    __strm.setf (ios_base::showpos);
    return __strm;
}



inline ios_base& noshowpos (ios_base& __strm)
{
    __strm.unsetf (ios_base::showpos);
    return __strm;
}



inline ios_base& skipws (ios_base& __strm)
{
    __strm.setf (ios_base::skipws);
    return __strm;
}



inline ios_base& noskipws (ios_base& __strm)
{
    __strm.unsetf (ios_base::skipws);
    return __strm;
}



inline ios_base& uppercase (ios_base& __strm)
{
    __strm.setf (ios_base::uppercase);
    return __strm;
}



inline ios_base& nouppercase (ios_base& __strm)
{
    __strm.unsetf (ios_base::uppercase);
    return __strm;
}





inline ios_base& internal (ios_base& __strm)
{
    __strm.setf (ios_base::internal, ios_base::adjustfield);
    return __strm;
}



inline ios_base& left (ios_base& __strm)
{
    __strm.setf (ios_base::left, ios_base::adjustfield);
    return __strm;
}



inline ios_base& right (ios_base& __strm)
{
    __strm.setf (ios_base::right, ios_base::adjustfield);
    return __strm;
}





inline ios_base& dec (ios_base& __strm)
{
    __strm.setf (ios_base::dec, ios_base::basefield);
    return __strm;
}



inline ios_base& hex (ios_base& __strm)
{
    __strm.setf (ios_base::hex, ios_base::basefield);
    return __strm;
}



inline ios_base& oct (ios_base& __strm)
{
    __strm.setf (ios_base::oct, ios_base::basefield);
    return __strm;
}





inline ios_base& bin (ios_base& __strm)
{
    __strm.setf (ios_base::bin, ios_base::basefield);
    return __strm;
}







inline ios_base& fixed (ios_base& __strm)
{
    __strm.setf (ios_base::fixed, ios_base::floatfield);
    return __strm;
}



inline ios_base& scientific (ios_base& __strm)
{
    __strm.setf (ios_base::scientific, ios_base::floatfield);
    return __strm;
}


}





namespace __rw {

using namespace std;







template <class _CharT>
class __rw_numpunct_init_data {
 public:
  bool _C_del;
  _CharT _C_dp, _C_ts;
  const char *_C_gr;
  const _CharT *_C_tn, *_C_fn;
};
class __rw_numpunct_impl_base {
 public:
  static __rw_numpunct_init_data<char> *_C_get_named_init_ (const char*);
};
template <class _CharT>
class __rw_numpunct_impl_data :
    public __rw_numpunct_impl_base,
    public __rw_punct_data<_CharT>
{

  friend class numpunct<_CharT>;
  friend class __rw_keyword_cracker<_CharT>;

  typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
  string_type;

  string_type _C_tn, _C_fn;

  __rw_keyword_def<_CharT> tf_defs_[2];
  __rw_keyword_map<_CharT> tf_map_;

 protected:
  inline __rw_numpunct_impl_data (const __rw_numpunct_init_data<_CharT>*);
  static __rw_numpunct_init_data<_CharT> *_C_get_init_by_name_ (const char*);
  void _C_initfacetbase (const locale&);
};

template <class _CharT>
inline
__rw_numpunct_impl_data<_CharT>::
__rw_numpunct_impl_data (const __rw_numpunct_init_data<_CharT> *__init)
{
    if (!__init) {
        this->_C_dp = _CharT ('.');
        this->_C_ts = _CharT (',');
    } else {
        this->_C_dp = __init->_C_dp;
        this->_C_ts = __init->_C_ts;
        this->_C_gr = __init->_C_gr;
        _C_tn = __init->_C_tn;
        _C_fn = __init->_C_fn;

        if (__init->_C_del)
            delete[] (char*) __init;
    }
}

template <class _CharT>
__rw_numpunct_init_data<_CharT>*
__rw_fixup_numpunct_init (__rw_numpunct_init_data<char>*, _CharT*);

template<>
inline __rw_numpunct_init_data<char>*
__rw_fixup_numpunct_init (__rw_numpunct_init_data<char> *init, char*)
{
    return init;
}
template <class _CharT>
class __rw_numpunct_impl :
    public __rw_numpunct_impl_data<_CharT>
{
 protected:
  __rw_numpunct_impl (const __rw_numpunct_init_data<_CharT>* init)
   : __rw_numpunct_impl_data<_CharT>(init) { }
 public:
  static const __rw_numpunct_init_data<_CharT> *_C_get_ivals ()
    { return 0L; }
};

template<>
class __rw_numpunct_impl<char>:
    public __rw_numpunct_impl_data<char>
{
  static const __rw_numpunct_init_data<char> _C_ivals;

 protected:
  __rw_numpunct_impl
      (const __rw_numpunct_init_data<char> *init):
       __rw_numpunct_impl_data<char>(init) { }
 public:
  static const __rw_numpunct_init_data<char> *_C_get_ivals ()
    { return &_C_ivals; }
};


template<>
class __rw_numpunct_impl<wchar_t>:
    public __rw_numpunct_impl_data<wchar_t>
{
  static const __rw_numpunct_init_data<wchar_t> _C_ivals;

 protected:
  __rw_numpunct_impl
      (const __rw_numpunct_init_data<wchar_t> *init):
       __rw_numpunct_impl_data<wchar_t>(init) { }
 public:
  static const __rw_numpunct_init_data<wchar_t> *_C_get_ivals ()
    { return &_C_ivals; }
};




template <class _CharT, class _InputIterator, class _TypeT>
inline _InputIterator
__rw_num_do_get (_CharT,
                 _InputIterator __begin,
                 _InputIterator __end,
                 ios_base &__flags,
                 ios_base::iostate &__err,
                 _TypeT &__val)
{
    __rw_digit_reader<_CharT, _InputIterator>
        __reader (__begin, __end, __flags);


    _TypeT __tmp = __reader._C_parse (__reader._C_get_digits (_TypeT ()),
                                      _TypeT ());

    if (__reader._C_error)
        __err = ios_base::failbit;
    else {
        __err = ios_base::goodbit;
        __val = __tmp;
    }

    if (__reader.eof ())
        __err |= ios_base::eofbit;

    return __begin;
}


}


namespace std {






template <class _CharT, class _InputIterator>
class num_get: public locale::facet
{
public:
    typedef _CharT char_type;
    typedef _InputIterator iter_type;

    static locale::id id;

    explicit num_get (size_t __refs = 0)
        : locale::facet (__refs, locale::numeric) { }



    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, bool& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }



    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, unsigned short& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }


    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, short& __val) const {
        ((void)0);
        return __rw::__rw_num_do_get (_CharT (), __begin, __end, __flags,
                                            __err, __val);
    }


    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, int& __val) const {
        ((void)0);
        return __rw::__rw_num_do_get (_CharT (), __begin, __end, __flags,
                                            __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, unsigned int& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, unsigned long& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, float& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, double& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, long double& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }

    iter_type get (iter_type __begin, iter_type __end, ios_base &__flags,
                   ios_base::iostate &__err, void*& __val) const {
        ((void)0);
        return do_get (__begin, __end, __flags, __err, __val);
    }
    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:



    virtual iter_type do_get (iter_type, iter_type, ios_base&,
                              ios_base::iostate&, bool&) const;


    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned short &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned int &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              unsigned long &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              float &__val) const {
        return __rw::__rw_num_do_get (char_type (), __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              double &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              long double &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }

    virtual iter_type do_get (iter_type __begin, iter_type __end,
                              ios_base &__flags, ios_base::iostate &__err,
                              void* &__val) const {
        return __rw::__rw_num_do_get (char_type (),
                                     __begin, __end,
                                     __flags, __err, __val);
    }
private:
};






template <class _CharT, class _OutputIterator>
class num_put: public locale::facet
{
public:
    typedef _CharT char_type;
    typedef _OutputIterator iter_type;

    explicit num_put (size_t __refs = 0)
        : locale::facet (__refs, locale::numeric) { }


    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   bool __val) const {
        return do_put(__it, __flags, __fill, __val);
    }


    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   long __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned long __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   double __val) const {
        return do_put (__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   long double __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   const void* __val) const {
        return do_put(__it, __flags, __fill, __val);
    }
    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   short __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned short __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   int __val) const {
        return do_put(__it, __flags, __fill, __val);
    }

    iter_type put (iter_type __it, ios_base& __flags, char_type __fill,
                   unsigned int __val) const {
        return do_put(__it, __flags, __fill, __val);
    }
    static locale::id id;


    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:


    virtual iter_type do_put (iter_type, ios_base&, char_type, bool) const;

    virtual iter_type do_put (iter_type, ios_base&, char_type, long) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned long) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type, double) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              long double) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              const void* p) const;


    virtual iter_type do_put (iter_type, ios_base&, char_type, short) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned short) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type, int) const;
    virtual iter_type do_put (iter_type, ios_base&, char_type,
                              unsigned int) const;
private:





};





template <class _CharT>
class numpunct: public locale::facet,
                public __rw::__rw_numpunct_impl<_CharT>
{
public:
    typedef _CharT char_type;
    typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
    string_type;





    explicit numpunct (size_t __refs = 0,
                        const __rw::__rw_numpunct_init_data<_CharT> *i =
                        __rw::__rw_numpunct_impl<_CharT>::_C_get_ivals());






    char_type decimal_point () const {
        return do_decimal_point();
    }

    char_type thousands_sep () const {
        return do_thousands_sep();
    }

    string grouping () const {
        return do_grouping();
    }

    string_type truename () const {
        return do_truename ();
    }

    string_type falsename () const {
        return do_falsename();
    }

    static locale::id id;


    enum { _C_facet_cat = locale::numeric, _C_ok_implicit = 1 };

protected:

    virtual char_type do_decimal_point () const {
        return this->_C_dp;
    }

    virtual char_type do_thousands_sep () const {
        return this->_C_ts;
    }

    virtual string do_grouping () const {
        return this->_C_gr;
    }

    virtual string_type do_truename () const {
        return this->_C_tn;
    }

    virtual string_type do_falsename () const {
        return this->_C_fn;
    }



private:
    virtual void _C_initfacet (const locale&);





};

template <class _CharT>
inline numpunct<_CharT>::numpunct
    (size_t refs, const __rw::__rw_numpunct_init_data<_CharT> *init):
     locale::facet(refs, locale::numeric),
     __rw::__rw_numpunct_impl<_CharT>(init)
{ }





template <class _CharT>
class numpunct_byname: public numpunct<_CharT>
{
public:

    explicit numpunct_byname (const char *__name, size_t __refs = 0) :



        numpunct<_CharT>(__refs,
                         __rw::__rw_numpunct_impl_data<_CharT>::_C_get_init_by_name_(__name))

        { }
};


}


namespace __rw {


using namespace std;




template <class _CharT>
inline numpunct<_CharT>*
__rw_create_named_facet (numpunct<_CharT>*, const char *__name, size_t __ref)
{
    return new numpunct_byname<_CharT>(__name, __ref);
}
}
namespace __rw {

using namespace std;






template <class _CharT>
class __rw_timepunct_init_data
{
public:
  const _CharT *_C_day_nms[7][2];
  const _CharT *_C_month_nms[12][2];
  const _CharT *_C_ampm_nms[2];
  const _CharT *_C_bad_nm;
  const _CharT *_C_ord_nms[100];
  const _CharT *_C_dt_tm_pats[6];
};

template <class _CharT>
class __rw_timepunct_init;

template<>
class __rw_timepunct_init<char>
{

 public:
  typedef basic_string<char, char_traits<char>,
                              allocator<char> > string_type;

  const __rw_timepunct_init_data<char>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<char> &i)
    : _C_tinit(i)
  {}

  const string_type _C_get_day(int i, bool abbr) const;
  const string_type _C_get_month(int i, bool abbr) const;
  const string_type _C_get_ampm(bool afternoon) const;
  const string_type _C_get_bad() const { return _C_tinit._C_bad_nm ; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};


template<>
class __rw_timepunct_init<wchar_t>
{

 public:
  typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > string_type;

  const __rw_timepunct_init_data<wchar_t>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<wchar_t> &i)
    : _C_tinit(i)
  {}

  const string_type _C_get_day(int i, bool abbr) const;
  const string_type _C_get_month(int i, bool abbr) const;
  const string_type _C_get_ampm(bool afternoon) const;





  const string_type _C_get_bad() const { return _C_tinit._C_bad_nm; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};



template <class _CharT>
class __rw_timepunct_init
{

 public:
  typedef basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > string_type;

  const __rw_timepunct_init_data<_CharT>& _C_tinit;

  __rw_timepunct_init (const __rw_timepunct_init_data<_CharT> &i)
    : _C_tinit(i)
  {}

  const string_type _C_get_day(int i, bool abbr) const { return _C_tinit._C_day_nms[i][abbr]; }
  const string_type _C_get_month(int i, bool abbr) const { return _C_tinit._C_month_nms[i][abbr]; }
  const string_type _C_get_ampm(bool afternoon) const { return _C_tinit._C_ampm_nms[afternoon]; }
  const string_type _C_get_bad() const { return _C_tinit._C_bad_nm; }
  const string_type _C_get_ord(int i) const { return _C_tinit._C_ord_nms[i]; }
  const string_type _C_get_pattern(int i) const { return _C_tinit._C_dt_tm_pats[i]; }
};
template <class _CharT>
class __rw_timepunct_impl_data {
  friend class __rw_timepunct<_CharT>;
  friend class __rw_keyword_cracker<_CharT>;
 public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;
 private:

  string_type _C_day_nms[7][2];
  string_type _C_month_nms[12][2];
  string_type _C_ampm_nms[2];
  string_type _C_bad_nm;
  string_type _C_ord_nms[100];
  string_type _C_dt_tm_pats[6];

  __rw_keyword_def<_CharT> _C_dn_defs[7][2];
  __rw_keyword_map<_CharT> _C_dn_defsmap;
  __rw_keyword_def<_CharT> _C_mn_defs[12][2];
  __rw_keyword_map<_CharT> _C_mn_defsmap;
  __rw_keyword_def<_CharT> _C_ampm_defs[2];
  __rw_keyword_map<_CharT> _C_ampm_defsmap;

 protected:
  __rw_timepunct_impl_data (const __rw_timepunct_init<_CharT> &i);
  void _C_initpat (const locale&);
  void _C_initfacet (const locale&);
};
template <class _CharT>
class __rw_timepunct_impl :
    public __rw_timepunct_impl_data<_CharT>
{
 protected:
  __rw_timepunct_impl(void);
};

template<>
class __rw_timepunct_impl<char>:
    public __rw_timepunct_impl_data<char>
{
  static const
  __rw_timepunct_init_data<char> _C_ivals;

 protected:
  __rw_timepunct_impl (void):
    __rw_timepunct_impl_data<char>(__rw_timepunct_init<char>(_C_ivals)) { }
};


template<>
class __rw_timepunct_impl<wchar_t>:
    public __rw_timepunct_impl_data<wchar_t>
{
  static const
  __rw_timepunct_init_data<wchar_t> _C_ivals;

 protected:
  __rw_timepunct_impl(void):
      __rw_timepunct_impl_data<wchar_t>(__rw_timepunct_init<wchar_t>(_C_ivals)) { }
};







template <class _CharT>
class __rw_timepunct : public locale::facet,
    public __rw_timepunct_impl<_CharT>
{
 public:
  typedef _CharT char_type;
  typedef basic_string<_CharT, char_traits<_CharT>,
                                allocator<_CharT> >
    string_type;

  explicit __rw_timepunct (size_t __refs=0):
      locale::facet(__refs, locale::time) { }

  string_type dayname (int __day, bool __abbreviated) const
      { return do_dayname(__day, __abbreviated); }
  string_type monthname (int __month, bool __abbreviated) const
      { return do_monthname(__month, __abbreviated); }
  string_type ordinal (int __number) const
      { return do_ordinal(__number); }

  static locale::id id;


  enum { _C_facet_cat = locale::time, _C_ok_implicit = 1 };

 protected:

  virtual string_type do_dayname (int day, bool abbreviated) const;
  virtual string_type do_monthname (int month, bool abbreviated) const;
  virtual string_type do_ordinal (int number) const;

 private:
  void _C_initfacet (const locale&);




};
template <class _CharT>
class __rw_keyword_cracker {
public:

    static const __rw_keyword_map<_CharT>&
    _C_get_tf_map (const numpunct<_CharT> &__np) {
        return __np.tf_map_;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_day_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_dn_defsmap;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_month_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_mn_defsmap;
    }

    static const __rw_keyword_map<_CharT>&
    _C_get_ampm_map (const __rw_timepunct<_CharT>& __tp) {
        return __tp._C_ampm_defsmap;
    }

    static const typename numpunct<_CharT>::string_type&
    _C_get_tf_string (const numpunct<_CharT>& __np, bool __val) {
        return __val ? __np._C_tn : __np._C_fn;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_day_string (const __rw_timepunct<_CharT>& __tp, unsigned __val, bool __abr) {
        return __val < 7 ? __tp._C_day_nms[__val][__abr] : __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_month_string (const __rw_timepunct<_CharT>& __tp, unsigned __val, bool __abr)
{
        return __val < 12 ? __tp._C_month_nms[__val][__abr] : __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_ampm_string (const __rw_timepunct<_CharT>& __tp, bool __pm) {
        return __tp._C_ampm_nms[__pm];
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_ord_string (const __rw_timepunct<_CharT>& __tp, unsigned __val) {
        return __val < 99 ? __tp._C_ord_nms[__val] : __tp._C_bad_nm;
    }

    static const typename __rw_timepunct<_CharT>::string_type&
    _C_get_patt_string (const __rw_timepunct<_CharT>& __tp, unsigned __val) {
        return __val < 6 ? __tp._C_dt_tm_pats[__val] : __tp._C_bad_nm;
    }
};
template <class _CharT>
class __rw_digit_handler_base_1
    : public __rw_keyword_cracker<_CharT>
{
public:
    const ctype<_CharT> &_C_ctyp;
    const __rw_digit_map<_CharT> &_C_dmap;
    const __rw_punct_data<_CharT> &_C_punct;


    __rw_digit_handler_base_1 (const locale& __loc)
        : _C_ctyp (use_facet < ctype<_CharT> >(__loc)),
          _C_dmap (__rw_digit_map<_CharT>::_C_get_digit_map (_C_ctyp)),
         _C_punct(use_facet < numpunct<_CharT> >(__loc))
        { }




    __rw_digit_handler_base_1 (const locale& __loc,
                          const __rw_punct_data<_CharT>& __pun)
        : _C_ctyp (use_facet < ctype<_CharT> >(__loc)),
          _C_dmap (__rw_digit_map<_CharT>::_C_get_digit_map (_C_ctyp)),
         _C_punct(__pun)
        { }

};
class __rw_digit_reader_base : public __rw_digit_map_base
{
public:

    enum {
        _C_good = 0x0000,
        _C_no_digits = 0x0001,
        _C_too_many_groups = 0x0004,
        _C_group_too_long = 0x0008,
        _C_group_is_empty = 0x0010,
        _C_bad_grouping = 0x0020,
        _C_bad_exponent = 0x0040,
        _C_overflow = 0x0080,
        _C_bad_curr_symbol = 0x0100,
        _C_bad_sign = 0x0200,


        _C_signed = 0x01000,
        _C_negative = 0x02000,
        _C_exp_negative = 0x04000,
        _C_advanced = 0x08000,
        _C_infinity = 0x10000,
        _C_nan = 0x20000,

        _C_DEF_BUFSIZE = 64
    };



    int _C_error;
    int _C_base;

    int _C_state;

    char *_C_frac_beg;
    char *_C_exp_beg;

    size_t _C_bufsize;


    char _C_buffer [_C_DEF_BUFSIZE];
    char *_C_digits;

    __rw_digit_reader_base (int __radix = 0)
        : _C_error (_C_good), _C_base (__radix), _C_state (_C_signed),
          _C_bufsize (_C_DEF_BUFSIZE), _C_digits (_C_buffer) { }

    ~__rw_digit_reader_base () {
        if (_C_digits != _C_buffer)
            delete[] _C_digits;
    }


    unsigned long _C_parse (const char *__end, unsigned long = 0);


    short _C_parse (const char *__end, short) {
        return _C_parse (__end, 0L);
    }

    unsigned short _C_parse (const char *__end, unsigned short) {
        return _C_parse (__end, 0UL);
    }

    int _C_parse (const char *__end, int) {
        return _C_parse (__end, 0L);
    }

    unsigned int _C_parse (const char *__end, unsigned int) {
        return _C_parse (__end, 0UL);
    }

    long _C_parse (const char *__end, long) {
        unsigned long __tmp = _C_parse (__end, 0UL);
        return _C_state & _C_negative ? -__tmp : __tmp;
    }
    void *_C_parse (const char *__end, void* __val);

    float _C_parse (const char *__end, float __val, const char *__fmt = "%g") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }

    double _C_parse (const char *__end, double __val,
                     const char *__fmt = "%lg") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }

    long double _C_parse (const char *__end, long double __val,
                       const char *__fmt = "%Lg") {
        return _C_parse_float (__end, __fmt, &__val), __val;
    }

protected:


    static char* _C_realloc (char *&__begin, char *__buf, size_t &__bufsize);


    char* _C_realloc ();

private:


    unsigned long _C_parse_decimal (const char *__beg, const char *__end);


    void _C_parse_float (const char *__end, const char *__fmt, void *__val);
};


inline char* __rw_digit_reader_base::_C_realloc ()
{

    ptrdiff_t __frac_off = _C_frac_beg - _C_digits;
    ptrdiff_t __exp_off = _C_exp_beg - _C_digits;

    char *__cur = _C_realloc (this->_C_digits, this->_C_buffer,
                              this->_C_bufsize);


    if (_C_frac_beg)
        _C_frac_beg = _C_digits + __frac_off;

    if (_C_exp_beg)
        _C_exp_beg = _C_digits + __exp_off;

    return __cur;
}
template <class _CharT>
class __rw_digit_reader_base_1
    : public __rw_digit_reader_base,
      public __rw_digit_handler_base_1<_CharT>
{
public:
    typedef basic_string<_CharT, char_traits<_CharT>,
                                  allocator<_CharT> > string_type;

protected:

    __rw_digit_reader_base_1 (const locale &__loc, int __radix = 0)
        : __rw_digit_reader_base (__radix),
          __rw_digit_handler_base_1<_CharT>(__loc) { }




    __rw_digit_reader_base_1 (const locale &__loc,
                         const __rw_punct_data<_CharT> &__mp)
        : __rw_digit_handler_base_1<_CharT>(__loc, __mp) { }



    _CharT _C_get_decimal_point() const {
        return this->_C_punct._C_dp;
    }

    _CharT _C_get_thousands_sep() const {
        return this->_C_punct._C_ts;
    }

    const char* _C_get_grouping() const {
        return this->_C_punct._C_gr.c_str();
    }
};
template <class _CharT, class InputIterator>
class __rw_digit_reader
    : public __rw_digit_reader_base_1<_CharT>
{
public:

    __rw_digit_reader (InputIterator &__first,
                       InputIterator &__last,
                       ios_base &__flags)
        : __rw_digit_reader_base_1<_CharT> (__flags.getloc (),
                                            __flags._C_base ()),
          _C_io (__flags), _C_in (__first), _C_end (__last) { }

protected:

    __rw_digit_reader (InputIterator &__first, InputIterator &__last,
                       ios_base &__flags,
                       const __rw_punct_data<_CharT> &__mp)
        : __rw_digit_reader_base_1<_CharT>(__flags.getloc (), __mp),
          _C_io (__flags), _C_in (__first), _C_end (__last) { }

public:
    char *_C_get_digits (int);


    char *_C_get_digits (short) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned short) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned int) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (long) {
        return _C_get_digits (0);
    }

    char *_C_get_digits (unsigned long) {
        return _C_get_digits (0);
    }
    char *_C_get_digits (double);


    char *_C_get_digits (float) {
        return _C_get_digits (0.0);
    }

    char *_C_get_digits (long double) {
        return _C_get_digits (0.0);
    }

    char *_C_get_digits (void*) {
        this->_C_base = 16;
        return _C_get_digits (0);
    }


    int _C_get_keyword (const __rw_keyword_map<_CharT>&);

    bool eof () const {
        return _C_in == _C_end;
    }

protected:

    ios_base &_C_io;
    InputIterator& _C_in;
    InputIterator& _C_end;

    const char *_C_grouping;
    _CharT thousands_sep;
    char _C_groups[40];
    char *_C_gpos;


    char *_C_get_digit_string (char*, bool = false);

    char *_C_get_digit_groups (char*);
};
class __rw_digit_writer_base :
    public __rw_digit_map_base
{
public:
    __rw_digit_writer_base (ios_base&);

    virtual ~__rw_digit_writer_base () {
        if (_C_start != _C_buffer)
            delete[] _C_start;
    }

    void _C_get_pattern (char*, const char*, bool);

    bool _C_get_f_pattern(char*, char);

    void _C_digitize (unsigned long, bool __is_signed, const char *__fmat);

    void _C_digitize (const void *__val);

    void _C_digitize (unsigned short __val) {
        _C_digitize (__val, false, "h");
    }

    void _C_digitize (short __val) {
        _C_digitize (__val, true, "h");
    }

    void _C_digitize (unsigned int __val) {
        _C_digitize (__val, false, "");
    }

    void _C_digitize (int __val) {
        _C_digitize (__val, true, "");
    }

    void _C_digitize (long __val) {
        _C_digitize (__val, true, "l");
    }

    void _C_digitize (unsigned long __val) {
        _C_digitize (__val, false, "l");
    }
    void _C_digitize (double);


    void _C_digitize (long double);



    void _C_to_binary (unsigned long);

    ios_base &_C_io;
    ios_base::fmtflags _C_flags;
    int _C_precision, _C_width, _C_base, _C_iprecision, _C_num_groups;
    enum { _C_left, _C_internal, _C_right } _C_adjust;
    bool _C_fractional, _C_separable;
    char *_C_start, *_C_end, *_C_group;

    enum { _C_DEF_BUFSIZE = 65 };
    char _C_buffer [_C_DEF_BUFSIZE ];
    char _C_groups[150];

    int _C_calc_groups (int, const char*);
};


inline
__rw_digit_writer_base::__rw_digit_writer_base (ios_base &__b)
    : _C_io(__b), _C_flags(__b.flags()), _C_precision(__b.precision()),
      _C_width(__b.width()), _C_iprecision(0), _C_num_groups(0),
      _C_fractional(false), _C_separable(true), _C_start(_C_buffer),
      _C_end(_C_buffer) {


    _C_base = __b._C_base ();

    switch (_C_flags & ios_base::adjustfield) {

    case ios_base::left:
        _C_adjust = _C_left;
        break;

    case ios_base::internal:
        _C_adjust = _C_internal;
        break;

    default:
        _C_adjust = _C_right;
        break;
    }
}
template <class _CharT>
class __rw_digit_writer_base_1 :
    public __rw_digit_writer_base,
    public __rw_digit_handler_base_1<_CharT>
{
 public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;

 protected:

  __rw_digit_writer_base_1(ios_base &__b, const locale &__loc)
      : __rw_digit_writer_base (__b), __rw_digit_handler_base_1<_CharT>(__loc)
        { }



  __rw_digit_writer_base_1 (ios_base&, const __rw_punct_data<_CharT>&);


  _CharT _C_get_decimal_point() const {
      return this->_C_punct._C_dp;
  }
  _CharT _C_get_thousands_sep() const {
      return this->_C_punct._C_ts;
  }
  const char *_C_get_grouping() const {
      return this->_C_punct._C_gr.c_str();
  }
};
template <class _CharT, class _OutputIterator>
class __rw_digit_writer :
    public __rw_digit_writer_base_1<_CharT>
{
public:
  typedef basic_string<_CharT, char_traits<_CharT>,
                             allocator<_CharT> > string_type;


  __rw_digit_writer (_OutputIterator& o, ios_base& b)
      : __rw_digit_writer_base_1<_CharT>(b, b.getloc ()), _C_out (o)
        { }

 protected:


    __rw_digit_writer (_OutputIterator &o, ios_base &b,
                  const __rw_punct_data<_CharT> &mp)
        : __rw_digit_writer_base_1<_CharT>(b, mp), _C_out (o)
        { }

 public:
  void _C_put_digits (_CharT fill);
  void _C_put_keyword (const string_type&, _CharT fill);

 protected:
  _OutputIterator &_C_out;
};


}
namespace __rw {

using namespace std;






template <class _CharT>
__rw_timepunct_impl_data<_CharT>::__rw_timepunct_impl_data
    (const __rw_timepunct_init<_CharT> &__init)
{
  size_t __i;
  for (__i=0; __i<7; __i++) {
      _C_day_nms[__i][0]=__init._C_get_day (__i, false);
      _C_day_nms[__i][1]=__init._C_get_day (__i, true);
  }
  for (__i=0; __i<12; __i++) {
      _C_month_nms[__i][0]=__init._C_get_month (__i, false);
      _C_month_nms[__i][1]=__init._C_get_month (__i, true);
  }
  _C_ampm_nms[0]=__init._C_get_ampm (false);
  _C_ampm_nms[1]=__init._C_get_ampm (true);
  _C_bad_nm=__init._C_get_bad ();
  for (__i=0; __i<100; __i++)
      _C_ord_nms[__i]=__init._C_get_ord (__i);
  for (size_t __j=0; __j<sizeof _C_dt_tm_pats/sizeof _C_dt_tm_pats[0]; __j++)
      _C_dt_tm_pats[__j]=__init._C_get_pattern (__j);
}


struct __rwstd_fmt {
    __rwstd_fmt () {}
    __rwstd_fmt (int __pos, int __len, char __fmtc)
        : _C_pos(__pos), _C_len(__len), _C_fmt_char(__fmtc) {}
    int _C_pos;
  int _C_len;
    char _C_fmt_char;
    bool operator < (const __rwstd_fmt& __fmt) {
        return _C_pos < __fmt._C_pos;
    }
};


template <class _CharT>
void __rw_timepunct_impl_data<_CharT>::_C_initpat (const locale &__loc)
{
  static const char __tm_single_data_patts[] = "YyjSMIHmBbAapdZUWw";

  tm __tmb;
  char __buf[256];
  __rwstd_fmt __fmtstruct_array[20];


  __tmb.tm_sec = 56;
  __tmb.tm_min = 54;
  __tmb.tm_hour = 22;
  __tmb.tm_mday = 30;
  __tmb.tm_mon = 10;
  __tmb.tm_year = 90;
  __tmb.tm_wday = 5;
  __tmb.tm_yday = -1;
  __tmb.tm_isdst = -1;
  (void) mktime (&__tmb);

  typedef std::ctype<_CharT> _Ctype;
  typedef __rw_facet_maker<_Ctype> _FacetMaker;




  const _Ctype &__ct =
      static_cast< const _Ctype& >(__loc._C_unsafe_use_facet (_Ctype::id, _Ctype::_C_ok_implicit, _Ctype::_C_facet_cat, _FacetMaker::_C_maker_func));






  std::string __oldloc = setlocale (0, 0);




    setlocale (0, __loc.name ().c_str ());



  static const char __tm_mult_data_patts[] = "xXcDrT";

  for (unsigned int __j = 0; __j != sizeof __tm_mult_data_patts - 1; ++__j) {

      char __tmfmt_pat[] = "% ";
      __tmfmt_pat[1] = __tm_mult_data_patts[__j];
      strftime (__buf, sizeof (__buf), __tmfmt_pat, &__tmb);
      std::string __tmfmt_result (__buf);



    int __pos;
    int __fmtstruct_index = 0;
    for (unsigned int __i=0; __i < sizeof (__tm_single_data_patts) - 1; ++__i) {
        char __tmp_fmt_arg[] = "% ";
      __tmp_fmt_arg[1] = __tm_single_data_patts[__i];
      strftime (__buf, sizeof (__buf), __tmp_fmt_arg, &__tmb);


      if (!(__tm_single_data_patts[__i]=='p' && strcmp (__buf, " ")==0)) {
        if ((__pos = __tmfmt_result.find (__buf)) != -1) {
          if (strlen (__buf) > 0) {
            __fmtstruct_array[__fmtstruct_index++] = __rwstd_fmt (__pos, strlen (__buf), __tm_single_data_patts[__i]);
            __tmfmt_result.replace (__pos, strlen (__buf), strlen (__buf), ' ');
          }
        }
      }
    }


    for (int __top = __fmtstruct_index; __top > 0; --__top) {
      int __large = 0;
      for (int __i = 0; __i < __top; ++__i) {
        if (__fmtstruct_array[__i] < __fmtstruct_array[__large])
          __large = __i;
      }
      __rwstd_fmt __temp = __fmtstruct_array[__large];
      __fmtstruct_array[__large] = __fmtstruct_array[__top-1];
      __fmtstruct_array[__top-1] = __temp;
    }


    {
      std::string __alt_tmfmt (__tmfmt_result);
      char __compare_buf[256];


      for (__rwstd_fmt *__tmpfmt = __fmtstruct_array;
           __tmpfmt < (__fmtstruct_array + __fmtstruct_index);
           ++__tmpfmt) {
        __tmfmt_result.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len,
                                 (std::string ("%").append (1, (*__tmpfmt)._C_fmt_char)));

        if ((*__tmpfmt)._C_fmt_char != 'd') {
          __alt_tmfmt.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len,
                        (std::string ("%").append (1, (*__tmpfmt)._C_fmt_char)));
        } else {
          __alt_tmfmt.replace ((*__tmpfmt)._C_pos, (*__tmpfmt)._C_len,
                        (std::string ("%e")));
        }
      }


      __tmb.tm_mday=3;


      strftime (__buf, sizeof (__buf), __tmfmt_result.c_str (), &__tmb);
      strftime (__compare_buf, sizeof (__compare_buf), __tmfmt_pat, &__tmb);





      if (strcmp (__buf, __compare_buf)) {
        __tmfmt_result = __alt_tmfmt;
      }


      __tmb.tm_mday=30;
    }


    string_type __convert;
    for (unsigned int k = 0; k < __tmfmt_result.length (); ++k)
      __convert = std::operator + (__convert, __ct.widen (__tmfmt_result[k]));
    _C_dt_tm_pats[__j] = __convert;

  }

  setlocale (0, __oldloc.c_str ());
}

template <class _CharT>
void __rw_timepunct_impl_data<_CharT>::_C_initfacet (const locale &__loc) {

    int __i;
    for (__i=0; __i<7; ++__i) {
        _C_dn_defs[__i][0]._C_name=_C_day_nms[__i][0].c_str ();
        _C_dn_defs[__i][0]._C_indx=__i;
        _C_dn_defs[__i][1]._C_name=_C_day_nms[__i][1].c_str ();
        _C_dn_defs[__i][1]._C_indx=__i;
    }

    for (__i=0; __i<12; ++__i) {
        _C_mn_defs[__i][0]._C_name=_C_month_nms[__i][0].c_str ();
        _C_mn_defs[__i][0]._C_indx=__i;
        _C_mn_defs[__i][1]._C_name=_C_month_nms[__i][1].c_str ();
        _C_mn_defs[__i][1]._C_indx=__i;
    }

    _C_ampm_defs[0]._C_name=_C_ampm_nms[0].c_str ();
    _C_ampm_defs[0]._C_indx= 0;
    _C_ampm_defs[1]._C_name=_C_ampm_nms[1].c_str ();
    _C_ampm_defs[1]._C_indx= 1;

    _C_dn_defsmap._C_numdefs=7*2;
    _C_dn_defsmap._C_defs=&(_C_dn_defs[0][0]);
    _C_mn_defsmap._C_numdefs=12*2;
    _C_mn_defsmap._C_defs=&(_C_mn_defs[0][0]);
    _C_ampm_defsmap._C_numdefs=2;
    _C_ampm_defsmap._C_defs=&(_C_ampm_defs[0]);
    _C_initpat (__loc);
}






template <class _CharT>
std::locale::id __rw_timepunct<_CharT>::id;

template <class _CharT>
void __rw_timepunct<_CharT>::_C_initfacet (const locale &__loc) {
  __rw_timepunct_impl<_CharT>::_C_initfacet (__loc);
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_dayname (int __day, bool __abbr) const {
  return this->_C_day_nms[__day][__abbr];
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_monthname (int __mon, bool __abbr) const {
  return this->_C_month_nms[__mon][__abbr];
}

template <class _CharT>
typename __rw_timepunct<_CharT>::string_type
__rw_timepunct<_CharT>::do_ordinal (int __num) const {
  return (__num<0 || __num>99) ? this->_C_bad_nm : this->_C_ord_nms[__num];
}






template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::
_C_get_digit_string (char *__first, bool __discard ) {

    char *__last = __first;


    const _CharT *__punct = this->_C_dmap._C_get_punct ();



    while (!eof ()) {

        int __c = *_C_in;
        int __digit = this->_C_dmap._C_eval (__c);


        if ( __digit >= this->_C_base || __digit < 0
            && ( 16 != this->_C_base
                || __c != __punct [this->_C_x] && __c != __punct [this->_C_X]))
            break;


        if (__last == this->_C_digits + this->_C_bufsize)
            __last = this->_C_realloc ();



        if ( 0 < __digit
            || 0 == __digit && (!__discard || __first != __last))
            *__last++ = char (__digit);

        ++_C_in;
    }

    return __last;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::_C_get_digits (int)
{
    char *__last = this->_C_digits;
    const _CharT* __punct = this->_C_dmap._C_get_punct ();

    _CharT __ch;

    if (!eof () && (this->_C_state & this->_C_signed)) {

        do {
            if ((__ch = *_C_in) == __punct [this->_C_minus])
                this->_C_state |= this->_C_negative;
            else if (__ch != __punct [this->_C_plus])
                break;

            do
                ++_C_in;
            while ( !eof ()
                   && this->_C_ctyp.is (std::ctype_base::space, *_C_in));

            this->_C_state |= this->_C_advanced;
        } while (0);
    }

    if (!this->_C_base) {

        this->_C_base = _C_io._C_base ();

        if (0 == this->_C_base || (_C_io.flags () & std::ios_base::showbase)) {



            if (0 == this->_C_base)
                this->_C_base = 10;

            if (!eof () && *_C_in == __punct[this->_C_zero]) {
                this->_C_base = 8;
                ++_C_in;
                *__last++ = 0;
                this->_C_state |= this->_C_advanced;

                if ( !eof ()
                    && ( (__ch = *_C_in) == __punct[this->_C_x]
                        || __ch == __punct[this->_C_X])) {
                    this->_C_base = 16;
                    ++_C_in;
                    __last--;
                }
            }
        }
    }

    if (!*(_C_grouping = this->_C_get_grouping ()))
        __last = _C_get_digit_string (__last);
    else {
        _C_gpos = _C_groups;

        thousands_sep = this->_C_get_thousands_sep ();
        __last = _C_get_digit_groups (__last);

        if (!this->_C_error && --_C_gpos > _C_groups) {

            const char *__gdef = _C_grouping;
            do {
                if (*__gdef != *_C_gpos && *__gdef != 127)
                    break;

                if (__gdef[1])
                    ++__gdef;
            } while (--_C_gpos > _C_groups);

            if (_C_gpos > _C_groups || *_C_gpos > *__gdef)
                this->_C_error |= this->_C_bad_grouping;
        }
    }

    if (__last > this->_C_digits)
        this->_C_state |= this->_C_advanced;

    return __last;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::_C_get_digits (double)
{

    this->_C_base = 10;
    char *__first = _C_get_digits (0);


    const _CharT *__punct = this->_C_dmap._C_get_punct ();

    this->_C_frac_beg = __first;

    if (!this->_C_error && !eof ()) {
        if (*_C_in == this->_C_get_decimal_point ()) {


            ++_C_in;
            __first = _C_get_digit_string (__first);
        }
    }




    if (__first == this->_C_digits && !eof ()) {

        char __c = tolower (char (*_C_in));

        if ('i' == __c) {
            static const char __inf[] = "infinity";

            for (const char *__p = __inf; ; ++__p, ++_C_in) {

                if (!*__p || 3 == __p - __inf && eof ()) {
                    this->_C_state |= this->_C_infinity;
                    return __first;
                }
                if (eof () || *__p != tolower (*_C_in))
                    break;
            }
        }
        else if ('n' == __c) {
            for (const char *__p = "nan"; ; ++__p, ++_C_in) {

                if (!*__p) {
                    if (eof ()) {
                        this->_C_state |= this->_C_nan;
                        return __first;
                    }
                    if ('(' == *_C_in) {

                        while (!eof ())
                            if (')' == *_C_in++) {
                                this->_C_state |= this->_C_nan;
                                return __first;
                            }
                    }
                    break;
                }
                else if (eof () || tolower (*_C_in) != *__p)
                    break;
            }
        }
    }

    if (__first == this->_C_digits)
        this->_C_error |= this->_C_no_digits;

    this->_C_exp_beg = __first;
    this->_C_state &= ~this->_C_exp_negative;

    _CharT __ch;

    if ( !this->_C_error && !eof ()
        && ( (__ch = *_C_in) == __punct [this->_C_e]
            || __ch == __punct [this->_C_E])) {



        ++_C_in;
        if (eof ())
            this->_C_error |= this->_C_bad_exponent;
        else {

            if ((__ch = *_C_in) == __punct [this->_C_plus])
                ++_C_in;
            else if (__ch == __punct [this->_C_minus]) {
                this->_C_state |= this->_C_exp_negative;
                ++_C_in;
            }


            int __radix = this->_C_base;
            this->_C_base = 10;
            __first = _C_get_digit_string (__first);
            this->_C_base = __radix;

            if (__first == this->_C_exp_beg)
                this->_C_error |= this->_C_bad_exponent;
        }
    }

    return __first;
}


template <class _CharT, class InputIterator>
char* __rw_digit_reader<_CharT, InputIterator>::
    _C_get_digit_groups (char *__first) {

    char *__eod=_C_get_digit_string (__first);

    if (_C_gpos==_C_groups+sizeof _C_groups)
        this->_C_error|=this->_C_too_many_groups;
    else {
        int __i=__eod-__first;
        if (__i >= 127)
            this->_C_error|=this->_C_group_too_long;
        else {
            if (__i!=0) {
                *_C_gpos++=__i;
                if (!eof () && *_C_in==thousands_sep) {
                    ++_C_in;
                    __eod=_C_get_digit_groups (__eod);
                }
            }
        }
    }

    return __eod;
}


template <class _CharT, class InputIterator>
int __rw_digit_reader<_CharT, InputIterator>::
    _C_get_keyword (const __rw_keyword_map<_CharT> &__in_map) {

    const __rw_keyword_def<_CharT> *__map_ptr=__in_map._C_defs;
    const __rw_keyword_def<_CharT> *__end_ptr=__in_map._C_defs+__in_map._C_numdefs;

    __rw_keyword_def<_CharT> __can_ary[40],
        *__can_ptr=__can_ary;

    const _CharT *__name;
    int __result;
    _CharT __input;
    while (1) {
        if (eof ()) {
            for ( ; __map_ptr<__end_ptr; ++__map_ptr)
                if (!*__map_ptr->_C_name)
                    return __map_ptr->_C_indx;
            return -1;
        }

        __input=*_C_in;
        __result=-1;

        for ( ; __map_ptr<__end_ptr; ++__map_ptr) {
            __name=__map_ptr->_C_name;
            if (__input==*__name) {
                __can_ptr->_C_name=++__name;
                __can_ptr->_C_indx=__map_ptr->_C_indx;
                ++__can_ptr;
            }
            else if (*__name==0 )
                __result=__can_ptr->_C_indx;
        }


        if (__can_ptr==__can_ary)
            return __result;



        ++_C_in;

        if (__can_ptr==__can_ary+1) {
            for (__name=__can_ary[0]._C_name; *__name; ++__name) {
                if (eof () || *_C_in!=*__name)
                    return -1;
                ++_C_in;
            }
            return __can_ary[0]._C_indx;
        }

        __end_ptr =__can_ptr;
        __can_ptr =__can_ary;
        __map_ptr =__can_ary;

    }

}






template <class _CharT>
__rw_digit_writer_base_1<_CharT>::
__rw_digit_writer_base_1(std::ios_base &b, const __rw_punct_data<_CharT> &mp)
    : __rw_digit_writer_base (b),
      __rw_digit_handler_base_1<_CharT>(b.getloc (), mp) {

    _C_flags&=~(std::ios_base::floatfield | std::ios_base::showpos);
    _C_flags|=std::ios_base::fixed;
    _C_base=10;
    _C_precision=0;
}





template <class _CharT, class OutputIterator>
void __rw_digit_writer<_CharT, OutputIterator>::_C_put_digits (_CharT __fill) {

    char *__p=this->_C_start;
    bool __has_sign=false, __has_point=false,
        __has_prefix_8=false, __has_prefix_16=false;

    if (__p<this->_C_end && (*__p==' ' || *__p=='-' || *__p=='+')) {
        __has_sign=true;
        __p++;
    }

    if (__p+1 < this->_C_end
        && (this->_C_base == 16 && *__p == '0'
            && (*(__p+1) == 'x') || *(__p+1) == 'X'))
        __has_prefix_16 = true;

    if (__p+1 < this->_C_end
        && (this->_C_base == 8 && *__p == '0'))
        __has_prefix_8 = true;


    char *__dec;
    if (!this->_C_fractional)
        __dec=this->_C_end;
    else {
        __dec=this->_C_start;
        if (__has_sign) __dec++;
        for ( ; __dec<this->_C_end; ++__dec)
            if (*__dec<'0' || *__dec>'9') {
                if (*__dec!='e' && *__dec!='E')
                    __has_point=true;
                break;
            }
    }



    _CharT __separator = _CharT ();

    int __ungrouped=__dec-this->_C_start;
    if (__has_sign)
        __ungrouped--;
    if (__has_prefix_16)
        __ungrouped -= 2;
    if (__has_prefix_8)
        __ungrouped--;

    if (this->_C_separable) {
        __ungrouped=_C_calc_groups (__ungrouped, this->_C_get_grouping ());
        if (this->_C_num_groups)
            __separator=this->_C_get_thousands_sep ();
    }


    int __left_fill=0, __internal_fill=0, __right_fill=0;
    if (this->_C_width>0) {
        int __w=this->_C_width - (this->_C_end - this->_C_start)
                               - this->_C_num_groups;
        this->_C_width=0;

        if (__w>0) {
            switch (this->_C_adjust) {
            case __rw_digit_writer_base::_C_left:
                __right_fill=__w;
                break;
            case __rw_digit_writer_base::_C_internal:
                __internal_fill=__w;
                break;
            default:
                __left_fill=__w;
            }
        }
    }




    _CharT __widebuf [__rw_digit_writer_base::_C_DEF_BUFSIZE];
    _CharT *__wide_digits = __widebuf;


    if (this->_C_end - this->_C_start >= __rw_digit_writer_base::_C_DEF_BUFSIZE)
        __wide_digits = new _CharT [this->_C_end - this->_C_start + 1];

    this->_C_ctyp.widen (this->_C_start, this->_C_end, __wide_digits);


    _CharT *__digit_pos = __wide_digits;
    while (__left_fill--)
        *_C_out++ = __fill;

    if (__has_sign)
        *_C_out++ = *__digit_pos++;

    if (__has_prefix_16) {
        *_C_out++ = *__digit_pos++;
        *_C_out++ = *__digit_pos++;
    }
    if (__has_prefix_8)
        *_C_out++ = *__digit_pos++;

    while (__internal_fill--)
        *_C_out++ = __fill;

    while (__ungrouped--)
        *_C_out++ = *__digit_pos++;

    while (this->_C_num_groups--) {
        *_C_out++ = __separator;

        while (this->_C_group[0]--)
            *_C_out++=*__digit_pos++;
        ++this->_C_group;
    }

    if (__has_point) {
        *_C_out++=this->_C_get_decimal_point ();
        ++__digit_pos;
    }

    __ungrouped = this->_C_end - __dec;

    if (__has_point)
        __ungrouped--;

    while ((__ungrouped--) > 0)
        *_C_out++ = *__digit_pos++;

    while (__right_fill--)
        *_C_out++ = __fill;

    if (__wide_digits != __widebuf)
        delete[] __wide_digits;
}

template <class _CharT, class OutputIterator>
void __rw_digit_writer<_CharT, OutputIterator>::
    _C_put_keyword (const string_type &__instr, _CharT __fillchar) {

    int __left_fill=0, __right_fill=0;
    int __fillnum=this->_C_width-__instr.length ();
    if (__fillnum>0) {
        switch (this->_C_adjust) {
        case __rw_digit_writer_base::_C_left:
            __right_fill=__fillnum;
            break;
        case __rw_digit_writer_base::_C_internal:
        default:
            __left_fill=__fillnum;
        }
        if (__left_fill)
            do *_C_out++=__fillchar;
            while (--__left_fill);
    }

    const _CharT *__tmp=__instr.c_str (), *__endtmp=__tmp+__instr.length ();
    while (__tmp<__endtmp)
        *_C_out++=*__tmp++;

    if (__right_fill)
        do *_C_out++=__fillchar;
        while (--__right_fill);
}

}
namespace __rw {

template <class _CharT>
__rw_numpunct_init_data<_CharT>*
 __rw_fixup_numpunct_init (__rw_numpunct_init_data<char> *init,
                                                 _CharT*) {
  if (init->_C_del)
    delete[] (char*) init;
  return 0L;
}





template <class _CharT>
void __rw_numpunct_impl_data<_CharT>::_C_initfacetbase (const locale&) {
  tf_defs_[0]._C_name=_C_tn.c_str();
  tf_defs_[0]._C_indx=1;
  tf_defs_[1]._C_name=_C_fn.c_str();
  tf_defs_[1]._C_indx=0;

  tf_map_._C_numdefs=2 ;
  tf_map_._C_defs=tf_defs_;
}

template <class _CharT>
__rw_numpunct_init_data<_CharT>*
__rw_numpunct_impl_data<_CharT>::_C_get_init_by_name_ (const char *name) {
  return __rw_fixup_numpunct_init(_C_get_named_init_(name), (_CharT*)0);
}

}


namespace std {






template <class _CharT, class InputIterator>
locale::id num_get<_CharT, InputIterator>::id;




template <class _CharT, class _InputIterator>
_InputIterator num_get<_CharT, _InputIterator>::
do_get (_InputIterator __first, _InputIterator __last,
        ios_base& __flags, ios_base::iostate& __err, bool& __val) const
{
    __rw::__rw_digit_reader<_CharT, _InputIterator>
        __reader(__first, __last, __flags);

    long __tmp = __reader._C_parse (__reader._C_get_digits(long()), long());

    __err = ios_base::failbit;

    if (__flags.flags () & ios_base::boolalpha) {

        if (__reader._C_error) {
            const numpunct<_CharT>& __punct =
                static_cast< const numpunct<_CharT>& >(__reader._C_punct);
            __tmp = __reader._C_get_keyword (__reader._C_get_tf_map (__punct));
            if (__tmp >= 0) {
                __val = __tmp;
                __err = ios_base::goodbit;
            }
        }
    }
    else if (!__reader._C_error) {

        if (0 == __tmp) {
            __val = false;
            __err = ios_base::goodbit;
        }
        else if (1 == __tmp && !(__reader._C_state & __reader._C_negative)) {
            __val = true;
            __err = ios_base::goodbit;
        }
    }


    if (__reader.eof ())
        __err |= ios_base::eofbit;

    return __first;
}
template <class _CharT, class OutputIterator>
locale::id num_put<_CharT, OutputIterator>::id;



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, bool __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  if (__flags.flags() & ios_base::boolalpha) {
    const numpunct<_CharT>& __punct =
        static_cast< const numpunct<_CharT>& >(writer._C_punct);
    writer._C_put_keyword(writer._C_get_tf_string(__punct, __val), fill);
  } else {
    writer._C_digitize((unsigned long) (__val? 1 : 0));
    writer._C_put_digits(fill);
  }
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        const void* __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, long __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned long __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}
template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, double __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> digits(out, __flags);
  digits._C_digitize(__val);
  digits._C_put_digits(fill);
  return out;
}


template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        long double __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> digits(out, __flags);
  digits._C_digitize(__val);
  digits._C_put_digits(fill);
  return out;
}



template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, short __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned short __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::do_put
    (OutputIterator out, ios_base& __flags, _CharT fill, int __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}

template <class _CharT, class OutputIterator>
OutputIterator num_put<_CharT, OutputIterator>::
do_put (OutputIterator out, ios_base& __flags, _CharT fill,
        unsigned int __val) const
{
  __rw::__rw_digit_writer<_CharT, OutputIterator> writer(out, __flags);
  writer._C_digitize(__val);
  writer._C_put_digits(fill);
  return out;
}





template <class _CharT>
locale::id numpunct<_CharT>::id;

template <class _CharT>
void numpunct<_CharT>::_C_initfacet (const locale &loc) {
  this->_C_dp=do_decimal_point();
  this->_C_ts=do_thousands_sep();
  this->_C_gr=do_grouping();
  this->_C_fn=do_falsename();
  this->_C_tn=do_truename();
  this->_C_initfacetbase(loc);
}


}






namespace __rw {
template<>
inline std::ctype<char>*
__rw_create_native_facet (std::ctype<char>*)
{
    return new std::ctype<char>(0, false, 1);
}


template<>
inline std::numpunct<char>*
__rw_create_native_facet (std::numpunct<char>*)
{
    return new std::numpunct_byname<char>("", 1);
}





template <class _Facet>
inline _Facet*
__rw_create_native_facet (_Facet*)
{
    return __rw_create_named_facet ((_Facet*)0, "", size_t (1));
}


}
extern const float _FLT_NANS;
extern const float _FLT_DMIN;





extern const double _DBL_NANS;
extern const double _DBL_DMIN;
extern const long double _LDBL_NANS;
extern const long double _LDBL_DMIN;
namespace std {



class codecvt_base
{
public:
    enum result { ok, partial, error, noconv };
};






template <class _InternT, class _ExternT, class _StateT>
class codecvt: public locale::facet,
               public codecvt_base
{
public:
    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT state_type;

    explicit codecvt (size_t __ref = 0): locale::facet (__ref) { }

    result out (state_type& __state,
                const intern_type* __from, const intern_type* __from_end,
                const intern_type*& __from_next,
                extern_type* __to, extern_type* __to_limit,
                extern_type*& __to_next) const {
        return do_out(__state,__from,__from_end,__from_next,
                      __to,__to_limit,__to_next);
    }

    result unshift (state_type& __state, extern_type* __to,
                    extern_type* __to_limit, extern_type*& __to_next) const {
        return do_unshift (__state,__to,__to_limit,__to_next);
    }

    result in (state_type& __state, const extern_type* __from,
               const extern_type* __from_end, const extern_type*& __from_next,
               intern_type* __to, intern_type* __to_limit,
               intern_type*& __to_next) const {
        return do_in (__state,__from,__from_end,__from_next,
                      __to,__to_limit,__to_next);
    }

    bool always_noconv() const throw() {
        return do_always_noconv();
    }

    int encoding() const throw() {
        return do_encoding();
    }

    int length (state_type& __state, const extern_type* __from,
                const extern_type* end, size_t __max) const {
        return do_length(__state,__from,end,__max);
    }

    int max_length() const throw() {
        return do_max_length();
    }

    static locale::id id;


    typedef basic_string<extern_type,char_traits<extern_type>,
                         allocator<extern_type> >
    external_string_type;

    typedef basic_string<intern_type,char_traits<intern_type>,
                         allocator<intern_type> >
    internal_string_type;

    internal_string_type in (const external_string_type &) const;

    external_string_type out (const internal_string_type &) const;


    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:



    virtual result do_out (state_type&,
                           const intern_type*, const intern_type*,
                           const intern_type*&,
                           extern_type*, extern_type*, extern_type*&) const {
        return noconv;
    }

    virtual result do_in (state_type&, const extern_type*,
                          const extern_type*, const extern_type*&,
                          intern_type*, intern_type*, intern_type*&) const {
        return noconv;
    }


    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }


    virtual int do_encoding () const throw() {
        return 1;
    }


    virtual bool do_always_noconv () const throw() {
        return true;
    }


    virtual int do_length (state_type&, const extern_type* __from,
                           const extern_type *__end, size_t __max) const {

        size_t __n = __end - __from;
        return __n < __max ? __n : __max;
    }


    virtual int do_max_length () const throw() {


        return 1;
    }

private:
};




template<>
class codecvt<char, char, mbstate_t>: public locale::facet,
                                      public codecvt_base
{
public:
    typedef char extern_type;
    typedef char intern_type;
    typedef mbstate_t state_type;

    explicit codecvt (size_t __refs = 0)
        : locale::facet (__refs, locale::ctype) { }

    result out (state_type &__state,
                const intern_type *__from, const intern_type* __from_end,
                const intern_type *&__from_next,
                extern_type* __to, extern_type* __to_limit,
                extern_type *&__to_next) const {
        return do_out (__state, __from, __from_end, __from_next,
                       __to, __to_limit, __to_next);
    }

    result unshift (state_type &__state,
                    extern_type *__to, extern_type *__to_limit,
                    extern_type*& __to_next) const {
        return do_unshift (__state, __to, __to_limit, __to_next);
    }

    result in (state_type &__state,
               const extern_type *__from, const extern_type *__from_end,
               const extern_type *&__from_next,
               intern_type *__to, intern_type *__to_limit,
               intern_type *&__to_next) const {
        return do_in (__state, __from, __from_end, __from_next,
                      __to, __to_limit, __to_next);
    }

    int encoding () const throw() {
        return do_encoding ();
    }

    bool always_noconv () const throw() {
        return do_always_noconv ();
    }

    int length (const state_type &__state, const extern_type *__from,
                const extern_type *__end, size_t __max) const {
        return do_length (__state,__from,__end,__max);
    }

    int max_length () const throw() {
        return do_max_length ();
    }

    static locale::id id;




    typedef string internal_string_type;
    typedef string external_string_type;

    internal_string_type in (const external_string_type & __s) const {
        return __s;
    }

    external_string_type out (const internal_string_type &__s) const {
        return __s;
    }




    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:

    virtual result do_out (state_type&,
                           const intern_type *__from, const intern_type*,
                           const intern_type *&__from_next,
                           extern_type *__to, extern_type*,
                           extern_type *&__to_next) const {
        __from_next = __from;
        __to_next = __to;
        return noconv;
    }

    virtual result do_in (state_type&,
                          const extern_type *__from, const extern_type*,
                          const extern_type *&__from_next,
                         intern_type *__to, intern_type*,
                          intern_type*& __to_next) const {
        __from_next = __from;
        __to_next = __to;
        return noconv;
    }


    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }

    virtual int do_encoding () const throw() {
        return 1;
    }

    virtual bool do_always_noconv () const throw(){
        return true;
    }

    virtual int do_length (const state_type&,
                           const extern_type *__from,
                           const extern_type *__from_end,
                           size_t __max) const {

        ((void)0);


        size_t __len = __from_end - __from;
        return __len < __max ? __len : __max;
    }

    virtual int do_max_length () const throw() {
        return 1;
    }
};







template<>
class codecvt<wchar_t, char, mbstate_t> : public locale::facet,
                                                        public codecvt_base
{
public:
    typedef wchar_t intern_type;
    typedef char extern_type;
    typedef mbstate_t state_type;

    explicit codecvt (size_t __refs = 0)
        : locale::facet(__refs,locale::ctype) { }

    result out (state_type& __state,
                const intern_type *__from, const intern_type *__from_end,
                const intern_type *&__from_next,
                extern_type *__to, extern_type* __to_limit,
                extern_type *& __to_next) const {
        return do_out (__state, __from, __from_end, __from_next, __to,
                       __to_limit, __to_next);
    }

    result unshift (state_type &__state,
                    extern_type *__to, extern_type *__to_limit,
                    extern_type *&__to_next) const {
        return do_unshift (__state, __to, __to_limit, __to_next);
    }

    result in (state_type& __state,
               const extern_type *__from, const extern_type *__from_end,
               const extern_type *&__from_next,
               intern_type *__to, intern_type *__to_limit,
               intern_type *&__to_next) const {
        return do_in (__state, __from, __from_end, __from_next,
                      __to, __to_limit, __to_next);
  }

    int encoding () const throw() {
        return do_encoding();
    }

    bool always_noconv () const throw() {
        return do_always_noconv ();
    }

    int length (const state_type &__state,
                const extern_type *__from, const extern_type *__end,
                size_t __max) const {
        return do_length (__state, __from, __end, __max);
    }

    int max_length () const throw() {
        return do_max_length ();
    }

    static locale::id id;


    typedef string external_string_type;
    typedef wstring internal_string_type;

    inline
    internal_string_type in (const external_string_type&) const;

    external_string_type out (const internal_string_type&) const;


    enum { _C_facet_cat = locale::ctype, _C_ok_implicit = 1 };

protected:

    virtual result do_out (state_type&,
                           const intern_type*, const intern_type*,
                           const intern_type*&,
                           extern_type*, extern_type*, extern_type*&) const;

    virtual result do_in (state_type&,
                          const extern_type*, const extern_type*,
                          const extern_type*&,
                          intern_type*, intern_type*, intern_type*&) const;


    virtual result do_unshift (state_type&, extern_type *__to,
                               extern_type*, extern_type *&__to_next) const {
        __to_next = __to;
        return noconv;
    }

    virtual bool do_always_noconv () const throw() {
        return false;
    }

    virtual int do_encoding () const throw() {
        return 1;
    }

    virtual int do_length (const state_type&, const extern_type* __from,
                           const extern_type* __from_end,
                           size_t __max) const {

        ((void)0);


        size_t __len = __from_end - __from;
        return __len < __max ? __len : __max;
    }


    virtual int do_max_length () const throw() {
        return 1;
    }
};


inline codecvt_base::result
codecvt<wchar_t, char, mbstate_t>::
do_out (state_type&,
        const intern_type *__from, const intern_type *__from_end,
        const intern_type *&__from_next,
        extern_type *__to, extern_type *__to_end, extern_type *&__to_next) const
{

    ((void)0);
    ((void)0);


    for (__from_next = __from, __to_next = __to;
         __from_next != __from_end && __to_next != __to_end;
         ++__from_next, ++__to_next)
        *__to_next = *__from_next;

    return ok;
}


inline codecvt_base::result
codecvt<wchar_t,char,mbstate_t>::
do_in (state_type&,
       const extern_type *__from, const extern_type *__from_end,
       const extern_type *&__from_next,
       intern_type *__to, intern_type *__to_end, intern_type *&__to_next) const
{

    ((void)0);
    ((void)0);


    for (__from_next = __from, __to_next = __to;
         __from_next != __from_end && __to_next != __to_end;
         ++__from_next, ++__to_next) {

        *__to_next = static_cast< unsigned char >(*__from_next);
    }

    return ok;
}



inline wstring
codecvt<wchar_t,char,mbstate_t>::in (const string &__s) const {

    wchar_t __result_buf[1000];
    size_t __max = sizeof (__result_buf) / sizeof (wchar_t);
    size_t __n = mbstowcs(__result_buf,__s.c_str(),__max);

    (__n != size_t(-1)) ? (void)0 : throw (runtime_error&)runtime_error ("/opt/aCC/include_std/rw/codecvt" ":" "507" ": ")._C_format ((0 + 22), __PRETTY_FUNCTION__);



    if (__n==__max) {


    }
    return wstring(__result_buf,(wstring::size_type)__n);
}



inline string
codecvt<wchar_t,char,mbstate_t>::out (const wstring &__s) const {
    char __result_buf[1000];
    size_t __n=wcstombs(__result_buf,__s.c_str(),sizeof __result_buf);

    (__n != size_t (-1)) ? (void)0 : throw (runtime_error&)runtime_error ("/opt/aCC/include_std/rw/codecvt" ":" "525" ": ")._C_format ((0 + 22), __PRETTY_FUNCTION__);



    if (__n==sizeof __result_buf) {


    }

    return string(__result_buf,(string::size_type)__n);
}






template <class _InternT, class _ExternT, class _StateT>
class codecvt_byname: public codecvt<_InternT, _ExternT, _StateT>
{
public:

    typedef _InternT intern_type;
    typedef _ExternT extern_type;
    typedef _StateT state_type;

    explicit codecvt_byname (const char*, size_t __ref = 0)
        : codecvt <_InternT, _ExternT, _StateT> (__ref) { }

protected:

    virtual codecvt_base::result
    do_out (state_type&,
            const intern_type*, const intern_type*, const intern_type*&,
            extern_type*, extern_type*, extern_type*&) const {
        return codecvt_base::error;
    }

    virtual codecvt_base::result
    do_in (state_type&,
           const extern_type*, const extern_type*, const extern_type*&,
           intern_type*, intern_type*, intern_type*&) const {
        return codecvt_base::error;
    }

    virtual codecvt_base::result
    do_unshift (state_type&,
                extern_type*, extern_type*, extern_type*&) const {
        return codecvt_base::error;
    }

    virtual int do_encoding () const throw() {
        return -1;
    }

    virtual bool do_always_noconv () const throw() {
        return false;
    }
};


template <class _InternT,class _ExternT,class _StateT>
typename codecvt<_InternT,_ExternT,_StateT>::internal_string_type
codecvt<_InternT,_ExternT,_StateT>::in (const external_string_type &__s) const
{
    int __n = 1000;



    const extern_type* __unused_from;
    intern_type* __unused_to;

    intern_type *__conversion_buffer = new intern_type[__n];

    state_type __stt (0);

    __n = do_in (__stt,
                 __s.c_str(), __s.c_str() + __s.length(), __unused_from,
                 __conversion_buffer, __conversion_buffer + __n, __unused_to);

    internal_string_type __result (__conversion_buffer,
                                   __conversion_buffer + __n);

    delete[] __conversion_buffer;

    return __result;
}


template<>
class codecvt_byname<wchar_t, char, mbstate_t>
    : public codecvt<wchar_t, char, mbstate_t>
{
public:

    explicit codecvt_byname (const char* = 0, size_t __ref = 0)
        : codecvt<wchar_t, char, mbstate_t> (__ref) { }

protected:

    virtual codecvt_base::result
    do_out (state_type&,
            const intern_type*, const intern_type*, const intern_type*&,
            extern_type*, extern_type*, extern_type*&) const;

    virtual codecvt_base::result
    do_in (state_type&,
           const extern_type*, const extern_type*, const extern_type*&,
           intern_type*, intern_type*, intern_type*&) const;

    virtual codecvt_base::result
    do_unshift (state_type&,
                extern_type*, extern_type*, extern_type*&) const;

    virtual int do_encoding () const throw() {



        return mbtowc (0, 0, 0) ? -1 : 1;
    }

    virtual bool do_always_noconv () const throw() {
        return false;
    }

    virtual int do_max_length () const throw() {


        return __nl_char_size;
    }
};


inline codecvt_base::result
codecvt_byname <wchar_t, char, mbstate_t>::
do_unshift (mbstate_t& __state,
            extern_type* __to, extern_type* __to_end,
            extern_type*& __to_next) const
{
    intern_type __c = intern_type ();
    const intern_type *__dummy = 0;




    return do_out (__state, &__c, &__c + 1, __dummy,
                   __to, __to_end, __to_next);
}


}
namespace std {






template <class _InternT,class _ExternT,class _StateT>
locale::id codecvt<_InternT,_ExternT,_StateT>::id;


}
namespace std {
template <class _Facet>
const _Facet& use_facet (const locale &__loc )
{
    const _Facet &__facet = static_cast< const _Facet& >(__loc._C_use_facet (_Facet::id, _Facet::_C_ok_implicit, _Facet::_C_facet_cat, __rw::__rw_facet_maker<_Facet>::_C_maker_func));





    return __facet;
}






template <class _Facet>
inline bool
has_facet (const locale &__loc )
    throw()
{
    return _Facet::_C_ok_implicit || __loc._C_get_facet (_Facet::id);
}







template <class _CharT>
inline bool isspace (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::space, __c);
}


template <class _CharT>
inline bool isprint (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::print, __c);
}

template <class _CharT>
inline bool iscntrl (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);
}


template <class _CharT>
inline bool isupper (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::upper, __c);
}


template <class _CharT>
inline bool islower (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::lower, __c);
}


template <class _CharT>
inline bool isalpha (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::alpha, __c);
}


template <class _CharT>
inline bool isdigit (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::digit, __c);
}


template <class _CharT>
inline bool ispunct (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is(ctype_base::punct, __c);
}


template <class _CharT>
inline bool isxdigit (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::xdigit, __c);
}


template <class _CharT>
inline bool isalnum (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::alnum, __c);
}


template <class _CharT>
inline bool isgraph (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).is (ctype_base::graph, __c);
}


template <class _CharT>
inline _CharT toupper (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).toupper (__c);
}


template <class _CharT>
inline _CharT tolower (_CharT __c, const locale& __loc)
{
    return use_facet < ctype<_CharT> >(__loc).tolower (__c);
}


}
namespace std {


template<class _CharT, class _Traits>
class basic_ios : public ios_base
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::int_type off_type;

protected:

    typedef basic_streambuf<char_type, traits_type> streambuf_type;
    typedef basic_ostream<char_type, traits_type> ostream_type;

public:




    explicit basic_ios (streambuf_type *__sb) {
        init (__sb);
    }

    operator void*() const {
        return fail () ? (void*)0 : (void*)1;
    }

    bool operator! () const {
        return fail ();
    }

    iostate rdstate () const {
        return _C_state;
    }


    iostate clear (iostate __st, iostate __mask);

    void clear (iostate __st = goodbit) {
        clear (__st, ~0);
    }


    iostate setstate (iostate __st, iostate __mask) {
        return clear (rdstate () | __st, __mask);
    }

    void setstate (iostate __st) {
        clear (rdstate () | __st);
    }

    bool good () const {
        return goodbit == rdstate ();
    }

    bool eof () const {
        return 0 != (rdstate () & eofbit);
    }

    bool fail () const {
        return 0 != (rdstate () & (failbit | badbit));
    }

    bool bad () const {
        return 0 != (rdstate () & badbit);
    }

    iostate exceptions () const {
        return _C_except;
    }

    void exceptions (iostate);

    ostream_type* tie () const {
        return _C_tiestrm;
    }

    ostream_type* tie (ostream_type *__strm) {
        return __rw::__rw_atomic_exchange ((_C_tiestrm), (__strm), false);
    }




    streambuf_type* rdbuf () const {
        return _C_strmbuf;
    }

    streambuf_type* rdbuf (streambuf_type *__sb);

    basic_ios& copyfmt (const basic_ios& __rhs);

    char_type fill () const {
        return _C_fillch;
    }

    char_type fill (char_type __c) {
        return __rw::__rw_atomic_exchange ((_C_fillch), (__c), false);
    }

    locale imbue (const locale&);

    char narrow (char_type __c, char __dflt) const {
        return use_facet < ctype<char_type> >(getloc ()).narrow (__c, __dflt);
    }

    char_type widen (char __c) const {
        return use_facet < ctype<char_type> >(getloc ()).widen (__c);
    }

protected:



    basic_ios () { }

    void init (streambuf_type*);

private:

    basic_ios (const basic_ios&);
    basic_ios& operator= (const basic_ios&);

    streambuf_type *_C_strmbuf;
    ostream_type *_C_tiestrm;
    char_type _C_fillch;
};



template<class _CharT, class _Traits>
inline ios_base::iostate
basic_ios<_CharT, _Traits>::clear (ios_base::iostate __st ,
                                   ios_base::iostate __mask )
{
    ((void)0);

    return _C_unsafe_clear (rdbuf () ? __st : __st | badbit, __mask);
}


template<class _CharT, class _Traits>
inline void basic_ios<_CharT, _Traits>::exceptions (iostate __ex)
{
    ((void)0);

    _C_except = __ex;

    _C_unsafe_clear (rdbuf () ? rdstate () : rdstate () | badbit);
}


template<class _CharT, class _Traits>
inline typename basic_ios<_CharT, _Traits>::streambuf_type*
basic_ios<_CharT, _Traits>::rdbuf (streambuf_type *__sb)
{
    ((void)0);

    streambuf_type *__tmp = _C_strmbuf;


    _C_unsafe_clear ((_C_strmbuf = __sb) ? goodbit : badbit);

    return __tmp;
}


template<class _CharT, class _Traits>
inline locale basic_ios<_CharT, _Traits>::imbue (const locale& __loc)
{
    ((void)0);

    locale __tmp = _C_unsafe_imbue (__loc);

    if (rdbuf ())
        rdbuf()->pubimbue (__loc);

    return __tmp;
}


template<class _CharT, class _Traits>
inline basic_ios<_CharT, _Traits>&
basic_ios<_CharT, _Traits>::copyfmt (const basic_ios<_CharT, _Traits>& __rhs)
{
    ((void)0);


    _C_copyfmt (__rhs);

    _C_tiestrm = __rhs._C_tiestrm;
    _C_fillch = __rhs._C_fillch;


    _C_fire_event (copyfmt_event, true);


    _C_except = __rhs._C_except;


    _C_unsafe_clear (rdstate ());

    return *this;
}


template<class _CharT, class _Traits>
inline void basic_ios<_CharT, _Traits>::init (streambuf_type *__sb)
{
    ((void)0);




    _C_state = (_C_strmbuf = __sb) ? goodbit : badbit;
    _C_tiestrm = 0;
    _C_except = goodbit;
    _C_fmtfl = skipws | dec;
    _C_wide = 0;
    _C_prec = 6;
    _C_fillch = widen (' ');
}


}
namespace std {


}
namespace std {


template<class _CharT, class _Traits>
class basic_streambuf: public __rw::__rw_synchronized
{
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    virtual ~basic_streambuf () { }

    locale pubimbue (const locale &__loc);

    locale getloc () const {
        return _C_locale;
    }




    locale& getloc () {
        return _C_locale;
    }

    basic_streambuf* pubsetbuf (char_type *__buf, streamsize __n) {
        return setbuf (__buf, __n);
    }

    pos_type pubseekoff (off_type __off, ios::seekdir __way,
                         ios::openmode __which = ios::in | ios::out) {
        return seekoff (__off, __way, __which);
    }

    pos_type pubseekpos (pos_type __sp,
                         ios::openmode __which = ios::in | ios::out) {
        return seekpos (__sp, __which);
    }

    int pubsync () {
        return sync ();
    }

    streamsize in_avail () {
        return gptr () < egptr () ? streamsize (egptr () - gptr ())
            : showmanyc ();
    }

    int_type snextc () {
        return _C_is_eof (sbumpc ()) ? traits_type::eof () : sgetc ();
    }

    int_type sbumpc ();

    int_type sgetc () {
        return gptr () >= egptr () ? underflow ()
            : traits_type::to_int_type (*gptr ());
    }

    streamsize sgetn (char_type *__s, streamsize __n) {
        ((void)0);
        return xsgetn (__s, __n);
    }

    int_type sputbackc (char_type);
    int_type sungetc ();

    int_type sputc (char_type __c);

    streamsize sputn (const char_type *__s, streamsize __n) {
        ((void)0);
        return xsputn (__s, __n);
    }

    ios::openmode _C_mode () const {
        return _C_iomode;
    }

protected:


    basic_streambuf (ios::openmode __mode = ios::in | ios::out)
        : _C_iomode (__mode),
          _C_buffer (0),
          _C_bufsize (0),
          _C_bufstate (0),
          _C_eback (0),
          _C_gptr (0),
          _C_egptr (0),
          _C_pbase (0),
          _C_pptr (0),
          _C_epptr (0)
        { }

    char_type* eback () const {
        return _C_eback;
    }

    char_type* gptr () const {
        return _C_gptr;
    }

    char_type* egptr () const {
        return _C_egptr;
    }

    void gbump (int __n) {
        ((void)0);
        _C_gptr += __n;
    }

    void setg (char_type *__eback, char_type *__gptr, char_type *__egptr) {
        _C_eback = __eback;
        _C_gptr = __gptr;
        _C_egptr = __egptr;
    }

    char_type* pbase () const {
        return _C_pbase;
    }

    char_type* pptr () const {
        return _C_pptr;
    }

    char_type* epptr () const {
        return _C_epptr;
    }

    void pbump (int __n) {
        _C_pptr += __n;
    }

    void setp (char_type *__pbase, char_type *__epptr) {
        _C_pbase = _C_pptr = __pbase;
        _C_epptr = __epptr;
    }


    virtual void imbue (const locale &__loc) {
        _C_locale = __loc;
    }

    virtual basic_streambuf* setbuf (char_type*, streamsize ) {
        return this;
    }

    virtual pos_type seekoff (off_type , ios::seekdir ,
                              ios::openmode = ios::in | ios::out) {
        return pos_type (off_type (-1));
    }

    virtual pos_type seekpos (pos_type ,
                              ios::openmode = ios::in | ios::out) {
        return pos_type (off_type (-1));
    }

    virtual streamsize showmanyc () {
        return 0;
    }

    virtual streamsize xsgetn (char_type *, streamsize);

    virtual int_type underflow () {
        return traits_type::eof ();
    }

    virtual int_type uflow ();

    virtual int_type overflow (int_type = traits_type::eof ()) {
        return traits_type::eof ();
    }

    virtual int_type pbackfail (int_type = traits_type::eof ()) {
        return traits_type::eof ();
    }

    virtual streamsize xsputn (const char_type*, streamsize);

    virtual int sync () {
        return 0;
    }







    streamsize _C_read_avail () const {
        return _C_is_in () ? egptr () - gptr () : 0;
    }


    streamsize _C_write_avail () const {
        return _C_is_out () ? epptr () - pptr () : 0;
    }


    streamsize _C_putback_avail () const {
        return (_C_is_in () && gptr () != 0) ? gptr () - eback () : 0;
    }


    bool _C_is_in () const {
        return 0 != (_C_iomode & ios::in);
    }


    bool _C_is_out () const {
        return 0 != (_C_iomode & ios::out);
    }


    bool _C_is_inout () const {
        return (_C_iomode & (ios::in | ios::out)) == (ios::in | ios::out);
    }


    bool _C_is_eof (int_type __c) const {
        return traits_type::eq_int_type (__c, traits_type::eof ());
    }


    char_type* _C_buf_end () const {
        return _C_buffer + _C_bufsize;
    }


    enum {
        _C_allocated = 0x1,
        _C_out_mode = 0x2,
        _C_unbuf_mode = 0x4
    };

    bool _C_own_buf () const {
        return 0 != (_C_bufstate & _C_allocated);
    }

    void _C_own_buf (bool __own) {
        if (__own)
            _C_bufstate |= _C_allocated;
        else
            _C_bufstate &= ~_C_allocated;
    }

    bool _C_out_last () const {
        return 0 != (_C_bufstate & _C_out_mode);
    }

    void _C_out_last (bool __last) {
        if (__last)
            _C_bufstate |= _C_out_mode;
        else
            _C_bufstate &= ~_C_out_mode;
    }

    bool _C_is_unbuffered () const {
        return 0 != (_C_bufstate & _C_unbuf_mode);
    }

    void _C_set_unbuffered (bool __unbuf) {
        if (__unbuf)
            _C_bufstate |= _C_unbuf_mode;
        else
            _C_bufstate &= ~_C_unbuf_mode;
    }


    ios::openmode _C_iomode;
    char_type* _C_buffer;
    streamsize _C_bufsize;
    int _C_bufstate;

private:

    char_type *_C_eback;
    char_type *_C_gptr;
    char_type *_C_egptr;

    char_type *_C_pbase;
    char_type *_C_pptr;
    char_type *_C_epptr;

    locale _C_locale;
};

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::uflow ()
{
    if (_C_is_eof (underflow ()))
        return traits_type::eof ();

    return traits_type::to_int_type (*_C_gptr++);
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sbumpc ()
{
    if (! _C_read_avail ())
        return uflow ();

    char_type __c = *gptr ();
    gbump (1);

    return traits_type::to_int_type (__c);
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputbackc (char_type __c)
{
    if (_C_putback_avail () && traits_type::eq (gptr ()[-1], __c) ) {
        gbump (-1);
        return traits_type::to_int_type (*gptr ());
    }

    return pbackfail (traits_type::to_int_type (__c));
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sputc (char_type __c)
{
    if (_C_write_avail ()) {
        traits_type::assign (*_C_pptr++, __c);
        return traits_type::to_int_type (__c);
    }

    return overflow (traits_type::to_int_type (__c));
}

template<class _CharT, class _Traits>
inline typename basic_streambuf<_CharT, _Traits>::int_type
basic_streambuf<_CharT, _Traits>::sungetc ()
{
    if (gptr () > eback ()) {
        gbump (-1);
        return traits_type::to_int_type (*gptr ());
    }

    return pbackfail ();
}


template<class _CharT, class _Traits>
inline streamsize
basic_streambuf<_CharT, _Traits>::xsgetn (char_type* __buf, streamsize __n)
{
    streamsize __nget = 0;

    for (; __nget < __n; ++__nget) {
        int_type __c = sbumpc ();
        if (_C_is_eof (__c))
            break;
        traits_type::assign (*__buf++, traits_type::to_char_type (__c));
    }

    return __nget;
}

template<class _CharT, class _Traits>
inline streamsize
basic_streambuf<_CharT, _Traits>::xsputn (const char_type* __buf,
                                          streamsize __n)
{
    streamsize __nput = 0;

    for (; __nput < __n; ++__nput)
        if (_C_is_eof (sputc (*__buf++)))
            break;

    return __nput;
}

template<class _CharT, class _Traits>
inline locale
basic_streambuf<_CharT, _Traits>::pubimbue (const locale &__loc)
{
    locale __retloc = getloc ();
    imbue (__loc);
    return __retloc;
}


template<class _CharT, class _Traits >
class ostreambuf_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_streambuf<char_type, traits_type> streambuf_type;
    typedef basic_ostream<char_type, traits_type> ostream_type;

    ostreambuf_iterator (ostream_type &__strm) throw()
    : _C_sb (__strm.rdbuf ()) { }

    ostreambuf_iterator (streambuf_type *__sb) throw()
    : _C_sb (__sb) { }

    ostreambuf_iterator& operator* () {
        return *this;
    }

    ostreambuf_iterator& operator++ () {
        return *this;
    }

    ostreambuf_iterator& operator++ (int) {
        return *this;
    }

    ostreambuf_iterator& operator= (char_type __c) {
        if (!failed () && traits_type::eq_int_type (_C_sb->sputc (__c),
                                                    traits_type::eof ()))
            _C_sb = 0;
        return *this;
    }

    bool failed () const throw() {
        return !_C_sb;
    }

private:
    streambuf_type *_C_sb;
};


template<class _CharT, class _Traits >
class istreambuf_iterator
    : public iterator<input_iterator_tag, _CharT,
                      typename _Traits::off_type, _CharT*, _CharT&>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;

    typedef typename traits_type::int_type int_type;

    typedef basic_streambuf<char_type, traits_type> streambuf_type;
    typedef basic_istream<char_type, traits_type> istream_type;


    class proxy {
        char_type _C_keep;
        streambuf_type *_C_sb;

        proxy (char_type __c, streambuf_type *__sb)
            : _C_keep (__c), _C_sb (__sb) { }

    public:

        char_type operator* () const {
            return _C_keep;
        }

        friend class istreambuf_iterator<char_type, traits_type>;
    };

public:

    istreambuf_iterator () throw()
    : _C_sb (0) { }

    istreambuf_iterator (istream_type& __strm) throw()
    : _C_sb (__strm.rdbuf ()) { }

    istreambuf_iterator (streambuf_type *__sb) throw()
    : _C_sb (__sb) { }

    istreambuf_iterator (const proxy &__proxy) throw()
    : _C_sb (__proxy._C_sb) { }

    char_type operator*() const {
        return traits_type::to_char_type (_C_sb ? _C_sb->sgetc ()
                                          : traits_type::eof ()) ;
    }

    istreambuf_iterator& operator++ () {
        if (_C_sb)
            _C_sb->sbumpc ();
        return *this;
    }

    proxy operator++ (int);


    bool equal (const istreambuf_iterator& __rhs) const {
        return (_C_sb ? _C_sb->sgetc () : traits_type::eof ())
               == (__rhs._C_sb ? __rhs._C_sb->sgetc () : traits_type::eof ());
    }

private:
    streambuf_type *_C_sb;
};


template<class _CharT, class _Traits>
inline typename istreambuf_iterator<_CharT, _Traits>::proxy
istreambuf_iterator<_CharT, _Traits>::operator++(int)
{
    int_type __c = _C_sb ? _C_sb->sgetc () : traits_type::eof ();

    if (!traits_type::eq_int_type (__c, traits_type::eof ()))
        _C_sb->sbumpc ();

    return proxy (traits_type::to_char_type (__c), _C_sb);
}

template<class _CharT, class _Traits>
inline bool
operator== (const istreambuf_iterator<_CharT, _Traits>& __x,
            const istreambuf_iterator<_CharT, _Traits>& __y)
{
    return __x.equal (__y);
}


template<class _CharT, class _Traits>
inline bool
operator!= (const istreambuf_iterator<_CharT, _Traits>& __x,
            const istreambuf_iterator<_CharT, _Traits>& __y)
{
    return !(__x == __y);
}


typedef basic_streambuf<char, char_traits<char> > streambuf;




typedef basic_streambuf<wchar_t, char_traits<wchar_t> > wstreambuf;




}





namespace __rw {


template <class _CharT, class _Traits, class _NativeType>
std::basic_ostream<_CharT, _Traits>&
__rw_insert (std::basic_ostream<_CharT, _Traits> &__strm,
             _NativeType __val);



template<class _CharT, class _Traits, class _StringT>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _StringT *__s,
             streamsize __len,
             streamsize __width);

}


namespace std {


template<class _CharT, class _Traits>
class basic_ostream:
    virtual public basic_ios<_CharT, _Traits>
{

public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_ios<char_type, traits_type> ios_type;


    explicit basic_ostream (basic_streambuf<char_type, traits_type> *__sb) {
        this->init (__sb);
    }


    basic_ostream& _C_opfx ();


    class sentry: public __rw::__rw_guard {
        sentry (const sentry&);
        sentry& operator= (const sentry&);

    public:

        explicit
        sentry (basic_ostream<char_type, traits_type> &__strm)
            : __rw::__rw_guard (__strm.rdbuf () ? &__strm.rdbuf ()->_C_mutex : 0),
              _C_strm (__strm) {
                _C_ok = _C_strm._C_opfx ().good ();
            }


        ~sentry () {
            if ( ( _C_strm.flags () & ios_base::unitbuf
                    || _C_strm._C_is_sync ()
                    && _C_strm._C_is_std ())


                 && -1 == _C_strm.rdbuf ()->pubsync ()) {


                _C_strm.setstate (ios_base::badbit, 0);

            }
        }

        operator bool () const {
            return _C_ok;
        }

    private:

        basic_ostream& _C_strm;
        bool _C_ok;
    };




    basic_ostream& operator<< (basic_ostream& (*__pf)(basic_ostream&)) {
        return (*__pf)(*this);
    }


    basic_ostream& operator<< (ios_base& (*__pf)(ios_base&)) {
        return (*__pf)(*this), *this;
    }


    basic_ostream& operator<< (ios_type& (*__pf)(ios_type&)) {
        return (*__pf)(*this), *this;
    }





    basic_ostream& operator<<(bool __val) {
        return __rw::__rw_insert (*this, __val);
    }



    basic_ostream& operator<< (short __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned short __val) {
        return *this << static_cast< unsigned long >(__val);
    }

    basic_ostream& operator<< (int __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned int __val) {
        return *this << static_cast< unsigned long >(__val);
    }

    basic_ostream& operator<< (long __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (unsigned long __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (float __val) {
        return *this << static_cast<double>(__val);
    }

    basic_ostream& operator<< (double __val) {
        return __rw::__rw_insert (*this, __val);
    }

    basic_ostream& operator<< (long double __val) {
        return __rw::__rw_insert (*this, __val);
    }
    basic_ostream& operator<< (const void *__val) {
        return __rw::__rw_insert (*this, __val);
    }


    basic_ostream& operator<< (basic_streambuf<char_type, traits_type>&);


    basic_ostream&
    operator<< (basic_streambuf<char_type, traits_type> *__sb) {
        return __sb ? *this << *__sb : (this->setstate (ios::badbit), *this);
    }




    basic_ostream& put (char_type __c) {
        return __rw::__rw_insert (*this, &__c, 1, 0 );
    }


    basic_ostream& write (const char_type *__s, streamsize __len) {
        return __rw::__rw_insert (*this, __s, __len, 0 );
    }


    basic_ostream& flush ();




    pos_type tellp ();


    basic_ostream& seekp (pos_type __pos) {

        ((void)0);
        ((void)0);

        if (!this->fail ())
            this->rdbuf ()->pubseekpos (__pos, ios_base::out);

        return *this;
    }


    basic_ostream& seekp (off_type, ios_base::seekdir);


    bool _C_is_cout () const {
        return false;
    }

    bool _C_is_cerr () const {
        return false;
    }


    bool _C_is_std () const {
        return false;
    }


    streamsize _C_pad (streamsize);
};


template<class _CharT, class _Traits>
inline streamsize
basic_ostream<_CharT, _Traits>::_C_pad (streamsize __len)
{

    for (streamsize __i = 0; __i < __len; ++__i) {
        if (traits_type::eq_int_type (this->rdbuf ()->sputc (this->fill ()),
                                      traits_type::eof ())) {
            return __i;
        }
    }
    return __len;
}



extern const void* __rw_std_streams[];


template<>
inline bool
basic_ostream<char, char_traits<char> >::_C_is_cout () const
{

    return static_cast< const ios_base* >(this) == __rw_std_streams [1];
}


template<>
inline bool
basic_ostream<char, char_traits<char> >::_C_is_cerr () const
{

    return static_cast< const ios_base* >(this) == __rw_std_streams [2];
}


template<>
inline bool
basic_ostream<char, char_traits <char> >::_C_is_std () const
{

    return _C_is_cout () || _C_is_cerr ()
        || static_cast< const ios_base* >(this) == __rw_std_streams [3];
}




template<>
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_cout () const
{

    return static_cast< const ios_base* >(this) == __rw_std_streams [5];
}


template<>
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_cerr () const
{

    return static_cast< const ios_base* >(this) == __rw_std_streams [6];
}


template<>
inline bool
basic_ostream<wchar_t, char_traits <wchar_t> >::_C_is_std () const
{

    return _C_is_cout () || _C_is_cerr ()
        || static_cast< const ios_base* >(this) == __rw_std_streams [7];
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::flush ()
{
    if (this->rdbuf ()) {
        ((void)0);

        if (-1 == this->rdbuf ()->pubsync ())
            this->setstate (ios_base::badbit);
    }

    return *this;
}


template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::seekp (off_type __off, ios_base::seekdir __dir)
{
    ((void)0);

    ((void)0);

    if (!this->fail ())
        this->rdbuf()->pubseekoff (__off, __dir, ios_base::out);

    return *this;
}


template<class _CharT, class _Traits>
inline typename basic_ostream<_CharT, _Traits>::pos_type
basic_ostream<_CharT, _Traits>::tellp ()
{
    ((void)0);

    ((void)0);

    return this->fail() ? pos_type (-1)
        : this->rdbuf()->pubseekoff (0, ios_base::cur, ios_base::out);
}


template <class _TypeT,
          class _CharT ,
          class _Traits >
class ostream_iterator
    : public iterator<output_iterator_tag, _TypeT,
                      typename _Traits::off_type, _TypeT*, _TypeT&>
{
    typedef iterator<output_iterator_tag, _TypeT,
                     typename _Traits::off_type, _TypeT*, _TypeT&> _C_base;
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_ostream<char_type, traits_type> ostream_type;


    typedef typename _C_base::value_type value_type;
    typedef typename _C_base::difference_type difference_type;
    typedef typename _C_base::pointer pointer;
    typedef typename _C_base::reference reference;
    typedef typename _C_base::iterator_category iterator_category;

    ostream_iterator (ostream_type& __strm)
      : _C_strm (&__strm), _C_str (0) { }

    ostream_iterator (ostream_type& __strm, const char_type* __s)
      : _C_strm (&__strm), _C_str (__s) { }

    ostream_iterator& operator= (const value_type &__val) {
        *_C_strm << __val;
        if (_C_str)
            *_C_strm << _C_str;
        return *this;
    }

    ostream_iterator& operator* () { return *this; }
    ostream_iterator& operator++ () { return *this; }
    ostream_iterator& operator++ (int) { return *this; }

protected:

    ostream_type* _C_strm;
    const char_type* _C_str;
};




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, _CharT __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, char __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}




template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, char __c)
{
    __rw::__rw_insert (__strm, &__c, 1, __strm.width ()).width (0);
    return __strm;
}
template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, const _CharT *__s)
{
    __rw::__rw_insert (__strm, __s, _Traits::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}




template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> &__strm, const char *__s)
{
    __rw::__rw_insert (__strm, __s, char_traits<char>::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}




template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, const char *__s)
{
    __rw::__rw_insert (__strm, __s, char_traits<char>::length (__s),
                      __strm.width ()).width (0);
    return __strm;
}
template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, unsigned char __c)
{
    return __strm << static_cast< char >(__c);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, signed char __c)
{
    return __strm << static_cast< char >(__c);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits> &__strm, const unsigned char *__s)
{
    return __strm << reinterpret_cast< const char* >(__s);
}


template <class _Traits>
inline basic_ostream<char, _Traits>&
operator<< (basic_ostream<char, _Traits>& __strm, const signed char *__s)
{
    return __strm << reinterpret_cast< const char* >(__s);
}






template<class _CharT, class _Traits, class _Allocator>
inline basic_ostream<_CharT, _Traits>&
operator<< (basic_ostream<_CharT, _Traits> & __strm,
            const basic_string<_CharT, _Traits, _Allocator> &__str)
{
    __rw::__rw_insert (__strm, __str.data (), __str.length (),
                      __strm.width ()).width (0);
    return __strm;
}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
endl (basic_ostream<_CharT, _Traits>& __strm)
{
    return __strm.put (__strm.widen ('\n')).flush ();
}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
ends (basic_ostream<_CharT, _Traits>& __strm)
{
    return __strm.put (_CharT ());
}



template<class _CharT, class _Traits>
inline basic_ostream<_CharT, _Traits>&
flush (basic_ostream<_CharT, _Traits>& __strm)
{
    return __strm.flush ();
}


}
namespace __rw {

using namespace std;

template <class _CharT, class _Traits, class _NativeType>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _NativeType __val)
{
    ios::iostate __err = ios::goodbit;

    typename basic_ostream<_CharT, _Traits>::sentry __opfx (__strm);

    try {

        if (__opfx) {

            typedef num_put<_CharT, ostreambuf_iterator<_CharT, _Traits> >
                __num_put_t;

            if (use_facet < __num_put_t >(__strm.getloc ())
                .put (ostreambuf_iterator<_CharT, _Traits>(__strm), __strm,
                      __strm.fill (), __val).failed ())
                __err = ios::badbit;

            __strm.width (0);
        }
    }
    catch (...) {
        if (__strm.setstate (ios::badbit, 0))
            throw;
    }

    if (__err)
        __strm.setstate (__err);

    return __strm;
}



template <class _CharT, class _Traits>
inline streamsize
__rw_sputn (basic_ostream<_CharT, _Traits> &__strm,
            const _CharT*__s, streamsize __len)
{
    return __strm.rdbuf ()->sputn (__s, __len);

}





template <class _CharT, class _Traits>
inline streamsize
__rw_sputn (basic_ostream<_CharT, _Traits> &__strm,
            const char *__s, streamsize __len)
{
    ((void)0);

    const ctype<_CharT>& __ct = use_facet < ctype<_CharT> >(__strm.getloc ());

    for (streamsize __i = 0; __i < __len; ++__i) {
        typename basic_ostream<_CharT, _Traits>::int_type __n =
            __strm.rdbuf ()->sputc (__ct.widen (__s [__i]));
        if (_Traits::eq_int_type (__n, _Traits::eof ()))
            return __i;
    }

    return __len;
}



template <class _Traits>
inline streamsize
__rw_sputn (basic_ostream<char, _Traits> &__strm,
            const char*__s, streamsize __len)
{
    return __strm.rdbuf ()->sputn (__s, __len);
}
template<class _CharT, class _Traits, class _StringT>
basic_ostream<_CharT, _Traits>&
__rw_insert (basic_ostream<_CharT, _Traits> &__strm,
             _StringT *__s,
             streamsize __len,
             streamsize __width)
{
    ((void)0);
    ((void)0);

    ios::iostate __err = ios::goodbit;

    try {

        typename basic_ostream<_CharT, _Traits>::sentry __opfx (__strm);

        if (__opfx) {



            const int __pad = __width - __len;
            const int __padbits = ios::adjustfield & __strm.flags ();


            if ( ios::left != __padbits
                && __pad != __strm._C_pad (__pad))
                __err = ios::badbit;


            if ( ios::goodbit == __err
                && __len && __len != __rw_sputn (__strm, __s, __len))
                __err = ios::badbit;


            if ( ios::goodbit == __err
                && ios::left == __padbits
                && __pad != __strm._C_pad (__pad))
                __err = ios::badbit;
        }
    }
    catch (...) {
        if (__strm.setstate (ios::badbit, 0 ))
            throw;
    }

    if (__err)
        __strm.setstate (__err);

    return __strm;
}


}


namespace std {


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::_C_opfx ()
{
    if (this->tie ())
        this->tie ()->flush ();

    if (this->_C_is_sync ()) {

        if (_C_is_cout ())
            fflush ((&__iob[1]));
        else if (_C_is_std ())
            fflush ((&__iob[2]));
    }


    if ( this->rdbuf ()
        && this->rdbuf ()->_C_mode () & ios_base::app)
        this->rdbuf ()->pubseekoff (0, ios::seekdir (ios::end), ios::out);

    return *this;
}


template<class _CharT, class _Traits>
basic_ostream<_CharT, _Traits>&
basic_ostream<_CharT, _Traits>::
operator<< (basic_streambuf<_CharT, _Traits>& __sb)
{
    ios_base::iostate __err = 0;

    bool __extracted = false;

    if (__sb._C_mode () & ios_base::in) {

        sentry opfx (*this);

        try {

            if (opfx) {
                if (_Traits::eq_int_type (__sb.sgetc (), _Traits::eof ()))
                    __err = ios_base::failbit;
                else {
                    while (true) {
                        int_type __c = __sb.sbumpc ();
                        if (_Traits::eq_int_type (__c, _Traits::eof ()))
                            break;
                        if (_Traits::eq_int_type (this->rdbuf ()->sputc (__c),
                                                  _Traits::eof ())) {
                            __err = ios_base::failbit;
                            break;
                        }
                        __extracted = true;
                    }
                }
            }
        }
        catch (...) {
            if (this->setstate (ios_base::badbit, 0))
                throw;
        }
    }

    if (!__extracted)
        __err = ios_base::failbit;

    if (__err)
        this->setstate (__err);

    return *this;
}


}
namespace __rw {

template <class _CharT, class _Traits, class _NativeType>
inline std::basic_istream<_CharT, _Traits>&
__rw_extract (std::basic_istream<_CharT, _Traits> &__strm,
              _NativeType &__val);

}


namespace std {


template<class _CharT, class _Traits>
class basic_istream
    : virtual public basic_ios<_CharT, _Traits>
{
public:

    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef typename traits_type::int_type int_type;
    typedef typename traits_type::pos_type pos_type;
    typedef typename traits_type::off_type off_type;

    typedef basic_ios<char_type, traits_type> ios_type;
    typedef basic_streambuf<char_type, traits_type> streambuf_type;

    explicit basic_istream (streambuf_type *__sb)
        : _C_chcount (0) {
        this->init (__sb);
    }


    basic_istream& _C_ipfx (int __flags);

    class sentry: public __rw::__rw_guard
    {
        bool _C_ok;

        sentry (const sentry&);
        sentry& operator= (const sentry&);

    public:


        explicit sentry (basic_istream &__strm, bool __noskipws = false)
            : __rw::__rw_guard (__strm.rdbuf ()->_C_mutex) {
            int __flags = (__strm.flags () & ios::skipws && !__noskipws ?
                _C_skipws : 0) | _C_faileof;
                _C_ok = __strm._C_ipfx (__flags).good ();
            }

        operator bool () const {
            return _C_ok;
        }
    };


    basic_istream& operator>> (basic_istream& (*__pf)(basic_istream&)) {
        return (*__pf)(*this);
    }


    basic_istream& operator>> (ios_base& (*__pf)(ios_base&)) {
        return (*__pf)(*this), *this;
    }


    basic_istream& operator>>(ios_type& (*__pf)(ios_type&)) {
        return (*__pf)(*this), *this;
    }



    basic_istream& operator>> (bool &__val) {
        return __rw::__rw_extract (*this, __val);
    }



    basic_istream& operator>>(short &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned short &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(int &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned int &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(long &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(unsigned long &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(float &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(double &__val) {
        return __rw::__rw_extract (*this, __val);
    }

    basic_istream& operator>>(long double &__val) {
        return __rw::__rw_extract (*this, __val);
    }
    basic_istream& operator>>(void* &__val) {
        return __rw::__rw_extract (*this, __val);
    }


    basic_istream& operator>> (streambuf_type& __sb) {

        return get (__sb, traits_type::eof ());
    }


    basic_istream& operator>>(streambuf_type *__sb) {
        return __sb ? *this >> *__sb : (this->setstate (ios::badbit), *this);
    }




    int_type get () {
        return sentry (*this, true) ?
              _C_unsafe_get (&_C_chcount, traits_type::eof (), _C_faileof)
            : traits_type::eof ();
    }


    basic_istream& get (char_type& __ch) {
        return read (&__ch, 1, traits_type::eof (), _C_failnoi);
    }



    basic_istream& get (char_type *__s, streamsize __n, char_type __delim) {
        return read (__s, __n, traits_type::to_int_type (__delim),
                     _C_nullterm | _C_failnoi);
    }



    basic_istream& get (char_type *__s, streamsize __n) {
        return get (__s, __n, this->widen ('\n'));
    }



    basic_istream& get (streambuf_type*, int_type);


    basic_istream& get (streambuf_type& __sb, char_type __delim) {

        return get (&__sb, traits_type::to_int_type (__delim));
    }


    basic_istream& get (streambuf_type& __sb) {
        return get (__sb, this->widen ('\n'));
    }



    basic_istream& getline (char_type *__s, streamsize __n, char_type __delim) {

        return read (__s, __n, traits_type::to_int_type (__delim),
                     _C_nullterm | _C_eatdelim | _C_failend | _C_failnoi);
    }


    basic_istream& getline (char_type *__s, streamsize __n) {
        return getline (__s, __n, this->widen ('\n'));
    }


    basic_istream& ignore (streamsize __n = 1,
                           int_type __delim = traits_type::eof ()) {

        return read (0, __n, __delim, _C_eatdelim);
    }


    basic_istream& read (char_type*, streamsize, int_type, int);


    basic_istream& read (char_type *__s, streamsize __n) {
        return read (__s, __n, traits_type::eof (), _C_faileof);
    }


    streamsize readsome (char_type *__s, streamsize __n);


    int_type peek ();


    pos_type tellg ();


    basic_istream& seekg (pos_type);


    basic_istream& seekg (off_type, ios::seekdir);


    int sync ();


    basic_istream& putback (char_type);


    basic_istream& unget ();


    streamsize gcount () const {
        return _C_chcount;
    }


    enum {
        _C_nullterm = 0x01,
        _C_wsterm = 0x02,
        _C_skipws = 0x04,
        _C_eatdelim = 0x08,
        _C_faileof = 0x10,
        _C_failend = 0x20,
        _C_failnoi = 0x40
    };



    int_type _C_unsafe_get (streamsize* = 0,
                            int_type = traits_type::eof (),
                            int = 0);

protected:

    streamsize _C_chcount;
};



template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
ws (basic_istream<_CharT, _Traits> &__strm)
{
    return __strm._C_ipfx (basic_istream<_CharT, _Traits>::_C_skipws);
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg (pos_type __pos)
{
    ((void)0);

    if (!this->fail ()) {
        ((void)0);




        if (-1 == this->rdbuf ()->pubseekpos (__pos, ios::in))
            this->setstate (ios::failbit);
    }

    return *this;
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::seekg (off_type __off, ios::seekdir __dir)
{
    ((void)0);

    if (!this->fail ()) {
        ((void)0);




        if (-1 == this->rdbuf ()->pubseekoff (__off, __dir, ios::in))
            this->setstate (ios::failbit);
    }

    return *this;
}




template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm,
            unsigned char& __c)
{
    return __strm >> reinterpret_cast< char& >(__c);
}

template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm,
            signed char& __c)
{
    return __strm >> reinterpret_cast< char& >(__c);
}


template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm,
            unsigned char* __s)
{
    return __strm >> reinterpret_cast< char* >(__s);
}


template <class _Traits>
inline basic_istream<char, _Traits>&
operator>> (basic_istream<char, _Traits>& __strm,
            signed char* __s)
{
    return __strm >> reinterpret_cast< char* >(__s);
}




template<class _CharT, class _Traits>
inline typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::peek ()
{
    ((void)0);

    _C_chcount = 0;

    return sentry (*this, true) ? this->rdbuf ()->sgetc ()
                                : traits_type::eof ();
}


template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits> &__strm, _CharT &__c)
{

    return __strm.read (&__c, 1, _Traits::eof (),
                        __strm._C_skipws | __strm._C_failnoi);
}



template<class _CharT, class _Traits>
inline basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits> &__strm, _CharT *__s)
{
    ((void)0);


    const streamsize __maxlen = __strm.width () ? __strm.width () :
                                numeric_limits<streamsize>::max () - 1;


    __strm.read (__s, __maxlen, _Traits::to_int_type (__strm.widen ('\n')),
                   __strm._C_nullterm | __strm._C_wsterm
                 | __strm._C_skipws | __strm._C_failnoi);

    __strm.width (0);

    return __strm;
}


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Allocator>& __str);


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline (basic_istream<_CharT, _Traits>& __strm,
         basic_string<_CharT, _Traits, _Allocator>& __str,
         _CharT __delim);


template<class _CharT, class _Traits, class _Allocator>
inline basic_istream<_CharT, _Traits>&
getline (basic_istream<_CharT, _Traits>& __is,
         basic_string<_CharT, _Traits, _Allocator>& __str)
{
    return getline (__is, __str, __is.widen ('\n'));
}


template<class _CharT, class _Traits>
class basic_iostream
    : public basic_istream<_CharT, _Traits>,
      public basic_ostream<_CharT, _Traits>
{
public:
    explicit basic_iostream (basic_streambuf<_CharT, _Traits> *__sb)
        : basic_istream<_CharT, _Traits> (__sb),
          basic_ostream<_CharT, _Traits> (__sb)
        { }
};


template <class _TypeT,
          class _CharT ,
          class _Traits ,
          class _Distance >
class istream_iterator;

template <class _TypeT, class _CharT, class _Traits, class _Distance>
bool operator== (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>&,
                 const istream_iterator<_TypeT, _CharT, _Traits, _Distance>&);


template <class _TypeT,
          class _CharT ,
          class _Traits ,
          class _Distance >
class istream_iterator
    : public iterator<input_iterator_tag, _TypeT, _Distance,
                      const _TypeT*, const _TypeT&>
{
    friend bool operator== <>
        (const istream_iterator&, const istream_iterator&);

    typedef iterator<input_iterator_tag, _TypeT, _Distance,
                     const _TypeT*, const _TypeT&> _C_base;
public:
    typedef _CharT char_type;
    typedef _Traits traits_type;
    typedef basic_istream<char_type, traits_type> istream_type;


    typedef typename _C_base::value_type value_type;
    typedef typename _C_base::difference_type difference_type;
    typedef typename _C_base::pointer pointer;
    typedef typename _C_base::reference reference;
    typedef typename _C_base::iterator_category iterator_category;

    istream_iterator (): _C_strm (0) { }

    istream_iterator (istream_type& __s)
        : _C_strm (&__s) {
        ++*this;
    }

    reference operator* () const {
        return _C_val;
    }

    pointer operator->() const { return &**this; };

    istream_iterator& operator++ () {
        return _C_strm && !!*_C_strm && (*_C_strm >> _C_val), *this;
    }

    istream_iterator operator++ (int) {
        istream_iterator __tmp = *this;
        return ++*this, __tmp;
    }

protected:

    istream_type *_C_strm;
    value_type _C_val;
};


template <class _TypeT, class _CharT, class _Traits, class _Distance>
inline bool
operator== (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __x,
            const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __y)
{
    return (__x._C_strm && !!*__x._C_strm) == (__y._C_strm && !!*__y._C_strm);
}


template <class _TypeT, class _CharT, class _Traits, class _Distance>
inline bool
operator!= (const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __x,
            const istream_iterator<_TypeT, _CharT, _Traits, _Distance>& __y)
{
    return !(__x == __y);
}


}
extern const float _FLT_NANS;
extern const float _FLT_DMIN;





extern const double _DBL_NANS;
extern const double _DBL_DMIN;
extern const long double _LDBL_NANS;
extern const long double _LDBL_DMIN;
namespace __rw {

using namespace std;

template <class _CharT, class _Traits, class _NativeType>
basic_istream<_CharT, _Traits>&
__rw_extract (std::basic_istream<_CharT, _Traits> &__strm,
              _NativeType &__val)
{
    ((void)0);

    typedef istreambuf_iterator<_CharT, _Traits> _Iter;
    typedef num_get<_CharT, _Iter> _NumGet;

    ios::iostate __err = ios::goodbit;

    typename basic_istream<_CharT, _Traits>::sentry __ipfx (__strm);

    if (__ipfx) {
        try {
            use_facet < _NumGet >(__strm.getloc ())
                .get (_Iter (__strm), _Iter (), __strm, __err, __val);
        }
        catch (...) {
            if (__strm.setstate (ios::badbit, 0 ))
                throw;
        }
    }

    if (ios::goodbit != __err)
        __strm.setstate (__err);

    return __strm;
}


}


namespace std {


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::_C_ipfx (int __flags)
{
    ((void)0);

    ios::iostate __err = this->rdstate ();



    _C_chcount = 0;

    if (ios::goodbit == __err) {

        if (this->tie ())
            this->tie ()->flush ();

        if (_C_skipws & __flags) {

            int_type __c = this->rdbuf ()->sgetc ();


            locale &__loc = this->getloc ();

            while (1) {

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err = ios::eofbit;
                    break;
                }

                if (!isspace (traits_type::to_char_type (__c), __loc))
                    break;

                __c = this->rdbuf ()->snextc ();


                ++_C_chcount;
            }
        }
    }


    if (ios::goodbit != __err)
        this->setstate (__err | (_C_faileof & __flags ? ios::failbit : 0));

    return *this;
}


template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::int_type
basic_istream<_CharT, _Traits>::
_C_unsafe_get (streamsize *__cnt ,
               int_type __delim ,
               int __flags )
{
    ((void)0);

    ios::iostate __err = ios::goodbit;

    int_type __c = traits_type::eof ();

    try {


        __c = this->rdbuf ()->sgetc ();



        if (traits_type::eq_int_type (__c, traits_type::eof ()))
            __err = ios::eofbit | (__flags & _C_faileof ? ios::failbit : 0);
        else if ( ( _C_eatdelim & __flags
                     || !traits_type::eq_int_type (__c, __delim))
                 && ( !(_C_wsterm & __flags)
                     || !isspace (traits_type::to_char_type (__c),
                                  this->getloc()))) {
            if (traits_type::eq_int_type (this->rdbuf ()->sbumpc (),
                                          traits_type::eof ()))
                __err = ios::failbit;
            else if (__cnt)
                ++*__cnt;
        }
    }
    catch (...) {
        if (this->setstate (ios::badbit, 0 ))
            throw;
    }

    if (__err)
        this->setstate (__err);

    return __c;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::
get (streambuf_type* __sb, int_type __delim)
{
    ((void)0);
    ((void)0);

    ios::iostate __err = 0;

    sentry __ipfx (*this, true);

    if (__ipfx) {

        try {

            while (1) {
                int_type __c = this->rdbuf ()->sgetc ();

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err = ios::eofbit;
                    break;
                }

                if (traits_type::eq (traits_type::to_char_type (__c),
                                     __delim))
                    break;

                try {

                    __c = __sb->sputc (__c);
                }
                catch (...) {
                    __c = traits_type::eof ();
                }

                if (traits_type::eq_int_type (__c, traits_type::eof ())) {
                    __err = ios::failbit;
                    break;
                }

                ++_C_chcount;
                this->rdbuf ()->sbumpc ();
            }
        }
        catch (...) {
            if (this->setstate (ios::badbit, 0 ))
                throw;
        }

        if (__err)
            this->setstate (__err);
    }


    if (!gcount ())
        this->setstate (ios::failbit);

    return *this;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::read (char_type *__s,
                                      streamsize __n,
                                      int_type __delim,
                                      int __flags)
{


    ((void)0);
    ((void)0);


    sentry __ipfx (*this, !(_C_skipws & __flags));


    if (__ipfx) {


        if (_C_nullterm & __flags)
            traits_type::assign (*__s, char_type ());


        while (__n && (--__n || !(_C_nullterm & __flags))) {


            int_type __c = _C_unsafe_get (&_C_chcount, __delim, __flags);


            if ( traits_type::eq_int_type (__c, traits_type::eof())
                || traits_type::eq_int_type (__c, __delim))
                break;

            char_type __ch = traits_type::to_char_type (__c);


            if ( _C_nullterm & __flags && traits_type::eq (__ch, char_type ())
                || _C_wsterm & __flags && isspace (__ch, this->getloc ()))
                break;


            if (__s)
                traits_type::assign (*__s++, __ch);
        }

        if (_C_nullterm & __flags && __s)
            traits_type::assign (*__s, char_type ());
    }


    if ( _C_failnoi & __flags && !gcount ()
        || _C_failend & __flags && !__n)
        this->setstate (ios::failbit);

    return *this;
}



template<class _CharT, class _Traits>
streamsize basic_istream<_CharT, _Traits>::
readsome (char_type *__s, streamsize __n)
{
    ((void)0);
    ((void)0);
    ((void)0);

    if (!this->good ()) {
        this->setstate (ios::failbit);
        return 0;
    }

    streamsize __navail = this->rdbuf ()->in_avail ();

    if(-1 == __navail) {
        this->setstate (ios::eofbit);
        return 0;
    }

    if (0 == __navail)
        return 0;

    if (__n > __navail)
        __n = __navail;

    read (__s, __n);
    return __n;
}


template<class _CharT, class _Traits>
typename basic_istream<_CharT, _Traits>::pos_type
basic_istream<_CharT, _Traits>::tellg ()
{
    pos_type __p = off_type (-1);

    if (!this->fail ()) {

        try {
            __p = this->rdbuf ()->pubseekoff (0, ios::cur, ios::in);
          }
        catch (...) {
            if (this->setstate (ios::badbit, 0 ))
                throw;
        }
    }

    return __p;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::putback (char_type __c)
{
    ios::iostate __err = 0;

    if (this->rdbuf ()) {

        sentry __ipfx (*this, true);

        if (__ipfx) {

            try {
                if (traits_type::eq_int_type (this->rdbuf ()->sputbackc (__c),
                                              traits_type::eof ()))
                    __err = ios::badbit;
            }
            catch (...) {
                if (this->setstate (ios::badbit, 0 ))
                    throw;
            }
        }
    }
    else
        __err = ios::badbit;

    if (__err)
        this->setstate (__err);

    return *this;
}


template<class _CharT, class _Traits>
basic_istream<_CharT, _Traits>&
basic_istream<_CharT, _Traits>::unget ()
{
    ios::iostate __err = 0;

    if (this->rdbuf ()) {

        sentry __ipfx (*this, true);

        if (__ipfx) {

            try {

                if (traits_type::eq_int_type (this->rdbuf ()->sungetc (),
                                              traits_type::eof ()))
                    __err = ios::badbit;
            }
            catch (...) {
                if (this->setstate (ios::badbit, 0 ))
                    throw;
            }
        }
    }
    else
        __err = ios::badbit;

    if (__err)
        this->setstate (__err);

    return *this;
}


template<class _CharT, class _Traits>
int basic_istream<_CharT, _Traits>::sync ()
{
    if (!this->rdbuf ())
        return -1;

    sentry __ipfx (*this, true);

    if (__ipfx) {

        try {
            if (-1 != this->rdbuf ()->pubsync ())
                return 0;
        }
        catch (...) {
            if (this->setstate (ios::badbit, 0 ))
                throw;
        }

        this->setstate (ios::badbit);
    }

    return traits_type::eof ();
}


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
operator>> (basic_istream<_CharT, _Traits>& __is,
            basic_string<_CharT, _Traits, _Allocator>& __str)
{
    ((void)0);

    ios::iostate __err = 0;

    try {

        typename basic_istream<_CharT, _Traits>::sentry __ipfx (__is);

        if (__ipfx) {







            size_t __maxlen =
                __is.width () ? __is.width () : __str.max_size ();

            size_t __i = 0;

            __str.erase ();
            __str.resize (32);

            while (__maxlen != __i) {

                typename _Traits::int_type __c = __is.rdbuf ()->sgetc ();

                if (_Traits::eq_int_type (__c, _Traits::eof ())) {
                    __err = ios::eofbit;
                    break;
                }


                typename _Traits::char_type
                    __ch = _Traits::to_char_type (__c);

                if (isspace (__ch, __is.getloc ()))
                    break;

                __is.rdbuf ()->sbumpc ();

                if (__str.size () == __i)
                    __str.resize (__i * 2);

                _Traits::assign (__str [__i++], __ch);
            }
            __str.resize (__i);

            __is.width (0);

            if (!__i)
                __err |= ios::failbit;
        }
    }
    catch (...) {
        if (__is.setstate (ios::badbit, 0 ))
            throw;
    }

    if (__err)
        __is.setstate (__err);

    return __is;
}


template<class _CharT, class _Traits, class _Allocator>
basic_istream<_CharT, _Traits>&
getline (basic_istream<_CharT, _Traits>& __is,
         basic_string<_CharT, _Traits, _Allocator>& __str,
         _CharT __delim)
{
    ((void)0);

    typename basic_istream<_CharT, _Traits>::sentry __ipfx (__is, true);

    if (__ipfx) {

        ios::iostate __err = ios::failbit;

        try {







            size_t __i = 0;

            __str.erase ();
            __str.resize (32);

            while (__str.max_size () != __i) {

                typename _Traits::int_type __c = __is.rdbuf ()->sbumpc ();

                if (_Traits::eq_int_type (__c, _Traits::eof ())) {

                    __err = ios::eofbit | (__i ? ios::goodbit : ios::failbit);
                    break;
                }

                if (_Traits::eq (_Traits::to_char_type (__c), __delim)) {
                    __err = ios::goodbit;
                    break;
                }

                if (__str.size () == __i)
                    __str.resize (__i * 2);

                _Traits::assign (__str [__i++], _Traits::to_char_type (__c));
            }
            __str.resize (__i);
        }
        catch (...) {
            if (__is.setstate (ios::badbit, 0 ))
                throw;
        }

        if (__err)
            __is.setstate (__err);
    }

    return __is;
}


}
namespace __rw {




static std::ios_base::Init __rw_stream_initializer;

}




namespace std {

extern istream &cin;
extern ostream &cout;
extern ostream &cerr;
extern ostream &clog;



extern wistream &wcin;
extern wostream &wcout;
extern wostream &wcerr;
extern wostream &wclog;



}



using namespace std;


int main (){
cout <<"hello1"<<endl;
}
