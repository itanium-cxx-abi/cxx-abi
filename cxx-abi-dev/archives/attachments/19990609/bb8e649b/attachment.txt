#include <string.h>#include <assert.h>#include <dl.h>#include <malloc.h>#include <stdio.h>#include <typeinfo>typedef typedef void*(*shl_allocator)();shl_symbol *sym_data, *sym_proc;int n_data, n_proc;static voidload_self_symbols() {   shl_descriptor *d = 0;   shl_gethandle(PROG_HANDLE, &d);   printf("Executable file %s\n", d->filename);   shl_t h = d->handle;   n_data = shl_getsymbols(h, TYPE_DATA, EXPORT_SYMBOLS,                           (shl_allocator)malloc, &sym_data);   n_proc = shl_getsymbols(h, TYPE_PROCEDURE, EXPORT_SYMBOLS,                           (shl_allocator)malloc, &sym_proc);   printf("Loaded %d data symbols and %d procedure symbols.\n", n_data, n_proc);}static char const*dataptr2sym(void const *a) {   if (!a)      return "<null pointer>";   int offset = 0x3fff, closest = -1;   for (int k = 0; k!=n_data; ++k) {      int diff = (char const*)a-(char const*)sym_data[k].value;      if (diff==0)         return sym_data[k].name;      else if (diff>0 && diff<offset) {         closest = k;         offset = diff;      }   }   static char msg[80];   if (closest==-1)      sprintf(msg, "<address %x not found>", a);   else      sprintf(msg, "%s + %d", sym_data[closest].name, offset);   return msg;}static char const*procptr2sym(void const *p) {   if (!p)      return "<null pointer>";   int offset = 0x3fff, closest = -1;   // Strip L-bit from plabel p and find offset:   char const* ep = *(char const**)(long(p)&(~2));   for (int k = 0; k!=n_proc; ++k) {      int diff = ep-*(char const**)(long(sym_proc[k].value)&(~2));      if (diff==0)         return sym_proc[k].name;      else if (diff>0 && diff<offset) {         closest = k;         offset = diff;      }   }   static char msg[80];   if (closest==-1)      sprintf(msg, "<address %x not found>", p);   else      sprintf(msg, "%s + %d", sym_proc[closest].name, offset);   return msg;}int n_vbases(void const *vptr) {   int offset = 0x3fff;   for (int k = 0; k!=n_data; ++k) {      int diff = (char const*)vptr-(char const*)sym_data[k].value;      if (diff==0)         return 0;      else if (diff>0 && diff<offset) {         offset = diff;      }   }   return offset/4-1;}void describe_vtable(void const* vptr);template<typename T>void describe(T& obj) {   printf("\n%s object: size==%d, address==%x\n",          typeid(T).name(), sizeof(T), &obj);   for (int offset = 0; offset<sizeof(T); offset+=sizeof(long)) {      char const *p = (char const*)&obj+offset;      if (*(long const*)p<='z')         printf("object.%c\n", char(*(long const*)p));      else         printf("pointer %x to: %s\n", *(void**)p, dataptr2sym(*(void**)p));   }   printf("\n");   for (int off = 0; off<sizeof(T); off+=sizeof(long)) {      char const *p = (char const*)&obj+off;      if (*(long const*)p>'z') {         char const *sym = dataptr2sym(*(void**)p);         if (strncmp(sym, "[Vtable", 7)==0) {            describe_vtable(*(void const**)p);         }      }   }   printf("\n");}void describe_vtable(void const* vptr) {   int n_vbs = n_vbases(vptr);   int start = n_vbs? -(n_vbs+1): 0;   int end = 4;   while (*((void const**)vptr+end)!=0)      ++end;   printf("\nDumping %s from [%d] to [%d]\n", dataptr2sym(vptr), start, end);   for(; start!=end+1; ++start) {      char const *p = (char const*)vptr+start*sizeof(void*);      if (*(long*)p>0x3ff) { // Does it look like a pointer?         void* ptr = *(void**)p;         if (long(ptr)&2) { // Does it look like a P-label with the L-bit set?            printf("   +%3d: PLABEL for %s (%x)\n", start,                   procptr2sym(ptr), *(void**)(long(ptr)&(~2)));         } else            printf("   +%3d: %s (%x)\n", start, dataptr2sym(ptr), ptr);      } else         printf("   +%3d: %d\n", start, *(long*)p);   }}struct P { virtual void f(); };struct Q: virtual P {};struct R: virtual P {};struct S: P, Q, virtual R {};void P::f() {}int main() {   assert(sizeof(void*)==sizeof(long));   load_self_symbols();   S s;   describe(s);}