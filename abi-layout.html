<HTML>

<HEAD>
<title>C++ ABI for IA-64: Data Layout</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI for IA-64: Data Layout
</b></i></font>

<font size=-1>
<p>
<i>Revised 18 April 2000</i>

</center>

</HEAD>

<BODY>


<p> <hr> <p>
<a name=intro>
<h3> Introduction </h3>

In this document, we define the memory layout for C++ data objects,
including both predefined and user-defined data types,
as well as internal compiler generated objects such as virtual tables.
In general, this document is written as a generic specification,
to be usable by C++ implementations on a variety of architectures.
However, it does contain processor-specific material for the IA-64
64-bit ABI, identified as such.

<p>
In general, text appearing in this document in color is either
tentative wording of agreements,
or proposals not yet agreed upon,
and should be taken as more subject to change than black material.

<p>
<font color=blue>
Note that the body of this document makes free use of a number of terms
which are defined in the <i><b>Definitions</b></i> section below.
</font>

<p> <hr> <p>
<h3> Contents </h3>

<ul>
<li> <a href=#general> General </a>
<li> <a href=#definitions> Definitions </a>
<li> <a href=#limits> Limits </a>
<li> <a href=#namespace> Namespace and Header </a>
<li> <a href=#pod> POD Data Types </a>
<li> <a href=#member-pointers> Member Pointers </a>
<li> <a href=#class-types> Non-POD Class Types </a>
<li> <a href=#vtable> Virtual Table Layout </a>
<li> <a href=#vcall> Virtual Function Calling Conventions </a>
<li> <a href=#vtable-ctor> Virtual Tables During Object Construction </a>
<li> <a href=#array-ctor> Array Constructors and Destructors </a>
<li> <a href=#guards> Initialization Guard Variables </a>
<li> <a href=#rtti> Run-Time Type Information (RTTI) </a>
<li> <a href=#mangling> External Names (a.k.a. Mangling)</a>
<li> <a href=#vague> Vague Linkage </a>
<li> <a href=#revisions> Revision History</a>
</ul>

<p> <hr> <p>
<h3> Outstanding Questions </h3>
<font color=red>
There are outstanding questions in the body of the document to be
clarified:

<ul>

<a href=#guards>
<li> Specify initialization guard variables.
</a>

<a href=#vmi>
<li> Is there any useful purpose for the has-public-base flag in
    <code>vmi_flags</code> of <code>__vmi_class_type_info</code>?
    (Action item 37.)
</a>

</ul>
</font>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[000417]</font>
Updates from 17 April meeting.
Clarify order of vcall offsets.
More elaboration of construction vtable.
Specification of COMDAT RTTI name.
Reorganization of pointer RTTI.
Modify mangling grammar to clarify substitution in compound names.
Clarify Vague Linkage section.

<p>
<font color=blue>[000407]</font>
Updates from 6 April meeting, email.
More elaboration of construction vtable.
Updates/issues in RTTI.
Minor mangling changes.
Added Vague Linkage section.

<p>
<font color=blue>[000327]</font>
Updates from 30 March meeting.
Define base classes to include self, proper base classes.
Modify local function mangling per JFW proposal.

<p>
<font color=blue>[000327]</font>
Updates from 23 March meeting.
Adopt construction vtable Proposal B, and rewrite.
Further work on mangling, especially substitution.

<p>
<font color=blue>[000320]</font>
Clarify class size limit.
Editorial changes in vtable components description.
Add alternate to construction vtable proposal.
Clarification in array cookie specification.
Removed COMMON proxy from class RTTI.
Extensive changes to mangling writeup.

<p>
<a href=#revisions>Revision History</a>


<p> <hr> <p>
<a name=definitions>
<h3> Definitions </h3>

<p>
The descriptions below make use of the following definitions:

<dl>

<p>
<dt> <i>alignment</i> of a type T (or object X)</dt>
<dd>
A value A such that any object X of type T has an address satisfying
the constraint that &X modulo A == 0.

<p>
<dt> <i>base class</i> of a class T</dt>
<dd>
When this document refers to base classes of a class T,
unless otherwise specified,
it means T itself as well as all of the classes from which it is derived,
directly or indirectly, virtually or non-virtually.
We use the term&nbsp; <i>proper base class</i>
to exclude T itself from the list.

<p>
<dt> <i>direct base class order</i> </dt>
<dd>
When the direct base classes of a class are viewed as an ordered set,
the order assumed is the order declared, left-to-right.

<p>
<dt> <i>diamond-shaped inheritance</i> </dt>
<dd>
A class has diamond-shaped inheritance iff it has a virtual base class
that can be reached by distinct inheritance graph paths through
more than one direct base.

<p>
<dt> <i>dynamic class</i> </dt>
<dd>
A class requiring a virtual table pointer
(because it or its bases have one or more virtual member functions or
virtual base classes).

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members other than zero-width bitfields,
no virtual functions, no virtual base classes,
and no non-empty non-virtual proper base classes.

<p>
<dt> <i>inheritance graph</i> </dt>
<dd>
A graph with nodes representing a class and all of its subobjects,
and arcs connecting each node with its direct bases.

<p>
<dt> <i>inheritance graph order</i> </dt>
<dd>
The ordering on a class object and all its subobjects obtained
by a depth-first traversal of its inheritance graph,
where:

<ul>
<p>
<li> No node is visited more than once.
(So, a virtual base subobject, and all of its base subobjects,
will be visited only once.)

<p>
<li>
The subobjects of a node are visited in the order in which they
were declared.
(So, given&nbsp; <code>class A : public B, public C</code>,
A is walked first,
then B and its subobjects,
and then C and its subobjects.)
</ul>

<p>
Note that the traversal may be preorder or postorder.
Unless otherwise specified,
preorder (derived classes before their bases) is intended.

<p>
<a name=q3></a>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class that contains no data except its virtual pointer (if any) or
virtual bases.  In particular, it:
<ul>
<li> has no non-static data members other than zero-width bitfields,
<li> has no proper base classes that are not either empty, nearly empty,
     or virtual, and
<li> has at most one non-virtual, nearly empty proper base class.
</ul>
Such classes may be primary base classes even if virtual,
sharing a virtual pointer with the derived class.

<p>
<dt> <i>primary base class</i> </dt>
<dd>
For a dynamic class,
the unique base class (if any) with which it shares the virtual pointer
at offset 0.

<p>
<dt> <i>secondary vtable</i> </dt>
<dd>
The instance of a vtable for a base class
that is embedded in the vtable of a class derived from it.

<p>
<dt> <i>thunk</i> </dt>
<dd>
A segment of code associated (in this ABI) with a target function,
which is called instead of the target function for the purpose of
modifying parameters (e.g. <code>this</code>)
or other parts of the environment
before transferring control to the target function,
and possibly making further modifications after its return.
A thunk may contain as little as an instruction to be executed prior to
falling through to an immediately following target function,
or it may be a full function with its own stack frame that does
a full call to the target function.

<p>
<dt> <i>vague linkage</i> </dt>
<dd>
The treatment of entities --
e.g. inline functions, templates, vtables --
with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.

<p>
<dt> <i>virtual table</i> (or <i>vtable</i>) </dt>
<dd>
A dynamic class has an associated table
(often several instances, but not one per object)
which contains information about its dynamic attributes,
e.g. virtual function pointers, virtual base class offsets, etc.

<p>
<dt> <i>vtable group</i> </dt>
<dd>
The primary vtable for a class along with all of the associated
secondary vtables for its proper base classes.

</dl>


<p> <hr> <p>
<a name=general>
<h3> General </h3>

<p>
In what follows, we define the memory layout for C++ data objects.
Specifically, for each type, we specify the following information about
an object O of that type:
<ul>
<li> the <i>size</i> of an object, <i>sizeof</i>(O);
<li> the <i>alignment</i> of an object, <i>align</i>(O); and
<li> the <i>offset</i> within O, <i>offset</i>(C),
     of each data component C, i.e. base or member.
</ul>

<p> For purposes internal to the specification,
we also specify:

<ul>
<li> <i>dsize</i>(O):
the <i>data size</i> of an object,
which intuitively is sizeof(O) minus the size of tail padding.

<p>
<li> <i>nvsize</i>(O):
the <i>non-virtual size</i> of an object,
which intuitively is dsize(O) minus the size of virtual bases.
It is always equal to <i>dsize</i>(O) for types without virtual bases.

<p>
<li> <i>nvalign</i>(O):
the <i>non-virtual alignment</i> of an object,
which intuitively is the alignment determined by ignoring virtual bases.
It is always equal to <i>align</i>(O) for types without virtual bases.

</ul>

<p> <hr> <p>
<a name=limits>
<h3> Limits </h3>

<p>
Various representations specified by this ABI impose limitations on
conforming user programs.
These include, for the 64-bit IA-64 ABI:

<ul>
<p>
<li>
The offset of a non-virtual base subobject in the full object containing
it must be representable by a 56-bit signed integer
(due to RTTI implementation).
This implies a practical limit of 2**55 bytes on the size of a class.

</ul>


<p> <hr> <p>
<a name=namespace>
<h3> Namespace and Header </h3>

<p>
This ABI specifies a number of type and function APIs supplemental
to those required by the ISO C++ Standard.
A header file named <code>cxxabi.h</code> will be provided by
implementations that declares these APIs.
The reference header file included with this ABI definition
shall be the authoritative definition of the APIs.

<p>
These APIs will be placed in a namespace <code>__cxxabiv1</code>.
The header file will also declare a namespace alias <code>abi</code>
for <code>__cxxabiv1</code>.
It is expected that users will use the alias,
and the remainder of the ABI specification will use it as well.

<p>
In general,
API objects defined as part of this ABI are assumed to be extern "C++".
However, some (many?) are specified to be extern "C" if they:
<ul>
<li> are expected to be called by users from C code,
     e.g. <code>longjmp_unwind</code>; or
<li> are expected to be called only implicitly by compiled code,
     and are likely to be implemented in C.
     Note: this second exception has not yet been adopted.
</ul>



<p> <hr> <p>
<a name=pod>
<h3> POD Data Types </h3>

<p>
The size and alignment of C POD types is as specified by the base (C) ABI.
Type bool has size and alignment 1.
All of these types have data size and non-virtual size equal to their size.
(We ignore tail padding for PODs because the Standard does not allow us
to use it for anything else.)


<p> <hr> <p>
<a name=member-pointers></a>
<h3> Member Pointers </h3>

<p>
A pointer to data member is an offset from the base
address of the class object containing it,
represented as a <code>ptrdiff_t</code>.
It has the size and alignment attributes of a <code>ptrdiff_t</code>.
A NULL pointer is represented as -1.

<p>
A pointer to member function is a pair <ptr, adj> as follows:

<dl>
<p>
<dt> <code>ptr</code>:
<dd> For a non-virtual function, this field is a simple function pointer.
     (Under current base IA-64 psABI conventions,
     that is a pointer to a GP/function address pair.)
     For a virtual function,
     it is 1 plus the Vtable offset (in bytes) of the function,
     represented as a <code>ptrdiff_t</code>.
     The value zero represents a NULL pointer,
     independent of the adjustment field value below.

<p>
<dt> <code>adj</code>:
<dd> The required adjustment to <i>this</i>,
     represented as a <code>ptrdiff_t</code>.
</dl>

<p>
It has the size, data size, and alignment
of a class containing those two members, in that order.
(For 64-bit IA-64, that will be 16, 16, and 8 bytes respectively.)



<p> <hr> <p>
<a name=class-types></a>
<h3> Non-POD Class Types </h3>

For non-POD class types C, assume that all component types
(i.e. proper base classes and non-static data member types)
have been laid out, defining size, data size, non-virtual size,
alignment, and non-virtual alignment.
(See the description of these terms in
<a href=#general><b>General</b></a> above.)
Layout (of type C) is done using the following procedure.

<ol type=I>
<p>
<li> <h5> Initialization </h5>
  <ol type=1>
  <p>
  <li> Initialize sizeof(C) to zero, align(C) to one, dsize(C) to zero.

  <p>
  <li> If C is a dynamic class type:
      <ol type=a>
      <p>
      <li> Identify all virtual base classes, direct or indirect,
	   that are primary base classes for some other direct or indirect
	   base class.
	   Call these <i>indirect primary base classes</i>.

      <p>
      <li> If C has a dynamic base class,
	   attempt to choose a primary base class B.
	   It is the first (in direct base class order)
	   non-virtual dynamic base class, if one exists.
	   Otherwise, it is a nearly empty virtual base class,
	   the first one in (preorder) inheritance graph order which
	   is not an indirect primary base class if any exist,
	   or just the first one if they are all indirect primaries.

	   <p>
	   Allocate the chosen primary base at offset zero, and set
	   sizeof(C) to sizeof(B), align(C) to nvalign(B),
	   dsize(C) to nvsize(B).
	   This step allocates only B's non-virtual part,
	   i.e. excluding any direct or indirect bases.

      <p>
      <li> Otherwise, allocate the vtable pointer for C at offset zero,
	   and set sizeof(C), align(C), and dsize(C) to the appropriate
	   values for a pointer (all 8 bytes for IA-64 64-bit ABI).
      </ol>
  </ol>

<p>
<li> <h5> Non-Virtual-Base Allocation </h5>
<p>
For each data component D (i.e. proper base or non-static data member)
except virtual bases,
first the non-virtual proper base classes in declaration order
and then the non-static data members in declaration order,
allocate as follows:

  <ol type=1>

  <p>
  <li> If D is a bitfield, i.e. declared as "<code>T [b]: n;"</code>,
       for some integral POD type T and bit count n,
       there are two cases depending on <code>sizeof(T)</code>
       and <code>n</code>:

       <ol type=a>
       <p>
       <li>
       If <code>sizeof(T)*8 >= n</code>,
       the bitfield is allocated as required by the underlying C psABI.
       That is, it will be placed in the next available n bits,
       subject to the constraint that it does not cross an alignment
       boundary for type <code>T</code>.
       The next available n bits are at offset dsize(C),
       unless the preceding byte is only partially filled by a bitfield,
       in which case the bitfield allocation can begin in that byte.
	<p>
	Update align(C) to max (align(C), align(T)).

       <p>
       <li>
       If <code>sizeof(T)*8 < n</code>,
       let T' be the largest integral POD type with
       <code>sizeof(T')*8 <= n</code>.
       The bitfield is allocated starting at the next offset aligned
       appropriately for T', with length n bits.
       The first <code>sizeof(T)*8</code> bits are used to hold the
       value of the bitfield,
       followed by <code>n - sizeof(T)*8</code> bits of padding.
	<p>
	Update align(C) to max (align(C), align(T')).
       </ol>

       <p>
       In either case,
       update sizeof(C) and dsize(C) to include the last byte
       containing (part of) the bitfield.

  <p>
  <li> Otherwise, if D is not an empty base class
	(including all data members),
	start at offset dsize(C),
	incremented if necessary to alignment nvalign(type(D)).
	Place D at this offset unless doing so would result in two
	components (direct or indirect) of the same type having the
	same offset.
	If such a component type conflict occurs,
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs
	(which will occur no later than sizeof(C) rounded up to the
	required alignment).

	<p>
	If D is a base class, this step allocates only its non-virtual
	part, i.e. excluding any direct or indirect virtual bases.

	<p>
	Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
	Update align(C) to max (align(C), nvalign(D)).
	If D is a base class (not empty in this case),
	update dsize(C) to offset(D)+nvsize(D).
	If D is a data member,
	update dsize(C) to max (offset(D)+dsize(D), offset(D)+1).

  <p>
  <li> If D is an empty proper base class,
	its allocation is similar to case (2) above,
	except that additional candidate offsets are considered before
	starting at dsize(C).
	First, attempt to place D at offset zero.
	If unsuccessful (due to a component type conflict),
	proceed with attempts at dsize(C) as for non-empty bases.
	As for that case, if there is a type conflict at dsize(C)
	(with alignment updated as necessary),
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs.

	<p>
	Once offset(D) has been chosen,
	update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)).
	Note that nvalign(D) is 1, so no update of align(C) is needed.
	Similarly, since D is an empty base class,
	no update of dsize(C) is needed.

  </ol>

  <p>
  After all such components have been allocated,
  set nvsize(C) = dsize(C) and nvalign(C) = align(C).
  These values will not change during virtual base allocation.

<p><a name=a17></a>
<li> <h5> Virtual Base Allocation </h5>
<p>

<p>
Finally allocate any direct or indirect virtual base classes
(except the primary base class or any indirect primary base classes)
as we did non-virtual base classes
in step II-2 (if empty) or II-3 (if non-empty),
in inheritance graph order.
Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
If non-empty, also update align(C) and dsize(C) as in II-2.

<p>
The primary base class has already been allocated in I-2b.
Any indirect primary base class E of the current class C,
that has been chosen as the primary base class of some other base class
(direct or indirect, virtual or non-virtual) of C,
will be allocated as part of that other base class,
and is not allocated here.
If E is a primary base class of more than one other base,
the instance used as its allocation in C shall be the first such
in the inheritance graph order.

<i>
<p>
Consider:
<pre><code>
  struct R { virtual void r (); };
  struct S { virtual void s (); };
  struct T : virtual public S { virtual void t (); };
  struct U : public R, virtual public T { virtual void u (); };

</code></pre>

R is the primary base class for U since it is the first direct
non-virtual dynamic base.
Then, since an inheritance-order walk of U is { U, R, T, S }
the T base is allocated next.
Since S is a primary base of T,
there is no need to allocate it separately.
However, given:

<pre><code>
  struct V : public R, virtual public S, virtual public T {
    virtual void v ();
  };

</code></pre>

the inheritance-order walk of V is { V, R, S, T }.
Nevertheless, although S is considered for allocation first as a virtual base,
it is not allocated separately because it is a primary base of T,
another base.
Thus sizeof (V) == sizeof (U),
and the full layout is equivalent to the C struct:
</i>

<pre><code>
  struct X {
    R r;
    T t;
  };

</code></pre>

<p>
<li> <h5> Finalization </h5>
<p>
Round sizeof(C) up to a non-zero multiple of align(C).

</ol>


<p> <hr> <p>
<a name=vtable></a>
<h3> Virtual Table Layout </h3>

<p>
<h4> General </h4>

<p>
A <i>virtual table</i> (<i>vtable</i>) is a table of information used
to dispatch virtual functions,
to access virtual base class subobjects,
and to access information for runtime type identification (RTTI).
Each class that has virtual member functions or virtual bases
has an associated set of vtables.
There may be multiple vtables for a particular class,
if it is used as a base class for other classes.
However, the vtable pointers within all the objects (instances)
of a particular most-derived class point to the same set of vtables.

<p>
A vtable consists of a sequence of offsets, data pointers,
and function pointers, as well as structures composed of such items.
We will describe below the sequence of such items.
Their offsets within the vtable are determined by that allocation
sequence and the natural ABI size and alignment,
just as a data struct would be.  In particular:
<ul>
<li> Offsets are of type <code>ptrdiff_t</code> unless otherwise stated.
<li> Data pointers have normal pointer size and alignment.
<li> Function pointers remain to be defined.
     One possibility is that they will be
     &lt;function address, GP address> pairs, with pointer alignment.
</ul>

<p>
In general, what we consider the address of a vtable
(i.e. the address contained in objects pointing to a vtable)
may not be the beginning of the vtable.
We call it the <i>address point</i> of the vtable.
The vtable may therefore contain components at either positive or
negative offsets from its address point.

<p>
<h4> Virtual Table Components and Order </h4>

<p>
This section describes the usage and relative order of various
components that may appear in virtual tables.
Precisely which components are present in various possible virtual
tables is specified in the next section.
If present, components are present in the order described,
except for the exceptions specified.

<ul>
<p>
<li>
<i>Virtual call (vcall) offsets</i> are used
to perform pointer adjustment for
virtual functions declared in a virtual base class or its subobjects,
and overridden in a class derived from it.
These entries are allocated in the vtable for the virtual base class
that is most immediately derived from the base class containing the
overridden virtual function declaration.
They are used
to find the necessary adjustment from the virtual base to the
derived class containing the overrider,
if any.
When a virtual function is invoked via a virtual base,
but has been overridden in a derived class,
the overriding function first adds a fixed offset to adjust the
<code>this</code> pointer to the virtual base,
and then adds the value contained at the vcall offset
in the virtual base to its <code>this</code> pointer
to get the address of the derived object where the function was overridden.
These values may be positive or negative.
These are first in the vtable if present,
ordered as defined in categories 3 and 4 below.

<p>
<li>
<a name=q1></a>
<i>Virtual Base (vbase) offsets</i> are used to access
the virtual bases of an object.
Such an entry is added to the derived class object address
(i.e. the address of its vtable pointer)
to get the address of a virtual base class.
Such an entry is required for each virtual base class.
The values can be positive or negative.

<br>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
However, in classes sharing a vtable with a primary base class,
the vcall and vbase offsets added by the derived class all come before
the vcall and vbase offsets required by the base class,
so that the latter may be laid out as required by the base class
without regard to additions from the derived class(es).
</i>

<p>
<li>
The <i>offset to top</i> holds the displacement to the top of the object
from the location within the object of the vtable pointer that addresses
this vtable,
as a&nbsp; <code>ptrdiff_t</code>.
It is always present.
The offset provides a way to find the top of the object from any base
subobject with a vtable pointer.
This is necessary for dynamic_cast&lt;void*> in particular.

<p>
<i>In a complete object vtable,
and therefore in all of its primary base vtables,
the value of this offset will be zero.
For the secondary vtables of other non-virtual bases,
and of many virtual bases,
it will be negative.
Only in some construction vtables will some virtual base vtables have
positive offsets, due to a different ordering of the virtual bases in
the full object than in the subobject's standalone layout.
</i>

<p>
<li>
The <i>typeinfo pointer</i> points to the typeinfo object used for RTTI.
It is always present.
All entries in each of the vtables for a given class must point to the
same typeinfo object.
A correct implementation of typeinfo equality is to check pointer equality,
except for pointers (directly or indirectly) to incomplete types.
The typeinfo pointer is a valid pointer for polymorphic classes,
i.e. those with virtual functions,
and is zero for non-polymorphic classes.

<p>
<li>
The vtable address point points here,
i.e. this is the vtable address contained in an object's virtual pointer.
This address must have the alignment required for pointers.

<p>
<li>
<i>Virtual function pointers</i> are used for virtual function dispatch.
Each pointer holds either the address of a virtual function of the class,
or the address of a secondary entry point that performs certain
adjustments before transferring control to a virtual function.

<p>
The form of a virtual function pointer is specified by the
processor-specific C++ ABI for the implementation.
In the specific case of 64-bit IA-64 shared library builds,
a virtual function pointer entry contains a pair of components
(each 64 bits):
the value of the target GP value and the actual function address.
That is, rather than being a normal function pointer,
which points to such a two-component descriptor,
a virtual function pointer entry is the descriptor.

<p>
The order of the virtual function pointers in a vtable is the order
of declaration of the corresponding member functions in the class.
There is an entry for any virtual function declared in a class,
whether it is a new function or overrides a base class function,
unless it overrides a function from the primary base,
and conversion between their return types does not require an adjustment.
(In the case of this exception,
the primary base and the derived class share the vtable,
and can share the virtual function entry because no adjustments are
necessary.)
If a class has an implicitly-defined virtual destructor,
its entries come after the declared virtual function pointers.

<p>
When a derived class and its primary base share a vtable,
the virtual function entries introduced by the derived class follow
those for the primary base,
so that the layout of the primary base's embedded vtable is the same as
that of its standalone vtable.

<p>
The entries for virtual destructors are actually pairs of entries.
The first destructor,
called the non-deleting in-charge destructor,
performs the destruction without calling delete() on the object.
The second destructor,
called the deleting in-charge destructor,
calls delete() after destroying the object.
Both destroy any virtual bases;
a separate, non-virtual function,
called the not-in-charge destructor,
performs destruction of the object but
not its virtual base subobjects, and does not call delete().

</ul>

<p>
Following the primary vtable of a derived class are
<i>secondary vtables</i> for each of its proper base classes,
except any primary base(s) with which it shares its primary vtable.
These are copies of the vtables for the respective base classes
(copies in the sense that they have the same layout,
though the fields may have different values).
We call the collection consisting of a primary vtable along with all of
its secondary vtables a <i>vtable group</i>.
The order in which they occur is the same as the order in which the
base class subobjects are considered for allocation in the derived object:

<ul>
<p>
<li>
First are the vtables of direct non-primary, non-virtual proper bases,
in the order declared,
including their secondary vtables for non-virtual bases in the order
they appear in the standalone vtable group for the base.
(Thus the effect is that these vtables occur in inheritance graph order,
excluding primary bases and virtual bases.)

<p>
<li>
Then come the virtual base vtables,
also in inheritance graph order,
and again excluding primary bases
(which share vtables with the classes for which they are primary).
</ul>


<p>
<h4> Virtual Table Construction </h4>

<p>
In this section, we describe how to construct the vtable for an class,
given vtables for all of its proper base classes.
To do so, we divide classes into several categories,
based on their base class structure.

<p>
<h5> Category 0: Trivial </h5>

Structure:
<ul>
<li> No virtual base classes.
<li> No virtual functions.
</ul>

<p>
Such a class has no associated vtable,
and its objects contain no virtual pointer.

<p>
<h5> Category 1: Leaf </h5>

Structure:
<ul>
<li> No inherited virtual functions.
<li> No virtual base classes.
<li> Declares virtual functions.
</ul>

<p>
The vtable contains offset-to-top and RTTI fields
followed by virtual function pointers.
There is one function pointer entry for each
virtual function declared in the class.

<p>
<h5> Category 2: Non-Virtual Bases </h5>

Structure:
<ul>
<li> Only non-virtual proper base classes.
<li> Inherits virtual functions.
</ul>

<p>
The class has a vtable for each proper base class that has a vtable.
The secondary vtables for the class
are constructed from copies of the base class complete object vtables.
The entries are the same, except:

<ul>
<p>
<li> The offset-to-top and RTTI fields
     contain information for the class,
     rather than for the base class. 

<p>
<li> The function pointer entries for virtual functions inherited from
     the base class and overridden by this class are replaced with the
     addresses of the overriding functions
     (or the corresponding adjustor secondary entry points).
</ul>

<p>
For a proper base class <code>Base</code>,
and a derived class <code>Derived</code> for which we are constructing
this set of vtables,
we shall refer to the vtable for <code>Base</code> as
<code>Base-in-Derived</code>.
The virtual pointer of each base subobject of an object of the
derived class will point to the corresponding base vtable in this set.

<p>
The vtable copied from the primary base class is also called the
primary vtable;
it is addressed by the vtable pointer at the top of the object.
The other vtables of the class are called secondary vtables;
they are addressed by vtable pointers inside the object.

<p>
Following the function pointer entries that correspond to those of the
primary base class,
the primary vtable holds the following additional entries at its tail:
<ul>
<li> Entries for virtual functions introduced by this class.
<li> Entries for overridden virtual functions not already in the vtable.
     (These are also called replicated entries because they are already
     in the secondary vtables of the class.)
</ul>

The primary vtable, therefore,
has the base class functions appearing before the derived class functions.
The primary vtable can be viewed as two vtables accessed
from a shared vtable pointer. 

<p>
<i>Note</i>:
Another benefit of replicating virtual function entries is that it
reduces the number of this pointer adjustments during virtual calls.
Without replication,
there would be more cases where the this pointer would have to be
adjusted to access a secondary vtable prior to the call.
These additional cases would be exactly those where the function
is overridden in the derived class,
implying an additional thunk adjustment back to the original pointer.
Thus replication saves two adjustments for each virtual call to an
overridden function introduced by a non-primary proper base class. 

<p>
<h5> Category 3: Virtual Bases Only </h5>

<p>
Structure:
<ul>
<li> Only virtual base classes.
<li> Base classes are not empty or nearly empty.
</ul>

<p>
The class has a vtable for each virtual base class that has a vtable.
These are all secondary vtables and are constructed from copies of the
base class vtables according to the same rules as in Category 2,
except that the vtable for a virtual base A also includes a vcall
offset entry for each virtual function represented in A's primary
vtable and the secondary vtables from A's non-virtual bases.

<font color=red>
The vcall offsets in the secondary vtable for a virtual base A are
ordered as described next.
We describe the ordering from the entry closest to the vtable address
point to that furthest.
Since the vcall offsets precede the vtable address point,
this means that the memory address order is the reverse of that
described.
<ul>
<p>
<li>
If virtual base A has a primary base class P sharing its virtual table,
P's vcall offsets come first,
in the same order they would appear if P itself were the virtual base.

<p>
<li>
Next (after any intervening vbase offsets for virtual bases of A
but not of P)
come vcall offsets for each virtual function declared in A,
in declaration order.

<p>
<li>
Finally come vbase offsets for virtual functions declared in
non-virtual bases of A other than P.
These bases are considered in inheritance graph preorder,
and the vcall offsets for multiple functions declared in one of them
are in declaration order.
</ul>

<p>
If the above listing of vcall offsets includes more than one
for a particular virtual function signature,
only the first one (closest to the vtable address point) is allocated.
That is, an offset from primary base P (and its non-virtual bases)
eliminates any from A or its other bases,
an offset from A eliminates any from the non-primary bases,
and an offset from a non-primary base B of A eliminates any from the
bases of B.

<p>
<i>
Note that there are no vcall offsets for virtual functions declared in
a virtual base class V of A and never overridden within A.
Calls to such functions will use the vcall offset in V's virtual table.
</i>
</font>

<p>
The class also has a vtable that is not copied from the virtual base
class vtables.
This vtable is the primary vtable of the class and is addressed by the
vtable pointer at the top of the object, which is not shared.
It holds the following function pointer entries: 

<ul>
<p>
<li> Entries for virtual functions introduced by this class.

<p>
<li> Entries for overridden virtual functions.
     (These are also called replicated entries,
     because they are already in the secondary vtables of the class.)
</ul>

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each virtual base class,
direct or indirect.
The entries are in the reverse of the inheritance graph order.
That is, the entry for the leftmost virtual
base is closest to the address point of the vtable.

<p>
When there is a primary base class,
its virtual base and vcall offsets are reused for the derived class
(so the derived class vtable does not have a second copy),
and they come first
(i.e. closest to the vtable address point)
so that they are in their previously defined locations for the base,
followed by the additional entries required by the full derived class.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>Ed. Note:
The above rule for laying out the virtual offsets
used to be a specialization of the Category 4 rule below,
made possible by the absence of non-virtual bases.
When we decided to always promote virtual base offsets to the derived
class vtable, the distinction disappeared,
and the relevant language has been removed.
</i>


<p>
<h5> Category 4: Complex </h5>

<p>
Structure:
<ul>
<li> None of the above,
     i.e. directly or indirectly inherits both virtual and non-virtual
     proper base classes, or at least one nearly empty virtual base class.
</ul>

<p>
The rules for constructing vtables of the class are a combination of
the rules from Categories 2 and 3,
and can be determined inductively.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>For an S-as-T vtable,
the vbase offset entries from the primary vtable for T
are replaced with appropriate offsets given the completed hierarchy.
</i>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Consider the following inheritance hierarchy:
<code><pre>
  struct S { virtual void f() };
  struct T : virtual public S {};
  struct U : virtual public T {};
  struct V : public T, virtual public U {};
</pre></code>
<p>
T's vtable contains a virtual base offset for S.
U's vtable contains virtual base offsets for S and T.
V's vtable contains virtual base offsets for S, U, and T
(in reverse inheritance graph preorder),
where the vbase offset for T is for the virtual base of U,
not for the non-virtual direct base of V.

<p>
Consider in addition:
<code><pre>
  struct W : public T {};
</pre></code>
<p>
T is a primary base class for W.
Therefore, its virtual base offset for S in its embedded T-in-W vtable
is the only one present.
</i>

<p>
<a name=vcall>
<h4> Virtual Function Calling Convention </h4>
</a>

<p>
This section sketches the calling convention for virtual functions,
based on the above virtual table layout.
<i>See also the <a href=abi-examples.html#vcall>ABI examples</a>
document for motivating examples and potential implementations.</i>

<p>
We explain, at a high level,
what information must be present in the vtable for a class A
which declares a virtual function f in order that,
given an pointer of type A*,
the caller can call the virtual function f.
This section does not specify exactly where that information is located
(see above),
nor does it specify how to convert a pointer to a class
derived from A to an A*,
if that is required.

<p>
When this section uses the term <i>function pointer</i> it is understood
that this term may refer either to a traditional function pointer
(i.e., a pointer to a GP/address pair) or a GP/address pair itself.
Which of these alternatives is actually used
is specified elsewhere in the ABI,
but is independent of the description in this section.

<p>
Throughout this section,
we assume that A is the class for which we are creating a vtable,
B is the most derived class in the hierarchy,
and C is the class that contains C::f,
the unique final overrider for A::f.
This section specifies the contents of the f entry in the A-in-B vtable.
(If A is primary base in the hierarchy,
then the A-in-B vtable will be shared with the derived class vtable --
but the contents of the A portion of that vtable
will still be as specified here.)

<p>
In all cases, the <i>non-adjusting entry point</i> for a virtual
function expects the `this' pointer to point to an instance of the
class in which the virtual function is defined.
In other words, the non-adjusting entry point for C::f will expect
that its `this' pointer points to a C object.

<p>
We say that a subobject X is a <i>morally virtual</i> base of Y
if X is either a virtual base of Y,
or the direct or indirect base of a virtual base of Y.


<p>
The calling convention is as follows:

<ul>
<li>Vtable Components:
<p>
For each virtual function declared in a class C,
we add an entry to its vtable if one is not already there
(i.e. if it is not overriding a function in its primary base).
In particular, a declaration which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
The content of this entry for class A is a function pointer,
as determined by one of the following cases.
Recall that we are dealing with a hierarchy where B is most derived,
A is a direct (or indirect) base of B defining f,
and C contains the unique final overrider C::f of A::f.

<ol type=1>
<p>
<li> A = C
<p>
(In this case, we are creating either the primary vtable for A,
or the A-in-B secondary vtable.)
<p>
The vtable contains a function pointer pointing to the
non-adjusting entry point for A::f.

<p>
<li> A != C
<p>
In this case, we are creating the A-in-B secondary vtable.
<p>
The vtable contains a pointer to an entry point that performs the
adjustment from an A* to a C*,
and then transfers control to the non-adjusting entry point for C::f.
</ol>

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions may use the slots to
determine the adjustment necessary.

<p>
<li>Callee:
<p>
For each direct or indirect base A of C that is not a morally virtual
base of C,
the compiler must emit, in the same object file as the code for C::f,
an <i>A-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to an A*,
and will convert it to a C*
(which merely requires adding a constant offset)
before transferring control to the non-adjusting entry point for C::f.

<p>
For each direct or indirect virtual base V of C such that either V declares f,
or is derived from a class that declares f,
the compiler must emit, in the same object file as the code for C::f,
a <i>V-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to the unique virtual V subobject of C.
(Note that there may in general be multiple V subobjects of C,
but that only one of them will be virtual.)
This entry point must load the vcall offset corresponding to f located
in the vtable for V obtained via its <code>this</code> pointer,
extract the vcall offset corresponding to f located in that vtable,
and add this offset to the <code>this</code> pointer.
(Note that, as specified in the data layout document,
when V is used as a virtual base,
its vtable contains vcall offsets for every virtual function
declared in V or any of its bases.)
Then,
this entry point must transfer control to the non-adjusting entry point.

<a name=morally-virtual>
<p>
For each morally virtual base M of C
such that M is <i><b>not</b></i> a virtual base
(and therefore must be a subobject of a virtual base V),
and such that M declares f,
the compiler must emit,
in the same object file as the code for C::f,
an <i>M-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to an M*,
and will convert it to a V* (a fixed offset),
where V is the nearest virtual base to M
along the inheritance path from C to M.
Then, it will convert the V* to a C* by using the vcall offset
stored in the V's vtable.
(Note that one implementation of the M-adjusting entry point
is to convert from M* to V*
and then transfer control to the V-adjusting entry point.)

<p>
<li>Caller:
<p>
When calling a virtual function f,
through a pointer of static type B*,
the caller

<ul>
<p>
<li>Selects a (possibly improper) subobject A of B
    such that A declares f.
    (In general, A may be the same as B.)
    (Note that A need not define f;
    it may contain either a definition of f,
    or a declaration of f as a pure virtual function.)

<p>
<li>Converts the B* to point to this subobject.
    (Call the resulting pointer `a'.)

<p>
<li>Uses the vtable pointer contained in the A subobject to locate
    the function pointer through which to perform the call.

<p>
<li>Calls through this function pointer,
    passing `a' as the <code>this</code> pointer.
</ul>

<i>
<p>
(Note that in general it will be optimal to select the class which
contained the final overrider (i.e., C)
as the class to which the B* should be converted.
This class is always a satisfactory choice,
since it is known to contain a definition of f.
In addition, if the dynamic type of the object is B,
then C::f will be the function ultimately selected by the call,
which means that C's vtable will
contain a pointer to the non-adjusting entry point,
meaning that no additional adjustments to the <code>this</code>
pointer will be required.

<p>
However, there may be cases in which choosing a different base
subobject could be superior.
For example, if there is an alternate base D which also declares f,
and a pointer to the D subobject is already available,
then it may be better to use the D subobject rather
than converting the B* to a C*,
in order to avoid the cost of the conversion.)
</i>


<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
<i>See further discussion of implementation in the
<a href=abi-examples.html#vcall-impl>ABI examples</a> document.</i>
</ul>


<p> <hr> <p>
<a name=vtable-ctor>
<h3> Vtables During Object Construction (open issue C-4)</h3>

<p>
In some situations,
a special vtable called a construction vtable is used during
the execution of proper base class constructors and destructors.
These vtables are for specific cases of virtual inheritance.

<p>
During the construction of a class object,
the object assumes the type of each of its proper base classes,
as each base class subobject is constructed.
RTTI queries in the base class constructor will return  
the type of the base class, and virtual calls will resolve to member  
functions of the base class rather than the complete class.
Normally,  this behavior is accomplished by setting,
in the base class constructor,
the object's vtable pointers to the addresses of the
vtables for the base class.

<p>
However, if the base class has direct or indirect virtual bases, the  
vtable pointers have to be set to the addresses of construction
vtables. This is because the normal proper base class vtables may not hold  
the correct virtual base index values to access the virtual bases of  
the object under construction, and adjustment addressed by these
vtables may hold
the wrong this parameter adjustment if the adjustment is to cast
from a virtual base to another part of the object. The problem is
that a complete object of a proper base class and a complete object of a
derived class do not have virtual bases at the same offsets.

<p>
A construction vtable holds the virtual function addresses,
offset-to-top,
and RTTI information associated with the base class,
and virtual base offsets and addresses of adjustor entry points with their
parameter adjustments associated with objects of the complete class.

<p>
To ensure that the vtable pointers are set to the appropriate
vtables during proper base class construction, a table of vtable pointers,  
called the VTT, which holds the addresses of construction and
non-construction vtables is generated for the complete class. The
constructor for the complete class passes to each proper base class
constructor a pointer to the appropriate place in the VTT where the  
proper base class constructor can find its set of vtables. Construction
vtables are used in a similar way during the execution of proper base class  
destructors.

<p>
<h4> VTT Order</h4>

<p>
An array of vtable addresses, called the VTT,
is declared for each class type that needs a construction vtable.
A class needs a construction vtable if it has
indirect or direct virtual base classes.
(Otherwise,
each proper base class may be initialized
using its complete object vtable group.)

<p>
The elements of the VTT array for a class D are in this order:

<ol type=1>
<li>
<i>Primary vptr</i>:
address of the primary vtable for the complete object D.

<p>
<li>
<i>Secondary VTTs</i>:
for each direct non-virtual proper base class B of D
that requires a construction vtable by virtue of having virtual bases,
in declaration order,
a sub-VTT for B-in-D,
structured like the main VTT,
with a primary virtual pointer, secondary VTTs,
and secondary virtual pointers
(but no virtual VTTs).

<p>
<i>
Note that this construction is applied recursively to embed sub-VTTs for
non-virtual subobjects encountered in each of the base classes.
</i>

<p>
<li>
<i>Secondary virtual pointers</i>:
For each subobject X with either (a) virtual bases
or (b) virtual function declarations overridden along a virtual path
between the declaration and D,
the address of the secondary vtable for X-in-D.
These include virtual and non-virtual, direct and indirect subobjects,
in inheritance graph postorder.
<font color=red>
(When constructing a sub-VTT for a subclass B of D in part 2 above,
the relevant condition (b) for the inclusion of a secondary virtual
pointer in the sub-VTT for B is the existence of a virtual function
declaration overridden along a virtual path between the declaration and B,
since otherwise the complete object virtual table for B is used.)
</font>
The order of the virtual pointers is
depth-first search postorder.
<font color=red>
(Ed. shouldn't this be preorder?)
</font>

<p>
<i>
Note that secondary virtual pointers may be required for base classes
that do not require secondary VTTs.
This may occur if, for D derived from B derived from A,
A does not contain virtual bases,
but does define a virtual function that is not overridden in B,
but is overridden in D (along a virtual path).
</i>

<p>
<li>
<i>Virtual VTTs</i>:
The sub-VTTs for each virtual subobject in
<font color=red>
initialization order (as specified by the C++ Standard,
i.e. depth-first search postorder),
</font>
i.e. the sub-VTT for virtual base W of virtual base V of D
comes before the sub-VTT for V.
These sub-VTTs are constructed as in (2) above,
including sub-VTTs for any non-virtual bases of the current virtual base.
The virtual VTT addresses come last because they are only passed
to the virtual base class constructors for the complete object.
</ol>

<p>
Each vtable address in the VTT is the address to be assigned to the
respective virtual pointer,
i.e. the address of the first virtual function pointer in the vtable,
not of the first vcall offset.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
It is intended that the VTT for a complete class D be identical in
structure to the sub-VTT for the same class D as a subclass of another
class E derived from it.
Therefore, the various components of its VTT are present based on the
rules given, even if they point to the D complete object vtable or its
secondary vtables.
That is, secondary VTTs are present for all bases with virtual bases
<font color=red>
(including the virtual bases themselves in the virtual VTT section),
</font>
and secondary virtual pointers are present for all bases with either
virtual bases or virtual function declarations overridden along a
virtual path.
The only exception is that a primary non-virtual base class does not
require a secondary virtual pointer.
</i>

<p>
For example, suppose we have the following hierarchy:
<code><pre>
  class A1 { int i; };
  class A2 { int i; virtual void f(); };
  class V1 : public A1, public A2 { int i; };
  class B1 { int i; };
  class B2 { int i; };
  class V2 : public B1, public B2, public virtual V1 { int i; virtual void f(); };
  class C1 : public virtual V1 { int i; };
  class C2 : public virtual V2 { int i; };
  class X1 { int i; };
  class C3 : public X1 { int i; };
  class D : public C1, public C2, public C3 { int i; virtual void f(); };

</pre></code>

<font color=red>
Then the VTT for D would appear in the following order,
where indenting indicates the sub-VTT structure,
and asterisks (*) indicate that construction vtables instead of
complete object vtables are required.
<code><pre>
  // 1. Primary virtual pointer:
  [0] D has virtual bases (complete object vptr)

  // 2. Secondary VTTs:
  [1]  C1 * (has virtual base)

  [2]  C2 * (has virtual bases)
  [3]    V1-in-C2 in D (secondary vptr)
  [4]    V2-in-C2 in D (secondary vptr)

  // 3. Secondary virtual pointers:
    // (no C1-in-D -- primary base)
  [5]    V1-in-D (A2::f overridden in D)
  [6]    V2-in-D (V2::f overridden in D, has virtual base)
  [7]  C2-in-D (postorder; has virtual bases)
    // (For complete object D VTT, these can all point to the
    // secondary vtables in the D vtable.  In the sub-VTT for
    // D in a class derived from D, some might be construction
    // vtables.)

  // 4. Virtual VTTs:
    // (V1 primary, can use complete object constructor).
  [8]  V2 * (V2::f overridden in D, has virtual base)
  [9]    V1-in-V2 in D * (secondary vptr, A2::f overridden in D)
	   (A2 is primary base of V1)

</pre></code>

<p>
If A2 is a virtual base of V1,
the VTT will contain 14 elements
(exercise left to the astute reader).
</font>

<p>
<h4> Construction VTABLE Layout</h4>

<p>
The construction vtables for a complete object are 
emitted in the same object file as the vtable.
</font>
So the vtable structures for a complete object of class C include,
in no particular order:

<ul>
<li>
the main vtable group for C,
i.e. the vtable to which the primary virtual pointer (at offset 0) points,
along with its proper base class subobject vtables in order of allocation,
including virtual base class subobject vtables;

<li>
any construction vtables required for non-virtual and virtual bases; and

<li>
the VTT array for C, providing location information for the above.
</ul>

<p>
The VTT array is referenced via its own mangled external name,
and the construction vtables are accessed via the VTT array,
so the latter do not have external names.


<p>
<h4> Construction VTABLE entries</h4>

<p>
The construction vtable group for a
proper base class subobject B (of derived class D)
does not have the same entries in the same
order as the main vtable group for a complete object B,
as described in <a href=#vtable>Virtual Table Layout</a> above.
Some of the base class subobjects may not need construction vtables,
which will therefore not be present in the construction vtable group,
even though the subobject vtables are present in the main vtable group
for the complete object.

<p>
The <i>values</i> of some construction vtable entries will differ
from the corresponding entries in either the main vtable
group for B or the vtable group for B-in-D,
primarily because the virtual bases of B will be at different relative
offsets in a D object than in a standalone B object,
as follows:

<ol>
<li>
Virtual base class offsets reflect the positions of the virtual base
classes in the full D object.

<li>
Similarly, vcall offsets reflect the relative positions of the
overridden and overriding classes within the complete object D.

<li>
The offset-to-top fields refer to B
(and B's in particular will therefore be zero).

<li>
The RTTI pointers point to B's RTTI.

<li>
Only functions in B and its base classes are considered for virtual
function resolution.
</ol>


<p>
<h4> Subobject Construction and Destruction</h4>

<p>
The complete object (in-charge) constructors and destructors
find the VTT via its mangled name.
They pass the address of the subobject's sub-VTT
entry in the VTT as a second parameter when calling
the subobject (not-in-charge) constructors and destructors.
The subobject ctor/dtors use the addresses passed to initialize
the primary virtual pointer and virtual pointers that point to the
classes which either have virtual bases or override virtual functions
with a virtual step
(have vcall offsets needing adjustment).

<p>
If the not-in-charge constructor calls constructors for base class
subobjects that do not need construction vtables,
the construction vtable parameter is not passed to the base class
subobject constructor,
and the base class subobject constructors use
their complete object vtables for initialization.

<p>
<i>
Note: The EDG compiler passes the constructor vtables
by assigning them to the subobject virtual pointer
and the subobject constructors get the array address from the virtual
pointer.
This doesn't work when an exception is raised during construction,
and the destructor doesn't have the constructor vtable's address anymore.
There may be a way to make this work with the landing pad model,
but I haven't worked that out.

<p>
Suppose we have a subobject class D that needs a construction vtable,
derived from a base B that needs a construction vtable as part of D,
and possibly from others that do not need construction vtables.
Then the sub-VTT and constructor code for D would look like the following:
</i>

<p>
<code><pre>
     // Sub-VTT for D (embedded in VTT for its derived class X):
     static vtable *__VTT__1D [1+n+m] =
	{ D primary vtable,
	  // The sub-VTT for B-in-D in X may have further structure:
	  B-in-D sub-VTT (n elements),
	  // The secondary virtual pointers for D's bases have elements
	  // corresponding to those in the B-in-D sub-VTT,
	  // and possibly others for virtual bases of D:
	  D secondary virtual pointer for B and bases (m elements) }; 

     D ( D *this, vtable **ctorvtbls )
     {
	// (The following will be unwound, not a real loop):
	for ( each base A of D ) {

	   // A "boring" base is one that does not need a ctorvtbl:
	   if ( ! boring(A) ) {
	     // Call subobject constructors with sub-VTT index
	     // if the base needs it -- only B in our example:
	      A ( (A*)this, ctorvtbls + sub-VTT-index(A) ); 

	   } else {
	     // Otherwise, just invoke the complete-object constructor:
	      A ( (A*)this );
	   }
	}

        // Initialize virtual pointer with primary ctorvtbls address
	// (first element):
        this->vptr = ctorvtbls+0;	// primary virtual pointer

	// (The following will be unwound, not a real loop):
	for ( each subobject A of D ) {
	
	   // Initialize virtual pointers of subobjects with ctorvtbls
	   // addresses for the bases 
	   if ( ! boring(A) ) {
	      ((A*)this)->vptr = ctorvtbls + 1+n + secondary-vptr-index(A);
		   // where n is the number of elements in the sub-VTTs
	    
	   } else {
	     // Otherwise, just use the complete-object vtable:
	      ((A *)this)->vptr = &(A-in-D vtable);
	   }
	}

        // Code for D constructor.
	...
      }
</pre></code>

</table>

<p>
A test program for this can be found in the
<a href=abi-examples.html#vtable-ctor>ABI Examples</a> document.



<p> <hr> <p>
<a name=array-ctor>
<h3> Array Constructors and Destructors </h3>

<p>
<a name=array-cookies>
<h4> Operator <code>new</code> Cookies </h4>

<p>
When operator <code>new</code> is used to create a new dynamic-length array,
a cookie is usually stored to remember the allocated length
(number of array elements)
so that it can be deallocated correctly.

<p>
Specifically:
<ul>
<p>
<li> No cookie is required if the array element type T has a trivial
    destructor (12.4 [class.dtor])
    and the usual (array) deallocation function
    (3.7.3.2 [basic.stc.dynamic.deallocation])
    function does not take two arguments.

    <p>
    (Note: if the usual array deallocation function takes two arguments,
    then it is a member function whose second argument is of type size_t.
    The standard guarantees (12.5 [class.free])
    that this function will be passed the
    number of bytes allocated with the previous array new expression.

<p>
<li> No cookie is required if the <code>new</code> operator being used
    is <code>::operator new[](size_t, void*)</code>.

<p>
<li> Otherwise, this ABI requires a cookie, setup as follows:
  <ul>
  <li> The cookie will have size <code>sizeof(size_t)</code>.
  <li> Let <code>align</code> be the maximum alignment of
  <code>size_t</code> and an element of the array to be allocated.
  <li> Let <code>padding</code> be the maximum of
  <code>sizeof(size_t)</code> and <code>align</code> bytes.
  <li> The space allocated for the array will be the space required
  by the array itself plus <code>padding</code> bytes.
  <li> The alignment of the space allocated for the array will be
  <code>align</code> bytes.
  <li> The array data will begin at an offset of <code>align</code> bytes
  from the space allocated for the array.
  <li> The cookie will be stored in the <code>sizeof(size_t)</code> bytes
  immediately preceding the array data.
  </ul>

  <i>
  <p>
  These rules have the following consequences:
  <ul>
  <li> The array elements and the cookie are all aligned naturally.
  <li> Padding will be required if <code>sizeof(size_t)</code>
  is smaller than the array element alignment,
  and if present will precede the cookie.
  </ul>
  </i>

</ul>

<p>
Given the above, the following is pseudocode for processing
<code>new(ARGS) T[n]</code>:
<code><pre>
  if T has a trivial destructor (C++ standard, 12.4/3)
    padding = 0
  else if we're using ::operator new[](size_t, void*)
    padding = 0
  else
    padding = max(sizeof(size_t), alignof(T))

  p = operator new[](n * sizeof(T) + padding, ARGS)
  p1 = (T*) ( (char *)p + padding )

  if padding > 0
    *( (unsigned long *)p1 - 1) = n

  for i = [0, n)
    create a T, using the default constructor, at p1[i]

  return p1
</pre></code>

<p>
<a name=array-runtime>
<h4> Constructor/Destructor Runtime Support </h4>

<p>
An ABI-compliant system shall provide several runtime routines for use
in array construction and destruction.
They may be used by compilers, but their use is not required.
The required APIs are:

<dl>

<dt><code><pre>
void * abi::__cxa_vec_new (
		size_t element_count,
		size_t element_size,
		size_t padding_size,
		void (*constructor) ( void *this ),
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the number and size of elements for an array,
and the size of prefix padding for a cookie,
allocate space for the array preceded by the specified padding,
initialize the cookie if the padding is non-zero,
and call the given constructor on each element.
Return the address of the array proper,
after the padding.
If allocation throws, rethrow.
If the constructor throws an exception,
call the given destructor for any already-constructed elements,
delete the space,
and rethrow the exception.
If the destructor throws an exception...
</dd>

<dt><code><pre>
void abi::__cxa_vec_ctor (
		void *array_address,
		size_t element_count,
		size_t element_size,
		void (*constructor) ( void *this ),
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
not including any cookie padding,
and the number and size of its elements,
call the given constructor on each element.
If the constructor throws an exception,
call the given destructor for any already-constructed elements,
and rethrow the exception.
If the destructor throws an exception...
If the constructor (destructor) pointer is NULL,
no constructor (destructor) call is to be made.
</dd>

<dt><code><pre>
void abi::__cxa_vec_dtor (
		void *array_address,
		size_t element_count,
		size_t element_size,
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
the number of elements,
and the size of its elements,
call the given destructor on each element.
If the destructor throws an exception,
rethrow after destroying the remaining elements if possible.
If the destructor throws a second exception, call terminate.
If padding_size is 0, the destructor pointer must be NULL.
If the destructor pointer is NULL,
no destructor call is to be made.
</dd>

<dt><code><pre>
void abi::__cxa_vec_delete (
		void *array_address,
		size_t element_size,
		size_t padding_size,
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
the size of prefix padding for the cookie,
and the size of its elements,
call the given destructor on each element,
using the cookie to determine the number of elements,
and then delete the space.
If the destructor throws an exception,
rethrow after destroying the remaining elements if possible.
If the destructor throws a second exception, call terminate.
If padding_size is 0, the destructor pointer must be NULL.
If the destructor pointer is NULL,
no destructor call is to be made.
</dd>

</dl>



<p> <hr> <p>
<a name=guards>
<h3> Initialization Guard Variables </h3>

<p>
Associated with each function-scope static variable requiring runtime
construction is a guard variable which is used to guarantee that
construction occurs only once.
Its name is mangled based on the mangling of the guarded object name,
to allow distinct instances of the function
(e.g. due to inlining) to use the same guard.

<p>
The size and content of the guard variable is not yet defined.
The specification will depend partially on the chosen approach to
threading support.



<p> <hr> <p>
<a name=rtti>
<h3> Run-Time Type Information (RTTI) </h3>

<p>
The C++ programming language definition implies that information about
types be available at run time for three distinct purposes:
<ol type=a>
<li> to support the typeid operator,
<li> to match an exception handler with a thrown object, and
<li> to implement the dynamic_cast operator.
</ol>
(c) only requires type information about dynamic class types,
but (a) and (b) may apply to other types as well;
for example, when a pointer to an int is thrown,
it can be caught by a handler that catches "int const*".

<p>
It is intended that two type_info pointers point to equivalent type
descriptions if and only if the pointers are equal.
An implementation must satisfy this constraint,
e.g. by using symbol preemption, COMDAT sections, or other mechanisms.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Note that the full structure described by an RTTI descriptor may
include incomplete types not required by the Standard to be completed,
although not in contexts where it would cause ambiguity.
Therefore, any cross-references within the RTTI to types not known to
be complete must be weak symbol references.
</i>

<p>
<h5>Place of emission</h5>

<p>
It is desirable to minimize the number of places where a
particular bit of RTTI is emitted.
For dynamic class types,
a similar problem occurs for virtual function tables,
and hence the RTTI descriptor should be emitted
with the primary vtable for that type.
For other types, they must be emitted at the location
where their use is implied:
the object file containing the typeid, throw or catch.

<p>
Basic type information (e.g. for "int", "bool", etc.)
will be kept in the run-time support library.
Specifically, the run-time support library
should contain type_info objects for the types
X, X* and X const*,
for every X in: void, bool, wchar_t, char, unsigned char, signed char,
short, unsigned short, int, unsigned int, long, unsigned long, long long,
unsigned long long, float, double, long double.
(Note that various other type_info objects for class types may reside
in the run-time support library by virtue of the preceding rules;
e.g., that of std::bad_alloc.)


<p>
<h5>The typeid operator</h5>

<p>
The typeid operator produces a reference to a std::type_info structure
with the following public interface (18.5.1):

<pre><code>
  struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };
</pre></code>

<p>
After linking and loading,
only one std::type_info structure is accessible via the external name
defined by this ABI for any particular complete type symbol
(see <a href=#vague-rtti>Vague Linkage</a>).
Therefore,
except for direct or indirect pointers to incomplete types,
the equality and inequality operators can be
written as address comparisons
when operating on those type_info objects:
two type_info structures describe the same type
if and only if they are the same structure (at the same address).
However, in the case of pointer types,
directly or indirectly pointing to incomplete class types,
a more complex comparison is required,
described below with the RTTI layout of pointer types.

<font color=red>
<p>
The <code>name()</code> member function returns the address of an NTBS,
unique to the type,
containing the <a href=mangling-type>mangled name</a> of the type.
It has a <a href=mangling-special>mangled name</a> defined by the ABI
to allow consistent reference to it,
and the <a href=#vague-rtti>Vague Linkage</a> section specifies how to
produce a unique copy.

<p>
In a flat address space
(such as that of the IA-64 architecture),
the <code>operator==</code>, <code>operator!=</code>, and <code>before()</code>
members are easily implemented in terms of
an address comparison of the name NTBS.
</font>

<p>
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const
and volatile qualifications applied to types.


<p>
<h5>The dynamic_cast operator</h5>

<p>
Although dynamic_cast can work on pointers and references,
from the point of view of representation we need only to worry
about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time
and do not need any RTTI.
There are then three kinds of truly dynamic cast operations:
<ul>
<li> dynamic_cast&lt;void cv*>, which returns a pointer to the complete lvalue,
<li> dynamic_cast operation from a proper base class to a derived class, and
<li> dynamic_cast across the hierarchy which can be seen as a cast to
	the complete lvalue and back to a sibling base.
</ul>

<p>
The most common kind of dynamic_cast is base-to-derived in a singly
inherited hierarchy.

<p>
<a name=rtti-layout></a>
<h5>RTTI layout</h5>

<ol type=1>

<p>
<li>
The RTTI layout for a given type depends on whether a 32-bit or
64-bit mode is in effect.
The class definitions below are to be interpreted as following the
class layout rules for the host ABI.

<p>
<li>
Every vtable shall contain one entry describing the offset from a
virtual pointer for that vtable to the origin of the object containing
that virtual pointer
(or equivalently: to the virtual pointer for the primary vtable).
This entry is directly useful to implement dynamic_cast&lt;void cv*>,
but is also needed for the other truly dynamic casts.
This entry is located two words ahead of the location
pointed to by the virtual pointer (i.e., entry "-2").
This entry is present in all vtables,
even for classes having virtual bases but no virtual functions.

<p>
<li>
Every vtable shall contain one entry that is a pointer to an object
derived from std::type_info.
This entry is located at the word preceding the location
pointed to by the virtual pointer (i.e., entry "-1").
The entry is allocated in all vtables;
for classes having virtual bases but no virtual functions,
the entry is zero.

<p>
std::type_info contains just two pointers:
<ul>
<li> its virtual pointer
<li> a pointer to a NTBS representing the name of the type
</ul>

<p>
The possible derived types are:
<ul>
  <li> abi::__fundamental_type_info
  <li> abi::__array_type_info
  <li> abi::__function_type_info
  <li> abi::__enum_type_info
  <li> abi::__class_type_info
  <li> abi::__si_class_type_info
  <li> abi::__vmi_class_type_info
  <li> abi::__pbase_type_info
  <li> abi::__pointer_type_info
  <li> abi::__pointer_to_member_type_info
</ul>

<p>
<li>
abi::__fundamental_type_info adds no data members to std::type_info;

<p>
<li>
abi::__array_type_info and abi::__function_type_info do not add data
members to std::type_info
(these types are only produced by the typeid operator;
they decay in other contexts).
abi::__enum_type_info does not add data members either.

<p>
<li>
Three different types are used to represent type information:

<ol type=a>
<p>
<li>
abi::__class_type_info is used for class types having no bases,
and is also a base type for the other two class type representations.

<p>
This RTTI class may
also be used for incomplete class types when referenced by a pointer RTTI,
in which case it must be prevented from preempting
the RTTI for the complete class type,
for instance by emitting it as a static object (without external linkage).

<font color=red>
<p>
<strike>
Two abi::__class_type_info objects are normally compared for equality
(i.e. of the types represented)
by comparison of their addresses.
However, incomplete class RTTI objects,
which can only be accessed via abi::__pointer_type_info objects,
must be compared for equality
by comparison of the name NTBS in their std::type_info bases.
</strike>

<p>
Two abi::__class_type_info objects can always be compared,
for equality (i.e. of the types represented) or ordering,
by comparison of their name NTBS addresses.
In addition, complete class RTTI objects
may also be compared for equality
by comparison of their type_info addresses.

</font>

<p>
<li>
For classes containing only a single, public, non-virtual base
at offset zero (i.e. the derived class is dynamic iff the base is),
class abi::__si_class_type_info is used.
It adds to abi::__class_type_info
a single member pointing to the type_info structure for the base type,
declared "<code>__class_type_info const *type</code>".

<a name=vmi>
<p>
<li>
For classes with bases that do not satisfy the
__si_class_type_info constraints,
abi::__vmi_class_type_info is used.
It is derived from abi::__class_type_info, and adds data members:
  <ul>
  <p>
  <li> vmi_flags: a word with flags describing details
      about the class (most for use of the derived classes):
	<ul>
	<li> 0x01: class has non-diamond repeated inheritance
	<li> 0x02: class is diamond shaped
	<li> 0x04: class has non-publicly inherited base(s)
	<li> 0x08: class has publicly inherited base(s)
	      <font color=red> (See action item #37.) </font>

	</ul>
      All of these flags refer to both direct and indirect bases.
      The type of the _VMI_flags field is defined by each psABI,
      but must be at least 16 bits.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_base_count: a word with the number of direct proper base class
      descriptions that follow.
      The type of the _VMI_base_count field is defined by each psABI.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_bases[]: base class descriptions for every direct proper base;
       each description is of the type:
<pre><code>
      struct abi::__base_class_info {
         __class_type_info const *type;
	 long vmi_offset_flags;
      };
</pre></code>

      <p>
      The <code>type</code> member points to the RTTI for the base type.

      <p>
      The upper 56 bits of vmi_offset_flags are a signed offset.
      For a non-virtual base,
      this is the offset in the object of the base subobject.
      For a virtual base,
      this is the offset in the vtable of the
      virtual base offset for the virtual base referenced
      (negative).

      <p>
      The lower byte of vmi_offset_flags contains flags,
      as given by the following masks:
	<ul>
	<li> 0x1: Base class is virtual
	<li> 0x2: Base class is public
	</ul>

  </ul>

<p>
Note that the resulting structure is variable-length,
with the actual size depending on the number of trailing base class
descriptions.

</ol>

<font color=red>
<p>
<li>
abi::__pbase_type_info is a base for both pointer types and
pointer-to-member types.
It adds two data members (in this order):
<ul>
  <p>
  <li> a flag word describing the cv-qualification
      and other attributes of the type pointed to
      (e.g., "int volatile*" should have the
      "volatile" bit set in that word);
      and
  <p>
  <li> a pointer to the std::type_info derivation
      for the unqualified type being pointed to.
</ul>

<p>
Note that the flag bits should not be folded into the pointer to
allow future definition of additional flags.
It contains:
<ul>
<li> 0x1: const qualifier
<li> 0x2: volatile qualifier
<li> 0x4: restrict qualifier
<li> 0x8: incomplete target type
<li> 0x10: incomplete class type (in pointer to member)
</ul>

<p>
When the abi::__pbase_type_info is for a direct or indirect pointer
to an incomplete class type,
the incomplete target type flag is set.
When it is for a direct or indirect pointer to a member of
an incomplete class type,
the incomplete class type flag is set.
In addition, it and all of the intermediate abi::__pointer_type_info
structs in the chain down to the abi::__class_type_info for the
incomplete class type must be prevented from resolving to the
corresponding type_info structs for the complete class type,
possibly by making them local static objects.
Finally, a dummy class RTTI is generated for the incomplete type
that will not resolve to the final complete class RTTI
(because the latter need not exist),
possibly by making it a local static object.

<font color=red>
<p>
<strike>
Two abi::__pbase_type_info objects are compared for equality
(i.e. of the types represented)
by checking for equal target or class
type RTTI pointers unless either or both
have either of the incomplete flags set,
in which case the
NTBS data members in the base std::type_info structures
must be checked for equality.
</strike>

<p>
Two abi::__pbase_type_info objects can always be compared
for equality (i.e. of the types represented) or ordering
by comparison of their name NTBS addresses.
In addition,
unless either or both have either of the incomplete flags set,
equality can be tested by comparing the type_info addresses.

</font>

<p>
<li>
abi::__pointer_type_info is derived from abi::__pbase_type_info
with no additional data members.
</font>

<font color=red>
<p>
<li>
The abi::__pointer_to_member_type_info type adds one field
to abi::__pbase_type_info:
<ul>
<li> a pointer to an abi::__class_type_info corresponding to the class type
    (e.g., the "A" in "int A::*")
</ul>

</ol>

</font>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Note that this ABI requires elsewhere that a vtable be emitted for a
dynamic type in the object where the first non-inline virtual function
member is defined, if any, or everywhere referenced if none.
Therefore, an implementation should include at least one
non-inline virtual function member and define it in the library,
to avoid having user code inadvertently preempt the vtable.
Since the Standard requires a virtual destructor,
and it will rarely be called,
it is a good candidate for this role.
</i>


<h5>std::type_info::name()</h5>
<p>
The null-terminated byte string returned by this routine is
the <a href=#mangling>mangled name</a> of the type.


<p>
<h5>The dynamic_cast algorithm</h5>

<p>
Dynamic casts to "void cv*" are inserted inline at compile time.
So are dynamic casts of null pointers and dynamic casts that are really
static.

<p>
This leaves the following test to be implemented in the run-time
library for truly dynamic casts of the form "dynamic_cast&lt;T>(v)":
(see [expr.dynamic_cast] 5.2.7/8)

<ul>
<p>
<li>
If, in the most derived object pointed (referred) to by v, v points
(refers) to a public base class sub-object of a T object
[note: this can be checked at compile time],
and if only one object of type T is derived
from the sub-object pointed (referred) to by v,
the result is a pointer (an lvalue referring) to that T object.

<p>
<li>
Otherwise, if v points (refers) to a public base class sub-object
of the most derived object,
and the type of the most derived object has an
unambiguous public base class of type T,
the result is a pointer
(an lvalue referring)
to the T sub-object of the most derived object. 

<p>
<li>
Otherwise, the run-time check fails.
</ul>

<p>
The first check corresponds to a "base-to-derived cast" and the second
to a "cross cast".
These tests are implemented by abi::__dynamic_cast:

<pre><code>
   void* abi::__dynamic_cast ( const void *sub,
			       const abi::__class_type_info *src,
			       const abi::__class_type_info *dst,
			       std::ptrdiff_t src2dst_offset);
   /* sub: source address to be adjusted; nonnull, and since the
    *      source object is polymoprhic, *(void**)sub is a virtual
    pointer.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast&lt;T>(v)").
    * src2dst_offset: a static hint about the location of the
    *    source subobject with respect to the complete object;
    *    special negative values are:
    *       -1: no hint
    *       -2: src is not a public base of dst
    *       -3: src is a multiple public base type but never a
    *           virtual base type
    *    otherwise, the src type is a unique public nonvirtual
    *    base type of dst at offset obj2sub_offset from the
    *    origin of dst.
    */

</pre></code>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Rationale: 
<ul>
<p>
<li> A simple dynamic_cast algorithm that is efficient in the common
    case of base-to-most-derived cast case is preferable to more
    sophisticated ideas that handle deep-base-to-in-between-derived
    casts more efficiently at a slight cost to the common case.
    Hence, an earlier scheme of providing a hash-table into the
    list of base classes
    (as is done e.g. in the HP aC++ compiler)
    was dropped.
<p>
<li> For similar reasons,
    we only keep direct base information about a class type.
    Indirect base information can be found by chasing type_info pointers
    (and care should be taken to determine ambiguous base class types).
<p>
<li> The GNU egcs development team has implemented an idea of this ABI
    group to accelerate dynamic_cast operations by a-posteriori
    checking a "likely outcome".
    This is the purpose of the src2dst_offset hint.
    An implementation is free to always pass -1 (no hint),
    or to always ignore the hint in __dynamic_cast.
</ul>
</i>

<p>
<h5>The exception handler matching algorithm</h5>

<p>
Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document
(beyond the layout of the RTTI data).


<p> <hr> <p>
<a name=mangling>
<h3> External Names (a.k.a. Mangling) </h3>

<p>
This section specifies the <i>mangling</i>, i.e. encoding,
of external names
(external in the sense of being visible outside the object file where
they occur).
The encoding is formalized as a derivation grammar along with the
explanatory text,
in a modified BNF with the following conventions:
<ul>
<li> Non-terminals are delimited by diamond braces: "&lt;>".
<li> Italics in non-terminals are modifiers to be ignored,
     e.g. &lt;<i>function</i> name> is the same as &lt;name>.
<li> Spaces are to be ignored.
<li> Text beginning with '#' is comments, to be ignored.
<li> Tokens in square brackets "[]" are optional.
<li> Tokens are placed in parentheses "()" for grouping purposes.
<li> '*' repeats the preceding item 0 or more times.
<li> '+' repeats the preceding item 1 or more times.
<li> All other characters are terminals, representing themselves.
</ul>

<p>
See the separate <a href=abi-mangling.html>table</a>
summarizing the encoding characters used as terminals.

<p>
In the various explanatory examples,
we use <code>Ret?</code> for an unknown function return type
(i.e. that is not given by the mangling),
or <code>Type?</code> for an unknown data type.

<p>
<h4> Loose Ends </h4>

<p>
<ul>
<li> Mangling of special entities: helper variables for thread protection, ...
<li> Encode return type of all functions?   (Issue F-10)
<li> Proof of nonambiguity
<li> ILP-32 conventions?
</ul>

<p>
<h4> General structure </h4>

<p>
Entities with C linkage and global namespace variables are not mangled.
Mangled names have the general structure:
<pre><font color=blue><code>
    &lt;mangled-name> ::= _Z &lt;encoding>
    &lt;encoding> ::= &lt;<i>function</i> name> &lt;bare-function-type>
	       ::= &lt;<i>data</i> name>
</pre></font></code>

Thus, a name is mangled by prefixing "_Z" to an encoding of its name,
and in the case of functions its type (to support overloading).
At this top level,
function types do not have the special delimiter characters required
when nested (see below).

<pre><font color=blue><code>
    &lt;name> ::= &lt;nested-name>
	   ::= &lt;unqualified-name>
	   ::= &lt;local-name>	# See <a href=#mangling-scope>Scope Encoding</a> below
	   ::= &lt;substitution> # See <a href=#mangling-compression>Compression</a> below
</pre></font></code>

Names of objects nested in namespaces or classes are identified as a
delimited sequence of names identifying the enclosing scopes.
In addition, when naming a class member function,
CV-qualifiers may be prefixed to the compound name,
encoding the <code>this</code> attributes.
Note that if member function CV-qualifiers are required,
the delimited form must be used even if the remainder of the name is
a single substitution.

<pre><font color=red><code>
    &lt;nested-name> ::= N [&lt;CV-qualifiers>] &lt;compound-name> E
    &lt;compound-name> ::= &lt;compound-prefix> &lt;compound-name>
		    ::= &lt;unqualified-name>
    &lt;compound-prefix> ::= &lt;path-component> [&lt;template-args>]
    &lt;path-component> ::= &lt;<i>namespace</i> source-name>
		     ::= &lt;<i>class-enum</i> source-name>
    &lt;unqualified-name> ::= &lt;source-name>  # types, functions
		       ::= &lt;source-name> &lt;template-args>
		       ::= &lt;operator-name>
		       ::= &lt;operator-name> &lt;template-args>
		       ::= &lt;special-name> # ctors, vtables, ...
		       ::= &lt;special-name> &lt;template-args>

    &lt;source-name> ::= &lt;<i>length</i> number> &lt;identifier>
    &lt;number> ::= &lt;<i>decimal integer</i>>
    &lt;identifier> ::= &lt;<i>unqualified source code identifier</i>>

</pre></font></code>

<font color=red>
The above grammar fragment describes the form of nested names.
However, for compression purposes
(discussed <a href=#mangling-compression>below</a>),
only a prefix of this nesting can be substituted,
corresponding to likely symbol table entries for namespaces,
types, objects, templates, and instantiated templates.
The following substitute grammar fragment for &lt;compound-name>,
though it permits many nonsensical constructs,
indicates which prefixes of valid names may be substituted:
</font>

<pre><font color=red><code>
    &lt;compound-name> ::= &lt;compound-name> &lt;compound-component>
		    ::= &lt;compound-component>
		    ::= &lt;substitution>
    &lt;compound-component> ::= &lt;source-name>
			 ::= &lt;operator-name>
			 ::= &lt;special-name> # ctors, vtables, ...
			 ::= &lt;template-args>

</pre></font></code>

<p>
&lt;number> is a pseudo-terminal representing a decimal integer,
giving the character length of the following identifier.
&lt;number>s appearing in mangled names never have leading zeroes,
except for the value zero, represented as '0'.
&lt;identifier> is a pseudo-terminal representing the unqualified
identifier for the entity in the source code.

<p>
&lt;type> is used to disambiguate overloaded functions,
but also to distinguish the various virtual tables associated
with a given complete class type.
&lt;type> is omitted for variables and static data members.

<p>
Note that &lt;source-name> in the productions for &lt;unqualified-name>
may be either a function or data object name when derived from &lt;name>,
or a class or enum name when derived from &lt;type>.

<p>
<a name=mangling-operator>
<h4> Operator Encodings </h4>

<p>
Operators appear as function names,
and in nontype template argument expressions.
Unlike Cfront,
unary and binary operators using the same symbol have different encodings.
All operators are encoded using exactly two letters,
the first of which is lowercase.

<pre><font color=blue><code>
  &lt;operator-name> ::= nw	# new           
		  ::= na	# new[]
		  ::= dl	# delete        
		  ::= da	# delete[]      
		  ::= ng	# - (unary)     
		  ::= ad	# & (unary)     
		  ::= de	# * (unary)     
		  ::= co	# ~             
		  ::= pl	# +             
		  ::= mi	# -             
		  ::= ml	# *             
		  ::= dv	# /             
		  ::= rm	# %             
		  ::= an	# &             
		  ::= or	# |             
		  ::= eo	# ^             
		  ::= aS	# =             
		  ::= pL	# +=            
		  ::= mI	# -=            
		  ::= mL	# *=            
		  ::= dV	# /=            
		  ::= rM	# %=            
		  ::= aN	# &=            
		  ::= oR	# |=            
		  ::= eO	# ^=            
		  ::= ls	# <<            
		  ::= rs	# >>            
		  ::= lS	# <<=           
		  ::= rS	# >>=           
		  ::= eq	# ==            
		  ::= ne	# !=            
		  ::= lt	# <             
		  ::= gt	# >             
		  ::= le	# <=            
		  ::= ge	# >=            
		  ::= nt	# !             
		  ::= aa	# &&            
		  ::= oo	# ||            
		  ::= pp	# ++            
		  ::= mm	# --            
		  ::= cm	# ,             
		  ::= pm	# ->*           
		  ::= pt	# ->            
		  ::= cl	# ()            
		  ::= ix	# []            
		  ::= qu	# ?             
		  ::= cv	# (cast)        
		  ::= sz	# sizeof        
		  ::= vx &lt;source-name>	# vendor extended operator

</pre></font></code>

<p>
Vendors who define builtin extended operators (e.g. __alignof)
shall encode them as a 'vx' prefix followed by the name in &lt;length,ID> form.


<p>
<a name=mangling-special>
<h4> Other Special Functions and Entities </h4>

<p>
Associated with a virtual table are several entities with mangled
external names: the vtable itself, the VTT for construction,
the typeinfo structure, and the name it references.
All have an encoding where the &lt;name> is a simple two-character code,
appearing as the last component of a &lt;nested-name>,
where the prefix is the name of the class with which they are associated.

<pre><font color=blue><code>
  &lt;special-name> ::= TV	# virtual table
		 ::= TT	# VTT structure (construction vtable index)
		 ::= TI	# typeinfo structure
<font color=blue>
		 ::= TS	# typeinfo name (null-terminated byte string)
</font>
</pre></font></code>

<p>
Initialization of function-scope static objects requires
a guard variable to prevent multiple initialization.
These are mangled as a 'GV' prefix with the mangled name of the object
being guarded.

<pre><font color=blue><code>
  &lt;special-name> ::= GV &lt;<i>object</i> name>	# Guard variable for one-time initialization
			# No &lt;type>

</pre></font></code>

<p>
Virtual function override thunks come in two forms.
Those overriding from a non-virtual base,
with fixed <code>this</code> adjustments,
use a "Th" prefix and encode the required adjustment offset,
probably negative, indicated by a 'n' prefix,
and the encoding of the target function.
Those overriding from a virtual base must encode two offsets
after a "Tv" prefix.
The first is the constant adjustment to the nearest virtual base
(of the full object),
of which the defining object is a non-virtual base.
It is coded like the non-virtual case,
with a 'n' prefix if negative.
The second offset identifies the vcall offset in the nearest virtual base,
which will be used to finish adjusting <code>this</code> to the full object.
After these two offsets comes the encoding of the target function.
The target function encodings of both thunks incorporate the function type;
no additional type is encoded for the thunk itself.


<pre><font color=blue><code>
  &lt;special-name> ::= Th[n] &lt;<i>offset</i> number> _ &lt;<i>base</i> name> &lt;<i>base</i> function-type>
			# non-virtual base override thunk
			# <i>base</i> is the nominal target function of thunk
			# No &lt;type> other than base function's
		 ::= Tv[n] &lt;<i>offset</i> number> _ &lt;<i>vcall offset</i> number> _ &lt;<i>base</i> name>
			# virtual base override thunk
			# <i>base</i> is the nominal target function of thunk
			# No &lt;type> other than base function's

</pre></font></code>

<p>
Constructors and destructors are simply special cases of &lt;nested-name>,
where the final &lt;unqualified-name> is replaced by one of the following:

<pre><font color=blue><code>
  &lt;special-name> ::= C1	# complete object (in-charge) constructor
		 ::= C2	# base object (not-in-charge) constructor
		 ::= C3	# complete object (in-charge) allocating constructor
		 ::= C4	# base object (not-in-charge) allocating constructor
		 ::= D0	# deleting (in-charge) destructor
		 ::= D1	# complete object (in-charge) destructor
		 ::= D2	# base object (not-in-charge) destructor

</pre></font></code>


<p>
<a name=mangling-type>
<h4> Type encodings </h4>

<p>
Types are encoded as follows:

<pre><font color=blue><code>
  &lt;type> ::= &lt;builtin-type>
	 ::= &lt;function-type>
	 ::= &lt;class-enum-type>
	 ::= &lt;array-type>
	 ::= &lt;pointer-to-member-type>
	 ::= &lt;template-param>
	 ::= &lt;substitution> # See <a href=#mangling-compression>Compression</a> below

</pre></font></code>

<p>
Types are qualified (optionally) by single-character prefixes encoding
cv-qualifiers and/or pointer, reference, complex, or imaginary types:

<pre><font color=blue><code>
  &lt;type> ::= &lt;CV-qualifiers> &lt;type>
	 ::= P &lt;type>	# pointer-to
	 ::= R &lt;type>	# reference-to
	 ::= C &lt;type>	# complex pair (C 2000)
	 ::= G &lt;type>	# imaginary (C 2000)
	 ::= U &lt;source-name> &lt;type>	# vendor extended type qualifier

  &lt;CV-qualifiers> ::= [r] [V] [K] 	# restrict (C99), volatile, const

</pre></font></code>

<p>
Vendors who define extended type qualifiers (e.g. _near, _far for pointers)
shall encode them as a 'U' prefix followed by the name in &lt;length,ID> form.

<p>
In cases where multiple order-insensitive qualifiers are present,
they should be ordered 'K' (closest to the base type), 'V', 'r', and
'U' (farthest from the base type), with the 'U' qualifiers in
alphabetical order by the vendor name
(with alphabetically earlier names closer to the base type).
For example, <code>int* volatile const restrict _far p</code>
has mangled type name <code>U4_farrVKPi</code>.

<p>
<i>
Vendors must therefore specify which of their extended qualifiers are
considered order-insensitive,
not necessarily on the basis of whether their language translators
impose an order in source code.
They are encouraged to resolve questionable cases as being
order-insensitive to maximize consistency in mangling.
</i>

<p>
<i>
For purposes of substitution,
given a CV-qualified type,
the base type is substitutible,
and the type with all the C, V, and r qualifiers plus any vendor
extended types in the same order-insensitive set is substitutible;
any types with a subset of those qualifiers is not.
That is, given a type <code>const volatile foo</code>,
the fully qualified type or foo may be substituted,
but not <code>const foo</code>.
</i>

<a name=mangling-builtin>
<p>
Builtin types are represented by single-letter codes:

<pre><font color=blue><code>
  &lt;builtin-type> ::= v	# void
		 ::= w	# wchar_t
		 ::= b	# bool
		 ::= c	# char
		 ::= a	# signed char
		 ::= h	# unsigned char
		 ::= s	# short
		 ::= t	# unsigned short
		 ::= i	# int
		 ::= j	# unsigned int
		 ::= l	# long
		 ::= m	# unsigned long
		 ::= x	# long long, __int64
		 ::= y	# unsigned long long, __int64
		 ::= n	# __int128
		 ::= o	# unsigned __int128
		 ::= f	# float
		 ::= d	# double
		 ::= e	# long double, __float80
		 ::= g	# __float128
		 ::= z	# ellipsis
		 ::= u &lt;source-name>	# vendor extended type

</pre></font></code>

<p>
Note that the encodings of __int64 and __float80 are based on the
assumption that the base psABI will treat them as typedefs,
which is not yet confirmed.

<p>
Vendors who define builtin extended types shall encode them
as a 'u' prefix followed by the name in &lt;length,ID> form.

<p>
Function types are composed from their parameter types and possibly the
result type.
Except at the outer level type of an &lt;encoding>,
or in the &lt;encoding> of an otherwise delimited external name in a
&lt;template-param> or &lt;local-name> function encoding,
these types are delimited by an "F..E" pair.
For purposes of substitution
(see <a href=#mangling-compression>Compression</a> below),
delimited and undelimited function types are considered the same.

<p>
The type of nontemplate function objects
(e.g. the &lt;type> in function name manglings,
or the target function type in thunk manglings)
includes only the parameter types.
For template functions,
or for function type specifications such as function parameters,
&lt;type> includes the return type followed by the parameter types.
Thus:
<ul>
<li> Template functions (names or types) have return types encoded.
<li> Non-template function names do not have return types encoded.
<li> Function types not appearing as part of a function name mangling,
e.g. parameters, pointer types, etc., have return type encoded.
</ul>

<p>
Empty parameter lists,
whether declared as <code>()</code> or conventionally as <code>(void)</code>,
are encoded with a void parameter specifier (v).
Therefore function types always encode at least one parameter type,
and function manglings can always be distinguished from data manglings
by the presence of the type.
Member functions do not encode the type of
their implicit <code>this</code> parameter.

<p>
A "Y" prefix for the bare function type encodes extern "C".
If there are any cv-qualifiers of <code>this</code>,
they are encoded at the beginning of the &lt;qualified-name>
as described above.
This affects only type mangling,
since extern "C" function objects have unmangled names.

<pre><font color=blue><code>
  &lt;function-type> ::= F [Y] &lt;bare-function-type> E
  &lt;bare-function-type> ::= &lt;<i>signature</i> type>+
	# types are possible return type, then parameter types

</pre></font></code>

<p>
<font color=red>
A class or enum type is simply a name,
It may be a simple &lt;unqualified-name>,
with or without a template argument list,
or a more complex &lt;nested-name>.
Thus, it is encoded like a function name,
except that no CV-qualifiers are present in a nested name specification.
</font>

<pre><font color=red><code>
  &lt;class-enum-type> ::= &lt;nested-name>
		    ::= &lt;unqualified-name>
</pre></font></code>

<p>
Array types encode the dimension (number of elements) and the element type.
Note that "array" parameters to functions are encoded as pointer types.
For variable length arrays,
the dimension (but not the '_' separator) is omitted.

<pre><font color=blue><code>
  &lt;array-type> ::= A [&lt;<i>dimension</i> number>] _ &lt;<i>element</i> type>

</pre></font></code>

<p>
Pointer-to-member types encode the class and member types.

<pre><font color=blue><code>
  &lt;pointer-to-member-type> ::= M &lt;<i>class</i> type> &lt;<i>member</i> type>

</pre></font></code>

<p>
Template parameters (including nontype and template template parameters)
encode the parameter number.
Objects appearing within multiple levels of template number the
top-level parameters 1..n, the next level n+1..n+m, etc.

<pre><font color=blue><code>
  &lt;template-param> ::= T &lt;<i>parameter</i> number> _

</pre></font></code>

<p>
Template argument lists appear after the unqualified template name,
and are bracketed by I/E.
This is used in names for specializations in particular,
but also in types and scope identification.

<pre><font color=blue><code>
  &lt;template-args> ::= I &lt;template-arg>+ E
  &lt;template-arg> ::= &lt;type>			# type
  &lt;template-arg> ::= L &lt;type> &lt;<i>value</i> number> E	# literal
  &lt;template-arg> ::= LZ &lt;encoding> E		# external name
  &lt;template-arg> ::= X &lt;expression> E		# expression

</pre></font></code>

<p>
Type arguments appear using their regular encoding.
For example, the template class "A&lt;char, float>" is encoded as "1AIcfE".
A slightly more involved example is
a dependent function parameter type "A&lt;T2>::X"
(T2 is the second template parameter)
which is encoded as "N1AIT2_E1XE",
where the "N...E" construct is used to describe a qualified name.

<p>
Literal arguments, e.g. "A&lt;42L>",
are encoded with their type and value.
Negative integer values are preceded with "n";
for example, "A&lt;-42L>" becomes "1AILln42EE".
The bool value false is encoded as 0, true as 1.
If floating-point arguments are accepted as an extension,
their values should be encoded using a fixed-length lowercase hexadecimal
string corresponding to the internal representation (IEEE on IA-64),
high-order bytes first, without leading zeroes.
For example: "Lfbff000000E" is -1.0f.

<p>
A reference to an entity with external linkage is encoded with
"L&lt;mangled name>E".
For example:
<code><pre>
          void foo(char); // mangled as _Z3fooc
          template&lt;void (&)(char)> struct CB;
          // CB&lt;foo> is mangled as "2CBIL_Z3foocEE"

</pre></code>

<p>
The &lt;encoding> of an extern "C" function is treated like
global-scope data,
i.e. as its &lt;source-name> without a type.
For example:
<code><pre>
          extern "C" bool IsEmpty(char *); // (un)mangled as IsEmpty
          template&lt;void (&)(char *)> struct CB;
          // CB&lt;IsEmpty> is mangled as "2CBIL_Z7IsEmptyEE"

</pre></code>

<p>
An expression, e.g., "B&lt;(J+1)/2>",
is encoded with a prefix traversal of the operators involved,
delimited by "X...E".
The operators are encoded using their two letter mangled names.
For example, "B&lt;(J+1)/2>", if J is template parameter 1,
becomes "1BI Xdv pl T1_ Li1E Li2E E E"
(the blanks are present only to visualize the decomposition).
<font color=red>
Note that the expression is mangled without constant folding or other
simplification,
and without parentheses, which are implicit in the postfix representation.
Except for the parentheses, therefore,
it represents the source token stream.
(C++ Standard reference 14.5.5.1 p. 5.)
</font>

<pre><font color=blue><code>
  &lt;expression> ::= &lt;<i>unary</i> operator-name> &lt;expression>
	       ::= &lt;<i>binary</i> operator-name> &lt;expression> &lt;expression>
	       ::= &lt;expr-primary>
  &lt;expr-primary> ::= &lt;template-param>
		 ::= L &lt;type> &lt;<i>value</i> number> E	# literal
		 ::= L &lt;mangled-name> E		# external name

</pre></font></code>

<font color=red>
<p>
The encoding for a literal of an enumerated type is the encoding of the
type name followed by the encoding of the numeric value of the literal
in its base integral type
(which deals with values that don't have names declared in the type).
</font>


<p>
<a name=mangling-scope>
<h4> Scope Encoding </h4>

<p>
A nonlocal scope is encoded as the qualifier of a qualified name:
it can be the top-level name qualification or it can appear inside
&lt;type> to denote dependent types or bind specific names as arguments.
Qualified names are encoded as:
<code><pre>
   N &lt;qual 1> ... &lt;qual N> &lt;unqual name> E
</pre></code>
where each &lt;qual K> is the encoding of a namespace name or a class name
(with the latter possibly including a template argument list).

<p>
Occasionally entities in local scopes must be mangled too
(e.g. because inlining or template compilation causes
multiple translation units to require access to that entity).
The encoding for such entities is as follows:
<code><pre>
  &lt;local-name> := Z &lt;<i>function</i> encoding> E &lt;<i>entity</i> name> [&lt;discriminator>]
<font color=red>
               := Z &lt;<i>function</i> encoding> E s [&lt;discriminator>]
               := Z &lt;<i>function</i> encoding> E c
</font>

  &lt;discriminator> := _ &lt;number> 
</pre></code>

<font color=red>
<p>
The first production is used for named local static objects,
which are identified by their declared names.
The discriminator is used only for the
second and later occurrences of the same name within a single function.
In this case &lt;number> is n - 2,
if this is the nth occurrence, in lexical order, of the given name.

<p>
The second production is used for string literals.
The discriminator is used only if there is more than one,
for the second and subsequent ones.
In this case &lt;number> is n - 2,
if this is the nth distinct string literal, in lexical order,
appearing in the function.
Multiple references to the same string literal produce one string
object with one name in the sequence.
</font>
<i>
Note that this assumes that the same string literal occurring twice
in a given function in fact represents a single entity,
i.e. has a unique address.
</i>

<i>
<p>
<font color=red>
For both named objects and string literals,
the numbering order is strictly lexical order based on the original
token sequence.
All objects occurring in that sequence are to be numbered,
even if subsequent optimization makes some of them unnecessary.
</font>
It is expected that this will be the 'natural' order in most compilers.
In any case, conflicts would arise only if different compilation units
including the same code were compiled by different compilers,
and multiple entities requiring mangling had the same name.
</i>

<font color=red>
<p>
The third production is used only to produce the name used for the
COMDAT group containing the local objects.
</font>

<p>
Example:
<code><pre>
   namespace N {
      inline char* f(int i) {
         static char *p = "IA-64 C++ ABI";  // p = 1, "..." = 2
         {  struct X {                      // X = 3
               void g() {}
            };   }
         return p[i];
      }
   }
</pre></code>

<ul>
<li> "<code>_ZZN1N1fEiE1p</code>":
    encoding of N::f:p (first local mangled entity)
<li> "<code>_ZZN1N1fEiEs&lt;hashed-literal></code>":
    encoding of N::f:"IA-64 C++ ABI"
<li> "<code>_ZNZN1N1fEiE1X1gE</code>":
    encoding of N::f:X::g()
    (third local mangled entity used as a class-qualifier)
</ul>



<p>
<a name=mangling-compression>
<h4> Compression </h4>

<p>
To minimize the length of external names,
we use two mechanisms,
a substitution encoding to eliminate repetition of name components,
and abbreviations for certain common names.
Each non-terminal in the grammar above for which &lt;substitution>
appears on the RHS,
types, names, and qualified name prefixes,
is both a source of future substitutions
and a candidate for being substituted.

<p>
<i>
All substitutions are for entities that would appear in a symbol table.
In particular,
we make substitutions for prefixes of qualified names,
but not for arbitrary components of them.
Thus, the components ::n1::foo() and ::n2:foo() appearing in the same
name would not result in substituting for the second "foo."
Similarly, we do not substitute for expressions,
though names appearing in them might be substituted.
The reason for this is to facilitate implementations that use the
symbol table to keep track of components that might be substitutable.
</i>

<p>
Logically, the substitutable components of a mangled name are
considered left-to-right,
components before the composite structure of which they are a part.
If a component has been encountered before,
it is substituted as described below.
If not, its mangling is identified,
and it is added to a dictionary of substitution candidates.
No entity is added to the dictionary twice.
Thus, an implementation may optimize by considering large structures
for substitution before their components.

<p>
Substitution is according to the production:

<pre><font color=blue><code>
  &lt;substitution> ::= S &lt;seq-id> _
		 ::= S_

</pre></font></code>

The &lt;seq-id> is a sequence number in base 36,
using digits and upper case letters,
and identifies the &lt;seq-id>-th most recently encoded component,
in right-to-left order, starting at "0".
As a special case,
the immediately preceding substitutable entity is encoded as "S_",
i.e. with no number,
so the numbered entities are the second preceding one as "S0_",
the third as "S1_", the twelfth as "SA_", the thirty-eighth as "S10_",
etc.
All substitutable components are so numbered,
except those that have already been numbered for substitution,
but the substitution occurs only if "S&lt;seq-id>_" (or "S_")
is strictly shorter than the unsubstituted encoding,
<font color=red>
i.e. the encoding obtained if no substitution of its parts were done.
</font>
A component is less recent than the structure of which it is a part.
For example:

<code><pre>
   "_ZN1N1TIiiE2mfES2_IddE": Ret? N::T&lt;int, int>::mf(N::T&lt;double, double>)
</pre></code>

since at the point where S2_ appears:
<code><pre>
   "S_" == N::T&lt;int, int>::mf
   "S0_" == N::T&lt;int, int>
   "S1_" == int
   "S2_" == N::T (template is less recent than template-id)
   "S3_" == N (qualifier is less recent than qualified entity)

</pre></code>

<p>
Note that substitutable components are the represented symbolic constructs,
not their associated mangling character strings.
Thus, a substituted object matches its unsubstituted form,
and a delimited &lt;function-type> matches its &lt;bare-function-type>.

<p>
In addition,
the following catalog of abbreviations of the form "Sx" are used:
<pre><font color=blue><code>
   &lt;substitution> ::= St # ::std::
   &lt;substitution> ::= Sa # ::std::allocator
   &lt;substitution> ::= Sb # ::std::basic_string
   &lt;substitution> ::= Ss # ::std::basic_string &lt; char,
						 ::std::char_traits&lt;char>,
						 ::std::allocator&lt;char> >
   &lt;substitution> ::= Si # ::std::basic_istream&lt;char,  std::char_traits&lt;char> >
   &lt;substitution> ::= So # ::std::basic_ostream&lt;char,  std::char_traits&lt;char> >
   &lt;substitution> ::= Sd # ::std::basic_iostream&lt;char, std::char_traits&lt;char> >
</pre></font></code>

To account for versioned standard library namespaces, the following substitutions
are defined, where &lt;inline-ns> is the numeric part of a namespace name matching
__[0-9]+, except __1 for which there is no substitution.

<p><i>
Note that versioning namespaces matching __1 are not compressed because that would
constitute an ABI break for existing implementations, which already use that scheme.
</i></p>

<pre><font color=blue><code>
   &lt;substitution> ::= Stv&lt;inline-ns>v # ::std::__[0-9]+
   &lt;substitution> ::= Sav&lt;inline-ns>v # ::std::__[0-9]+::allocator
   &lt;substitution> ::= Sbv&lt;inline-ns>v # ::std::__[0-9]+::basic_string
   &lt;substitution> ::= Ssv&lt;inline-ns>v # ::std::__[0-9]+::basic_string &lt; char,
                                                                        ::std::__[0-9]+::char_traits&lt;char>,
                                                                        ::std::__[0-9]+::allocator&lt;char> >
   &lt;substitution> ::= Siv&lt;inline-ns>v # ::std::__[0-9]+::basic_istream&lt;char,  std::__[0-9]+::char_traits&lt;char> >
   &lt;substitution> ::= Sov&lt;inline-ns>v # ::std::__[0-9]+::basic_ostream&lt;char,  std::__[0-9]+::char_traits&lt;char> >
   &lt;substitution> ::= Sdv&lt;inline-ns>v # ::std::__[0-9]+::basic_iostream&lt;char, std::__[0-9]+::char_traits&lt;char> >
</pre></font></code>

<p>
The abbreviation St is always an initial qualifier,
i.e. appearing as the first element of a compound name.
It does not require N...E delimiters unless
either followed by more than one additional composite name component,
or preceded by CV-qualifiers for a member function.
This adds the case:
<pre><font color=blue><code>
   &lt;name> ::= St &lt;unqualified-name> # ::std::

</pre></font></code>

For example:
<code><pre>
   "_ZSt5state": ::std::state
   "_ZNSt3_In4wardE": ::std::_In::ward
</pre></code>


<p>
<a name=mangling-examples>
<h4> Examples </h4>

<p>
In the table below,
<code>Ret?</code> in the source name indicates a function for which
the return type is not part of the mangling.
<code>Type?</code> indicates a data object
(for which the type is never part of the mangling).
Spaces appear in some of the mangled names to assist a human parser --
they are not part of the actual mangled name, and should be ignored.

<p>
<table border=1 cellpadding=4>
<tr><th> Mangled name <br><i>(ignore spaces)</i> </th>
<th> Source name </th> </tr>

<tr class=small><td> f </td>
<td> C function or variable "f" or a global namespace variable "f"</td></tr>

<tr class=small><td> _Z1fv </td>
<td> Ret? f(); <i>or</i> Ret? f(void); </td></tr>

<tr class=small><td> _Z1fi </td>
<td> Ret? f(int); </td></tr>

<tr class=small><td> _Z3foo3bar </td>
<td> Ret? foo(bar); </td></tr>

<tr class=small><td> _Zrm1X1X </td>
<td> Ret? operator%(X, X); </td></tr>

<tr class=small><td> _ZplR1XR1X </td>
<td> Ret? operator+(X&, X&); </td></tr>

<tr class=small><td> _ZlsRK1XS_ </td>
<td> Ret? operator&lt;&lt; (X const&, X const&);
<br> (Note: strlen("S_")&lt;strlen("RK1X")) </td></tr>

<tr class=small><td> _ZlsRK1XS_S_ </td>
<td> Ret? operator&lt;&lt; (X const&, X const&, X const&);
</td></tr>

<tr class=small><td> _ZN3FooIA4_iE3barE </td>
<td> Type? Foo&lt;int[4]>::bar; </td></tr>

<tr class=small><td> _Z1fIiEvi </td>
<td> void f&lt;int>(/*nondependent*/int);
<br> (Note: the return type is always explicitly encoded for template
functions taking parameters.)</td></tr>

<tr class=small><td> _Z5firstI3DuoEvS1_ </td>
<td> void first&lt;Duo>(/*nondependent*/Duo);
<br>(Note: "S_" would refer to the "void" return type.) </td></tr>

<tr class=small><td> _Z5firstI3DuoEvT1_ </td>
<td> void first&lt;Duo>(/*T1=*/Duo); </td></tr>

<tr class=small><td> _Z3fooIiPFidEiEvv </td>
<td> void foo&lt;int,int(*)(double),int>();
<br>(Note: return type encoded for template function.)</td></tr>

<tr class=small><td> _ZN1N1fE </td>
<td> Type? N::f </td></tr>

<tr class=small><td> _ZN6System5Sound4beepEv </td>
<td> Ret? System::Sound::beep(); </td></tr>

<tr class=small><td> _ZN5Arena5levelE </td>
<td> Type? Arena::level; </td></tr>

<tr class=small><td> _ZN5StackIiiE5levelE </td>
<td> Type? Stack&lt;int, int>::level; </td></tr>

<tr class=small><td> _Z1fI1XE vPV N1AIT1_E1TE </td>
<td> void f&lt;X>(A&lt;/*T1=*/X>::T volatile*); </td></tr>

<tr class=small><td> _ZngILi42EE vN1AIXplT1_Li2EE1TE </td>
<td> void operator-&lt;/*int J=*/42>(A&lt;J+2>::T); </td></tr>

<tr class=small><td> _Z4makeI7FactoryiE T1_IT2_E </td>
<td> /*T1=*/Factory&lt;/*T2=*/int> make&lt;Factory, int>();
<br> // T1 == template template parameter </td></tr>

<tr class=small><td> _Z3foo 5Hello5WorldS_S0_ </td>
<td> void foo(Hello,World,World,Hello) </td></tr>

<tr class=small><td> _Z3fooPM2ABi </td>
<td> foo(int AB::**)
<br> // M is a pointer, P adds another level </td></tr>

<tr class=small><td> _ZlsRSoRKSs </td>
<td> operator&lt;&lt; (std::ostream&,std::string const&) </td></tr>

</table>


<p> <hr> <p>
<a name=vague>
<h3> Vague Linkage </h3>

<p>
Many objects in C++ are not clearly part of a single object file,
but are required by the ODR to have a single definition.
This section identifies, for such objects,
where (i.e. in which objects) they should be emitted,
and what special treatment might be required if duplicates are possible.

<p>
In many cases,
we will deal with duplicates by putting possibly duplicated objects
in distinct ELF sections or groups of sections,
and using the COMDAT feature of <code>SHT_GROUP</code> sections in the
gABI to remove duplicates.
We will refer to this simply as using a COMDAT group,
and specify the symbol to be used to identify duplicates in the
<code>SHT_GROUP</code> section.

<p>
<a name=vague-inline></a>
<b>Out-of-line Functions</b>

<p>
It may sometimes be necessary or desirable to reference an out-of-line
copy of a function declared inline,
<font color=red>
i.e. to reference a global symbol naming the function.
This may occur because the implementation cannot, or chooses not to,
inline the function, or because it needs an address rather than a call.
In such a case,
the function is to be emitted in each object where its name is referenced.
</font>
A COMDAT group is used to eliminate duplicates,
with the mangled name of the function as the identifying symbol.

<font color=red>
<p>
Inline functions, whether or not declared as such,
and whether they are inline or out-of-line copies,
may reference static data or character string literals,
that must be kept in common among all copies
by using the local symbol mangling defined above.
These objects are named according to the rules for local names in the
<a href=#scope-encoding> Scope Encoding </a> section above,
and their definitions are emitted in a single COMDAT group,
the identifier of which is specified in the
<a href=#scope-encoding> Scope Encoding </a> section above.
This COMDAT group must be emitted in each object with references to the
symbols for objects it contains, either inline or out-of-line.

<p>
Issue:  Different instances may require different subsets of the local
objects defined, e.g. due to different optimization levels.
In particular, the inlined copies might eliminate large parts of the code.
So we must either require that each COMDAT contain all declared local objects,
put them in different COMDATs,
or otherwise guarantee that everything required is present.
</font>

<p>
<a name=vague-vtable></a>
<b>Virtual Tables</b>

<p>
The virtual table for a class is emitted in the same object containing
the definition of its <i>key function</i>,
i.e. the first virtual function that is not inline at the point of
class definition.
If there is no key function, it is emitted everywhere used.
The emitted virtual table includes the full virtual table group for the class,
any new construction virtual tables required for subobjects,
and the VTT for the class.
They are emitted in a COMDAT group,
with the virtual table mangled name as the identifying symbol.
<font color=red>
<i>
Note that if the key function is not declared inline in the class definition,
but its definition later is always declared inline,
it will be emitted in every object containing the definition.
</i>
</font>

<p>
<a name=vague-rtti></a>
<b>Typeinfo</b>

<font color=red>
<p>
The RTTI std::type_info structure for a complete class type is
emitted in the same object as its virtual table if dynamic,
or everywhere referenced if not.
The RTTI std::type_info structure for an incomplete class type is
emitted wherever referenced.
The RTTI std::type_info structures for various basic types as
specified by the <a href=#rtti>Run-Time Type Information</a> section
are provided by the runtime library.
The RTTI name NTBS objects are emitted with each referencing
std::type_info object.

<p>
The RTTI std::type_info structures for complete class types and basic
types are emitted in COMDAT groups identified by their mangled names.
The RTTI std::type_info structures for incomplete class types
are emitted with other than the ABI-defined complete type mangled names;
an implementation may choose to emit them as local static objects,
or in COMDAT groups with implementation-defined names and COMDAT identifiers.
The RTTI name NTBS objects are emitted in separate COMDAT groups
identified by the NTBS mangled names.
</font>

<p>
<a name=vague-ctor></a>
<b>Constructors and Destructors</b>

<font color=red>
<p>
Constructors and destructors for a class,
whether implicitly-defined or user-defined,
are emitted under the same rules as other functions.
That is, user-defined constructors or destructors,
unless the function is declared inline, or has internal linkage,
are emitted where defined,
with all variants required (in-charge/not-in-charge).
A user-defined constructor or destructor with non-inline,
internal linkage is emitted where defined,
with only the variants actually referenced.
Implicitly-defined or inline user-defined constructors and destructors
are emitted where referenced,
each in its own COMDAT group identified by the constructor or
destructor name.
</font>

<p>
<a name=vague-itemplate></a>
<b>Instantiated Templates</b>


<p>
<hr>

<p> <hr> <p>
<a name=revisions>
<h3> Revision History </h3>

<p>
<font color=blue>[000314]</font>
Construction vtable modifications.
RTTI modifications for incomplete class types.
Mangling rework: grammar, new constructs, function return types.

<p>
<font color=blue>[000309]</font>
Add limits section.
Specify NULL member pointer values.
Combine vtable content and order sections; clarify ordering.
Specify when distinct virtual function entries are needed for overriders.
Define (and modify) vector constructor/destructor runtime APIs.
Virtual base offsets are promoted from non-virtual bases.

<p>
<font color=blue>[000228]</font>
Add thunk definition.
Revise inheritance graph order definition.
Fix member function pointer description (no division by two).
Move bitfield allocation description (much modified)
to the non-virtual-base allocation description.
Replace virtual function calling convention description.

<p>
<font color=blue>[000228]</font>
Add thunk definition.
Revise inheritance graph order definition.
Fix member function pointer description (no division by two).
Move bitfield allocation description (much modified)
to the non-virtual-base allocation description.
Replace virtual function calling convention description.

<p>
<font color=blue>[000217]</font>
Add excess-size bitfield specification.
Add namespace/header section.
Touch up array new cookies.
Remove construction vtable example to new file.
Add mangling proposal.

<p>
<font color=blue>[000214]</font>
Complete array new cookie specification.
Remove unnecessary RTTI flags.
Correct repeated inheritance flag description.
Move all type_info subclasses in namespace abi, not namespace std.
Note requirements for an implementation to prevent users from emitting
invalid vtables for RTTI classes.
Include construction vtable proposal.

<p>
<font color=blue>[000203]</font>
Incorporate discussion of 3 Febrary.
Remove __reference_type_info (issue A-22).
Restructure struct RTTI and flags (issue A-23).
Clarify __base_class_info layout.

<p>
<font color=blue>[000125]</font>
Incorporate discussion of 20 January, generally clarifications.
Resolved A-19 (choice of a primary virtual base).
Answered Nathan's questions about RTTI.
Included RTTI "Deliberations" as rationale notes in the specification,
or removed redundant ones.
Added array operator new section.

<p>
<font color=blue>[000119]</font>
Clarify when virtual base offsets are required.
Note that a vtable has offset-to-top and RTTr entries for classes with
virtual bases even if there are no virtual functions.
Resolve allocation of a virtual base class that is a primary base for
another base (A-17).
Resolve choice of a primary virtual base class that is a primary base for
another base (A-19).
Describe the (non-)effect of virtual bases on the alignment of the
non-virtual part of a class as the base of another class (A-18).

<p>
<font color=blue>[991230]</font>
Integrate proposed resolution of A-16, A-17 in base class layout.
Add outstanding questions list, and clean up questions in text.

<p>
<font color=blue>[991229]</font>
Clarify definition of nearly empty class, layout of virtual bases.

<p>
<font color=blue>[991203]</font>
Added description of vfunc calling convention from Jason.

<p>
<font color=blue>[991104]</font>
Noted pair of vtable entries for virtual destructors.

<p>
<font color=blue>[991019]</font>
Modified RTTI proposal for 14 October decisions.

<p>
<font color=blue>[991006]</font>
Added RTTI proposal.

<p>
<font color=blue>[990930]</font>
Updated to new vtable layout proposal.

<p>
<font color=blue>[990811]</font>
Described member pointer representations, virtual table layout.

<p>
<font color=blue>[990730]</font>
Selected first variant for empty base allocation; removed others.

<p>
<hr>

</BODY>
</HTML>
